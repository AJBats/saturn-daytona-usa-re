#!/usr/bin/env python3
"""Cross-reference analyzer — map function → data/code references.

Scans L3 assembly files for pool entries (.4byte) that reference symbols
or addresses. Builds a bidirectional cross-reference table:
  function → referenced symbols (outgoing refs)
  symbol → referencing functions (incoming refs)

This is the static approximation of per-function memory R/W profiling.

Usage:
  python tools/xref.py reimpl/src --summary
  python tools/xref.py reimpl/src --query sym_06063D98
  python tools/xref.py reimpl/src -o build/xrefs.json
"""

import os
import re
import sys
import json
from collections import defaultdict


def scan_file(filepath):
    """Scan a .s file for pool entry references.

    Returns:
      symbols: list of (symbol_name, line_number) for .4byte sym_* / FUN_* / etc.
      addresses: list of (hex_addr, line_number) for .4byte 0xNNNNNNNN
    """
    symbols = []
    addresses = []

    with open(filepath, 'r', errors='replace') as f:
        for lineno, line in enumerate(f, 1):
            line = line.strip()
            # .4byte symbol_name or .4byte symbol + offset
            m = re.match(r'\.4byte\s+([A-Za-z_]\w+)', line)
            if m:
                sym = m.group(1)
                # Skip section-internal labels (generated by assembler)
                if not sym.startswith('.L'):
                    symbols.append((sym, lineno))
                continue

            # .4byte 0xNNNNNNNN (raw address — already handled by hw_tag.py)
            m = re.match(r'\.4byte\s+0x([0-9a-fA-F]+)', line)
            if m:
                val = int(m.group(1), 16)
                # Only record WRAM-H addresses (likely code/data pointers)
                if 0x06000000 <= val <= 0x06100000:
                    addresses.append((f'0x{val:08X}', lineno))

    return symbols, addresses


def extract_tu_name(filepath):
    """Extract TU name from filepath."""
    return os.path.splitext(os.path.basename(filepath))[0]


def build_xrefs(src_dir):
    """Build cross-reference tables from all .s files.

    Returns:
      outgoing: {tu_name -> [symbol_names]}
      incoming: {symbol_name -> [tu_names]}
      raw_addrs: {tu_name -> [hex_addresses]}
    """
    outgoing = {}
    incoming = defaultdict(list)
    raw_addrs = {}

    for fname in sorted(os.listdir(src_dir)):
        if not fname.endswith('.s'):
            continue

        filepath = os.path.join(src_dir, fname)
        tu_name = extract_tu_name(filepath)
        symbols, addresses = scan_file(filepath)

        if symbols:
            # Deduplicate but keep order
            seen = set()
            sym_names = []
            for sym, _ in symbols:
                if sym not in seen:
                    seen.add(sym)
                    sym_names.append(sym)
            outgoing[tu_name] = sym_names
            for sym in sym_names:
                incoming[sym].append(tu_name)

        if addresses:
            raw_addrs[tu_name] = list(set(a for a, _ in addresses))

    return outgoing, dict(incoming), raw_addrs


def main():
    import argparse
    parser = argparse.ArgumentParser(description='Cross-reference analyzer')
    parser.add_argument('src_dir', help='Directory with .s files')
    parser.add_argument('--summary', action='store_true', help='Print summary')
    parser.add_argument('--query', '-q', help='Query a symbol name')
    parser.add_argument('--output', '-o', help='Output JSON file')
    parser.add_argument('--top-refs', type=int, default=20,
                        help='Show top N most-referenced symbols')
    args = parser.parse_args()

    outgoing, incoming, raw_addrs = build_xrefs(args.src_dir)

    if args.query:
        sym = args.query
        if sym in incoming:
            refs = incoming[sym]
            print(f"\n'{sym}' is referenced by {len(refs)} functions:")
            for tu in sorted(refs):
                print(f"  {tu}")
        else:
            # Check if it's a TU name
            if sym in outgoing:
                refs = outgoing[sym]
                print(f"\n'{sym}' references {len(refs)} symbols:")
                for s in refs:
                    ref_count = len(incoming.get(s, []))
                    print(f"  {s}  (referenced by {ref_count} functions)")
            else:
                print(f"'{sym}' not found in cross-references")
                # Fuzzy match
                matches = [s for s in incoming if sym.lower() in s.lower()]
                if matches:
                    print(f"  Partial matches: {', '.join(matches[:10])}")
        return

    if args.summary or not args.output:
        total_tus = len(outgoing)
        total_syms = len(incoming)
        total_refs = sum(len(refs) for refs in outgoing.values())

        print(f"\n{'='*60}")
        print(f"  CROSS-REFERENCE SUMMARY")
        print(f"{'='*60}")
        print(f"  Functions with external refs: {total_tus}")
        print(f"  Unique symbols referenced:    {total_syms}")
        print(f"  Total reference edges:        {total_refs}")
        print(f"  Functions with raw addr refs:  {len(raw_addrs)}")

        # Most referenced symbols
        top = sorted(incoming.items(), key=lambda x: -len(x[1]))[:args.top_refs]
        print(f"\n  Top {args.top_refs} most-referenced symbols:")
        for sym, refs in top:
            print(f"    {sym:<45s}  {len(refs):>4d} refs")

        # Most referencing functions (widest dependency fan-out)
        top_out = sorted(outgoing.items(), key=lambda x: -len(x[1]))[:10]
        print(f"\n  Top 10 functions by reference count (widest fan-out):")
        for tu, syms in top_out:
            print(f"    {tu:<45s}  {len(syms):>4d} refs")

        # Self-referencing clusters (mutual references)
        mutual = []
        for tu, syms in outgoing.items():
            for sym in syms:
                if sym in outgoing and tu in outgoing.get(sym, []):
                    mutual.append((tu, sym))
        if mutual:
            print(f"\n  Mutual references: {len(mutual)} pairs")

    if args.output:
        output = {
            'outgoing': outgoing,
            'incoming': incoming,
            'raw_address_refs': raw_addrs,
            'stats': {
                'functions_with_refs': len(outgoing),
                'unique_symbols': len(incoming),
                'total_edges': sum(len(r) for r in outgoing.values()),
            }
        }
        os.makedirs(os.path.dirname(args.output) or '.', exist_ok=True)
        with open(args.output, 'w') as f:
            json.dump(output, f, indent=2)
        print(f"\nWrote {args.output}")


if __name__ == '__main__':
    main()
