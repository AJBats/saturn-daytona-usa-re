#!/usr/bin/env python3
"""
symbolize_pools.py — Sawyer L2: Convert binary to relocatable assembly source.

Reads the original APROG.BIN binary and symbol tables, outputs per-function .s
files with symbolic pool entries (.4byte SYMBOL) for addresses matching known
symbols. All other bytes stay as .byte directives, guaranteeing byte-identical
output when linked at original addresses.

Outputs:
  - reimpl/src/*.s       — one .s file per function (1234 + _start)
  - reimpl/sawyer.ld     — linker script with PROVIDE declarations + ordering

Usage: python3 tools/symbolize_pools.py
"""

import os
import re
import struct
import sys

# --- Configuration ---
BASE_ADDR = 0x06003000

# Paths relative to project root
PROJ = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
BINARY_PATH = os.path.join(PROJ, "build", "aprog.bin")
SYMS_PATH = os.path.join(PROJ, "build", "aprog_syms.txt")
STUBS_PATH = os.path.join(PROJ, "reimpl", "src_c_archive", "linker_stubs.c")
OUT_DIR = os.path.join(PROJ, "reimpl", "src")
LD_OUT = os.path.join(PROJ, "reimpl", "sawyer.ld")


def load_binary(path):
    with open(path, "rb") as f:
        return f.read()


def load_fun_symbols(path):
    """Parse FUN_ symbols from aprog_syms.txt -> {addr: name}"""
    syms = {}
    with open(path) as f:
        for line in f:
            m = re.match(r"(FUN_[0-9A-Fa-f]+)\s*=\s*0x([0-9A-Fa-f]+)", line)
            if m:
                name = m.group(1)
                addr = int(m.group(2), 16)
                syms[addr] = name
    return syms


def load_dat_symbols(path):
    """Parse DAT_ symbols from linker_stubs.c -> {addr: name}"""
    syms = {}
    with open(path) as f:
        for line in f:
            m = re.match(r"int\s+(DAT_[0-9A-Fa-f]+)", line)
            if m:
                name = m.group(1)
                addr = int(name[4:], 16)
                syms[addr] = name
    return syms


def build_function_ranges(fun_syms, binary_len):
    """Build sorted list of (start_addr, end_addr, name) for all functions."""
    addrs = sorted(fun_syms.keys())
    ranges = []

    # _start: from BASE_ADDR to first FUN_
    ranges.append((BASE_ADDR, addrs[0], "_start"))

    # Each FUN_: from its address to the next FUN_ (or end of binary)
    for i in range(len(addrs)):
        start = addrs[i]
        end = addrs[i + 1] if i + 1 < len(addrs) else BASE_ADDR + binary_len
        ranges.append((start, end, fun_syms[start]))

    return ranges


def emit_function(name, start, end, binary_data, all_symbols):
    """Generate .s file content for one function.

    Scans all 4-byte-aligned positions for known symbol addresses.
    Matching values become .4byte SYMBOL; everything else stays .byte.
    """
    offset_start = start - BASE_ADDR
    offset_end = end - BASE_ADDR
    func_bytes = binary_data[offset_start:offset_end]
    func_size = len(func_bytes)

    lines = []

    # Section header
    section_name = "startup" if name == "_start" else name
    lines.append(f"    .section .text.{section_name}")
    lines.append(f"    .global {name}")
    if name != "_start":
        lines.append(f"    .type {name}, @function")
    lines.append(f"{name}:")

    # Track symbolized pool entries for stats
    sym_count = 0

    i = 0
    while i < func_size:
        addr = start + i

        # Check for 4-byte-aligned position with a known symbol value
        if addr % 4 == 0 and i + 4 <= func_size:
            value = struct.unpack(">I", func_bytes[i : i + 4])[0]
            if value in all_symbols:
                sym_name = all_symbols[value]
                lines.append(f"    .4byte {sym_name}")
                i += 4
                sym_count += 1
                continue

        # Emit as .byte pair (2 bytes per line, matching SH-2 instruction width)
        if i + 2 <= func_size:
            lines.append(f"    .byte 0x{func_bytes[i]:02X}, 0x{func_bytes[i+1]:02X}")
            i += 2
        else:
            lines.append(f"    .byte 0x{func_bytes[i]:02X}")
            i += 1

    return "\n".join(lines) + "\n", sym_count


def generate_linker_script(fun_syms, dat_syms):
    """Generate sawyer.ld with PROVIDE declarations for all symbols."""
    lines = []
    lines.append('/* sawyer.ld — Sawyer L2 linker script')
    lines.append(' * AUTO-GENERATED by tools/symbolize_pools.py — do not edit manually')
    lines.append(' *')
    lines.append(' * Functions placed in address order via SORT_BY_NAME.')
    lines.append(' * DAT_ symbols provided at original addresses.')
    lines.append(' */')
    lines.append("")
    lines.append('OUTPUT_FORMAT("elf32-sh")')
    lines.append("OUTPUT_ARCH(sh)")
    lines.append("ENTRY(_start)")
    lines.append("")
    lines.append("SECTIONS")
    lines.append("{")
    lines.append(f"    . = 0x{BASE_ADDR:08X};")
    lines.append("    .text : {")
    lines.append("        *(.text.startup)")
    lines.append("        *(SORT_BY_NAME(.text.FUN_*))")
    lines.append("    }")
    lines.append("")
    lines.append("    /DISCARD/ : {")
    lines.append("        *(.comment)")
    lines.append("        *(.note.*)")
    lines.append("        *(.eh_frame)")
    lines.append("    }")
    lines.append("}")
    lines.append("")

    # PROVIDE declarations for FUN_ symbols (so pool references resolve
    # even if a function's .s file is temporarily missing)
    lines.append("/* FUN_ symbols — defined by .global labels in .s files,")
    lines.append(" * PROVIDE ensures resolution even if a file is missing */")
    for addr in sorted(fun_syms.keys()):
        name = fun_syms[addr]
        lines.append(f"PROVIDE({name} = 0x{addr:08X});")
    lines.append("")

    # PROVIDE declarations for DAT_ symbols
    lines.append("/* DAT_ symbols — data addresses in RAM/VRAM */")
    for addr in sorted(dat_syms.keys()):
        name = dat_syms[addr]
        lines.append(f"PROVIDE({name} = 0x{addr:08X});")

    return "\n".join(lines) + "\n"


def main():
    print("=== Sawyer L2: symbolize_pools.py ===")

    # Load inputs
    print(f"Loading binary: {BINARY_PATH}")
    binary_data = load_binary(BINARY_PATH)
    print(f"  Binary size: {len(binary_data)} bytes")

    print(f"Loading FUN_ symbols: {SYMS_PATH}")
    fun_syms = load_fun_symbols(SYMS_PATH)
    print(f"  {len(fun_syms)} FUN_ symbols")

    print(f"Loading DAT_ symbols: {STUBS_PATH}")
    dat_syms = load_dat_symbols(STUBS_PATH)
    print(f"  {len(dat_syms)} DAT_ symbols")

    # Merge symbol tables (FUN_ takes priority over DAT_ at same address)
    all_symbols = {}
    all_symbols.update(dat_syms)
    all_symbols.update(fun_syms)
    print(f"  {len(all_symbols)} total unique symbols")

    # Build function ranges
    ranges = build_function_ranges(fun_syms, len(binary_data))
    print(f"  {len(ranges)} functions (including _start)")

    # Create output directory
    os.makedirs(OUT_DIR, exist_ok=True)

    # Generate per-function .s files
    total_sym = 0
    total_bytes = 0
    for start, end, name in ranges:
        content, sym_count = emit_function(
            name, start, end, binary_data, all_symbols
        )
        total_sym += sym_count
        total_bytes += end - start

        filename = f"{name}.s"
        filepath = os.path.join(OUT_DIR, filename)
        with open(filepath, "w", newline="\n") as f:
            f.write(content)

    print(f"\nGenerated {len(ranges)} .s files in {OUT_DIR}")
    print(f"  {total_sym} pool entries symbolized")
    print(f"  {total_bytes} bytes total")

    # Generate linker script
    ld_content = generate_linker_script(fun_syms, dat_syms)
    with open(LD_OUT, "w", newline="\n") as f:
        f.write(ld_content)
    print(f"Generated linker script: {LD_OUT}")

    print("\nDone. Run 'cd reimpl && make && make validate' to test.")


if __name__ == "__main__":
    main()
