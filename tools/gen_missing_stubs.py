#!/usr/bin/env python3
"""gen_missing_stubs.py -- Generate rts/nop stubs for functions missing from reimpl.

Compares function labels in build/aprog.s against symbols in reimpl ELF.
Generates a C file with inline asm stubs for every function that has a linker
section but no source code.

Usage:
    python tools/gen_missing_stubs.py
"""

import os
import re
import subprocess

PROJDIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
APROG_S = os.path.join(PROJDIR, "build", "aprog.s")
ELF = os.path.join(PROJDIR, "reimpl", "build", "daytona.elf")
NM = os.path.join(PROJDIR, "tools", "sh-elf", "bin", "sh-elf-nm")
OUTPUT = os.path.join(PROJDIR, "reimpl", "src", "missing_stubs.c")


def get_aprog_functions():
    """Extract all FUN_ labels from aprog.s (normalized to uppercase hex)."""
    funcs = set()
    with open(APROG_S, "r") as f:
        for line in f:
            m = re.match(r'^(FUN_[0-9a-fA-F]+):', line)
            if m:
                funcs.add(m.group(1).upper())
    return funcs


def get_elf_symbols():
    """Extract all FUN_ symbols defined in the reimpl ELF (normalized to uppercase hex)."""
    result = subprocess.run(
        ["wsl", "-d", "Ubuntu", "-e", "bash", "-c",
         f'"{NM.replace(os.sep, "/").replace("D:", "/mnt/d")}" '
         f'"{ELF.replace(os.sep, "/").replace("D:", "/mnt/d")}" | tr -d "\\r"'],
        capture_output=True, text=True
    )
    syms = set()
    for line in result.stdout.splitlines():
        # Format: "06003218 T _FUN_06003218"
        parts = line.split()
        if len(parts) >= 3 and parts[2].startswith("_FUN_"):
            # Strip leading underscore and normalize to uppercase
            syms.add(parts[2][1:].upper())
    return syms


def main():
    print("Reading aprog.s function labels...")
    aprog_funcs = get_aprog_functions()
    print(f"  Found {len(aprog_funcs)} functions in aprog.s")

    print("Reading reimpl ELF symbols...")
    elf_syms = get_elf_symbols()
    print(f"  Found {len(elf_syms)} FUN_ symbols in ELF")

    missing = sorted(aprog_funcs - elf_syms)
    print(f"\n  {len(missing)} functions missing from reimpl")

    if not missing:
        print("Nothing to generate!")
        return

    # Generate C file with inline asm stubs
    lines = []
    lines.append("/* missing_stubs.c -- Auto-generated rts/nop stubs for functions")
    lines.append(" * missing from the reimpl. These functions exist in the original")
    lines.append(" * binary but had no source code in any reimpl/src/*.c file.")
    lines.append(" *")
    lines.append(f" * Generated by tools/gen_missing_stubs.py ({len(missing)} functions)")
    lines.append(" *")
    lines.append(" * Each stub is placed at the function's original address via")
    lines.append(" * .text.FUN_XXXXXXXX section (matched by saturn_fixed.ld).")
    lines.append(" * The stub is just rts + nop (4 bytes, clean return).")
    lines.append(" *")
    lines.append(" * CLASS 4 FIX: These stubs prevent crashes from jumping into")
    lines.append(" * empty memory. They don't do the right thing -- subsequent")
    lines.append(" * validation loop iterations will reveal which need real code.")
    lines.append(" */")
    lines.append("")

    # Group into a single __asm__ block for efficiency
    lines.append("__asm__(")

    for func in missing:
        addr = func.replace("FUN_", "0x")
        lines.append(f'    /* {func} @ {addr} */')
        lines.append(f'    ".section .text.{func}, \\"ax\\"\\n"')
        lines.append(f'    ".balign 2\\n"')
        lines.append(f'    ".global _{func}\\n"')
        lines.append(f'    ".type _{func}, @function\\n"')
        lines.append(f'    "_{func}:\\n"')
        lines.append(f'    ".word 0x000B\\n"  /* rts */')
        lines.append(f'    ".word 0x0009\\n"  /* nop (delay slot) */')
        lines.append(f'')

    lines.append(");")
    lines.append("")

    with open(OUTPUT, "w", newline="\n") as f:
        f.write("\n".join(lines))

    print(f"\nGenerated {OUTPUT}")
    print(f"  {len(missing)} stubs (rts + nop at original addresses)")
    print(f"\nMissing functions:")
    for func in missing:
        print(f"  {func}")


if __name__ == "__main__":
    main()
