#include "game.h"

/*
 * vdp_polygon_setup.c -- VDP polygon vertex data setup
 *
 * Hand-translated from binary at 0x06038120 (215 instructions).
 *
 * Functions:
 *   FUN_06038120 (0x06038120) -- Configure polygon vertex buffers
 *
 * Processes a polygon descriptor structure and fills two output buffers
 * with vertex coordinate and normal data for VDP rendering.
 *
 * Only active when the render mode is 4 or 8. The first 5 bytes of
 * the input structure control which data channels are enabled and the
 * iteration stride.
 *
 * Input structure layout:
 *   [0..4]    Channel enable flags (byte each: [0]=Z, [1]=Y, [2]=X, [3]=N, [4]=stride_mode)
 *   [8..11]   Coordinate data descriptor A (32-bit)
 *   [12..15]  Coordinate data descriptor B (32-bit)
 *   [16+]     Vertex data entries (12 bytes each: X, Y, Z coordinates)
 *   [0x1810+] Normal data entries (4 bytes each, 64 entries max)
 *
 * Output buffers:
 *   0x060A2470 -- Vertex coordinate buffer (selected channels)
 *   0x060A3C70 -- Normal data buffer
 *
 * Called from render_setup.c.
 */

/* Output buffers */
#define VERTEX_BUF_BASE      ((volatile int *)0x060A2470)
#define NORMAL_BUF_BASE      ((volatile int *)0x060A3C70)

/* Config structs (data + buffer pointer pairs) */
#define CONFIG_A_DATA        (*(volatile int *)0x060A3D70)
#define CONFIG_A_BUF         (*(volatile int *)0x060A3D74)
#define CONFIG_B_DATA        (*(volatile int *)0x060A3D78)
#define CONFIG_B_BUF         (*(volatile int *)0x060A3D7C)

/* Output structure base (bitfield + offsets) */
#define OUT_STRUCT_BASE      0x060A3DF8
#define OUT_BITFIELD         (*(volatile short *)(OUT_STRUCT_BASE + 0x2A))
#define OUT_HALF_A           (*(volatile int *)(OUT_STRUCT_BASE + 0x2C))

/* Mode-dependent output slots */
#define OUT_SLOT_MODE4       (*(volatile int *)(OUT_STRUCT_BASE + 0x30))
#define OUT_SLOT_MODE8       (*(volatile int *)(OUT_STRUCT_BASE + 0x34))

/* Render mode flag */
#define RENDER_MODE          (*(volatile int *)0x060635A8)

/* Output count registers */
#define VERTEX_COUNT         (*(volatile short *)0x060635A0)
#define NORMAL_COUNT         (*(volatile short *)0x060635A2)
#define MODE_OUTPUT          (*(volatile short *)0x060635AC)

/* Constants */
#define HALF_MASK            0x0007FFFF
#define VERTEX_ENTRIES       512
#define NORMAL_ENTRIES       64
#define ENTRY_SIZE           12   /* 3 ints per vertex entry */
#define NORMAL_DATA_OFFSET   0x1810


/* ================================================================
 * FUN_06038120 -- VDP Polygon Vertex Setup (0x06038120)
 *
 * CONFIDENCE: DEFINITE (binary verified at 0x06038120-0x060382F2)
 * Pool verified:
 *   0x0603815C = 0x060A3DF8 (output struct base)
 *   0x06038160 = 0x060A3C70 (normal buffer)
 *   0x06038164 = 0x060A2470 (vertex buffer)
 *   0x06038168 = 0x060635A8 (render mode)
 *   0x060382A0 = 0x0000FF00 (8-bit shift mask)
 *   0x060382A4 = 0x060A3D70 (config A)
 *   0x060382A8 = 0x060A3D78 (config B)
 *   0x060382AC = 0x0007FFFF (19-bit mask)
 *   0x060382B0 = 0x060635A0 (vertex count)
 *   0x060382F4 = 0x1810 (normal data offset)
 *   0x060382F8 = 0x060635A2 (normal count)
 *   0x060382FC = 0x060635AC (mode output)
 * Word pool:
 *   0x0603815A = 0x0200 (512 entries)
 *
 * 215 instructions. Saves r8-r14. 4-byte stack frame.
 * ================================================================ */
#if 0 /* FUN_06038120 -- replaced by ASM import */
int FUN_06038120(unsigned char *param)
{
    int mode = RENDER_MODE;

    /* Only process for render modes 4 or 8 */
    if (mode != 4 && mode != 8)
        return 1;  /* non-zero = no processing needed */

    /* Build channel enable bitfield from first 5 bytes */
    unsigned short bitfield =
        ((param[3] & 1) << 0) |
        ((param[2] & 1) << 1) |
        ((param[1] & 1) << 2) |
        ((param[0] & 1) << 3) |
        ((param[4] & 3) << 4);

    /* For mode 8: shift bitfield into high byte */
    if (mode == 8)
        bitfield = (bitfield << 8) & 0xFF00;

    /* Store bitfield to output struct */
    OUT_BITFIELD = bitfield;

    /* Set up coordinate data config structs */
    unsigned int desc_a = *(unsigned int *)(param + 8);
    unsigned int desc_b = *(unsigned int *)(param + 12);

    CONFIG_A_DATA = (int)desc_a;
    CONFIG_A_BUF = (int)VERTEX_BUF_BASE;
    CONFIG_B_DATA = (int)desc_b;
    CONFIG_B_BUF = (int)NORMAL_BUF_BASE;

    /* Store half-values with 19-bit mask */
    if (mode == 8) {
        OUT_SLOT_MODE8 = (int)((desc_a >> 1) & HALF_MASK);
    } else {
        OUT_SLOT_MODE4 = (int)((desc_a >> 1) & HALF_MASK);
    }
    OUT_HALF_A = (int)((desc_b >> 1) & HALF_MASK);

    /* Compute stride from param[4] (0→1, 1→2, 2→4, 3→8) */
    unsigned short stride;
    {
        unsigned char s = param[4];
        if (s == 0) stride = 1;
        else if (s == 1) stride = 2;
        else if (s == 2) stride = 4;
        else if (s == 3) stride = 8;
        else stride = 0;
    }

    /* === Loop 1: Fill vertex buffer from coordinate data === */
    {
        unsigned short out_idx = 0;
        unsigned short in_idx = 0;

        while (in_idx < VERTEX_ENTRIES) {
            /* Channel X (param[2]) */
            if (param[2] != 0) {
                short entry_off = (short)(in_idx * 4 + in_idx * 8);  /* in_idx * 12 */
                int val = *(int *)(param + 0x10 + entry_off);
                ((volatile int *)VERTEX_BUF_BASE)[out_idx] = val;
                out_idx++;
            }

            /* Channel Y (param[1]) */
            if (param[1] != 0) {
                short entry_off = (short)(in_idx * 4 + in_idx * 8);
                int val = *(int *)(param + 0x10 + entry_off + 4);
                ((volatile int *)VERTEX_BUF_BASE)[out_idx] = val;
                out_idx++;
            }

            /* Channel Z (param[0]) */
            if (param[0] != 0) {
                short entry_off = (short)(in_idx * 4 + in_idx * 8);
                int val = *(int *)(param + 0x10 + entry_off + 8);
                ((volatile int *)VERTEX_BUF_BASE)[out_idx] = val;
                out_idx++;
            }

            in_idx += stride;
        }

        VERTEX_COUNT = out_idx;
    }

    /* === Loop 2: Fill normal buffer (64 entries) === */
    {
        unsigned short out_idx = 0;
        unsigned short in_idx = 0;

        while (in_idx < NORMAL_ENTRIES) {
            /* Channel N (param[3]) */
            if (param[3] != 0) {
                int val = *(int *)(param + NORMAL_DATA_OFFSET + in_idx * 4);
                ((volatile int *)NORMAL_BUF_BASE)[out_idx] = val;
                out_idx++;
            }

            in_idx++;
        }

        NORMAL_COUNT = out_idx;
    }

    /* Set mode output flag */
    MODE_OUTPUT = 2;

    return 0;
}
#endif

/* FUN_06038120 -- original binary (480 bytes) */
__asm__(
    ".section .text.FUN_06038120, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06038120\n"
    ".type _FUN_06038120, @function\n"
    "_FUN_06038120:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0xED, 0x00, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0xE9, 0x40\n"  /* 0x06038120 */
    ".byte 0x2F, 0x86, 0x7F, 0xFC, 0x9A, 0x11, 0xDB, 0x09, 0xDC, 0x09, 0xD6, 0x0A, 0xD8, 0x0A, 0x60, 0x82\n"  /* 0x06038130 */
    ".byte 0x88, 0x08, 0x01, 0x29, 0x71, 0xFF, 0x61, 0x1B, 0x88, 0x04, 0x00, 0x29, 0xCA, 0x01, 0x20, 0x19\n"  /* 0x06038140 */
    ".byte 0x20, 0x08, 0x8D, 0x0B, 0x6E, 0xDD, 0xA0, 0xC4, 0x00, 0x09, 0x02, 0x00, 0x06, 0x0A, 0x3D, 0xF8\n"  /* 0x06038150 */
    ".byte 0x06, 0x0A, 0x3C, 0x70, 0x06, 0x0A, 0x24, 0x70, 0x06, 0x06, 0x35, 0xA8, 0x84, 0x43, 0x60, 0x0C\n"  /* 0x06038160 */
    ".byte 0xC9, 0x01, 0x65, 0x0D, 0x84, 0x42, 0x60, 0x0C, 0x40, 0x00, 0xC9, 0x02, 0x25, 0x0B, 0x84, 0x41\n"  /* 0x06038170 */
    ".byte 0x60, 0x0C, 0x40, 0x08, 0xC9, 0x04, 0x25, 0x0B, 0x60, 0x40, 0x60, 0x0C, 0x40, 0x08, 0x40, 0x00\n"  /* 0x06038180 */
    ".byte 0xC9, 0x08, 0x25, 0x0B, 0x84, 0x44, 0x60, 0x0C, 0x40, 0x08, 0x40, 0x08, 0xC9, 0x30, 0x25, 0x0B\n"  /* 0x06038190 */
    ".byte 0x67, 0xB3, 0x63, 0xB3, 0x73, 0x2C, 0x2F, 0x32, 0x60, 0x82, 0x88, 0x08, 0x8F, 0x07, 0x77, 0x30\n"  /* 0x060381A0 */
    ".byte 0x63, 0x5D, 0x43, 0x18, 0xD2, 0x3A, 0x23, 0x29, 0x65, 0x3D, 0x67, 0xB3, 0x77, 0x34, 0xE0, 0x2A\n"  /* 0x060381B0 */
    ".byte 0x62, 0x63, 0x0B, 0x55, 0x62, 0xC3, 0xD5, 0x37, 0x53, 0x42, 0x25, 0x32, 0x15, 0x61, 0xD5, 0x36\n"  /* 0x060381C0 */
    ".byte 0x53, 0x43, 0x25, 0x32, 0x15, 0xC1, 0xD5, 0x35, 0x53, 0x42, 0x43, 0x01, 0x23, 0x59, 0x27, 0x32\n"  /* 0x060381D0 */
    ".byte 0x62, 0xF2, 0x53, 0x43, 0x43, 0x01, 0x23, 0x59, 0x22, 0x32, 0x84, 0x44, 0x62, 0x03, 0x62, 0x2C\n"  /* 0x060381E0 */
    ".byte 0x22, 0x28, 0x8B, 0x00, 0xEE, 0x01, 0x84, 0x44, 0x60, 0x0C, 0x88, 0x01, 0x8B, 0x00, 0xEE, 0x02\n"  /* 0x060381F0 */
    ".byte 0x84, 0x44, 0x60, 0x0C, 0x88, 0x02, 0x8B, 0x00, 0xEE, 0x04, 0x84, 0x44, 0x60, 0x0C, 0x88, 0x03\n"  /* 0x06038200 */
    ".byte 0x8B, 0x00, 0xEE, 0x08, 0x67, 0xDD, 0x65, 0xDD, 0x84, 0x42, 0x60, 0x0C, 0x20, 0x08, 0x89, 0x0E\n"  /* 0x06038210 */
    ".byte 0x60, 0x7D, 0x63, 0x53, 0x62, 0x53, 0x40, 0x08, 0x77, 0x01, 0x43, 0x08, 0x42, 0x08, 0x42, 0x00\n"  /* 0x06038220 */
    ".byte 0x33, 0x2C, 0x63, 0x3F, 0x61, 0x43, 0x71, 0x10, 0x33, 0x1C, 0x63, 0x32, 0x06, 0x36, 0x84, 0x41\n"  /* 0x06038230 */
    ".byte 0x60, 0x0C, 0x20, 0x08, 0x89, 0x0E, 0x60, 0x7D, 0x63, 0x53, 0x62, 0x53, 0x40, 0x08, 0x77, 0x01\n"  /* 0x06038240 */
    ".byte 0x43, 0x08, 0x42, 0x08, 0x42, 0x00, 0x33, 0x2C, 0x63, 0x3F, 0x61, 0x43, 0x71, 0x10, 0x33, 0x1C\n"  /* 0x06038250 */
    ".byte 0x53, 0x31, 0x06, 0x36, 0x60, 0x40, 0x60, 0x0C, 0x20, 0x08, 0x89, 0x0E, 0x60, 0x7D, 0x63, 0x53\n"  /* 0x06038260 */
    ".byte 0x62, 0x53, 0x40, 0x08, 0x77, 0x01, 0x43, 0x08, 0x42, 0x08, 0x42, 0x00, 0x33, 0x2C, 0x63, 0x3F\n"  /* 0x06038270 */
    ".byte 0x61, 0x43, 0x71, 0x10, 0x33, 0x1C, 0x53, 0x32, 0x06, 0x36, 0x62, 0xED, 0x35, 0x2C, 0x63, 0x5D\n"  /* 0x06038280 */
    ".byte 0x33, 0xA3, 0x8B, 0xC1, 0xD3, 0x06, 0x23, 0x71, 0x67, 0xDD, 0x65, 0xDD, 0xA0, 0x0A, 0x00, 0x09\n"  /* 0x06038290 */
    ".byte 0x00, 0x00, 0xFF, 0x00, 0x06, 0x0A, 0x3D, 0x70, 0x06, 0x0A, 0x3D, 0x78, 0x00, 0x07, 0xFF, 0xFF\n"  /* 0x060382A0 */
    ".byte 0x06, 0x06, 0x35, 0xA0, 0x84, 0x43, 0x60, 0x0C, 0x20, 0x08, 0x89, 0x09, 0x60, 0x7D, 0x40, 0x08\n"  /* 0x060382B0 */
    ".byte 0x77, 0x01, 0x63, 0x5D, 0x43, 0x08, 0x92, 0x15, 0x32, 0x4C, 0x33, 0x2C, 0x63, 0x32, 0x0C, 0x36\n"  /* 0x060382C0 */
    ".byte 0x75, 0x01, 0x62, 0x5D, 0x32, 0x93, 0x8B, 0xE1, 0xD3, 0x07, 0x23, 0x71, 0xE2, 0x02, 0xD3, 0x07\n"  /* 0x060382D0 */
    ".byte 0x23, 0x21, 0x7F, 0x04, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6\n"  /* 0x060382E0 */
    ".byte 0x00, 0x0B, 0x6E, 0xF6, 0x18, 0x10, 0xFF, 0xFF, 0x06, 0x06, 0x35, 0xA2, 0x06, 0x06, 0x35, 0xAC\n"  /* 0x060382F0 */
);

