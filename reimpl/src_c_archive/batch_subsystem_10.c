#include "game.h"

extern int DAT_060100f6;
extern int DAT_060100f8;
extern int DAT_060101b2;
extern int DAT_0601038c;
extern int DAT_0601038e;
extern int DAT_0601043e;
extern int DAT_0601064a;
extern int DAT_06010736;
extern int DAT_0601096e;
extern int DAT_06010a2a;
extern int DAT_06010c4c;
extern int DAT_06010c4e;
extern int DAT_0601112c;
extern int DAT_0601112e;
extern int DAT_06011206;
extern int DAT_06011208;
extern int DAT_0601120a;
extern int DAT_060112e2;
extern int DAT_060112e4;
extern int DAT_060112e6;
extern int DAT_060113b2;
extern int DAT_060113b4;
extern int DAT_060113b6;
extern int DAT_06011462;
extern int DAT_06011464;
extern int DAT_06011466;
extern int DAT_060115c6;
extern int DAT_06011fd4;
extern int DAT_06011fd6;
extern int DAT_06011fd8;
extern int DAT_06011fda;
extern void FUN_06010d94();
extern void FUN_060111e2();
extern void FUN_06011310();
extern void FUN_060116a8(int,int,short,int,short);
extern int FUN_06011978();
extern void FUN_06011e7c();
extern int PTR_DAT_06010274;
extern int PTR_DAT_06010278;
extern int PTR_DAT_0601030c;
extern int PTR_DAT_06010440;
extern int PTR_DAT_06010508;
extern int PTR_DAT_06010870;
extern int PTR_DAT_06010970;
extern int PTR_DAT_06010ac8;
extern int PTR_DAT_06010c50;
extern int PTR_DAT_06011130;
extern int PTR_DAT_0601120c;
extern int PTR_DAT_06011f04;
extern short DAT_06011efe;
extern short DAT_06011f00;
extern short DAT_06011f02;

/* player_sprite_render -- Render player car sprite with animation/scaling.
 * Loads sprite data from table at 0x060447C8 indexed by player slot.
 * DMA-copies palette (0x20 bytes) to VRAM. If game mode > 4, advances
 * animation frame counter at 0x06078870 (max 0x1E for active, 0x1D for
 * inactive players). Active player uses stride from DAT_060101b2,
 * others use 0x72B. Calls 3D sprite renderer (FUN_06011AF4) with
 * computed position, scale, and texture from course lookup table. */
#if 0 /* FUN_060100A4 -- replaced by ASM import */
int FUN_060100a4(param_1)
    unsigned char param_1;
{
  short y_offset;
  unsigned short anim_frame;
  char *palette_src;
  int tex_x;
  char *tex_y;
  int scale_y;
  char *scale_x;
  int anim_stride;

  scale_x = (char *)0x00010000;
  y_offset = (unsigned short)param_1 + DAT_060100f6;
  scale_y = (int)DAT_060100f8;
  tex_x = *(int *)(0x060447C8 + (unsigned int)(param_1 << 4));         /* sprite table X */
  tex_y = *(char **)((int)(0x060447C8 + (unsigned int)(param_1 << 4)) + 4); /* sprite table Y */
  if ((unsigned int)param_1 == CAR_COUNT) {
    palette_src = 0x0605D0BC + (unsigned int)(param_1 << 5);            /* active player palette */
  } else {
    palette_src = 0x0605D0BC + (param_1 + 3) << 5;                     /* inactive player palette */
  }
  (*(int(*)())0x0602766C)(*(int *)(0x06078888 + (unsigned int)(param_1 << 2)), palette_src, 0x20);
  if (4 < (unsigned char)*(int *)0x0607887F) {          /* game mode > 4: animate */
    if ((unsigned int)param_1 == CAR_COUNT) {            /* active player */
      if (*(unsigned short *)(0x06078870 + (unsigned int)(param_1 << 1)) < 0x1e) {
        anim_frame = *(short *)(0x06078870 + (unsigned int)(param_1 << 1)) + 1;
        *(unsigned short *)(0x06078870 + (unsigned int)(param_1 << 1)) = anim_frame;
      } else {
        *(short *)(0x06078870 + (unsigned int)(param_1 << 1)) = 0x20;
        anim_frame = 0x20;
      }
      tex_x = tex_x + *(int *)(0x060447F8 + (char)(param_1 * '\f')) * (unsigned int)anim_frame;
      tex_y = tex_y + *(int *)((int)(0x060447F8 + (char)(param_1 * '\f')) + 4) * (unsigned int)anim_frame;
      anim_stride = (unsigned int)anim_frame * (int)DAT_060101b2;
    } else {                                             /* inactive player */
      if (0x1d < *(unsigned short *)(0x06078870 + (unsigned int)(param_1 << 1))) {
        return (unsigned int)(param_1 << 1);             /* animation complete */
      }
      anim_frame = *(short *)(0x06078870 + (unsigned int)(param_1 << 1)) + 1;
      *(unsigned short *)(0x06078870 + (unsigned int)(param_1 << 1)) = anim_frame;
      anim_stride = (unsigned int)anim_frame * 0x72b;
    }
    scale_y = scale_y + (unsigned int)anim_frame * -0x800;
    scale_x = scale_x + -anim_stride;
  }
  if (0xb < (unsigned char)*(int *)0x0607887F) {        /* mode > 11: override Y */
    tex_y = (short *)0x00960000;
  }
  tex_x = (*(int(*)())0x06011AF4)(tex_x, tex_y,        /* 3D sprite render */
                     (*(unsigned int *)(0x06044844 + *(int *)(0x0605AA98 << 2)) >> 1) << 0x10,
                     0x00200000, scale_y, scale_x, (int)y_offset);
  return tex_x;
}
#endif

/* FUN_060100A4 -- original binary (584 bytes) */
__asm__(
    ".section .text.FUN_060100A4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060100A4\n"
    ".global _FUN_060100a4\n"
    ".type _FUN_060100A4, @function\n"
    "_FUN_060100A4:\n"
    "_FUN_060100a4:\n"
    ".byte 0x2F, 0xE6, 0x6E, 0x43, 0x2F, 0xD6, 0x63, 0xEC, 0x64, 0xEC, 0x61, 0xEC, 0x2F, 0xC6, 0x44, 0x08\n"  /* 0x060100A4 */
    ".byte 0x2F, 0xB6, 0x44, 0x08, 0x2F, 0xA6, 0x4F, 0x22, 0x4F, 0x12, 0x7F, 0xF8, 0x2F, 0x32, 0x92, 0x18\n"  /* 0x060100B4 */
    ".byte 0x33, 0x2C, 0x63, 0x3D, 0x60, 0x33, 0x81, 0xF2, 0xD2, 0x0C, 0x9C, 0x13, 0xDD, 0x0C, 0xD0, 0x0D\n"  /* 0x060100C4 */
    ".byte 0x34, 0x2C, 0x60, 0x02, 0x6A, 0x42, 0x31, 0x00, 0x8D, 0x18, 0x5B, 0x41, 0x65, 0xF2, 0x75, 0x03\n"  /* 0x060100D4 */
    ".byte 0x45, 0x08, 0x45, 0x08, 0x45, 0x00, 0xD3, 0x08, 0x35, 0x3C, 0xA0, 0x16, 0xE6, 0x20, 0x06, 0xA2\n"  /* 0x060100E4 */
    ".byte 0x0B, 0x22, 0x01, 0x01, 0x80, 0x00, 0xFF, 0xFF, 0x06, 0x05, 0xAB, 0x19, 0x06, 0x04, 0x47, 0xC8\n"  /* 0x060100F4 */
    ".byte 0x00, 0x01, 0x00, 0x00, 0x06, 0x07, 0xEA, 0xD8, 0x06, 0x05, 0xD0, 0xBC, 0xE6, 0x20, 0x65, 0xEC\n"  /* 0x06010104 */
    ".byte 0x45, 0x08, 0x45, 0x08, 0x45, 0x00, 0xD3, 0x26, 0x35, 0x3C, 0x64, 0xEC, 0xD2, 0x25, 0xD1, 0x26\n"  /* 0x06010114 */
    ".byte 0x44, 0x08, 0x34, 0x2C, 0x41, 0x0B, 0x64, 0x42, 0xD3, 0x24, 0xE2, 0x04, 0x63, 0x30, 0x63, 0x3C\n"  /* 0x06010124 */
    ".byte 0x33, 0x27, 0x8B, 0x5A, 0x62, 0xEC, 0xD3, 0x23, 0xD5, 0x21, 0x63, 0x32, 0x32, 0x30, 0x8F, 0x2E\n"  /* 0x06010134 */
    ".byte 0xE4, 0x1E, 0x60, 0xEC, 0x40, 0x00, 0x03, 0x5D, 0x63, 0x3D, 0x33, 0x43, 0x8B, 0x06, 0x60, 0xEC\n"  /* 0x06010144 */
    ".byte 0x40, 0x00, 0xE3, 0x20, 0x05, 0x35, 0x64, 0x33, 0xA0, 0x05, 0x00, 0x09, 0x60, 0xEC, 0x40, 0x00\n"  /* 0x06010154 */
    ".byte 0x04, 0x5D, 0x74, 0x01, 0x05, 0x45, 0x65, 0xE3, 0x63, 0xE3, 0xD2, 0x17, 0x45, 0x08, 0x43, 0x08\n"  /* 0x06010164 */
    ".byte 0x43, 0x00, 0x35, 0x3C, 0x65, 0x5E, 0x63, 0x4D, 0x35, 0x2C, 0x61, 0x52, 0x01, 0x37, 0x51, 0x51\n"  /* 0x06010174 */
    ".byte 0x03, 0x1A, 0x3A, 0x3C, 0x63, 0x4D, 0x01, 0x37, 0x03, 0x1A, 0x3B, 0x3C, 0x63, 0x4D, 0x43, 0x18\n"  /* 0x06010184 */
    ".byte 0x43, 0x08, 0x43, 0x00, 0x3C, 0x38, 0x64, 0x4D, 0x91, 0x09, 0xA0, 0x24, 0x04, 0x17, 0x60, 0xEC\n"  /* 0x06010194 */
    ".byte 0x40, 0x00, 0x03, 0x5D, 0x63, 0x3D, 0x33, 0x43, 0x8B, 0x10, 0xA0, 0x3A, 0x00, 0x09, 0x02, 0x0C\n"  /* 0x060101A4 */
    ".byte 0x06, 0x05, 0xD0, 0xBC, 0x06, 0x07, 0x88, 0x88, 0x06, 0x02, 0x76, 0x6C, 0x06, 0x07, 0x88, 0x7F\n"  /* 0x060101B4 */
    ".byte 0x06, 0x07, 0x88, 0x70, 0x06, 0x07, 0xEA, 0xD8, 0x06, 0x04, 0x47, 0xF8, 0x60, 0xEC, 0x40, 0x00\n"  /* 0x060101C4 */
    ".byte 0x04, 0x5D, 0x74, 0x01, 0x05, 0x45, 0x63, 0x4D, 0x43, 0x18, 0x43, 0x08, 0x43, 0x00, 0x3C, 0x38\n"  /* 0x060101D4 */
    ".byte 0x64, 0x4D, 0x92, 0x45, 0x04, 0x27, 0x04, 0x1A, 0x3D, 0x48, 0xE2, 0x0C, 0xD3, 0x22, 0x63, 0x30\n"  /* 0x060101E4 */
    ".byte 0x63, 0x3C, 0x33, 0x23, 0x8B, 0x00, 0xDB, 0x21, 0xD2, 0x21, 0x65, 0xB3, 0xD3, 0x21, 0x62, 0x22\n"  /* 0x060101F4 */
    ".byte 0x42, 0x08, 0x32, 0x3C, 0x61, 0x22, 0x2F, 0x12, 0x85, 0xF2, 0x62, 0x03, 0x2F, 0x26, 0x2F, 0xD6\n"  /* 0x06010204 */
    ".byte 0x2F, 0xC6, 0xD7, 0x1D, 0x56, 0xF3, 0xD2, 0x1D, 0x46, 0x01, 0x46, 0x28, 0x42, 0x0B, 0x64, 0xA3\n"  /* 0x06010214 */
    ".byte 0x7F, 0x0C, 0x7F, 0x08, 0x4F, 0x16, 0x4F, 0x26, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6\n"  /* 0x06010224 */
    ".byte 0x00, 0x0B, 0x6E, 0xF6, 0xD4, 0x16, 0xE2, 0x00, 0xD0, 0x16, 0xD3, 0x17, 0x60, 0x01, 0x60, 0x0D\n"  /* 0x06010234 */
    ".byte 0x24, 0x22, 0x20, 0x3A, 0x92, 0x15, 0xC9, 0xFF, 0x65, 0x0D, 0x35, 0x27, 0x8B, 0x02, 0x62, 0x42\n"  /* 0x06010244 */
    ".byte 0x72, 0x01, 0x24, 0x22, 0x65, 0x5D, 0x93, 0x0D, 0x35, 0x37, 0x8B, 0x02, 0x63, 0x42, 0x73, 0x01\n"  /* 0x06010254 */
    ".byte 0x24, 0x32, 0x62, 0x42, 0xD3, 0x0D, 0x23, 0x20, 0x61, 0x42, 0xD3, 0x0D, 0x00, 0x0B, 0x23, 0x12\n"  /* 0x06010264 */
    ".byte 0x07, 0x2B, 0x00, 0x80, 0x00, 0xC0, 0xFF, 0xFF, 0x06, 0x07, 0x88, 0x7F, 0x00, 0x96, 0x00, 0x00\n"  /* 0x06010274 */
    ".byte 0x06, 0x05, 0xAA, 0x98, 0x06, 0x04, 0x48, 0x44, 0x00, 0x20, 0x00, 0x00, 0x06, 0x01, 0x1A, 0xF4\n"  /* 0x06010284 */
    ".byte 0x06, 0x07, 0xEA, 0xDC, 0x06, 0x06, 0x3D, 0x9C, 0x00, 0x00, 0xFF, 0xFF, 0x06, 0x07, 0x88, 0x7E\n"  /* 0x06010294 */
    ".byte 0x06, 0x07, 0xEA, 0xD8, 0xD5, 0x19, 0x63, 0x4D, 0xD2, 0x19, 0x23, 0x29, 0x23, 0x38, 0x89, 0x07\n"  /* 0x060102A4 */
    ".byte 0xE2, 0x02, 0xD3, 0x16, 0x63, 0x32, 0x33, 0x23, 0x89, 0x02, 0x62, 0x52, 0x72, 0x01, 0x25, 0x22\n"  /* 0x060102B4 */
    ".byte 0x64, 0x4D, 0x93, 0x20, 0x24, 0x39, 0x24, 0x48, 0x89, 0x06, 0xD3, 0x10, 0x63, 0x32, 0x43, 0x15\n"  /* 0x060102C4 */
    ".byte 0x8B, 0x02, 0x63, 0x52, 0x73, 0xFF, 0x25, 0x32, 0x62, 0x52, 0xD3, 0x0E, 0x23, 0x20, 0x61, 0x52\n"  /* 0x060102D4 */
    ".byte 0xD3, 0x0D, 0x00, 0x0B, 0x23, 0x12, 0x62, 0x4D\n"  /* 0x060102E4 */
);


/* player_count_detect -- Detect player count from cabinet analog input.
 * Reads inverted analog input, checks two thresholds:
 *   >0x72B = one additional player, >0xC0 = one additional player
 * Result: 0=single, 1=2P, 2=4P. Mirrors to CAR_COUNT and game state. */
void player_count_detect(void)
{
    unsigned short raw = *(unsigned short *)0x06063D9C;
    int *player_count = (int *)0x0607EADC;
    unsigned int input_val = ((unsigned int)raw ^ 0xFFFF) & 0xFF;

    *player_count = 0;
    if ((int)input_val > 0x72B)
        *player_count += 1;
    if ((int)input_val > 0xC0)
        *player_count += 1;

    *(int *)0x0607887E = (char)*player_count;
    CAR_COUNT = *player_count;
}
void FUN_06010238(void) __attribute__((alias("player_count_detect")));

/* coin_start_handler -- Handle coin insert / start button during attract.
 * Decrements start timer at 0x0607EBCC. If start bits (PTR_DAT_0601030c)
 * are set in param_1: transitions to GAME_STATE=6 (service mode).
 * Otherwise: if timer expired or confirm button pressed, loads sound bank
 * for current player count, sets game mode to 2, mirrors CAR_COUNT.
 * On course 0 with START pressed, enables route select (0x0605AB18). */
void FUN_060102ea(unsigned short param_1)
{
  int *start_timer = (int *)0x0607EBCC;
  *start_timer = *start_timer - 1;

  if ((param_1 & PTR_DAT_0601030c) == 0) {
    if ((*start_timer < 1) || ((param_1 & DAT_0601038c) != 0)) {
      (*(int(*)())0x0601D5F4)(0, *(int *)(0x0604481C + *(int *)(0x0607EADC << 2)));
      *start_timer = 0;
      *(int *)0x0607887F = 2;              /* set game mode */
      *(int *)0x06078648 = (char)CAR_COUNT;
      *(int *)0x0605AB18 = 0;
      if ((*(int *)0x06085FF4 == '\0') &&
          (COURSE_SELECT == 0 && ((*(unsigned short *)0x06063D98 & DAT_0601038e) != 0))) {
        *(char *)0x0605AB18 = 1;           /* enable route select */
      }
    }
  } else {
    GAME_STATE = 6;                         /* service mode transition */
  }
}

/* player_select_dpad -- Handle D-pad input for player/character selection.
 * Up (bit 0x8000): increment selection (max 1).
 * Down (DAT_0601043e): decrement selection (min 0).
 * Mirrors selection to 0x0607EAB8 and 0x06078868, then DMA-copies
 * the appropriate character sprite data (0xC0 bytes) for both slots. */
#if 0 /* FUN_060103B8 -- replaced by ASM import */
void FUN_060103b8(unsigned int param_1)
{
  int *select_idx = (int *)0x0607EADC;  /* player selection index */

  if (((param_1 & 0xffff & 0x00008000) != 0) && (*select_idx < 1)) {
    *select_idx = *select_idx + 1;
  }
  if (((param_1 & 0xffff & (int)DAT_0601043e) != 0) && (0 < *select_idx)) {
    *select_idx = *select_idx + -1;
  }

  *(int *)0x0607EAB8 = *select_idx;     /* mirror to character select */
  *(int *)0x06078868 = *select_idx;      /* mirror to car select */

  if (*(int *)0x0607EAB8 == 0) {
    (*(int(*)())0x0602766C)(*(int *)0x06078884, *(int *)0x0605D05C, 0xc0);
    (*(int(*)())0x0602766C)(*(int *)0x06078880, *(int *)0x0605D088, 0xc0);
  } else {
    (*(int(*)())0x0602766C)(*(int *)0x06078884, *(int *)0x0605D084, 0xc0);
    (*(int(*)())0x0602766C)(*(int *)0x06078880, *(int *)0x0605D060, 0xc0);
  }
}
#endif

/* FUN_060103B8 -- original binary (184 bytes) */
__asm__(
    ".section .text.FUN_060103B8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060103B8\n"
    ".global _FUN_060103b8\n"
    ".type _FUN_060103B8, @function\n"
    "_FUN_060103B8:\n"
    "_FUN_060103b8:\n"
    ".byte 0x2F, 0xE6, 0x63, 0x4D, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0xDE, 0x20, 0xD2, 0x20, 0x23, 0x29\n"  /* 0x060103B8 */
    ".byte 0x23, 0x38, 0x89, 0x07, 0xE2, 0x01, 0xD3, 0x1D, 0x63, 0x32, 0x33, 0x23, 0x89, 0x02, 0x62, 0xE2\n"  /* 0x060103C8 */
    ".byte 0x72, 0x01, 0x2E, 0x22, 0x64, 0x4D, 0x93, 0x2E, 0x24, 0x39, 0x24, 0x48, 0x89, 0x06, 0xD3, 0x17\n"  /* 0x060103D8 */
    ".byte 0x63, 0x32, 0x43, 0x15, 0x8B, 0x02, 0x63, 0xE2, 0x73, 0xFF, 0x2E, 0x32, 0xD4, 0x15, 0x62, 0xE2\n"  /* 0x060103E8 */
    ".byte 0x24, 0x22, 0x63, 0xE2, 0xD2, 0x14, 0x22, 0x32, 0xDC, 0x14, 0x9D, 0x1D, 0x60, 0x42, 0x20, 0x08\n"  /* 0x060103F8 */
    ".byte 0x89, 0x08, 0x66, 0xD3, 0xD5, 0x12, 0xD4, 0x13, 0x65, 0x52, 0x4C, 0x0B, 0x64, 0x42, 0xD5, 0x12\n"  /* 0x06010408 */
    ".byte 0xA0, 0x08, 0x66, 0xD3, 0x66, 0xD3, 0xD5, 0x11, 0xD4, 0x0E, 0x65, 0x52, 0x4C, 0x0B, 0x64, 0x42\n"  /* 0x06010418 */
    ".byte 0x66, 0xD3, 0xD5, 0x0F, 0x65, 0x52, 0xD4, 0x0F, 0x4C, 0x0B, 0x64, 0x42, 0x4F, 0x26, 0x6C, 0xF6\n"  /* 0x06010428 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x40, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0x06, 0x07, 0xEA, 0xDC\n"  /* 0x06010438 */
    ".byte 0x00, 0x00, 0x80, 0x00, 0x06, 0x07, 0xEA, 0xB8, 0x06, 0x07, 0x88, 0x68, 0x06, 0x02, 0x76, 0x6C\n"  /* 0x06010448 */
    ".byte 0x06, 0x05, 0xD0, 0x84, 0x06, 0x07, 0x88, 0x84, 0x06, 0x05, 0xD0, 0x60, 0x06, 0x05, 0xD0, 0x5C\n"  /* 0x06010458 */
    ".byte 0x06, 0x05, 0xD0, 0x88, 0x06, 0x07, 0x88, 0x80\n"  /* 0x06010468 */
);


/* player_select_analog -- Analog input version of player/character selection.
 * Reads raw analog value from 0x06063D9C, inverts (XOR 0xFFFF), masks to low byte.
 * Resets selection to 0, then if analog value > 0xC0 increments to 1.
 * Mirrors to 0x0607EAB8 and 0x06078868, DMA-copies sprite data (0xC0 bytes). */
/* FUN_06010470 -- original binary (112 bytes) */
__asm__(
    ".section .text.FUN_06010470, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06010470\n"
    ".type _FUN_06010470, @function\n"
    "_FUN_06010470:\n"
    ".byte 0x2F, 0xE6, 0xE2, 0x00, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0xDD, 0x24, 0x9E, 0x44, 0xD0, 0x24\n"  /* 0x06010470 */
    ".byte 0xD3, 0x24, 0x60, 0x01, 0x60, 0x0D, 0x20, 0x3A, 0xC9, 0xFF, 0x64, 0x0D, 0x34, 0xE7, 0x8F, 0x03\n"  /* 0x06010480 */
    ".byte 0x2D, 0x22, 0x62, 0xD2, 0x72, 0x01, 0x2D, 0x22, 0xD4, 0x1F, 0x63, 0xD2, 0x24, 0x32, 0x62, 0xD2\n"  /* 0x06010490 */
    ".byte 0xD3, 0x1E, 0x23, 0x22, 0xDC, 0x1E, 0x60, 0x42, 0x20, 0x08, 0x89, 0x08, 0x66, 0xE3, 0xD5, 0x1D\n"  /* 0x060104A0 */
    ".byte 0xD4, 0x1D, 0x65, 0x52, 0x4C, 0x0B, 0x64, 0x42, 0xD5, 0x1C, 0xA0, 0x08, 0x66, 0xE3, 0x66, 0xE3\n"  /* 0x060104B0 */
    ".byte 0xD5, 0x1B, 0xD4, 0x19, 0x65, 0x52, 0x4C, 0x0B, 0x64, 0x42, 0x66, 0xE3, 0xD5, 0x19, 0x65, 0x52\n"  /* 0x060104C0 */
    ".byte 0xD4, 0x19, 0x4C, 0x0B, 0x64, 0x42, 0x4F, 0x26, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x060104D0 */
);


/* track_select_button_input -- handle digital button input for track/music selection */
unsigned int FUN_060104e0(param_1)
    unsigned int param_1;
{
  char game_mode;
  char *double_buf_toggle;
  char *current_index;
  char *odd_even_flag;
  char *selection_counter;
  unsigned int result;
  int prev_index;
  unsigned int new_index;
  int max_entries;
  int *dma_target;
  int scroll_offset;

  double_buf_toggle = (short *)0x060788A8; /* double-buffer page toggle */
  current_index = (char *)0x06078868;      /* displayed track index */
  odd_even_flag = (int *)0x0607EAB8;       /* odd/even page flag */
  selection_counter = (char *)0x0607EADC;  /* selection index counter */

  /* Determine max selection entries based on game mode */
  game_mode = *(int *)0x0605AB16;
  if ((game_mode == '\x01') || (game_mode == '\x02')) {
LAB_06010504:
    max_entries = 5;
  }
  else {
    if (game_mode != '\x03') {
      if (game_mode == '\x04') goto LAB_06010504;
      if ((game_mode != '\x05') && (game_mode != '\x06')) {
        if (game_mode == '\a') {
          max_entries = 9;
        }
        else {
          max_entries = 3;
        }
        goto LAB_06010570;
      }
    }
    max_entries = 7;
  }

LAB_06010570:
  if (*(int *)0x0605AB17 == '\a') {
    max_entries = 0xb;
  }
  result = (unsigned int)(char)*(int *)0x0605AB17;
  if (result == 0xf) {
    max_entries = 0xd;
  }

  /* Check button input: bit 0x8000 = scroll up, DAT_0601064a = scroll down */
  if ((param_1 & 0xffff & (unsigned int)0x00008000) == 0) {
    /* No up button — check down button */
    if ((param_1 & 0xffff & (int)DAT_0601064a) != 0) {
      /* Scroll down: decrement selection */
      *(char **)0x0607889C = 0x00010000; /* scroll_direction = positive */
      prev_index = *(int *)selection_counter;
      *(int *)selection_counter = prev_index + -1;
      if (prev_index + -1 < 0) {
        *(int *)selection_counter = max_entries; /* wrap to end */
      }
      scroll_offset = 0xFFF40000;
      result = (unsigned int)(unsigned char)*double_buf_toggle;
      if (result == 0) {
        *double_buf_toggle = 1;
        *(int *)0x06078898 = scroll_offset;
        *(int *)0x060788A4 = *(int *)selection_counter;
      }
      else {
        *double_buf_toggle = 0;
        *(int *)0x06078894 = scroll_offset;
        *(int *)0x060788A0 = *(int *)selection_counter;
      }
    }
  }
  else {
    /* Scroll up: increment selection with CD preview load */
    *(int *)0x0607889C = 0xFFFF0000; /* scroll_direction = negative */
    prev_index = *(int *)selection_counter;
    *(int *)selection_counter = prev_index + 1;
    if (max_entries < prev_index + 1) {
      *(int *)selection_counter = 0; /* wrap around */
    }
    if (*double_buf_toggle == '\0') {
      *double_buf_toggle = 1;
      (*(int(*)())0x060359E4)();     /* cd_seek_preview */
      result = (*(int(*)())0x060357B8)(); /* cd_read_preview */
      *(unsigned int *)0x06078898 = result; /* page_a_offset = cd data */
      *(int *)0x060788A4 = *(int *)selection_counter;
    }
    else {
      *double_buf_toggle = 0;
      (*(int(*)())0x060359E4)();
      result = (*(int(*)())0x060357B8)();
      *(unsigned int *)0x06078894 = result;
      *(int *)0x060788A0 = *(int *)selection_counter;
    }
  }

  /* Update current display index */
  new_index = *(unsigned int *)selection_counter;
  *(unsigned int *)current_index = new_index;
  *(unsigned int *)odd_even_flag = new_index & 1;

  /* DMA transfer track preview sprite if index < 10 */
  if (*(unsigned int *)current_index < 10) {
    if (*double_buf_toggle == '\0') {
      scroll_offset = *(int *)(0x0605D05C + *(int *)((int)(int)current_index << 2));
      dma_target = (int *)0x06078884; /* vdp1_target_a */
    }
    else {
      scroll_offset = *(int *)(0x0605D05C + *(int *)((int)(int)current_index << 2));
      dma_target = (int *)0x06078880; /* vdp1_target_b */
    }
    result = (*(int(*)())0x0602766C)(*dma_target,scroll_offset,0xc0); /* dma_copy_vdp1_alt */
  }

  /* DMA transfer selection highlight when button was pressed */
  if ((param_1 & 0xffff & (unsigned int)0x0000C000) != 0) {
    if (*(unsigned int *)current_index < 0xc) {
      max_entries = *(int *)current_index;
    }
    else {
      max_entries = *(int *)current_index + -2;
    }
    result = (*(int(*)())0x0602761E)(0x25F00000 + (*(int *)((int)(int)odd_even_flag << 1) + 0x23) << 5,
                       0x0605CA9C + (max_entries << 6),0x40);
    return result;
  }

  return result;
}

/* track_select_analog_scroll -- handle analog stick input for track/music selection menu */
unsigned int FUN_06010760()
{
  char game_mode;
  char *dma_copy_fn;
  char *double_buf_toggle;
  char *current_index;
  char *selection_counter;
  char *scroll_target;
  unsigned int stick_pos;
  unsigned int result;
  unsigned int new_index;
  int prev_index;
  int max_entries;
  int scroll_offset;

  selection_counter = (short *)0x0607EADC; /* selection index counter */
  current_index = (char *)0x06078868;      /* displayed track index */
  double_buf_toggle = (int *)0x060788A8;   /* double-buffer page toggle */
  dma_copy_fn = (char *)0x0602761E;        /* dma_copy_vdp1 function */

  /* Determine max selection entries based on game mode */
  game_mode = *(int *)0x0605AB16;
  if ((game_mode == '\x01') || (game_mode == '\x02')) {
LAB_06010782:
    max_entries = 5;
  }
  else {
    if (game_mode != '\x03') {
      if (game_mode == '\x04') goto LAB_06010782;
      if ((game_mode != '\x05') && (game_mode != '\x06')) {
        if (game_mode == '\a') {
          max_entries = 9;
        }
        else {
          max_entries = 3; /* default: 4 entries (0-3) */
        }
        goto LAB_060107c8;
      }
    }
    max_entries = 7;
  }

LAB_060107c8:
  /* Special mode overrides */
  if (*(int *)0x0605AB17 == '\a') {
    max_entries = 0xb;
  }
  if (*(int *)0x0605AB17 == '\x0f') {
    max_entries = 0xd;
  }

  /* Read analog stick X position (inverted, 8-bit) */
  stick_pos = ((unsigned int)*(unsigned short *)0x06063D9C ^ (unsigned int)0x0000FFFF) & 0xff;
  result = stick_pos;

  /* Stick right (> 0x90): scroll forward */
  if (0x90 < (int)stick_pos) {
    *(int *)0x0607889C = 0xFFFF0000; /* scroll_direction = negative */
    *(int *)0x0605AA9C = 0x1e;       /* scroll_repeat_delay = 30 frames */
    prev_index = *(int *)selection_counter;
    *(int *)selection_counter = prev_index + 1;
    if (max_entries < prev_index + 1) {
      *(int *)selection_counter = 0; /* wrap around */
    }
    scroll_target = (char *)0x000C0000;
    result = (unsigned int)(unsigned char)*double_buf_toggle;
    if (result == 0) {
      *double_buf_toggle = 1;
      *(char **)0x06078898 = scroll_target; /* page_a_offset */
      *(int *)0x060788A4 = *(int *)selection_counter; /* page_a_index */
    }
    else {
      *double_buf_toggle = 0;
      *(char **)0x06078894 = scroll_target; /* page_b_offset */
      *(int *)0x060788A0 = *(int *)selection_counter; /* page_b_index */
    }
  }

  /* Stick left (< 0x70): scroll backward */
  if (stick_pos < 0x70) {
    *(char **)0x0607889C = 0x00010000; /* scroll_direction = positive */
    *(int *)0x0605AA9C = 0x1e;         /* scroll_repeat_delay */
    prev_index = *(int *)selection_counter;
    *(int *)selection_counter = prev_index + -1;
    if (prev_index + -1 < 0) {
      *(int *)selection_counter = max_entries; /* wrap to end */
    }
    scroll_offset = 0xFFF40000;
    result = (unsigned int)(unsigned char)*double_buf_toggle;
    if (result == 0) {
      *double_buf_toggle = 1;
      *(int *)0x06078898 = scroll_offset;
      *(int *)0x060788A4 = *(int *)selection_counter;
    }
    else {
      *double_buf_toggle = 0;
      *(int *)0x06078894 = scroll_offset;
      *(int *)0x060788A0 = *(int *)selection_counter;
    }
  }

  /* Update current display index */
  new_index = *(unsigned int *)selection_counter;
  *(unsigned int *)current_index = new_index;
  *(unsigned int *)0x0607EAB8 = new_index & 1; /* odd/even page flag */

  /* DMA transfer track preview sprite if index < 10 */
  if (*(unsigned int *)current_index < 10) {
    if (*double_buf_toggle == '\0') {
      scroll_offset = *(int *)(0x0605D05C + *(int *)((int)(int)current_index << 2));
      max_entries = *(int *)(0x06059FFC << 3) + *(int *)0x06063F5C + 0x40;
    }
    else {
      scroll_offset = *(int *)(0x0605D05C + *(int *)((int)(int)current_index << 2));
      max_entries = *(int *)(0x06059FFC << 3) + *(int *)0x06063F5C + DAT_0601096e + 0x40;
    }
    result = (*(int(*)())dma_copy_fn)(max_entries,scroll_offset,0xc0);
  }

  /* DMA transfer selection highlight arrow when stick moved */
  if ((stick_pos < 0x70) || (0x90 < (int)stick_pos)) {
    if (*(unsigned int *)current_index < 0xc) {
      max_entries = *(int *)current_index;
    }
    else {
      max_entries = *(int *)current_index + -2;
    }
    result = (*(int(*)())dma_copy_fn)(0x25F00000 + (*(int *)(0x0607EAB8 << 1) + 0x23) << 5,
                              0x0605CA9C + (max_entries << 6),0x40);
  }

  return result;
}

/* character_sprite_dma -- DMA-copy character sprite data for current selection.
 * Normal mode (0x06083255 == 0): copies 0xC0 bytes from sprite table indexed
 *   by car selection (0x06078868), dest from scroll offset + VDP base + 0x40.
 * Demo mode: copies 0x20 bytes from demo sprite table indexed by 0x0607EAB8,
 *   dest includes player count offset and additional scroll offset.
 * Always copies a second sprite block for the overlay at 0x0607ED91. */
#if 0 /* FUN_06010994 -- replaced by ASM import */
void FUN_06010994(void)
{
  int scroll_base = *(int *)0x06063F5C;   /* VDP scroll base address */
  int scroll_page = *(int *)0x06059FFC;   /* current scroll page index */
  int dest, src, size;

  if (*(int *)0x06083255 == '\0') {
    size = 0xc0;
    src = *(int *)(0x0605D05C + *(int *)(0x06078868 << 2));
    dest = *(int *)(scroll_page << 3) + scroll_base + 0x40;
  } else {
    size = 0x20;
    src = *(int *)(0x0605D0AC + *(int *)(0x0607EAB8 << 2));
    dest = ((unsigned int)(unsigned char)((int *)0x060448B5)[CAR_COUNT] +
            (unsigned int)*(unsigned short *)0x0607886C) << 5 +
            *(int *)(scroll_page << 3) + scroll_base;
  }

  (*(int(*)())0x0602761E)(dest, src, size);
  (*(int(*)())0x0602761E)(*(int *)(scroll_page << 3) + scroll_base + DAT_06010a2a + 0x40,
                    *(int *)(0x0605D05C + (unsigned int)(unsigned char)*(int *)(0x0607ED91 << 2)));
}
#endif

/* FUN_06010994 -- original binary (272 bytes) */
__asm__(
    ".section .text.FUN_06010994, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06010994\n"
    ".type _FUN_06010994, @function\n"
    "_FUN_06010994:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0xDC, 0x23, 0xDD, 0x24, 0xDE, 0x24, 0xD0, 0x25\n"  /* 0x06010994 */
    ".byte 0x60, 0x00, 0x20, 0x08, 0x89, 0x1A, 0xE6, 0x20, 0xD5, 0x23, 0xD3, 0x24, 0xD4, 0x24, 0xD2, 0x25\n"  /* 0x060109A4 */
    ".byte 0xD1, 0x25, 0x60, 0xC2, 0x65, 0x52, 0x64, 0x42, 0x61, 0x11, 0x40, 0x08, 0x45, 0x08, 0x34, 0x2C\n"  /* 0x060109B4 */
    ".byte 0x61, 0x1D, 0x35, 0x3C, 0x64, 0x40, 0x65, 0x52, 0x64, 0x4C, 0x34, 0x1C, 0x44, 0x08, 0x44, 0x08\n"  /* 0x060109C4 */
    ".byte 0x44, 0x00, 0x40, 0x00, 0x34, 0x0C, 0x61, 0xD2, 0xA0, 0x0D, 0x34, 0x1C, 0x96, 0x23, 0xD5, 0x1B\n"  /* 0x060109D4 */
    ".byte 0xD3, 0x1B, 0x64, 0xC2, 0x65, 0x52, 0x44, 0x08, 0x45, 0x08, 0x35, 0x3C, 0x65, 0x52, 0x44, 0x00\n"  /* 0x060109E4 */
    ".byte 0x62, 0xD2, 0x34, 0x2C, 0x74, 0x40, 0x4E, 0x0B, 0x00, 0x09, 0x96, 0x14, 0xD5, 0x15, 0xD3, 0x14\n"  /* 0x060109F4 */
    ".byte 0x64, 0xC2, 0x62, 0xD2, 0x61, 0x63, 0x65, 0x50, 0x44, 0x08, 0x71, 0x40, 0x65, 0x5C, 0x44, 0x00\n"  /* 0x06010A04 */
    ".byte 0x45, 0x08, 0x34, 0x2C, 0x35, 0x3C, 0x65, 0x52, 0x4E, 0x0B, 0x34, 0x1C, 0x4F, 0x26, 0x6C, 0xF6\n"  /* 0x06010A14 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x00, 0xC0, 0x06, 0x05, 0x9F, 0xFC, 0x06, 0x06, 0x3F, 0x5C\n"  /* 0x06010A24 */
    ".byte 0x06, 0x02, 0x76, 0x1E, 0x06, 0x08, 0x32, 0x55, 0x06, 0x07, 0xEA, 0xB8, 0x06, 0x05, 0xD0, 0xAC\n"  /* 0x06010A34 */
    ".byte 0x06, 0x07, 0xEA, 0xD8, 0x06, 0x04, 0x48, 0xB5, 0x06, 0x07, 0x88, 0x6C, 0x06, 0x07, 0x88, 0x68\n"  /* 0x06010A44 */
    ".byte 0x06, 0x05, 0xD0, 0x5C, 0x06, 0x07, 0xED, 0x91, 0x7F, 0xFC, 0x65, 0x43, 0x2F, 0x42, 0x45, 0x08\n"  /* 0x06010A54 */
    ".byte 0x96, 0x30, 0xD3, 0x1A, 0xD4, 0x1A, 0x35, 0x3C, 0x64, 0x42, 0x65, 0x52, 0x44, 0x08, 0x44, 0x00\n"  /* 0x06010A64 */
    ".byte 0xD2, 0x18, 0x62, 0x22, 0x34, 0x2C, 0x61, 0x63, 0x71, 0x40, 0x34, 0x1C, 0xD1, 0x16, 0x41, 0x2B\n"  /* 0x06010A74 */
    ".byte 0x7F, 0x04, 0x64, 0x4D, 0x93, 0x1F, 0x24, 0x39, 0x24, 0x48, 0x89, 0x04, 0xE3, 0x01, 0xD2, 0x13\n"  /* 0x06010A84 */
    ".byte 0x22, 0x32, 0xA0, 0x03, 0x00, 0x09, 0xE3, 0x00, 0xD2, 0x10, 0x22, 0x32, 0x00, 0x0B, 0x00, 0x09\n"  /* 0x06010A94 */
);


/* subsystem_slot_dma -- DMA a sprite data block for subsystem HUD slot.
 * Destination: scroll page base + HUD offset + 0x40.
 * Source: character sprite table indexed by slot_idx. */
void subsystem_slot_dma(int slot_idx)
{
    int dest = *(int *)(0x06059FFC << 3) + *(int *)0x06063F5C + PTR_DAT_06010ac8 + 0x40;
    int src = *(int *)(0x0605D05C + (slot_idx << 2));
    (*(int(*)())0x0602761E)(dest, src);
}
void FUN_06010a5c(int slot_idx) __attribute__((alias("subsystem_slot_dma")));

/* sound_bank_load -- Load the sound bank for the current course/mode.
 * Normal mode: look up bank ID from course sound table, indexed by course.
 * Demo mode: use fixed SCSP bank IDs (different bank for player 2).
 * The SCSP command function at 0x0601D5F4 sends the bank load command. */
#if 0 /* sound_bank_load -- redirected to ASM import via linker PROVIDE */
int sound_bank_load(void)
{
    int scsp_cmd = 0x0601D5F4;
    int result;

    if (DEMO_MODE_FLAG == 0) {
        int course = CHAR_SELECT_IDX;
        int bank_id = *(int *)(0x0604483C + (course << 2));
        result = (*(int(*)())scsp_cmd)(0, bank_id);
    } else {
        int bank = 0xAB110BFF;
        if (*(int *)0x06078644 == 1)
            bank = 0xAB110AFF;
        result = (*(int(*)())scsp_cmd)(0, bank);
    }
    return result;
}
#endif /* sound_bank_load */
#if 0 /* FUN_06010B54 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // int FUN_06010b54(void) __attribute__((alias("sound_bank_load")));
#endif

#if 0 /* FUN_06010BC4 -- replaced by ASM import */
int FUN_06010bc4()
{
  unsigned short dma_complete_mask;
  short angle_step;
  char *pos_y;          /* 0x06078894 */
  char *pos_z;          /* 0x06078898 */
  char *anim_counter;   /* 0x0608A52C */
  char *rotation;       /* 0x06078878 */
  int result;
  unsigned char *dma_status;  /* 0xFFFFFE11 — SH-2 DMA operation register */
  rotation = (char *)0x06078878;
  anim_counter = (short *)0x0608A52C;
  pos_z = (char *)0x06078898;
  pos_y = (int *)0x06078894;
  angle_step = PTR_DAT_06010c50;
  dma_complete_mask = DAT_06010c4e;
  dma_status = (unsigned char *)-495;          /* 0xFFFFFE11 */
  if (*(int *)0x06085FF4 == '\0') {
    /* First-run: initial position setup */
    *(int *)0x060788A0 = 1;                    /* model slot active */
    *(short *)rotation = *(short *)rotation + angle_step;
    FUN_06011310();
    pos_y = (int *)0x060270D0;                 /* matrix push function */
    *(int *)anim_counter = *(int *)anim_counter + 0x30;
    (*(int(*)())pos_y)();
    /* Set initial 3D position (fixed-point) */
    *(int *)0x0607884C = 1;                    /* model visible */
    *(char **)0x06078850 = 0x00038000;         /* initial X */
    *(int *)0x06078854 = 0xFFFF0000;           /* initial Y (-1.0) */
    *(char **)0x06078858 = 0x0006B333;         /* initial Z (+6.7) */
    *(char **)0x06063574 = 0x06010F04;         /* render callback */
    *(short *)0x21000000 = (short)0x0000FFFF;  /* VDP1 system clip */
    FUN_06010d94(0,0xFFFC8000,0xFFFF0000,0x0006B333);
    pos_y = (int *)0x0603C000;                 /* object render */
    /* Poll DMA completion */
    do {
    } while ((*dma_status & dma_complete_mask) != dma_complete_mask);
    *dma_status = *dma_status & 0xf;           /* clear DMA status */
    result = (*(int(*)())pos_y)();
  }
  else {
    /* Ongoing: apply velocity with clamping */
    *(short *)0x06078878 = *(short *)0x06078878 + PTR_DAT_06010c50;
    rotation = (char *)0x0607889C;             /* velocity */
    *(int *)pos_y = *(int *)pos_y + *(int *)0x0607889C;
    *(int *)pos_z = *(int *)pos_z + *(int *)rotation;
    /* Clamp position at zero based on velocity direction and axis */
    if (*(int *)rotation < 0) {
      if (*(int *)0x060788A8 == '\0') {
        if (*(int *)pos_y < 1) {
          *(int *)pos_y = 0;
          *(int *)rotation = 0;
        }
      }
      else if ((*(int *)0x060788A8 == '\x01') && (*(int *)pos_z < 1)) {
        *(int *)pos_z = 0;
        *(int *)rotation = 0;
      }
    }
    else if (*(int *)0x060788A8 == '\0') {
      if (-1 < *(int *)pos_y) {
        *(int *)pos_y = 0;
        *(int *)rotation = 0;
      }
    }
    else if ((*(int *)0x060788A8 == '\x01') && (-1 < *(int *)pos_z)) {
      *(int *)pos_z = 0;
      *(int *)rotation = 0;
    }
    FUN_060111e2();
    rotation = (char *)0x060270D0;             /* matrix push */
    *(int *)anim_counter = *(int *)anim_counter + 0x30;
    (*(int(*)())rotation)();
    /* Set current position for rendering */
    *(int *)0x0607884C = 1;
    *(int *)0x06078850 = *(int *)pos_z;
    *(int *)0x06078854 = 0xFFFF3334;           /* Y offset (-0.8) */
    *(char **)0x06078858 = 0x00063333;         /* Z offset (+6.2) */
    *(char **)0x06063574 = 0x06010F04;         /* render callback */
    *(short *)0x21000000 = (short)0x0000FFFF;  /* VDP1 system clip */
    FUN_06010d94(0,*(int *)pos_y,0xFFFF3334,0x00063333);
    pos_y = (int *)0x0603C000;                 /* object render */
    /* Poll DMA completion */
    do {
    } while ((*dma_status & dma_complete_mask) != dma_complete_mask);
    *dma_status = *dma_status & 0xf;
    result = (*(int(*)())pos_y)();
  }
  *(int *)anim_counter = *(int *)anim_counter + -0x30;
  return result;

}
#endif

/* FUN_06010B54 -- original binary (112 bytes) */
__asm__(
    ".section .text.FUN_06010B54, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06010B54\n"
    ".global _FUN_06010b54\n"
    ".type _FUN_06010B54, @function\n"
    "_FUN_06010B54:\n"
    "_FUN_06010b54:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0xDE, 0x0E, 0xD0, 0x0F, 0x60, 0x02, 0x20, 0x08, 0x89, 0x25, 0xD0, 0x0E\n"  /* 0x06010B54 */
    ".byte 0x60, 0x02, 0x88, 0x01, 0x8B, 0x1C, 0xD5, 0x0D, 0xA0, 0x1B, 0x00, 0x09, 0x06, 0xFC, 0x02, 0x00\n"  /* 0x06010B64 */
    ".byte 0x00, 0xE1, 0x00, 0xE2, 0x00, 0x90, 0x07, 0xA2, 0x06, 0x06, 0x3F, 0x42, 0x06, 0x06, 0x3D, 0x9E\n"  /* 0x06010B74 */
    ".byte 0x06, 0x07, 0x88, 0x7F, 0x06, 0x07, 0x88, 0x68, 0x06, 0x05, 0xAC, 0xE3, 0x06, 0x02, 0x84, 0xAE\n"  /* 0x06010B84 */
    ".byte 0x06, 0x01, 0xD5, 0xF4, 0x06, 0x07, 0xEA, 0xE0, 0x06, 0x07, 0x86, 0x44, 0xAB, 0x11, 0x0A, 0xFF\n"  /* 0x06010B94 */
    ".byte 0xD5, 0x2B, 0x4E, 0x0B, 0xE4, 0x00, 0xA0, 0x08, 0x00, 0x09, 0xD5, 0x2A, 0xD3, 0x2A, 0x65, 0x52\n"  /* 0x06010BA4 */
    ".byte 0x45, 0x08, 0x35, 0x3C, 0x65, 0x52, 0x4E, 0x0B, 0xE4, 0x00, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x06010BB4 */
);

/* FUN_06010BC4 -- original binary (464 bytes) */
__asm__(
    ".section .text.FUN_06010BC4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06010BC4\n"
    ".global _FUN_06010bc4\n"
    ".type _FUN_06010BC4, @function\n"
    "_FUN_06010BC4:\n"
    "_FUN_06010bc4:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x4F, 0x22, 0xE9, 0x01\n"  /* 0x06010BC4 */
    ".byte 0xDA, 0x22, 0xDB, 0x23, 0xDC, 0x23, 0x9D, 0x37, 0x9E, 0x37, 0x96, 0x37, 0xD5, 0x22, 0xD0, 0x23\n"  /* 0x06010BD4 */
    ".byte 0x60, 0x00, 0x20, 0x08, 0x8F, 0x02, 0xE4, 0x00, 0xA0, 0x79, 0x00, 0x09, 0x63, 0x51, 0x33, 0x6C\n"  /* 0x06010BE4 */
    ".byte 0x25, 0x31, 0xD5, 0x1F, 0x62, 0xA2, 0x63, 0x52, 0x32, 0x3C, 0x2A, 0x22, 0x62, 0xB2, 0x63, 0x52\n"  /* 0x06010BF4 */
    ".byte 0x32, 0x3C, 0x2B, 0x22, 0xD6, 0x1B, 0x62, 0x52, 0x42, 0x11, 0x8B, 0x14, 0x60, 0x60, 0xA0, 0x0C\n"  /* 0x06010C04 */
    ".byte 0x60, 0x0C, 0x62, 0xA2, 0x42, 0x11, 0x8B, 0x39, 0x2A, 0x42, 0xA0, 0x37, 0x25, 0x42, 0x62, 0xB2\n"  /* 0x06010C14 */
    ".byte 0x42, 0x11, 0x8B, 0x33, 0x2B, 0x42, 0xA0, 0x31, 0x25, 0x42, 0x88, 0x00, 0x89, 0xF1, 0x88, 0x01\n"  /* 0x06010C24 */
    ".byte 0x89, 0xF5, 0xA0, 0x2B, 0x00, 0x09, 0x60, 0x60, 0xA0, 0x24, 0x60, 0x0C, 0x62, 0xA2, 0x42, 0x15\n"  /* 0x06010C34 */
    ".byte 0x89, 0x24, 0x2A, 0x42, 0xA0, 0x22, 0x25, 0x42, 0xFE, 0x11, 0x00, 0x80, 0x01, 0x00, 0xFF, 0xFF\n"  /* 0x06010C44 */
    ".byte 0xAB, 0x11, 0x0B, 0xFF, 0x06, 0x07, 0xEA, 0xB8, 0x06, 0x04, 0x48, 0x3C, 0x06, 0x07, 0x88, 0x94\n"  /* 0x06010C54 */
    ".byte 0x06, 0x07, 0x88, 0x98, 0x06, 0x08, 0xA5, 0x2C, 0x06, 0x07, 0x88, 0x78, 0x06, 0x08, 0x5F, 0xF4\n"  /* 0x06010C64 */
    ".byte 0x06, 0x07, 0x88, 0x9C, 0x06, 0x07, 0x88, 0xA8, 0x62, 0xB2, 0x42, 0x15, 0x89, 0x06, 0x2B, 0x42\n"  /* 0x06010C74 */
    ".byte 0xA0, 0x04, 0x25, 0x42, 0x88, 0x00, 0x89, 0xD9, 0x88, 0x01, 0x89, 0xF5, 0xB2, 0xA7, 0x00, 0x09\n"  /* 0x06010C84 */
    ".byte 0x62, 0xC2, 0xD3, 0x2E, 0x72, 0x30, 0x43, 0x0B, 0x2C, 0x22, 0xD3, 0x2D, 0x23, 0x92, 0x62, 0xB2\n"  /* 0x06010C94 */
    ".byte 0xD3, 0x2C, 0x23, 0x22, 0xD2, 0x2C, 0xD3, 0x2D, 0x23, 0x22, 0xD2, 0x2D, 0xD3, 0x2D, 0x23, 0x22\n"  /* 0x06010CA4 */
    ".byte 0xD2, 0x2D, 0xD3, 0x2E, 0x23, 0x22, 0xD2, 0x2E, 0xD3, 0x2E, 0x23, 0x21, 0xD7, 0x28, 0xD6, 0x26\n"  /* 0x06010CB4 */
    ".byte 0x65, 0xA2, 0xB0, 0x65, 0xE4, 0x00, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x8B, 0xFA\n"  /* 0x06010CC4 */
    ".byte 0x60, 0xD0, 0xD3, 0x29, 0xC9, 0x0F, 0x43, 0x0B, 0x2D, 0x00, 0xA0, 0x2B, 0x00, 0x09, 0xD7, 0x27\n"  /* 0x06010CD4 */
    ".byte 0x27, 0x92, 0x62, 0x51, 0x32, 0x6C, 0xB3, 0x11, 0x25, 0x21, 0x62, 0xC2, 0xD3, 0x17, 0x72, 0x30\n"  /* 0x06010CE4 */
    ".byte 0x43, 0x0B, 0x2C, 0x22, 0xD3, 0x16, 0x23, 0x92, 0xD2, 0x21, 0xD3, 0x16, 0x23, 0x22, 0xD2, 0x21\n"  /* 0x06010CF4 */
    ".byte 0xD3, 0x16, 0x23, 0x22, 0xD2, 0x20, 0xD3, 0x17, 0x23, 0x22, 0xD2, 0x17, 0xD3, 0x17, 0x23, 0x22\n"  /* 0x06010D04 */
    ".byte 0xD2, 0x17, 0xD3, 0x18, 0x23, 0x21, 0xD7, 0x1C, 0xD6, 0x1A, 0xD5, 0x1C, 0xB0, 0x38, 0xE4, 0x00\n"  /* 0x06010D14 */
    ".byte 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x8B, 0xFA, 0x60, 0xD0, 0xD3, 0x12, 0xC9, 0x0F\n"  /* 0x06010D24 */
    ".byte 0x43, 0x0B, 0x2D, 0x00, 0x62, 0xC2, 0x72, 0xD0, 0x2C, 0x22, 0x4F, 0x26, 0x69, 0xF6, 0x6A, 0xF6\n"  /* 0x06010D34 */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xFF, 0xFF, 0x06, 0x02, 0x70, 0xD0\n"  /* 0x06010D44 */
    ".byte 0x06, 0x07, 0x88, 0x4C, 0x06, 0x07, 0x88, 0x50, 0xFF, 0xFF, 0x33, 0x34, 0x06, 0x07, 0x88, 0x54\n"  /* 0x06010D54 */
    ".byte 0x00, 0x06, 0x33, 0x33, 0x06, 0x07, 0x88, 0x58, 0x06, 0x01, 0x0F, 0x04, 0x06, 0x06, 0x35, 0x74\n"  /* 0x06010D64 */
    ".byte 0x00, 0x00, 0xFF, 0xFF, 0x21, 0x00, 0x00, 0x00, 0x06, 0x03, 0xC0, 0x00, 0x06, 0x07, 0x88, 0xA0\n"  /* 0x06010D74 */
    ".byte 0x00, 0x03, 0x80, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x06, 0xB3, 0x33, 0xFF, 0xFC, 0x80, 0x00\n"  /* 0x06010D84 */
);


/* character_model_3d_render -- Render 3D character model with matrix pipeline.
 * Only renders if slot index at 0x060788A0 < 10 (max visible models).
 * Pushes matrix stack (0x06026E0C), translates by param position,
 * rotates by heading angle from 0x06078878. Then renders 3 body
 * segments (torso/arms/legs) each with: multiply (0x06031D8C),
 * scale (0x06031A28), matrix pop (0x06026DBC), translate, repeat.
 * Transform data at 0x06044640-0x06044678, rotation index from
 * table at 0x06089E44. State pointer at 0x06089EDC tracks stack. */
#if 0 /* FUN_06010D94 -- replaced by ASM import */
void FUN_06010d94(param_1, param_2, param_3, param_4)
    int param_1;
    int param_2;
    int param_3;
    int param_4;
{
  short *rot_entry;

  if (*(unsigned int *)0x060788A0 < 10) {               /* max visible models */
    OBJ_STATE_PRIMARY = OBJ_STATE_PRIMARY + 0x30;        /* advance state */
    (*(int(*)())0x06026E0C)();                           /* matrix_push */
    (*(int(*)())0x06026E2E)(param_2, param_3, param_4);  /* matrix_translate */
    (*(int(*)())0x06026EDE)((int)*(short *)0x06078878);  /* matrix_rotate_y (heading) */
    rot_entry = (short *)(0x06089E44 + (param_1 << 1));  /* rotation index table */
    /* --- segment 0: torso --- */
    (*(int(*)())0x06031D8C)(*(int *)0x0606212C, *(int *)0x060621D8);  /* matrix_multiply */
    (*(int(*)())0x06031A28)(*(int *)0x060620D8, (int)*rot_entry, *(int *)0x06062180); /* matrix_scale */
    (*(int(*)())0x06026DBC)();                           /* matrix_pop */
    (*(int(*)())0x06026E2E)(*(int *)0x06044640, *(int *)0x06044644,   /* translate seg 1 */
                      -*(int *)0x06044648);
    /* --- segment 1: arms --- */
    (*(int(*)())0x06031D8C)(*(int *)(0x0606212C + 4), *(int *)0x060621DC);
    (*(int(*)())0x06031A28)(*(int *)(0x060620D8 + 4), (int)*rot_entry, *(int *)(0x06062180 + 4));
    *(int *)0x06089EDC = *(int *)0x06089EDC + -0x30;     /* stack adjust */
    (*(int(*)())0x06026DBC)();                           /* matrix_pop */
    (*(int(*)())0x06026E2E)(*(int *)0x0604464C, *(int *)0x06044650,   /* translate seg 2 */
                      -*(int *)0x06044654);
    /* --- segment 2: legs --- */
    (*(int(*)())0x06031D8C)(*(int *)(0x0606212C + 8), *(int *)0x060621E0);
    (*(int(*)())0x06031A28)(*(int *)(0x060620D8 + 8), (int)*rot_entry, *(int *)(0x06062180 + 8));
    *(int *)0x06089EDC = *(int *)0x06089EDC + -0x30;     /* stack adjust */
    (*(int(*)())0x06026DBC)();                           /* matrix_pop */
    (*(int(*)())0x06026E2E)(*(int *)0x06044670, *(int *)0x06044674,   /* translate seg 3 */
                      -*(int *)0x06044678);
    /* --- segment 3: extra --- */
    (*(int(*)())0x06031D8C)(*(int *)(0x0606212C + 0xc), *(int *)0x060621E4);
    (*(int(*)())0x06031A28)(*(int *)(0x060620D8 + 0xc), (int)*rot_entry, *(int *)(0x06062180 + 0xc));
    *(int *)0x06089EDC = *(int *)0x06089EDC + -0x60;     /* stack adjust (2 levels) */
  }
}
#endif

/* course_banner_render -- Render 3-layer course selection banner sprites.
 * Draws course name/icon in 3 priority layers via VDP1 (0x06028400).
 * Layer priority flickers based on FRAME_COUNTER (mode 3: every frame,
 * otherwise every 2 frames) for the active player's selection.
 * Non-selected players forced to priority 3.
 * Sprite data from 0x0605AC70 (car table) and 0x0605AB98 (course table).
 * Banner position from 0x06063750 + DAT_0601112c. */
/* FUN_06011094 -- original binary (334 bytes) */
__asm__(
    ".section .text.FUN_06011094, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011094\n"
    ".type _FUN_06011094, @function\n"
    "_FUN_06011094:\n"
    ".byte 0x2F, 0xE6, 0xE4, 0x03, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86\n"  /* 0x06011094 */
    ".byte 0x4F, 0x22, 0x7F, 0xF0, 0xD5, 0x22, 0xD0, 0x23, 0x60, 0x00, 0x60, 0x0C, 0x88, 0x03, 0x8F, 0x07\n"  /* 0x060110A4 */
    ".byte 0x6E, 0x43, 0x60, 0x52, 0xC8, 0x01, 0x89, 0x01, 0xA0, 0x0A, 0x6C, 0xE3, 0xA0, 0x08, 0xEC, 0x04\n"  /* 0x060110B4 */
    ".byte 0x6C, 0x52, 0xE3, 0x02, 0x2C, 0x49, 0x3C, 0x33, 0x89, 0x01, 0xA0, 0x01, 0x6C, 0xE3, 0xEC, 0x04\n"  /* 0x060110C4 */
    ".byte 0xD4, 0x19, 0x90, 0x29, 0xD9, 0x19, 0x0B, 0x4E, 0x70, 0x10, 0x0A, 0x4E, 0x60, 0x92, 0x20, 0x08\n"  /* 0x060110D4 */
    ".byte 0x89, 0x01, 0xA0, 0x01, 0x2F, 0xE2, 0x2F, 0xC2, 0xDD, 0x15, 0x67, 0xF2, 0x47, 0x18, 0x47, 0x08\n"  /* 0x060110E4 */
    ".byte 0x47, 0x08, 0x1F, 0x71, 0x37, 0xBC, 0x96, 0x18, 0xD0, 0x12, 0xD3, 0x13, 0x60, 0x02, 0x40, 0x08\n"  /* 0x060110F4 */
    ".byte 0x1F, 0x33, 0x05, 0x3E, 0x4D, 0x0B, 0xE4, 0x04, 0xD8, 0x10, 0x57, 0xF1, 0x96, 0x0E, 0xD3, 0x10\n"  /* 0x06011104 */
    ".byte 0x60, 0x82, 0x37, 0xAC, 0x40, 0x08, 0x2F, 0x32, 0x05, 0x3E, 0x4D, 0x0B, 0xE4, 0x08, 0x60, 0x92\n"  /* 0x06011114 */
    ".byte 0x88, 0x01, 0x89, 0x17, 0xA0, 0x17, 0x1F, 0xE1, 0x00, 0xD4, 0x02, 0x82, 0x04, 0x8C, 0xFF, 0xFF\n"  /* 0x06011124 */
    ".byte 0x06, 0x07, 0xEB, 0xC8, 0x06, 0x07, 0x88, 0x7F, 0x06, 0x06, 0x37, 0x50, 0x06, 0x07, 0xEA, 0xDC\n"  /* 0x06011134 */
    ".byte 0x06, 0x02, 0x84, 0x00, 0x06, 0x07, 0x86, 0x44, 0x06, 0x05, 0xAC, 0x70, 0x06, 0x05, 0xAD, 0x00\n"  /* 0x06011144 */
    ".byte 0x06, 0x05, 0xAB, 0x98, 0x1F, 0xC1, 0x57, 0xF1, 0x77, 0x02, 0x47, 0x18, 0x47, 0x08, 0x47, 0x08\n"  /* 0x06011154 */
    ".byte 0x1F, 0x72, 0x37, 0xBC, 0x96, 0x4D, 0xD5, 0x29, 0x53, 0xF3, 0x65, 0x52, 0x45, 0x08, 0x35, 0x3C\n"  /* 0x06011164 */
    ".byte 0x55, 0x53, 0x4D, 0x0B, 0xE4, 0x04, 0x57, 0xF2, 0x96, 0x44, 0x65, 0x82, 0x63, 0xF2, 0x37, 0xAC\n"  /* 0x06011174 */
    ".byte 0x45, 0x08, 0x35, 0x3C, 0x55, 0x53, 0x4D, 0x0B, 0xE4, 0x08, 0x60, 0x92, 0x88, 0x02, 0x89, 0x01\n"  /* 0x06011184 */
    ".byte 0xA0, 0x01, 0x1F, 0xE2, 0x1F, 0xC2, 0x57, 0xF2, 0x77, 0x04, 0x47, 0x18, 0x47, 0x08, 0x47, 0x08\n"  /* 0x06011194 */
    ".byte 0x1F, 0x71, 0x37, 0xBC, 0x96, 0x2F, 0xD5, 0x19, 0x53, 0xF3, 0x65, 0x52, 0x45, 0x08, 0x35, 0x3C\n"  /* 0x060111A4 */
    ".byte 0x55, 0x56, 0x4D, 0x0B, 0xE4, 0x04, 0x57, 0xF1, 0x96, 0x26, 0x65, 0x82, 0x63, 0xF2, 0x37, 0xAC\n"  /* 0x060111B4 */
    ".byte 0x45, 0x08, 0x35, 0x3C, 0x55, 0x56, 0x4D, 0x0B, 0xE4, 0x08, 0x7F, 0x10, 0x4F, 0x26, 0x68, 0xF6\n"  /* 0x060111C4 */
    ".byte 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x060111D4 */
);


/* char_select_sprite -- Render character selection sprite overlay.
 * Draws 3 VDP1 sprites for character select: background banner,
 * character icon (from 0x0605ABBC indexed by car selection), and
 * transmission indicator (manual=0x0605A9B0, auto=0x0605A9B8).
 * Player A (0x0607EAB8==0): base priority, player B: priority+2.
 * Mode 0xB: flicker priority 3↔4 on alternating frames.
 * Position from scroll offset table at 0x06063828+4. */
#if 0 /* FUN_060111E2 -- replaced by ASM import */
void FUN_060111e2()
{
  int priority;
  int *sprite_pos = (int *)0x06063828;
  int vdp1_draw = 0x06028400;
  int *trans_sprite;
  int cmd_offset;
  int pos;

  priority = 3;
  if ((*(int *)0x0607887F == '\v') && ((FRAME_COUNTER & 1) == 0)) {
    priority = 4;                                        /* flicker on mode 0xB */
  }
  if (*(int *)0x0607EAB8 == 0) {                         /* player A selected */
    pos = *(int *)(sprite_pos + 4) + (priority << 12);
    (*(int(*)())vdp1_draw)(4, 0x0605A7FC, 0x2a0, pos);  /* background banner A */
    (*(int(*)())vdp1_draw)(4, *(int *)
                         (0x0605ABBC +
                         (unsigned int)(*(int *)0x06078644 != 0) << 2 + *(int *)(0x06078868 << 3)),
                      0x530, pos);                       /* character icon */
    cmd_offset = (int)DAT_060112e6;
    trans_sprite = (int *)0x0605A9B8;                    /* auto transmission sprite */
    if (*(int *)0x06078644 != 0) {
      trans_sprite = (int *)0x0605A9B0;                  /* manual transmission sprite */
    }
  } else {                                               /* player B selected */
    pos = *(int *)(sprite_pos + 4) + ((priority + 2) << 12);
    (*(int(*)())vdp1_draw)(4, 0x0605A8B6, 0x2a0, pos);  /* background banner B */
    (*(int(*)())vdp1_draw)(4, *(int *)
                         (0x0605ABBC +
                         (unsigned int)(*(int *)0x06078644 != 0) << 2 + *(int *)(0x06078868 << 3)),
                      0x530, pos);                       /* character icon */
    cmd_offset = (int)DAT_060112e6;
    trans_sprite = (int *)0x0605A9B8;
    if (*(int *)0x06078644 != 0) {
      trans_sprite = (int *)0x0605A9B0;
    }
  }
  (*(int(*)())vdp1_draw)(4, trans_sprite, cmd_offset, pos); /* transmission indicator */
}
#endif

/* FUN_060111E2 -- original binary (302 bytes) */
__asm__(
    ".section .text.FUN_060111E2, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060111E2\n"
    ".global _FUN_060111e2\n"
    ".type _FUN_060111E2, @function\n"
    "_FUN_060111E2:\n"
    "_FUN_060111e2:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x4F, 0x22, 0xD0, 0x09, 0x60, 0x00\n"  /* 0x060111E2 */
    ".byte 0x60, 0x0C, 0x88, 0x0B, 0x8F, 0x12, 0xED, 0x03, 0xD0, 0x07, 0x60, 0x02, 0xC8, 0x01, 0x89, 0x0C\n"  /* 0x060111F2 */
    ".byte 0xA0, 0x0C, 0x00, 0x09, 0x02, 0x9E, 0x04, 0xA8, 0x02, 0xBA, 0x04, 0xC4, 0xFF, 0xFF, 0x06, 0x07\n"  /* 0x06011202 */
    ".byte 0x86, 0x44, 0x06, 0x07, 0x88, 0x7F, 0x06, 0x07, 0xEB, 0xC8, 0xED, 0x04, 0xDC, 0x32, 0xDE, 0x32\n"  /* 0x06011212 */
    ".byte 0xD0, 0x33, 0x60, 0x02, 0x20, 0x08, 0x89, 0x2A, 0xDA, 0x32, 0x6B, 0xD3, 0x96, 0x58, 0xD5, 0x31\n"  /* 0x06011222 */
    ".byte 0x57, 0xA1, 0x7B, 0x02, 0x4B, 0x18, 0x4B, 0x08, 0x4B, 0x08, 0x37, 0xBC, 0x4E, 0x0B, 0xE4, 0x04\n"  /* 0x06011232 */
    ".byte 0x57, 0xA1, 0x96, 0x4E, 0x60, 0xC2, 0x20, 0x08, 0x8D, 0x02, 0x37, 0xBC, 0xA0, 0x01, 0xE0, 0x01\n"  /* 0x06011242 */
    ".byte 0xE0, 0x00, 0x40, 0x08, 0xD5, 0x29, 0xD3, 0x29, 0x65, 0x52, 0x45, 0x08, 0x45, 0x00, 0x35, 0x3C\n"  /* 0x06011252 */
    ".byte 0x05, 0x5E, 0x4E, 0x0B, 0xE4, 0x04, 0x57, 0xA1, 0x96, 0x3C, 0x60, 0xC2, 0x20, 0x08, 0x8D, 0x03\n"  /* 0x06011262 */
    ".byte 0x37, 0xBC, 0xD5, 0x23, 0xA0, 0x2B, 0x00, 0x09, 0xD5, 0x23, 0xA0, 0x28, 0x00, 0x09, 0xDA, 0x1C\n"  /* 0x06011272 */
    ".byte 0x6B, 0xD3, 0x96, 0x2D, 0xD5, 0x21, 0x57, 0xA1, 0x4B, 0x18, 0x4B, 0x08, 0x4B, 0x08, 0x37, 0xBC\n"  /* 0x06011282 */
    ".byte 0x4E, 0x0B, 0xE4, 0x04, 0x57, 0xA1, 0x96, 0x24, 0x60, 0xC2, 0x20, 0x08, 0x8D, 0x02, 0x37, 0xBC\n"  /* 0x06011292 */
    ".byte 0xA0, 0x01, 0xE0, 0x01, 0xE0, 0x00, 0x40, 0x08, 0xD5, 0x14, 0xD3, 0x14, 0x65, 0x52, 0x45, 0x08\n"  /* 0x060112A2 */
    ".byte 0x45, 0x00, 0x35, 0x3C, 0x05, 0x5E, 0x4E, 0x0B, 0xE4, 0x04, 0x57, 0xA1, 0x96, 0x12, 0x60, 0xC2\n"  /* 0x060112B2 */
    ".byte 0x20, 0x08, 0x8D, 0x03, 0x37, 0xBC, 0xD5, 0x0E, 0xA0, 0x01, 0x00, 0x09, 0xD5, 0x0E, 0x4E, 0x0B\n"  /* 0x060112C2 */
    ".byte 0xE4, 0x04, 0x4F, 0x26, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x060112D2 */
    ".byte 0x02, 0xA0, 0x05, 0x30, 0x05, 0x34, 0x06, 0x07, 0x86, 0x44, 0x06, 0x02, 0x84, 0x00, 0x06, 0x07\n"  /* 0x060112E2 */
    ".byte 0xEA, 0xB8, 0x06, 0x06, 0x38, 0x28, 0x06, 0x05, 0xA8, 0xB6, 0x06, 0x07, 0x88, 0x68, 0x06, 0x05\n"  /* 0x060112F2 */
    ".byte 0xAB, 0xBC, 0x06, 0x05, 0xA9, 0xB0, 0x06, 0x05, 0xA9, 0xB8, 0x06, 0x05, 0xA7, 0xFC\n"  /* 0x06011302 */
);


/* dual_char_select_sprite -- Render character selection for 2-player mode.
 * Draws 2 sets of 3 sprites each (banner, transmission, car variant)
 * via VDP1 (0x06028400). Player 0: uses priority flicker, forced to
 * priority 3 if not selected (0x0607EADC != 0). Player 1: priority+2.
 * Transmission sprites: auto=0x0605A9B8/0x0605A978, manual=0x0605A9B0/0x0605A998.
 * Position from scroll offset 0x06063828+4. */
#if 0 /* FUN_06011310 -- replaced by ASM import */
void FUN_06011310()
{
  int priority_base;
  int pos;

  /* determine flicker priority */
  if (*(int *)0x0607887F == '\v') {
    priority_base = ((FRAME_COUNTER & 1) == 0) ? 4 : 3;
  } else if ((FRAME_COUNTER & 3) < 2) {
    priority_base = 3;
  } else {
    priority_base = 4;
  }
  /* --- player 0 sprites --- */
  {
    int pri_0 = priority_base;
    if (*(int *)0x0607EADC != 0) pri_0 = 3;             /* non-active: force 3 */
    pos = *(int *)(0x06063828 + 4) + (pri_0 << 12);
    (*(int(*)())0x06028400)(4, 0x0605A7FC, 0x288, pos); /* banner A */
    char *trans_0 = (char *)0x0605A9B8;                  /* auto transmission */
    if (*(int *)0x06078644 != 0) trans_0 = (char *)0x0605A9B0; /* manual */
    (*(int(*)())0x06028400)(4, trans_0, (int)DAT_060113b4, pos);
    char *car_0 = (char *)0x0605A978;                    /* auto car variant */
    if (*(int *)0x06078644 != 0) car_0 = (char *)0x0605A998; /* manual */
    (*(int(*)())0x06028400)(4, car_0, 0x518, pos);
  }
  /* --- player 1 sprites --- */
  {
    int pri_1 = priority_base;
    if (*(int *)0x0607EADC != 1) pri_1 = 3;
    int offset_1 = (pri_1 + 2) << 12;
    pos = *(int *)(0x06063828 + 4) + offset_1;
    (*(int(*)())0x06028400)(4, 0x0605A8B6, (int)DAT_06011462, pos); /* banner B */
    char *trans_1 = (char *)0x0605A9B8;
    if (*(int *)0x06078644 != 0) trans_1 = (char *)0x0605A9B0;
    (*(int(*)())0x06028400)(4, trans_1, 0x54a, pos);
    char *car_1 = (char *)0x0605A980;
    if (*(int *)0x06078644 != 0) car_1 = (char *)0x0605A9A0;
    (*(int(*)())0x06028400)(4, car_1, (int)DAT_06011466, pos);
  }
}
#endif

/* FUN_06011310 -- original binary (412 bytes) */
__asm__(
    ".section .text.FUN_06011310, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011310\n"
    ".type _FUN_06011310, @function\n"
    "_FUN_06011310:\n"
    ".byte 0x2F, 0xE6, 0xE4, 0x03, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x4F, 0x22\n"  /* 0x06011310 */
    ".byte 0x7F, 0xFC, 0xD5, 0x25, 0xD0, 0x25, 0x60, 0x00, 0x60, 0x0C, 0x88, 0x0B, 0x8F, 0x07, 0x6C, 0x43\n"  /* 0x06011320 */
    ".byte 0x60, 0x52, 0xC8, 0x01, 0x89, 0x01, 0xA0, 0x0A, 0x6B, 0xC3, 0xA0, 0x08, 0xEB, 0x04, 0xE3, 0x02\n"  /* 0x06011330 */
    ".byte 0x6B, 0x52, 0x2B, 0x49, 0x3B, 0x33, 0x89, 0x01, 0xA0, 0x01, 0x6B, 0xC3, 0xEB, 0x04, 0xD0, 0x1C\n"  /* 0x06011340 */
    ".byte 0x60, 0x02, 0x20, 0x08, 0x89, 0x01, 0xA0, 0x01, 0x2F, 0xC2, 0x2F, 0xB2, 0xDD, 0x19, 0xDE, 0x1A\n"  /* 0x06011350 */
    ".byte 0x69, 0xF2, 0x96, 0x26, 0xD5, 0x19, 0x57, 0xE1, 0x49, 0x18, 0x49, 0x08, 0x49, 0x08, 0x37, 0x9C\n"  /* 0x06011360 */
    ".byte 0x4D, 0x0B, 0xE4, 0x04, 0xDA, 0x16, 0x57, 0xE1, 0x96, 0x1C, 0x60, 0xA2, 0x20, 0x08, 0x8D, 0x03\n"  /* 0x06011370 */
    ".byte 0x37, 0x9C, 0xD5, 0x14, 0xA0, 0x01, 0x00, 0x09, 0xD5, 0x13, 0x4D, 0x0B, 0xE4, 0x04, 0x57, 0xE1\n"  /* 0x06011380 */
    ".byte 0x96, 0x11, 0x60, 0xA2, 0x20, 0x08, 0x8D, 0x03, 0x37, 0x9C, 0xD5, 0x10, 0xA0, 0x01, 0x00, 0x09\n"  /* 0x06011390 */
    ".byte 0xD5, 0x0F, 0x4D, 0x0B, 0xE4, 0x04, 0xD0, 0x06, 0x60, 0x02, 0x88, 0x01, 0x89, 0x1A, 0xA0, 0x1A\n"  /* 0x060113A0 */
    ".byte 0x2F, 0xC2, 0x02, 0x88, 0x05, 0x1C, 0x05, 0x18, 0x06, 0x07, 0xEB, 0xC8, 0x06, 0x07, 0x88, 0x7F\n"  /* 0x060113B0 */
    ".byte 0x06, 0x07, 0xEA, 0xDC, 0x06, 0x02, 0x84, 0x00, 0x06, 0x06, 0x38, 0x28, 0x06, 0x05, 0xA7, 0xFC\n"  /* 0x060113C0 */
    ".byte 0x06, 0x07, 0x86, 0x44, 0x06, 0x05, 0xA9, 0xB0, 0x06, 0x05, 0xA9, 0xB8, 0x06, 0x05, 0xA9, 0x98\n"  /* 0x060113D0 */
    ".byte 0x06, 0x05, 0xA9, 0x78, 0x2F, 0xB2, 0x6C, 0xF2, 0x57, 0xE1, 0x96, 0x3A, 0xD5, 0x1E, 0x7C, 0x02\n"  /* 0x060113E0 */
    ".byte 0x4C, 0x18, 0x4C, 0x08, 0x4C, 0x08, 0x37, 0xCC, 0x4D, 0x0B, 0xE4, 0x04, 0x57, 0xE1, 0x96, 0x31\n"  /* 0x060113F0 */
    ".byte 0x60, 0xA2, 0x20, 0x08, 0x8D, 0x03, 0x37, 0xCC, 0xD5, 0x18, 0xA0, 0x01, 0x00, 0x09, 0xD5, 0x18\n"  /* 0x06011400 */
    ".byte 0x4D, 0x0B, 0xE4, 0x04, 0x57, 0xE1, 0x96, 0x26, 0x60, 0xA2, 0x20, 0x08, 0x8D, 0x03, 0x37, 0xCC\n"  /* 0x06011410 */
    ".byte 0xD5, 0x14, 0xA0, 0x01, 0x00, 0x09, 0xD5, 0x14, 0x4D, 0x0B, 0xE4, 0x04, 0x7F, 0x04, 0x4F, 0x26\n"  /* 0x06011420 */
    ".byte 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xD7, 0x0F\n"  /* 0x06011430 */
    ".byte 0x57, 0x71, 0xD3, 0x0F, 0x37, 0x3C, 0xE6, 0x0E, 0xD5, 0x0E, 0xD3, 0x0F, 0x43, 0x2B, 0xE4, 0x04\n"  /* 0x06011440 */
    ".byte 0xD7, 0x0A, 0x57, 0x71, 0xD3, 0x0D, 0x37, 0x3C, 0xE6, 0x10, 0xD5, 0x0D, 0xD3, 0x0A, 0x43, 0x2B\n"  /* 0x06011450 */
    ".byte 0xE4, 0x04, 0x02, 0xB6, 0x05, 0x4A, 0x05, 0x46, 0x06, 0x05, 0xA8, 0xB6, 0x06, 0x05, 0xA9, 0xB0\n"  /* 0x06011460 */
    ".byte 0x06, 0x05, 0xA9, 0xB8, 0x06, 0x05, 0xA9, 0xA0, 0x06, 0x05, 0xA9, 0x80, 0x06, 0x06, 0x38, 0x28\n"  /* 0x06011470 */
    ".byte 0x00, 0x00, 0xD0, 0x00, 0x06, 0x05, 0xA6, 0x34, 0x06, 0x02, 0x84, 0x00, 0x00, 0x00, 0xE0, 0x00\n"  /* 0x06011480 */
    ".byte 0x06, 0x05, 0xA7, 0x18, 0x60, 0x4D, 0xE2, 0x00, 0xD1, 0x19, 0xD3, 0x18, 0x40, 0x08, 0x21, 0x22\n"  /* 0x06011490 */
    ".byte 0x40, 0x08, 0xD1, 0x18, 0x30, 0x3C, 0x62, 0x02, 0x00, 0x0B, 0x21, 0x22\n"  /* 0x060114A0 */
);


/* gauge_needle_update -- Interpolate gauge needle position toward target.
 * Reads target position from lookup table at 0x060447A8, indexed by
 * player selection and param_1. Smooths toward target by halving the
 * difference each frame (exponential approach).
 * In game modes 3/0xB, skips rendering on odd frames.
 * Calls FUN_060116a8 (needle sprite render) and FUN_06011978 (gauge marks). */
#if 0 /* FUN_060114AC -- replaced by ASM import */
unsigned int FUN_060114ac(unsigned int param_1)
{
  int *needle_pos = (int *)0x06078860;  /* current needle position */
  int target = *(int *)(0x060447A8 + *(int *)(0x0607EADC << 2) + (param_1 & 0xffff) << 4);
  int delta = target - *needle_pos;

  *needle_pos = *needle_pos + ((int)(delta + (unsigned int)(delta < 0)) >> 1);

  if (((*(int *)0x0607887F == '\x03') || (*(int *)0x0607887F == '\v')) &&
     ((FRAME_COUNTER & 1) != 0)) {
    return FRAME_COUNTER;
  }

  {
    short *sprite_idx = (short *)(0x060447A4 + (param_1 & 0xffff) << 1);
    int *needle_data = (int *)(0x060447A8 + (param_1 & 0xffff) << 4 + 0xc);
    unsigned int uVar2;

    FUN_060116a8(*needle_pos, *needle_data, (int)DAT_060115c6, 0x00010000, (int)*sprite_idx);
    FUN_06011978(0x06044764, *needle_pos, *needle_data, (int)*sprite_idx);
    uVar2 = FUN_06011978(0x06044784, *needle_pos, *needle_data, (int)*sprite_idx);
    return uVar2;
  }
}
#endif

/* sprite_row_data_load -- Load 0x1C sprite row entries from course data table.
 * Iterates 0x1C entries at stride 0x58 in the course data block (0x06063788),
 * copying 2-word pairs into the sprite buffer at 0x0605AAA6.
 * Then triggers DMA via 0x06028400 with the row offset into VRAM. */
#if 0 /* FUN_0601155E -- replaced by ASM import */
void FUN_0601155e(unsigned short param_1)
{
  char *sprite_buf = (char *)0x0605AAA6;
  int course_data = *(int *)0x06063788;
  unsigned short i = 0;

  do {
    unsigned int idx = (unsigned int)i;
    short *src = (short *)(idx * 0x58 + (unsigned int)(param_1 << 1) + course_data + 4);
    *(short *)(sprite_buf + (idx << 2)) = *src;
    *(short *)((int)(sprite_buf + (idx << 2)) + 2) = src[1];
    i = i + 1;
  } while (i < 0x1c);

  (*(int(*)())0x06028400)(8, 0x0605AAA2, (param_1 & 0x3f) << 1,
             0x0000F000 + *(int *)(0x06063788 + 4));
}
#endif

/* FUN_0601155E -- original binary (146 bytes) */
__asm__(
    ".section .text.FUN_0601155E, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601155E\n"
    ".global _FUN_0601155e\n"
    ".type _FUN_0601155E, @function\n"
    "_FUN_0601155E:\n"
    "_FUN_0601155e:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0xEE, 0x1C, 0x2F, 0xC6, 0xED, 0x2C, 0x4F, 0x12, 0x7F, 0xFC, 0x2F, 0x41\n"  /* 0x0601155E */
    ".byte 0xE4, 0x00, 0x61, 0xF1, 0xDC, 0x1A, 0xD7, 0x1A, 0x61, 0x1D, 0x6C, 0xC2, 0x7C, 0x04, 0x41, 0x00\n"  /* 0x0601156E */
    ".byte 0x65, 0x4D, 0x66, 0x4D, 0x45, 0x00, 0x06, 0xD7, 0x74, 0x01, 0x45, 0x00, 0x06, 0x1A, 0x35, 0x7C\n"  /* 0x0601157E */
    ".byte 0x46, 0x00, 0x36, 0x1C, 0x36, 0xCC, 0x63, 0x61, 0x25, 0x31, 0x85, 0x61, 0x63, 0x4D, 0x33, 0xE3\n"  /* 0x0601158E */
    ".byte 0x8F, 0xEE, 0x81, 0x51, 0xD7, 0x0E, 0xD3, 0x0F, 0x60, 0xF1, 0x57, 0x71, 0x60, 0x0D, 0x37, 0x3C\n"  /* 0x0601159E */
    ".byte 0xC9, 0x3F, 0x66, 0x03, 0x46, 0x00, 0xD5, 0x0C, 0xE4, 0x08, 0x7F, 0x04, 0x4F, 0x16, 0x6C, 0xF6\n"  /* 0x060115AE */
    ".byte 0x6D, 0xF6, 0xD3, 0x0A, 0x43, 0x2B, 0x6E, 0xF6, 0x80, 0x00, 0x06, 0x04, 0x47, 0xA4, 0x00, 0x01\n"  /* 0x060115BE */
    ".byte 0x00, 0x00, 0x06, 0x04, 0x47, 0xA8, 0x06, 0x04, 0x47, 0x64, 0x06, 0x04, 0x47, 0x84, 0x06, 0x06\n"  /* 0x060115CE */
    ".byte 0x37, 0x88, 0x06, 0x05, 0xAA, 0xA6, 0x00, 0x00, 0xF0, 0x00, 0x06, 0x05, 0xAA, 0xA2, 0x06, 0x02\n"  /* 0x060115DE */
    ".byte 0x84, 0x00\n"  /* 0x060115EE */
);


/* rotated_quad_vertex_compute -- Compute 4 rotated vertices for VDP1 polygon.
 * Takes center position (x,y), rotation angle, scale, and color.
 * Writes 8 vertex coordinates (4 corners x X,Y) to polygon command table
 * at 0x060786CC with 0x18-byte stride. Uses sin/cos decomposition
 * with asymmetric offsets to form a trapezoidal gauge shape. */
#if 0 /* FUN_060116A8 -- replaced by ASM import */
void FUN_060116a8(int center_x,int center_y,short angle,int scale,short color)
{
  char *poly_table;
  char *poly_count_ptr;
  char *fixed_to_short;  /* 0x0602754C */
  char *fixed_mul;       /* 0x06027552 */
  int sin_val;
  int cos_val;
  int rotated;
  short screen_coord;
  short center_screen;
  short slot_idx;
  short *vertex_ptr;
  int sin_component;
  int cos_component;
  short angle_copy;
  angle_copy = angle;

  /* Decompose angle into sin/cos */
  (*(int(*)())0x06027358)((int)angle,&sin_component,&cos_component);
  fixed_mul = (char *)0x06027552;
  fixed_to_short = (char *)0x0602754C;
  poly_count_ptr = (char *)0x0605AAA0;
  poly_table = (char *)0x060786CC;
  vertex_ptr = (short *)(0x060786CC + (short)(*(short *)0x0605AAA0 * 0x18) + 8);
  /* Vertex 0 X (top-left): offset (-56, +30) rotated */
  sin_val = (*(int(*)())0x06027552)(0xFFC80000,cos_component);
  cos_val = (*(int(*)())fixed_mul)(0x001E0000,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_x);
  *vertex_ptr = center_screen + screen_coord;
  /* Vertex 0 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0xFFC80000,sin_component);
  cos_val = (*(int(*)())fixed_mul)(0x001E0000,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 10) = center_screen + screen_coord;
  /* Vertex 1 X (top-right): offset (+56, +30) rotated */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0x00380000,cos_component);
  cos_val = (*(int(*)())fixed_mul)(0x001E0000,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_x);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0xc) = center_screen + screen_coord;
  /* Vertex 1 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0x00380000,sin_component);
  cos_val = (*(int(*)())fixed_mul)(0x001E0000,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0xe) = center_screen + screen_coord;
  /* Vertex 2 X (bottom-right): offset (+56, -30) rotated */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0x00380000,cos_component);
  cos_val = (*(int(*)())fixed_mul)(0xFFE20000,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_x);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x10) = center_screen + screen_coord;
  /* Vertex 2 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0x00380000,sin_component);
  cos_val = (*(int(*)())fixed_mul)(0xFFE20000,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x12) = center_screen + screen_coord;
  /* Vertex 3 X (bottom-left): offset (-56, -30) rotated */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0xFFC80000,cos_component);
  cos_val = (*(int(*)())fixed_mul)(0xFFE20000,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_x);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x14) = center_screen + screen_coord;
  /* Vertex 3 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(0xFFC80000,sin_component);
  cos_val = (*(int(*)())fixed_mul)(0xFFE20000,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(center_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x16) = center_screen + screen_coord;
  /* Set polygon color and flags, advance polygon count */
  *(short *)(poly_table + (short)(*(short *)poly_count_ptr * 0x18) + 6) = color;
  poly_table[(short)(*(short *)poly_count_ptr * 0x18) + 4] = 0;    /* draw mode */
  poly_table[(short)(*(short *)poly_count_ptr * 0x18) + 5] = 1;    /* visible */
  *(short *)poly_count_ptr = *(short *)poly_count_ptr + 1;
  return;
}
#endif

/* gauge_mark_render -- Render gauge tick mark as VDP1 polygon.
 * Writes 4-vertex polygon (8 coords) to VDP1 command table at
 * 0x060786CC, stride 0x18 per entry. Each vertex pair computed
 * as fixed-point truncation (0x0602754C) of template offsets
 * (param_1[0..7]) + needle position (param_2=X, param_3=Y).
 * Sets sprite index (param_4), flags (visible=1), and advances
 * the command table counter at 0x0605AAA0. */
/* FUN_06011978 -- original binary (20 bytes) */
__asm__(
    ".section .text.FUN_06011978, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011978\n"
    ".type _FUN_06011978, @function\n"
    "_FUN_06011978:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x6B, 0x43, 0x2F, 0x96, 0x6A, 0x53\n"  /* 0x06011978 */
    ".byte 0x2F, 0x86, 0x69, 0x63\n"  /* 0x06011988 */
);


/* rotated_rect_vertex_compute -- Compute 4 rotated vertices for VDP1 polygon.
 * Like rotated_quad_vertex_compute but with explicit width/height parameters
 * instead of fixed offsets. Takes center (x,y), half-width, half-height,
 * rotation angle, scale, and color. Writes 8 coords to polygon table
 * at 0x060786CC (0x18-byte stride). */
#if 0 /* FUN_06011AF4 -- replaced by ASM import */
void FUN_06011af4(int center_x,int center_y,int half_width,int half_height,short angle,short scale,short color)
{
  char *poly_table;
  char *poly_count_ptr;
  char *fixed_to_short;  /* 0x0602754C */
  char *fixed_mul;       /* 0x06027552 */
  int sin_val;
  int cos_val;
  int rotated;
  short screen_coord;
  short center_screen;
  short slot_idx;
  short *vertex_ptr;
  int sin_component;
  int cos_component;
  int saved_y;
  int saved_x;
  int neg_width;
  int neg_height;
  saved_y = center_y;
  saved_x = center_x;
  /* Decompose angle into sin/cos */
  (*(int(*)())0x06027358)((int)angle,&sin_component,&cos_component);
  fixed_mul = (char *)0x06027552;
  fixed_to_short = (int *)0x0602754C;
  poly_count_ptr = (char *)0x0605AAA0;
  poly_table = (char *)0x060786CC;
  neg_width = -half_width;
  vertex_ptr = (short *)(0x060786CC + (short)(*(short *)0x0605AAA0 * 0x18) + 8);
  /* Vertex 0 X (top-left): (-width * cos - height * sin) * scale */
  sin_val = (*(int(*)())0x06027552)(neg_width,cos_component);
  cos_val = (*(int(*)())fixed_mul)(half_height,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_x);
  *vertex_ptr = center_screen - screen_coord;
  /* Vertex 0 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(neg_width,sin_component);
  cos_val = (*(int(*)())fixed_mul)(half_height,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 10) = center_screen + screen_coord;
  /* Vertex 1 X (top-right): (width * cos - height * sin) * scale */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(half_width,cos_component);
  cos_val = (*(int(*)())fixed_mul)(half_height,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_x);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0xc) = center_screen - screen_coord;
  /* Vertex 1 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(half_width,sin_component);
  cos_val = (*(int(*)())fixed_mul)(half_height,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0xe) = center_screen + screen_coord;
  /* Vertex 2 X (bottom-right): (width * cos + height * sin) * scale */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(half_width,cos_component);
  neg_height = -half_height;
  cos_val = (*(int(*)())fixed_mul)(neg_height,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_x);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x10) = center_screen - screen_coord;
  /* Vertex 2 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(half_width,sin_component);
  cos_val = (*(int(*)())fixed_mul)(neg_height,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x12) = center_screen + screen_coord;
  /* Vertex 3 X (bottom-left): (-width * cos + height * sin) * scale */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(neg_width,cos_component);
  cos_val = (*(int(*)())fixed_mul)(neg_height,sin_component);
  rotated = (*(int(*)())fixed_mul)(sin_val - cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_x);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x14) = center_screen - screen_coord;
  /* Vertex 3 Y */
  slot_idx = *(short *)poly_count_ptr;
  sin_val = (*(int(*)())fixed_mul)(neg_width,sin_component);
  cos_val = (*(int(*)())fixed_mul)(neg_height,cos_component);
  rotated = (*(int(*)())fixed_mul)(sin_val + cos_val,scale);
  screen_coord = (*(int(*)())fixed_to_short)(rotated);
  center_screen = (*(int(*)())fixed_to_short)(saved_y);
  *(short *)(poly_table + (short)(slot_idx * 0x18) + 0x16) = center_screen + screen_coord;
  /* Set polygon color and flags, advance polygon count */
  *(short *)(poly_table + (short)(*(short *)poly_count_ptr * 0x18) + 6) = color;
  poly_table[(short)(*(short *)poly_count_ptr * 0x18) + 4] = 0;
  poly_table[(short)(*(short *)poly_count_ptr * 0x18) + 5] = 0;
  *(short *)poly_count_ptr = *(short *)poly_count_ptr + 1;
  return;
}
#endif

/* vdp1_overlay_dispatch -- Emit VDP1 commands for overlay sprite queue.
 * Iterates overlay entries at 0x060786CC (24 bytes each), count at 0x0605AAA0.
 * Entry byte +5 selects command type: 0=normal sprite (0x060280F8),
 * non-zero=polygon (0x060280C4, clears flag after). Advances VDP1 write
 * pointer by 0x20 per entry, increments frame counter. Resets queue count. */
#if 0 /* FUN_06011DC0 -- replaced by ASM import */
void FUN_06011dc0(void)
{
  int *vdp1_write = (int *)0x060785FC;     /* VDP1 command write pointer */
  char *overlay_buf = (char *)0x060786CC;  /* overlay command buffer (24B entries) */
  int *frame_cnt = (int *)0x0605A008;      /* frame counter */
  unsigned short *queue_cnt = (unsigned short *)0x0605AAA0;
  unsigned short i;

  for (i = 0; i < *queue_cnt; i++) {
    int off = (short)(i * 0x18);
    if (overlay_buf[off + 5] == '\0') {
      (*(int(*)())0x060280F8)(overlay_buf + off, *vdp1_write);
    } else {
      (*(int(*)())0x060280C4)(overlay_buf + off, *vdp1_write);
      overlay_buf[off + 5] = 0;            /* clear polygon flag */
    }
    *frame_cnt = *frame_cnt + 1;
    *vdp1_write = *vdp1_write + 0x20;
  }
  *queue_cnt = 0;
}
#endif

/* FUN_06011DC0 -- original binary (188 bytes) */
__asm__(
    ".section .text.FUN_06011DC0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011DC0\n"
    ".global _FUN_06011dc0\n"
    ".type _FUN_06011DC0, @function\n"
    "_FUN_06011DC0:\n"
    "_FUN_06011dc0:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x4F, 0x22\n"  /* 0x06011DC0 */
    ".byte 0xD8, 0x24, 0xDA, 0x25, 0xEB, 0x00, 0xDC, 0x25, 0xDE, 0x25, 0xA0, 0x33, 0x6D, 0xBD, 0x62, 0xD3\n"  /* 0x06011DD0 */
    ".byte 0x63, 0xD3, 0x42, 0x08, 0x43, 0x08, 0x42, 0x00, 0x43, 0x08, 0x32, 0x3C, 0x62, 0x2F, 0x32, 0xCC\n"  /* 0x06011DE0 */
    ".byte 0x84, 0x25, 0x62, 0x03, 0x62, 0x2C, 0x22, 0x28, 0x8B, 0x0D, 0x65, 0xE2, 0x64, 0xD3, 0x63, 0xD3\n"  /* 0x06011DF0 */
    ".byte 0x44, 0x08, 0x43, 0x08, 0x44, 0x00, 0x43, 0x08, 0x34, 0x3C, 0x64, 0x4F, 0xD3, 0x19, 0x43, 0x0B\n"  /* 0x06011E00 */
    ".byte 0x34, 0xCC, 0xA0, 0x10, 0x00, 0x09, 0x69, 0xD3, 0x63, 0xD3, 0x65, 0xE2, 0x49, 0x08, 0x43, 0x08\n"  /* 0x06011E10 */
    ".byte 0x49, 0x00, 0x43, 0x08, 0x39, 0x3C, 0x69, 0x9F, 0xD3, 0x13, 0x39, 0xCC, 0x43, 0x0B, 0x64, 0x93\n"  /* 0x06011E20 */
    ".byte 0x62, 0xBC, 0x60, 0x23, 0x80, 0x95, 0x63, 0xA2, 0x73, 0x01, 0x2A, 0x32, 0x62, 0xE2, 0x72, 0x20\n"  /* 0x06011E30 */
    ".byte 0x2E, 0x22, 0x7D, 0x01, 0x63, 0xDD, 0x62, 0x81, 0x62, 0x2D, 0x33, 0x23, 0x8B, 0xC7, 0x28, 0xB1\n"  /* 0x06011E40 */
    ".byte 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B\n"  /* 0x06011E50 */
    ".byte 0x6E, 0xF6, 0xFF, 0xFF, 0x06, 0x05, 0xAA, 0xA0, 0x06, 0x05, 0xA0, 0x08, 0x06, 0x07, 0x86, 0xCC\n"  /* 0x06011E60 */
    ".byte 0x06, 0x07, 0x85, 0xFC, 0x06, 0x02, 0x80, 0xF8, 0x06, 0x02, 0x80, 0xC4\n"  /* 0x06011E70 */
);


/* subsystem_sprite_pair_update -- Update 2 paired VDP1 sprites.
 * Builds VDP1 commands for two sprite entries at 0x060638B0/A0
 * using shared vertical offset from DAT_06011efe. */
#if 0 /* FUN_06011E7C -- replaced by ASM import */
void FUN_06011e7c(void)
{
    register int vdp_cmd_build asm("r3") = 0x06028400;
    register int y_offset asm("r2") = (int)DAT_06011efe;

    (*(int(*)())vdp_cmd_build)(0xC, *(int *)0x060638B0, (int)DAT_06011f00,
        *(int *)0x060638B4 + y_offset);
    (*(int(*)())vdp_cmd_build)(0xC, *(int *)0x060638A0, (int)DAT_06011f02,
        *(int *)0x060638A4 + y_offset);
}
#endif

/* FUN_06011E7C -- original binary (278 bytes) */
__asm__(
    ".section .text.FUN_06011E7C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011E7C\n"
    ".global _FUN_06011e7c\n"
    ".type _FUN_06011E7C, @function\n"
    "_FUN_06011E7C:\n"
    "_FUN_06011e7c:\n"
    ".byte 0x4F, 0x22, 0x7F, 0xFC, 0xD3, 0x21, 0x2F, 0x32, 0x67, 0x33, 0x96, 0x3B, 0x65, 0xF2, 0x57, 0x71\n"  /* 0x06011E7C */
    ".byte 0x93, 0x37, 0x65, 0x52, 0x37, 0x3C, 0xD3, 0x1E, 0x43, 0x0B, 0xE4, 0x0C, 0xD2, 0x1D, 0x2F, 0x22\n"  /* 0x06011E8C */
    ".byte 0x67, 0x23, 0x57, 0x71, 0x93, 0x2D, 0x37, 0x3C, 0x96, 0x2D, 0x65, 0x23, 0x65, 0x52, 0xE4, 0x0C\n"  /* 0x06011E9C */
    ".byte 0x7F, 0x04, 0xD3, 0x17, 0x43, 0x2B, 0x4F, 0x26, 0x7F, 0xFC, 0xD0, 0x17, 0x60, 0x00, 0x20, 0x08\n"  /* 0x06011EAC */
    ".byte 0x89, 0x01, 0xAF, 0xDD, 0x7F, 0x04, 0xD0, 0x15, 0x60, 0x02, 0x20, 0x08, 0x89, 0x0C, 0xD3, 0x0F\n"  /* 0x06011EBC */
    ".byte 0x2F, 0x32, 0x67, 0x33, 0x57, 0x71, 0x93, 0x14, 0x37, 0x3C, 0x96, 0x15, 0x65, 0xF2, 0x65, 0x52\n"  /* 0x06011ECC */
    ".byte 0xE4, 0x0C, 0xD3, 0x0B, 0x43, 0x2B, 0x7F, 0x04, 0xD2, 0x0A, 0x2F, 0x22, 0x67, 0x23, 0x57, 0x71\n"  /* 0x06011EDC */
    ".byte 0x93, 0x07, 0x37, 0x3C, 0x96, 0x08, 0x65, 0x23, 0x65, 0x52, 0xE4, 0x0C, 0xD3, 0x04, 0x43, 0x2B\n"  /* 0x06011EEC */
    ".byte 0x7F, 0x04, 0x40, 0x00, 0x04, 0xBE, 0x04, 0x86, 0x04, 0x20, 0xFF, 0xFF, 0x06, 0x06, 0x38, 0xB0\n"  /* 0x06011EFC */
    ".byte 0x06, 0x02, 0x84, 0x00, 0x06, 0x06, 0x38, 0xA0, 0x06, 0x08, 0x5F, 0xF4, 0x06, 0x07, 0xEA, 0xDC\n"  /* 0x06011F0C */
    ".byte 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x99, 0x55, 0xEA, 0x1F, 0xEB, 0x10\n"  /* 0x06011F1C */
    ".byte 0x9C, 0x53, 0x9D, 0x53, 0xE6, 0x00, 0x65, 0x6F, 0x60, 0x41, 0x63, 0x6F, 0x67, 0x0F, 0x24, 0x31\n"  /* 0x06011F2C */
    ".byte 0x27, 0xA9, 0x77, 0xFE, 0x47, 0x15, 0x8B, 0x01, 0xA0, 0x01, 0x62, 0x73, 0xE2, 0x00, 0x67, 0x0F\n"  /* 0x06011F3C */
    ".byte 0x63, 0x41, 0x27, 0x99, 0x23, 0x2B, 0x77, 0xC0, 0x24, 0x31, 0x47, 0x15, 0x8B, 0x01, 0xA0, 0x01\n"  /* 0x06011F4C */
    ".byte 0x62, 0x73, 0xE2, 0x00, 0x63, 0x41, 0x67, 0x0F, 0x23, 0x2B, 0x27, 0xC9, 0x24, 0x31, 0x37, 0xDC\n"  /* 0x06011F5C */
    ".byte 0x47, 0x15, 0x8B, 0x01, 0xA0, 0x01, 0x62, 0x73, 0xE2, 0x00, 0x75, 0x01, 0x63, 0x41, 0x23, 0x2B\n"  /* 0x06011F6C */
    ".byte 0x24, 0x31, 0x62, 0x5F, 0x32, 0xB3, 0x8F, 0xD7, 0x74, 0x02, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6\n"  /* 0x06011F7C */
    ".byte 0x6C, 0xF6, 0x00, 0x0B, 0x6D, 0xF6\n"  /* 0x06011F8C */
);


/* sprite_pair_or_single_update -- Update VDP1 sprite(s) for HUD overlay.
 * In alternate mode (0x06085FF4 != 0): updates both sprites via FUN_06011e7c.
 * Otherwise: updates single sprite from buffer 0x060638B0 (if 0x0607EADC set)
 * or 0x060638A0 (default). Uses fixed character ID 0x420 with Y offset. */
void FUN_06011eb4(void)
{
  if (*(int *)0x06085FF4 != '\0') {
    FUN_06011e7c();                         /* update both sprites */
    return;
  }

  if (*(int *)0x0607EADC != 0) {
    (*(int(*)())0x06028400)(0xc, *(int *)0x060638B0, 0x420,
               *(int *)(0x060638B0 + 4) + (int)DAT_06011efe);
  } else {
    (*(int(*)())0x06028400)(0xc, *(int *)0x060638A0, 0x420,
               *(int *)(0x060638A0 + 4) + (int)DAT_06011efe);
  }
}

/* palette_darken -- Attenuate 16 RGB555 palette entries toward black.
 * For each entry: decomposes into R (bits 0-4), G (masked by DAT_06011fd4),
 * B (masked by DAT_06011fd6). Subtracts 2 from R, 0x40 from G, 0x800 from B
 * (clamping each to 0). Recomposes into RGB555 and writes back.
 * Used for fade-to-black transitions. */
void FUN_06011f1c(param_1)
    unsigned short *param_1;
{
  unsigned short rgb;
  unsigned short green_mask, blue_mask;
  short i;
  int red, green, blue;

  blue_mask = DAT_06011fd6;
  green_mask = DAT_06011fd4;
  i = 0;
  do {
    rgb = *param_1;
    *param_1 = 0;
    red = ((int)(short)rgb & 0x1fU) - 2;                /* attenuate R by 2 */
    if (red < 1) red = 0;
    green = (short)(rgb & green_mask) + -0x40;           /* attenuate G by 0x40 */
    *param_1 = *param_1 | (unsigned short)red;
    if (green < 1) green = 0;
    *param_1 = *param_1 | (unsigned short)green;
    blue = (short)(rgb & blue_mask) + -2048;             /* attenuate B by 0x800 */
    if (blue < 1) blue = 0;
    i = i + 1;
    *param_1 = *param_1 | (unsigned short)blue;
    param_1 = param_1 + 1;
  } while (i < 0x10);
}

/* palette_blend_toward -- Blend 16 RGB555 entries toward target palette.
 * For each entry: increments R by 1 (capped at target R), increments
 * G by 0x20 (capped at target G), increments B by 0x400 (capped at
 * target B). param_1 = current palette, param_2 = target palette.
 * Used for fade-in or palette transition effects. */
#if 0 /* FUN_06011F92 -- replaced by ASM import */
void FUN_06011f92(param_1, param_2)
    unsigned short *param_1;
    unsigned short *param_2;
{
  unsigned short cur_rgb;
  unsigned short tgt_rgb;
  int channel;
  unsigned short result;
  unsigned short blue_mask;
  unsigned int green_mask;
  short i;

  blue_mask = DAT_06011fd6;
  green_mask = 0x400 - 0x20;                             /* green channel mask (0x3E0) */
  i = 0;
  do {
    cur_rgb = *param_1;
    tgt_rgb = *param_2;
    *param_1 = 0;
    /* red channel: increment by 1, cap at target */
    channel = ((int)(short)cur_rgb & 0x1fU) + 1;
    if (channel < (short)tgt_rgb) {
      result = (unsigned short)channel;
    } else {
      result = tgt_rgb & 0x1f;                           /* cap at target R */
    }
    *param_1 = *param_1 | result;
    /* green channel: increment by 0x20, cap at target */
    channel = ((int)(short)cur_rgb & green_mask) + 0x20;
    if ((((short)tgt_rgb <= channel ^ 1) & green_mask) == 0) {
      result = tgt_rgb & (unsigned short)green_mask;     /* cap at target G */
    } else {
      result = (unsigned short)channel;
    }
    channel = (short)(cur_rgb & blue_mask) + 0x400;
    *param_1 = *param_1 | result;
    /* blue channel: increment by 0x400, cap at target */
    if ((((short)tgt_rgb <= channel ^ 1) & blue_mask) == 0) {
      tgt_rgb = tgt_rgb & blue_mask;                     /* cap at target B */
    } else {
      tgt_rgb = (unsigned short)channel;
    }
    i = i + 1;
    *param_1 = *param_1 | tgt_rgb;
    param_1 = param_1 + 1;
    param_2 = param_2 + 1;
  } while (i < 0x10);
}
#endif

/* FUN_06011F92 -- original binary (190 bytes) */
__asm__(
    ".section .text.FUN_06011F92, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011F92\n"
    ".global _FUN_06011f92\n"
    ".type _FUN_06011F92, @function\n"
    "_FUN_06011F92:\n"
    "_FUN_06011f92:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x7F, 0xF8\n"  /* 0x06011F92 */
    ".byte 0xE8, 0x10, 0x99, 0x19, 0xEA, 0x00, 0xEE, 0x1F, 0x67, 0x93, 0x77, 0xE0, 0x96, 0x12, 0x6B, 0xAF\n"  /* 0x06011FA2 */
    ".byte 0x6D, 0x41, 0x6C, 0x51, 0x63, 0xDF, 0x24, 0xA1, 0x62, 0xCF, 0x23, 0xE9, 0x73, 0x01, 0x2F, 0x32\n"  /* 0x06011FB2 */
    ".byte 0x1F, 0x21, 0x33, 0x23, 0x00, 0x29, 0xCA, 0x01, 0x20, 0xE9, 0x20, 0x08, 0x89, 0x05, 0xA0, 0x06\n"  /* 0x06011FC2 */
    ".byte 0x62, 0xF2, 0x03, 0xE0, 0x7C, 0x00, 0xF8, 0x00, 0x04, 0x00, 0x52, 0xF1, 0x22, 0xE9, 0x61, 0x41\n"  /* 0x06011FD2 */
    ".byte 0x63, 0xCF, 0x21, 0x2B, 0x62, 0xDF, 0x24, 0x11, 0x22, 0x79, 0x72, 0x20, 0x2F, 0x22, 0x1F, 0x31\n"  /* 0x06011FE2 */
    ".byte 0x32, 0x33, 0x00, 0x29, 0xCA, 0x01, 0x20, 0x79, 0x20, 0x08, 0x89, 0x01, 0xA0, 0x02, 0x63, 0xF2\n"  /* 0x06011FF2 */
    ".byte 0x53, 0xF1, 0x23, 0x79, 0x62, 0xDF, 0x61, 0x41, 0x22, 0x69, 0x21, 0x3B, 0x32, 0x9C, 0x24, 0x11\n"  /* 0x06012002 */
    ".byte 0x63, 0xCF, 0x2F, 0x22, 0x1F, 0x31, 0x32, 0x33, 0x00, 0x29, 0xCA, 0x01, 0x20, 0x69, 0x20, 0x08\n"  /* 0x06012012 */
    ".byte 0x89, 0x01, 0xA0, 0x02, 0x63, 0xF2, 0x53, 0xF1, 0x23, 0x69, 0x61, 0x41, 0x7B, 0x01, 0x21, 0x3B\n"  /* 0x06012022 */
    ".byte 0x63, 0xBF, 0x24, 0x11, 0x74, 0x02, 0x33, 0x83, 0x8F, 0xBA, 0x75, 0x02, 0x7F, 0x08, 0x68, 0xF6\n"  /* 0x06012032 */
    ".byte 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x06012042 */
);


/* FUN_060116A8 -- original binary (20 bytes) */
__asm__(
    ".section .text.FUN_060116A8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060116A8\n"
    ".global _FUN_060116a8\n"
    ".type _FUN_060116A8, @function\n"
    "_FUN_060116A8:\n"
    "_FUN_060116a8:\n"
    ".byte 0x2F, 0xE6, 0x60, 0x63, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x6A, 0x73\n"  /* 0x060116A8 */
    ".byte 0x2F, 0x86, 0x69, 0x53\n"  /* 0x060116B8 */
);

/* FUN_06011AF4 -- original binary (20 bytes) */
__asm__(
    ".section .text.FUN_06011AF4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06011AF4\n"
    ".global _FUN_06011af4\n"
    ".type _FUN_06011AF4, @function\n"
    "_FUN_06011AF4:\n"
    "_FUN_06011af4:\n"
    ".byte 0x2F, 0xE6, 0xE0, 0x3A, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x69, 0x73\n"  /* 0x06011AF4 */
    ".byte 0x2F, 0x86, 0x68, 0x63\n"  /* 0x06011B04 */
);

/* FUN_060114AC -- original binary (12 bytes) */
__asm__(
    ".section .text.FUN_060114AC, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060114AC\n"
    ".global _FUN_060114ac\n"
    ".type _FUN_060114AC, @function\n"
    "_FUN_060114AC:\n"
    "_FUN_060114ac:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x6D, 0x43, 0x2F, 0xB6, 0x60, 0xDD\n"  /* 0x060114AC */
);

/* FUN_06010D94 -- original binary (368 bytes) */
__asm__(
    ".section .text.FUN_06010D94, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06010D94\n"
    ".global _FUN_06010d94\n"
    ".type _FUN_06010D94, @function\n"
    "_FUN_06010D94:\n"
    "_FUN_06010d94:\n"
    ".byte 0x2F, 0xE6, 0xE2, 0x0A, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86\n"  /* 0x06010D94 */
    ".byte 0x4F, 0x22, 0x7F, 0xF0, 0x1F, 0x42, 0x1F, 0x51, 0x2F, 0x62, 0x1F, 0x73, 0xD3, 0x02, 0x63, 0x32\n"  /* 0x06010DA4 */
    ".byte 0x33, 0x22, 0x8B, 0x03, 0xA0, 0x67, 0x00, 0x09, 0x06, 0x07, 0x88, 0xA0, 0xDE, 0x37, 0xD3, 0x38\n"  /* 0x06010DB4 */
    ".byte 0x62, 0xE2, 0x72, 0x30, 0x43, 0x0B, 0x2E, 0x22, 0xD8, 0x36, 0x56, 0xF3, 0x65, 0xF2, 0x48, 0x0B\n"  /* 0x06010DC4 */
    ".byte 0x54, 0xF1, 0xD4, 0x35, 0xD3, 0x35, 0x43, 0x0B, 0x64, 0x41, 0xDD, 0x35, 0xD5, 0x35, 0xD3, 0x36\n"  /* 0x06010DD4 */
    ".byte 0x65, 0x52, 0x43, 0x0B, 0x64, 0xD2, 0xD9, 0x35, 0xDB, 0x35, 0xDC, 0x36, 0x5A, 0xF2, 0xD3, 0x36\n"  /* 0x06010DE4 */
    ".byte 0x66, 0xC2, 0x4A, 0x00, 0x3A, 0x3C, 0x65, 0xA1, 0x4B, 0x0B, 0x64, 0x92, 0xD3, 0x33, 0x43, 0x0B\n"  /* 0x06010DF4 */
    ".byte 0x00, 0x09, 0xD6, 0x33, 0xD5, 0x33, 0xD4, 0x34, 0x66, 0x62, 0x65, 0x52, 0x66, 0x6B, 0x48, 0x0B\n"  /* 0x06010E04 */
    ".byte 0x64, 0x42, 0xD5, 0x32, 0xD3, 0x28, 0x65, 0x52, 0x43, 0x0B, 0x54, 0xD1, 0x56, 0xC1, 0x65, 0xA1\n"  /* 0x06010E14 */
    ".byte 0x4B, 0x0B, 0x54, 0x91, 0x62, 0xE2, 0xD3, 0x29, 0x72, 0xD0, 0x43, 0x0B, 0x2E, 0x22, 0xD6, 0x2C\n"  /* 0x06010E24 */
    ".byte 0xD5, 0x2C, 0xD4, 0x2D, 0x66, 0x62, 0x65, 0x52, 0x66, 0x6B, 0x48, 0x0B, 0x64, 0x42, 0xD5, 0x2B\n"  /* 0x06010E34 */
    ".byte 0xD3, 0x1D, 0x65, 0x52, 0x43, 0x0B, 0x54, 0xD2, 0x56, 0xC2, 0x65, 0xA1, 0x4B, 0x0B, 0x54, 0x92\n"  /* 0x06010E44 */
    ".byte 0x62, 0xE2, 0xD3, 0x1E, 0x72, 0xD0, 0x43, 0x0B, 0x2E, 0x22, 0xD6, 0x25, 0xD5, 0x25, 0xD4, 0x26\n"  /* 0x06010E54 */
    ".byte 0x66, 0x62, 0x65, 0x52, 0x66, 0x6B, 0x48, 0x0B, 0x64, 0x42, 0xD5, 0x24, 0xD3, 0x12, 0x65, 0x52\n"  /* 0x06010E64 */
    ".byte 0x43, 0x0B, 0x54, 0xD3, 0x56, 0xC3, 0x65, 0xA1, 0x4B, 0x0B, 0x54, 0x93, 0x62, 0xE2, 0x72, 0xD0\n"  /* 0x06010E74 */
    ".byte 0x63, 0x23, 0x73, 0xD0, 0x2E, 0x32, 0x7F, 0x10, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6\n"  /* 0x06010E84 */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xFF, 0xFF, 0x06, 0x08, 0x9E, 0xDC\n"  /* 0x06010E94 */
    ".byte 0x06, 0x02, 0x6E, 0x0C, 0x06, 0x02, 0x6E, 0x2E, 0x06, 0x07, 0x88, 0x78, 0x06, 0x02, 0x6E, 0xDE\n"  /* 0x06010EA4 */
    ".byte 0x06, 0x06, 0x21, 0x2C, 0x06, 0x06, 0x21, 0xD8, 0x06, 0x03, 0x1D, 0x8C, 0x06, 0x06, 0x20, 0xD8\n"  /* 0x06010EB4 */
    ".byte 0x06, 0x03, 0x1A, 0x28, 0x06, 0x06, 0x21, 0x80, 0x06, 0x08, 0x9E, 0x44, 0x06, 0x02, 0x6D, 0xBC\n"  /* 0x06010EC4 */
    ".byte 0x06, 0x04, 0x46, 0x48, 0x06, 0x04, 0x46, 0x44, 0x06, 0x04, 0x46, 0x40, 0x06, 0x06, 0x21, 0xDC\n"  /* 0x06010ED4 */
    ".byte 0x06, 0x04, 0x46, 0x54, 0x06, 0x04, 0x46, 0x50, 0x06, 0x04, 0x46, 0x4C, 0x06, 0x06, 0x21, 0xE0\n"  /* 0x06010EE4 */
    ".byte 0x06, 0x04, 0x46, 0x78, 0x06, 0x04, 0x46, 0x74, 0x06, 0x04, 0x46, 0x70, 0x06, 0x06, 0x21, 0xE4\n"  /* 0x06010EF4 */
);
