/* VERIFIED: called every physics frame during racing (part of player_physics_main pipeline)
 * Method: call-trace differential — 5 frames idle vs 5 frames with LEFT in race
 *   117 calls during LEFT (baseline 39, +78) — same delta as player_physics_main
 * Date: 2026-02-28
 */
/* player_collision -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600C5D6 - 0x0600C74E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Player car collision response — handles collision detection, wall impact,
 * speed reduction, and steering correction after collisions.
 *
 * Persistent registers:
 *   r10 = fpmul function pointer
 *   r11 = &collision_counter (incremented each frame of active collision)
 *   r12 = collision result struct pointer (from BSR + 0x18 offset)
 *   r13 = collision params struct
 *   r14 = car struct (from car_struct_ptr)
 *
 * Collision paths:
 *   Path A (gear_mode==2 OR surface_timer>0 AND shift_timer>0):
 *     → BSR 0x0600CA96 with collision params
 *   Path B (detailed collision):
 *     Check car[+3] bit 3, surface_timer, car[+0x161] bit 5, collision counter,
 *     car[+0x204] threshold
 *     → BSR 0x0600CF58 (collision_dispatch)
 *     → Decrement car[+0x204] by 2 while positive
 *     → BSR 0x0600CC38 if depleted
 *
 * Post-collision:
 *   - If gear_mode==3: car[+0x194] = fpmul(car[+0x198], car[+8])
 *   - BSR 0x0600C8CC (steering correction)
 *   - If game_flags bits 23:21 clear:
 *     → sincos_pair for steering angle → X/Z velocity integration
 *   - Else: BSR 0x0600C928 + 0x0600C7D4 (wall response vectors)
 *
 * Car struct offsets used:
 *   +0x08 = car type/speed scaling
 *   +0x0C = current speed
 *   +0x10 = X position (updated by sin component)
 *   +0x14 = Y position (cleared on steering path)
 *   +0x18 = Z position (updated by cos component)
 *   +0x20 = Y angle (set from collision params)
 *   +0x28 = steering angle (used with sincos_pair)
 *   +0xB8 = shift timer
 *   +0x161 = collision flags (bit 5 = wall contact)
 *   +0x18C = cos output buffer
 *   +0x190 = sin output buffer
 *   +0x194 = collision speed result
 *   +0x198 = collision speed input
 *   +0x1BC = surface response timer
 *   +0x204 = collision cooldown (decremented by 2)
 *   +0x208 = surface timer
 */

    .section .text.FUN_0600C5D6


    .global player_collision
    .type player_collision, @function
player_collision:
    mov.l r14, @-r15                     /* save r14 (car struct) */
    mov.l r13, @-r15                     /* save r13 (collision params) */
    mov.l r12, @-r15                     /* save r12 (collision result) */
    mov.l r11, @-r15                     /* save r11 (collision counter ptr) */
    mov.l r10, @-r15                     /* save r10 (fpmul fn ptr) */
    sts.l pr, @-r15                      /* save return address */
    add #-0x4, r15                       /* allocate 4 bytes on stack */
    .byte   0xDA, 0x0E    /* mov.l .L_fn_fpmul, r10 — load fpmul function pointer */
    .byte   0xDB, 0x0F    /* mov.l .L_collision_counter, r11 — load collision counter addr */
    .byte   0xDE, 0x0F    /* mov.l .L_car_struct_ptr, r14 — load car struct pointer addr */
    .byte   0xDD, 0x10    /* mov.l .L_collision_params, r13 — load collision params addr */
    .byte   0xB3, 0xA8    /* bsr 0x0600CD40 (external) — run collision detection */
    mov.l @r14, r14                      /* r14 = dereference car struct pointer */
    mov r0, r12                          /* r12 = collision result base from detection */
    .byte   0xD0, 0x0F    /* mov.l .L_gear_mode, r0 — load gear mode address */
    mov.w @r0, r0                        /* r0 = read gear mode (16-bit) */
    extu.w r0, r0                        /* zero-extend to 32 bits */
    cmp/eq #0x2, r0                      /* gear_mode == 2 (reverse)? */
    bt/s    .L_simple_collision          /* yes → take simple collision path */
    add #0x18, r12                       /* r12 += 0x18 (advance to collision result) */
    mov.w   DAT_0600c616, r0            /* r0 = 0x01BC (surface response timer offset) */
    mov.l @(r0, r14), r2                 /* r2 = car[+0x1BC] surface response timer */
    cmp/pl r2                            /* surface timer > 0? */
    bt      .L_simple_collision          /* yes → take simple collision path */
    mov.w   .L_off_shift_timer, r0       /* r0 = 0x00B8 (shift timer offset) */
    mov.l @(r0, r14), r2                 /* r2 = car[+0xB8] shift timer */
    cmp/pl r2                            /* shift timer > 0? */
    bf      .L_detailed_collision        /* no → take detailed collision path */
.L_simple_collision:                         /* --- simple collision path --- */
    .byte   0xB2, 0x42    /* bsr 0x0600CA96 (external) — simple collision response */
    mov r13, r4                          /* arg: collision params struct */
    bra     .L_post_collision            /* jump to post-collision processing */
    nop                                  /* delay slot */

    .global DAT_0600c616
DAT_0600c616:
    .2byte  0x01BC                        /* car offset: surface response timer */
.L_off_shift_timer:
    .2byte  0x00B8                        /* car offset: shift timer */
    .2byte  0xFFFF
    .4byte  0x00480000                  /* (adjacent data: fixed-point threshold) */
.L_fn_fpmul:
    .4byte  fpmul                      /* fixed-point multiply */
.L_collision_counter:
    .4byte  sym_0607EBDC               /* collision frame counter */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_collision_params:
    .4byte  sym_06078680               /* collision parameters struct */
.L_gear_mode:
    .4byte  sym_06087804               /* gear/transmission mode (16-bit) */
.L_detailed_collision:                       /* --- detailed collision path --- */
    .byte   0xD2, 0x33    /* mov.l .L_car_array_base, r2 — load car array base ptr */
    mov.l @r2, r2                        /* r2 = dereference car array base */
    mov r2, r0                           /* r0 = car array base (for byte access) */
    mov.b @(3, r0), r0                   /* r0 = car_base[+3] controller flags byte */
    tst #0x8, r0                         /* test bit 3 (controller input active?) */
    bf      .L_wall_collision            /* bit set → forced wall collision path */
    mov.w   DAT_0600c6f6, r0            /* r0 = 0x0208 (surface timer offset) */
    mov.l @(r0, r14), r3                 /* r3 = car[+0x208] surface timer */
    cmp/pl r3                            /* surface timer > 0? */
    bt      .L_wall_collision            /* yes → wall collision path */
    mov.w   DAT_0600c6f8, r0            /* r0 = 0x0161 (collision flags offset) */
    mov.b @(r0, r14), r0                 /* r0 = car[+0x161] collision flags byte */
    tst #0x20, r0                        /* test bit 5 (wall contact flag) */
    bf      .L_wall_collision            /* wall contact set → wall collision path */
    mov #0xA, r2                         /* r2 = 10 (collision counter threshold) */
    mov.l @r11, r3                       /* r3 = current collision counter */
    cmp/gt r2, r3                        /* counter > 10? */
    bt      .L_cooldown_decrement        /* yes → skip dispatch, just decrement */
    mov.w   DAT_0600c6fa, r0            /* r0 = 0x0204 (collision cooldown offset) */
    mov #0x66, r3                        /* r3 = 0x66 (cooldown threshold) */
    mov.l @(r0, r14), r2                 /* r2 = car[+0x204] collision cooldown */
    cmp/ge r3, r2                        /* cooldown >= 0x66? */
    bt      .L_cooldown_decrement        /* yes → skip dispatch */
    .byte   0xB4, 0x79    /* bsr 0x0600CF58 (external) — collision dispatch handler */
    mov r12, r4                          /* arg: collision result struct */
.L_cooldown_decrement:                       /* --- cooldown decrement loop --- */
    mov.w   DAT_0600c6fa, r0            /* r0 = 0x0204 (collision cooldown offset) */
    mov.l @(r0, r14), r2                 /* r2 = car[+0x204] collision cooldown */
    cmp/pl r2                            /* cooldown > 0? */
    bf      .L_cooldown_depleted         /* no → cooldown fully depleted */
    mov.w   DAT_0600c6fa, r0            /* r0 = 0x0204 (reload offset for store) */
    mov.l @(r0, r14), r2                 /* r2 = car[+0x204] (re-read for modify) */
    add #-0x2, r2                        /* decrement cooldown by 2 */
    mov.l r2, @(r0, r14)                /* write back decremented cooldown */
    .byte   0xB2, 0x0E    /* bsr 0x0600CA96 (external) — simple collision response */
    mov r13, r4                          /* arg: collision params struct */
    mov.l @r11, r2                       /* r2 = collision counter */
    add #0x1, r2                         /* increment collision counter */
    bra     .L_post_collision            /* jump to post-collision processing */
    mov.l r2, @r11                       /* delay slot: store incremented counter */
.L_cooldown_depleted:                        /* --- cooldown depleted → full response --- */
    mov r13, r5                          /* arg2: collision params struct */
    .byte   0xB2, 0xD8    /* bsr 0x0600CC38 (external) — full collision response */
    mov r12, r4                          /* arg1: collision result struct */
    bra     .L_post_collision            /* jump to post-collision processing */
    nop                                  /* delay slot */
.L_wall_collision:                           /* --- wall/forced collision path --- */
    mov r13, r5                          /* arg2: collision params struct */
    .byte   0xB2, 0xD3    /* bsr 0x0600CC38 (external) — full collision response */
    mov r12, r4                          /* arg1: collision result struct */
.L_post_collision:                           /* --- post-collision processing --- */
    .byte   0xD0, 0x1D    /* mov.l .L_gear_mode_2, r0 — load gear mode address (dup) */
    mov.w @r0, r0                        /* r0 = read gear mode (16-bit) */
    extu.w r0, r0                        /* zero-extend to 32 bits */
    cmp/eq #0x3, r0                      /* gear_mode == 3 (drive)? */
    bf      .L_steering_correction       /* no → skip speed calculation */
    mov.w   DAT_0600c6fc, r0            /* r0 = 0x0198 (collision speed input offset) */
    mov.l @(r0, r14), r5                 /* r5 = car[+0x198] collision speed input */
    jsr @r10                             /* call fpmul(car[+0x198], collision_result[+8]) */
    mov.l @(8, r12), r4                  /* delay slot: r4 = collision result[+8] scale */
    mov.w   DAT_0600c6fe, r1            /* r1 = 0x0194 (collision speed result offset) */
    add r14, r1                          /* r1 = &car[+0x194] */
    mov.l r0, @r1                        /* car[+0x194] = fpmul result (scaled speed) */
.L_steering_correction:                      /* --- apply steering correction --- */
    mov r13, r5                          /* arg2: collision params struct */
    .byte   0xB1, 0x0E    /* bsr 0x0600C8CC (external) — steering correction */
    mov r14, r4                          /* arg1: car struct */
    .byte   0xD2, 0x16    /* mov.l .L_game_flags_ptr, r2 — load game flags pointer */
    mov.l @r2, r2                        /* r2 = dereference game flags struct pointer */
    mov.l @r2, r3                        /* r3 = first word of game flags */
    .byte   0xD2, 0x16    /* mov.l .L_flag_mask_e00000, r2 — load flag mask 0x00E00000 */
    and r2, r3                           /* r3 = isolate bits 23:21 (wall response mode) */
    tst r3, r3                           /* all three bits clear? */
    bf      .L_wall_response_vectors     /* no → use wall response vector path */
    mov.w @(14, r13), r0                 /* r0 = collision params[+14] Y angle */
    mov r0, r3                           /* r3 = copy of Y angle */
    mov.l r0, @(32, r14)                 /* car[+0x20] = Y angle from collision */
    mov.w   DAT_0600c700, r6            /* r6 = 0x0190 (sin output buffer offset) */
    mov.w   DAT_0600c702, r5            /* r5 = 0x018C (cos output buffer offset) */
    mov.l @(40, r14), r4                 /* r4 = car[+0x28] steering angle */
    .byte   0xD3, 0x12    /* mov.l .L_fn_sincos, r3 — load sincos_pair function */
    add r14, r6                          /* r6 = &car[+0x190] (sin output addr) */
    add r14, r5                          /* r5 = &car[+0x18C] (cos output addr) */
    jsr @r3                              /* call sincos_pair(-steering, &cos, &sin) */
    neg r4, r4                           /* delay slot: negate steering angle */
    mov.w   DAT_0600c702, r0            /* r0 = 0x018C (cos output buffer offset) */
    mov.l @(r0, r14), r5                 /* r5 = car[+0x18C] cos component */
    jsr @r10                             /* call fpmul(cos, speed) */
    mov.l @(12, r14), r4                 /* delay slot: r4 = car[+0x0C] current speed */
    mov.l @(16, r14), r3                 /* r3 = car[+0x10] X position */
    add r0, r3                           /* r3 = X + cos*speed */
    mov.l r3, @(16, r14)                 /* car[+0x10] = updated X position */
    mov.w   DAT_0600c700, r0            /* r0 = 0x0190 (sin output buffer offset) */
    mov.l @(r0, r14), r5                 /* r5 = car[+0x190] sin component */
    jsr @r10                             /* call fpmul(sin, speed) */
    mov.l @(12, r14), r4                 /* delay slot: r4 = car[+0x0C] current speed */
    mov.l @(24, r14), r3                 /* r3 = car[+0x18] Z position */
    add r0, r3                           /* r3 = Z + sin*speed */
    mov.l r3, @(24, r14)                 /* car[+0x18] = updated Z position */
    mov #0x0, r2                         /* r2 = 0 (clear Y velocity) */
    bra     .L_epilogue                  /* jump to function epilogue */
    mov.l r2, @(20, r14)                 /* delay slot: car[+0x14] = 0 (Y position) */

    .global DAT_0600c6f6
DAT_0600c6f6:
    .2byte  0x0208                        /* car offset: surface timer */

    .global DAT_0600c6f8
DAT_0600c6f8:
    .2byte  0x0161                        /* car offset: collision flags byte */

    .global DAT_0600c6fa
DAT_0600c6fa:
    .2byte  0x0204                        /* car offset: collision cooldown */

    .global DAT_0600c6fc
DAT_0600c6fc:
    .2byte  0x0198                        /* car offset: collision speed input */

    .global DAT_0600c6fe
DAT_0600c6fe:
    .2byte  0x0194                        /* car offset: collision speed result */

    .global DAT_0600c700
DAT_0600c700:
    .2byte  0x0190                        /* car offset: sin output buffer */

    .global DAT_0600c702
DAT_0600c702:
    .2byte  0x018C                        /* car offset: cos output buffer */
.L_car_array_base:
    .4byte  sym_0607E944               /* car array base pointer */
.L_gear_mode_2:
    .4byte  sym_06087804               /* gear/transmission mode (dup for reach) */
.L_game_flags_ptr:
    .4byte  sym_0607E940               /* game flags struct pointer */
.L_flag_mask_e00000:
    .4byte  0x00E00000                  /* flag mask: bits 23:21 (wall response mode) */
.L_fn_sincos:
    .4byte  sincos_pair                /* sin/cos computation for steering */
.L_wall_response_vectors:                    /* --- wall response vector path --- */
    .byte   0xB1, 0x06    /* bsr 0x0600C928 (external) — wall normal computation */
    mov r14, r4                          /* arg: car struct */
    mov r13, r5                          /* arg: collision params struct */
    .byte   0xB0, 0x59    /* bsr 0x0600C7D4 (external) — wall response vectors */
    mov r14, r4                          /* arg: car struct */
    mov r15, r6                          /* r6 = stack frame pointer */
    mov r14, r5                          /* r5 = car struct base */
    mov.l r6, @-r15                      /* push stack frame pointer */
    add #0x10, r5                        /* r5 = &car[+0x10] (XYZ position base) */
    mov.l r5, @-r15                      /* push position base pointer */
    mov.l @(24, r14), r5                 /* r5 = car[+0x18] Z position */
    .byte   0xD3, 0x25    /* mov.l .L_fn_atan2, r3 — load atan2 function (cross-TU) */
    jsr @r3                              /* call atan2(X, Z) → angle in r0 */
    mov.l @(16, r14), r4                 /* delay slot: r4 = car[+0x10] X position */
    mov r0, r4                           /* r4 = computed angle */
    mov.l @r15+, r5                      /* pop position base pointer */
    .byte   0xD3, 0x23    /* mov.l .L_fn_apply_response, r3 — load response fn (cross-TU) */
    jsr @r3                              /* call apply_response(angle, pos_base, stack) */
    mov.l @r15+, r6                      /* delay slot: pop stack frame pointer */
.L_epilogue:                                 /* --- function epilogue --- */
    add #0x4, r15                        /* free 4-byte stack allocation */
    lds.l @r15+, pr                      /* restore return address */
    mov.l @r15+, r10                     /* restore r10 */
    mov.l @r15+, r11                     /* restore r11 */
    mov.l @r15+, r12                     /* restore r12 */
    mov.l @r15+, r13                     /* restore r13 */
    rts                                  /* return to caller */
    mov.l @r15+, r14                     /* delay slot: restore r14 */
