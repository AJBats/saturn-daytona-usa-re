/* player_collision -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600C5D6 - 0x0600C74E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Player car collision response — handles collision detection, wall impact,
 * speed reduction, and steering correction after collisions.
 *
 * Persistent registers:
 *   r10 = fpmul function pointer
 *   r11 = &collision_counter (incremented each frame of active collision)
 *   r12 = collision result struct pointer (from BSR + 0x18 offset)
 *   r13 = collision params struct
 *   r14 = car struct (from car_struct_ptr)
 *
 * Collision paths:
 *   Path A (gear_mode==2 OR surface_timer>0 AND shift_timer>0):
 *     → BSR 0x0600CA96 with collision params
 *   Path B (detailed collision):
 *     Check car[+3] bit 3, surface_timer, car[+0x161] bit 5, collision counter,
 *     car[+0x204] threshold
 *     → BSR 0x0600CF58 (collision_dispatch)
 *     → Decrement car[+0x204] by 2 while positive
 *     → BSR 0x0600CC38 if depleted
 *
 * Post-collision:
 *   - If gear_mode==3: car[+0x194] = fpmul(car[+0x198], car[+8])
 *   - BSR 0x0600C8CC (steering correction)
 *   - If game_flags bits 23:21 clear:
 *     → sincos_pair for steering angle → X/Z velocity integration
 *   - Else: BSR 0x0600C928 + 0x0600C7D4 (wall response vectors)
 *
 * Car struct offsets used:
 *   +0x08 = car type/speed scaling
 *   +0x0C = current speed
 *   +0x10 = X position (updated by sin component)
 *   +0x14 = Y position (cleared on steering path)
 *   +0x18 = Z position (updated by cos component)
 *   +0x20 = Y angle (set from collision params)
 *   +0x28 = steering angle (used with sincos_pair)
 *   +0xB8 = shift timer
 *   +0x161 = collision flags (bit 5 = wall contact)
 *   +0x18C = cos output buffer
 *   +0x190 = sin output buffer
 *   +0x194 = collision speed result
 *   +0x198 = collision speed input
 *   +0x1BC = surface response timer
 *   +0x204 = collision cooldown (decremented by 2)
 *   +0x208 = surface timer
 */

    .section .text.FUN_0600C5D6


    .global player_collision
    .type player_collision, @function
player_collision:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    sts.l pr, @-r15
    add #-0x4, r15
    .byte   0xDA, 0x0E    /* mov.l .L_fn_fpmul, r10 */
    .byte   0xDB, 0x0F    /* mov.l .L_collision_counter, r11 */
    .byte   0xDE, 0x0F    /* mov.l .L_car_struct_ptr, r14 */
    .byte   0xDD, 0x10    /* mov.l .L_collision_params, r13 */
    .byte   0xB3, 0xA8    /* bsr 0x0600CD40 (external) — collision detect */
    mov.l @r14, r14                    /* r14 = car struct */
    mov r0, r12                        /* r12 = collision result base */
    .byte   0xD0, 0x0F    /* mov.l .L_gear_mode, r0 */
    mov.w @r0, r0                     /* read gear mode (16-bit) */
    extu.w r0, r0
    cmp/eq #0x2, r0
    bt/s    .L_0600C60E               /* gear_mode==2 → simple collision */
    add #0x18, r12                    /* r12 += 0x18 (collision result offset) */
    mov.w   DAT_0600c616, r0         /* +0x1BC = surface response timer */
    mov.l @(r0, r14), r2
    cmp/pl r2
    bt      .L_0600C60E              /* surface timer > 0 → simple collision */
    mov.w   .L_off_shift_timer, r0   /* +0xB8 = shift timer */
    mov.l @(r0, r14), r2
    cmp/pl r2
    bf      .L_0600C634              /* shift timer <= 0 → detailed collision */
.L_0600C60E:                              /* --- simple collision path --- */
    .byte   0xB2, 0x42    /* bsr 0x0600CA96 (external) — simple collision response */
    mov r13, r4
    bra     .L_0600C692
    nop

    .global DAT_0600c616
DAT_0600c616:
    .2byte  0x01BC                        /* car offset: surface response timer */
.L_off_shift_timer:
    .2byte  0x00B8                        /* car offset: shift timer */
    .2byte  0xFFFF
    .4byte  0x00480000                  /* (adjacent data: fixed-point threshold) */
.L_fn_fpmul:
    .4byte  fpmul                      /* fixed-point multiply */
.L_collision_counter:
    .4byte  sym_0607EBDC               /* collision frame counter */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_collision_params:
    .4byte  sym_06078680               /* collision parameters struct */
.L_gear_mode:
    .4byte  sym_06087804               /* gear/transmission mode (16-bit) */
.L_0600C634:                              /* --- detailed collision path --- */
    .byte   0xD2, 0x33    /* mov.l .L_car_array_base, r2 */
    mov.l @r2, r2                     /* r2 = car array base */
    mov r2, r0
    mov.b @(3, r0), r0               /* car_base[+3] = controller flags */
    tst #0x8, r0                      /* bit 3 = controller input? */
    bf      .L_0600C68C              /* → wall response path */
    mov.w   DAT_0600c6f6, r0         /* +0x208 = surface timer */
    mov.l @(r0, r14), r3
    cmp/pl r3
    bt      .L_0600C68C              /* surface timer > 0 → wall path */
    mov.w   DAT_0600c6f8, r0         /* +0x161 = collision flags byte */
    mov.b @(r0, r14), r0
    tst #0x20, r0                     /* bit 5 = wall contact */
    bf      .L_0600C68C              /* wall contact → wall path */
    mov #0xA, r2
    mov.l @r11, r3                    /* collision counter */
    cmp/gt r2, r3
    bt      .L_0600C666              /* counter > 10 → skip dispatch */
    mov.w   DAT_0600c6fa, r0         /* +0x204 = collision cooldown */
    mov #0x66, r3
    mov.l @(r0, r14), r2
    cmp/ge r3, r2
    bt      .L_0600C666              /* cooldown >= 0x66 → skip dispatch */
    .byte   0xB4, 0x79    /* bsr 0x0600CF58 (external) — collision dispatch */
    mov r12, r4
.L_0600C666:                              /* --- cooldown decrement --- */
    mov.w   DAT_0600c6fa, r0         /* +0x204 */
    mov.l @(r0, r14), r2
    cmp/pl r2
    bf      .L_0600C682              /* cooldown <= 0 → depleted path */
    mov.w   DAT_0600c6fa, r0
    mov.l @(r0, r14), r2
    add #-0x2, r2                     /* decrement cooldown by 2 */
    mov.l r2, @(r0, r14)
    .byte   0xB2, 0x0E    /* bsr 0x0600CA96 (external) — simple collision */
    mov r13, r4
    mov.l @r11, r2
    add #0x1, r2                      /* increment collision counter */
    bra     .L_0600C692
    mov.l r2, @r11
.L_0600C682:                              /* --- cooldown depleted path --- */
    mov r13, r5
    .byte   0xB2, 0xD8    /* bsr 0x0600CC38 (external) — full collision response */
    mov r12, r4
    bra     .L_0600C692
    nop
.L_0600C68C:                              /* --- wall/forced collision path --- */
    mov r13, r5
    .byte   0xB2, 0xD3    /* bsr 0x0600CC38 (external) — full collision response */
    mov r12, r4
.L_0600C692:                              /* --- post-collision processing --- */
    .byte   0xD0, 0x1D    /* mov.l .L_gear_mode_2, r0 */
    mov.w @r0, r0                     /* read gear mode */
    extu.w r0, r0
    cmp/eq #0x3, r0
    bf      .L_0600C6AA              /* gear != 3 → skip speed calc */
    mov.w   DAT_0600c6fc, r0         /* +0x198 = collision speed input */
    mov.l @(r0, r14), r5
    jsr @r10                           /* fpmul(car[+0x198], car[+8]) */
    mov.l @(8, r12), r4              /* collision result[+8] */
    mov.w   DAT_0600c6fe, r1         /* +0x194 = collision speed result */
    add r14, r1
    mov.l r0, @r1                     /* car[+0x194] = fpmul result */
.L_0600C6AA:                              /* --- steering correction --- */
    mov r13, r5
    .byte   0xB1, 0x0E    /* bsr 0x0600C8CC (external) — steering correction */
    mov r14, r4
    .byte   0xD2, 0x16    /* mov.l .L_game_flags_ptr, r2 */
    mov.l @r2, r2                     /* r2 = game flags struct */
    mov.l @r2, r3                     /* r3 = flags word */
    .byte   0xD2, 0x16    /* mov.l .L_flag_mask_e00000, r2 */
    and r2, r3                        /* check bits 23:21 */
    tst r3, r3
    bf      .L_0600C718              /* bits set → wall response vectors */
    mov.w @(14, r13), r0             /* collision params[+14] = Y angle */
    mov r0, r3
    mov.l r0, @(32, r14)             /* car[+0x20] = Y angle */
    mov.w   DAT_0600c700, r6         /* +0x190 = sin output */
    mov.w   DAT_0600c702, r5         /* +0x18C = cos output */
    mov.l @(40, r14), r4             /* r4 = steering angle */
    .byte   0xD3, 0x12    /* mov.l .L_fn_sincos, r3 */
    add r14, r6
    add r14, r5
    jsr @r3                            /* sincos_pair(-steering, &cos, &sin) */
    neg r4, r4
    mov.w   DAT_0600c702, r0         /* car[+0x18C] = cos component */
    mov.l @(r0, r14), r5
    jsr @r10                           /* fpmul(cos, speed) */
    mov.l @(12, r14), r4             /* r4 = car speed */
    mov.l @(16, r14), r3             /* X position */
    add r0, r3
    mov.l r3, @(16, r14)             /* X += cos * speed */
    mov.w   DAT_0600c700, r0         /* car[+0x190] = sin component */
    mov.l @(r0, r14), r5
    jsr @r10                           /* fpmul(sin, speed) */
    mov.l @(12, r14), r4
    mov.l @(24, r14), r3             /* Z position */
    add r0, r3
    mov.l r3, @(24, r14)             /* Z += sin * speed */
    mov #0x0, r2
    bra     .L_0600C73E
    mov.l r2, @(20, r14)             /* Y position = 0 */

    .global DAT_0600c6f6
DAT_0600c6f6:
    .2byte  0x0208                        /* car offset: surface timer */

    .global DAT_0600c6f8
DAT_0600c6f8:
    .2byte  0x0161                        /* car offset: collision flags byte */

    .global DAT_0600c6fa
DAT_0600c6fa:
    .2byte  0x0204                        /* car offset: collision cooldown */

    .global DAT_0600c6fc
DAT_0600c6fc:
    .2byte  0x0198                        /* car offset: collision speed input */

    .global DAT_0600c6fe
DAT_0600c6fe:
    .2byte  0x0194                        /* car offset: collision speed result */

    .global DAT_0600c700
DAT_0600c700:
    .2byte  0x0190                        /* car offset: sin output buffer */

    .global DAT_0600c702
DAT_0600c702:
    .2byte  0x018C                        /* car offset: cos output buffer */
.L_car_array_base:
    .4byte  sym_0607E944               /* car array base pointer */
.L_gear_mode_2:
    .4byte  sym_06087804               /* gear/transmission mode (dup for reach) */
.L_game_flags_ptr:
    .4byte  sym_0607E940               /* game flags struct pointer */
.L_flag_mask_e00000:
    .4byte  0x00E00000                  /* flag mask: bits 23:21 (wall response mode) */
.L_fn_sincos:
    .4byte  sincos_pair                /* sin/cos computation for steering */
.L_0600C718:                              /* --- wall response vector path --- */
    .byte   0xB1, 0x06    /* bsr 0x0600C928 (external) — wall normal computation */
    mov r14, r4
    mov r13, r5
    .byte   0xB0, 0x59    /* bsr 0x0600C7D4 (external) — wall response vectors */
    mov r14, r4
    mov r15, r6                       /* r6 = stack frame */
    mov r14, r5
    mov.l r6, @-r15
    add #0x10, r5                     /* r5 = &car[+0x10] (position XYZ) */
    mov.l r5, @-r15
    mov.l @(24, r14), r5             /* r5 = Z position */
    .byte   0xD3, 0x25    /* mov.l .L_fn_atan2, r3 — cross-TU: atan2 */
    jsr @r3                            /* atan2(X, Z) */
    mov.l @(16, r14), r4             /* r4 = X position */
    mov r0, r4                        /* r4 = angle result */
    mov.l @r15+, r5
    .byte   0xD3, 0x23    /* mov.l .L_fn_apply_response, r3 — cross-TU: response */
    jsr @r3                            /* apply wall response vectors */
    mov.l @r15+, r6
.L_0600C73E:
    add #0x4, r15
    lds.l @r15+, pr
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
