/* camera_track_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601450C - 0x060145BC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Camera tracking slot selector — adjusts the active car slot index based
 * on D-pad Up/Down input, clamped to valid range. Runs the input check
 * only every 4th frame (frame_counter & 3 == 0) for debounce.
 *
 * Algorithm:
 *   1. Read car_slot_index, button_state, frame_counter
 *   2. If frame_counter & 3 != 0 → skip input handling
 *   3. If Down (0x4000) pressed and slot > 0 → decrement slot
 *   4. If Up (0x8000) pressed and slot < 0x1C → increment slot
 *   5. If active_car_count >= 3 → clamp slot to [0x1B, 0x1C]
 *   6. Look up variant byte from table[slot], store to variant_code
 *   7. If slot changed → tail-call sound_cmd_dispatch (click sound)
 *
 * Key state variables:
 *   sym_06084B08 = car slot index (32-bit)
 *   g_pad_state = held button state (16-bit word)
 *   sym_0607EBC8 = frame counter (32-bit, low 2 bits used for debounce)
 *   sym_06084B18 = active car count (32-bit)
 *   sym_0605AD2C = car variant lookup table base (byte array, indexed by slot)
 *   sym_06084B20 = current variant code output (32-bit)
 */

    .section .text.FUN_0601450C


    .global camera_track_update
    .type camera_track_update, @function
camera_track_update:
    mov.l r14, @-r15                    ! save r14 (will hold &car_slot_index)
    mov.l   .L_ptr_car_slot, r14        ! r14 = &car_slot_index
    mov.l   .L_ptr_button_state, r4     ! r4 = &held_button_state
    mov.l   .L_ptr_frame_counter, r0    ! r0 = &frame_counter
    mov.w @r4, r4                       ! r4 = held buttons (16-bit)
    mov.l @r0, r0                       ! r0 = frame_counter value
    tst #0x3, r0                        ! test frame_counter & 3
    bf/s    .L_apply_clamp              ! if nonzero → skip input (debounce)
    mov.l @r14, r5                      ! (delay) r5 = old_slot (save for change detect)
    extu.w r4, r3                       ! r3 = buttons zero-extended to 32-bit
    mov.w   DAT_06014594, r2            ! r2 = 0x4000 (Down button mask)
    and r2, r3                          ! r3 = buttons & Down
    tst r3, r3                          ! Down pressed?
    bt      .L_check_up                 ! if not → check Up button
    mov #0x0, r2                        ! r2 = 0 (minimum slot)
    mov.l @r14, r3                      ! r3 = current car_slot
    cmp/hi r2, r3                       ! T = (slot > 0)?
    bf      .L_apply_clamp             ! if slot == 0 → already at min, skip
    mov.l @r14, r2                      ! r2 = current slot
    add #-0x1, r2                       ! r2 = slot - 1
    bra     .L_apply_clamp             ! go to clamp check
    mov.l r2, @r14                      ! (delay) store decremented slot
.L_check_up:
    extu.w r4, r4                       ! r4 = buttons zero-extended
    mov.l   .L_mask_up_button, r2       ! r2 = 0x00008000 (Up button mask)
    and r2, r4                          ! r4 = buttons & Up
    tst r4, r4                          ! Up pressed?
    bt      .L_apply_clamp             ! if not → skip to clamp
    mov.l @r14, r3                      ! r3 = current slot
    mov #0x1C, r2                       ! r2 = 0x1C (28 = max slot)
    cmp/hs r2, r3                       ! T = (slot >= 28)?
    bt      .L_apply_clamp             ! if already at max → skip
    mov.l @r14, r2                      ! r2 = current slot
    add #0x1, r2                        ! r2 = slot + 1
    mov.l r2, @r14                      ! store incremented slot
.L_apply_clamp:
    mov.l   .L_ptr_car_count, r3        ! r3 = &active_car_count
    mov #0x3, r2                        ! r2 = 3
    mov.l @r3, r3                       ! r3 = active_car_count
    cmp/hs r2, r3                       ! T = (car_count >= 3)?
    bf      .L_lookup_variant           ! if fewer than 3 cars → skip clamp
    mov #0x1B, r4                       ! r4 = 0x1B (27 = clamp lower bound)
    mov.l @r14, r2                      ! r2 = current slot
    cmp/hs r4, r2                       ! T = (slot >= 27)?
    bt      .L_clamp_upper             ! if slot >= 27 → check upper bound
    bra     .L_lookup_variant          ! otherwise → force slot = 0x1B
    mov.l r4, @r14                      ! (delay) car_slot = 0x1B
.L_clamp_upper:
    mov #0x1C, r3                       ! r3 = 0x1C (28 = clamp upper bound)
    mov.l @r14, r2                      ! r2 = current slot
    cmp/hi r3, r2                       ! T = (slot > 28)?
    bf      .L_lookup_variant           ! if slot <= 28 → already valid
    mov #0x1C, r3                       ! r3 = 0x1C
    mov.l r3, @r14                      ! car_slot = 0x1C (cap at max)
.L_lookup_variant:
    mov.l @r14, r2                      ! r2 = final car_slot
    mov.l   .L_ptr_variant_table, r3    ! r3 = variant_table base
    mov.l   .L_ptr_variant_code, r1     ! r1 = &variant_code output
    add r3, r2                          ! r2 = &variant_table[slot]
    mov.b @r2, r2                       ! r2 = variant_table[slot] (byte)
    extu.b r2, r2                       ! r2 = zero-extend to 32-bit
    mov.l r2, @r1                       ! variant_code = table[slot]
    mov.l @r14, r0                      ! r0 = current slot
    cmp/eq r0, r5                       ! slot changed from original?
    bt      .L_no_change                ! if same → return without sound
    mov.l   .L_snd_slot_change, r5      ! r5 = 0xAB111DFF (slot change click sound)
    mov #0x0, r4                        ! r4 = 0 (sound channel)
    mov.l   .L_fn_sound_dispatch, r3    ! r3 = &sound_cmd_dispatch
    jmp @r3                             ! tail-call sound_cmd_dispatch(0, 0xAB111DFF)
    mov.l @r15+, r14                    ! (delay) restore r14
.L_no_change:
    rts                                 ! return — no slot change, no sound
    mov.l @r15+, r14                    ! (delay) restore r14

    .global DAT_06014594
DAT_06014594:
    .2byte  0x4000
    .2byte  0xFFFF
.L_ptr_car_slot:
    .4byte  sym_06084B08
.L_ptr_button_state:
    .4byte  g_pad_state
.L_ptr_frame_counter:
    .4byte  sym_0607EBC8
.L_mask_up_button:
    .4byte  0x00008000                  /* 0x8000 = Up button mask (32-bit for AND) */
.L_ptr_car_count:
    .4byte  sym_06084B18
.L_ptr_variant_table:
    .4byte  sym_0605AD2C
.L_ptr_variant_code:
    .4byte  sym_06084B20
.L_snd_slot_change:
    .4byte  0xAB111DFF
.L_fn_sound_dispatch:
    .4byte  sound_cmd_dispatch
