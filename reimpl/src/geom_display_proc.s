/* geom_display_proc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601F4B4 - 0x0601F5D0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Decodes a 7-byte packed geometry display record into 6 output
 * parameter bytes written to the caller's output buffer (r4).
 *
 * Each source byte encodes a two-digit BCD value (high nibble =
 * tens, low nibble = ones): decoded = high*10 + low.
 *
 * output[0]: BCD-decoded record[6] * 100 + BCD-decoded record[5]
 *            + base offset 0xF844, truncated to byte.
 *            (4-digit combined value from bytes [5]+[6])
 * output[1]: record[4] low nibble (raw)
 * output[2]: BCD-decoded record[3] (high*10 + low)
 * output[3]: BCD-decoded record[2]
 * output[4]: BCD-decoded record[1]
 * output[5]: record[4] high nibble (raw)
 *
 * Called from hud_handler_main with:
 *   r4 = output buffer (sym_060877E8, "geom display parameter block")
 *
 * Pool references:
 *   sym_060877E4 = cached raw command pointer (written here)
 *   sym_060A4C98 = indirect pointer to current geom display record
 */

    .section .text.FUN_0601F4B4


    .global geom_display_proc
    .type geom_display_proc, @function
geom_display_proc:
    mov.l r14, @-r15               ! save callee-saved regs
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    sts.l macl, @-r15
    add #-0x1C, r15                ! allocate 28-byte stack frame
    mov.l   .L_ptr_cmd_cache, r5   ! r5 = &cmd_cache (sym_060877E4)
    mov.l   .L_ptr_cmd_source, r3  ! r3 = &cmd_source_ptr (sym_060A4C98)
    mov.l @r3, r3                  ! r3 = *cmd_source_ptr (current record addr)
    mov.l r3, @r5                  ! cmd_cache = current record addr
    mov r3, r12                    ! --- unpack record bytes [1]..[6] ---
    add #0x1, r12
    mov.b @r12, r12                ! r12 = record[1]
    extu.b r12, r12
    mov r3, r11
    add #0x2, r11
    mov.b @r11, r11                ! r11 = record[2]
    extu.b r11, r11
    mov r3, r13
    add #0x3, r13
    mov.b @r13, r13                ! r13 = record[3]
    extu.b r13, r13
    mov r3, r10
    add #0x4, r10
    mov.b @r10, r10                ! r10 = record[4]
    extu.b r10, r10
    mov r3, r14
    add #0x5, r14
    mov.b @r14, r14                ! r14 = record[5]
    extu.b r14, r14
    mov r3, r0
    mov #0xF, r5                   ! r5 = 0xF (nibble mask, kept for all calcs)
    mov r14, r1                    ! --- decode record[5] high nibble ---
    mov r14, r7
    mov.b @(6, r0), r0             ! r0 = record[6]
    shar r1                        ! r1 = record[5] >> 4 (arithmetic)
    and r5, r7                     ! r7 = record[5] & 0xF (low nibble)
    extu.b r0, r0
    shar r1
    mov r0, r14                    ! r14 = record[6] (saved for later)
    shar r1
    shar r14                       ! --- decode record[6] high nibble ---
    shar r1
    shar r14
    and r5, r1                     ! r1 = (record[5]>>4) & 0xF (high nibble of byte5)
    shar r14
    mov r1, r3                     ! --- BCD tens*10 for record[5] high nibble ---
    shll r1                        ! r1 = tens * 2
    shll2 r3                       ! r3 = tens * 4
    shll r3                        ! r3 = tens * 8
    add r3, r1                     ! r1 = tens*2 + tens*8 = tens*10
    shar r14                       ! continuing record[6] high nibble extraction
    and r5, r14                    ! r14 = (record[6]>>4) & 0xF
    mov.w   .L_const_1000, r3     ! r3 = 1000
    mul.l r3, r14                  ! macl = record[6]_high * 1000
    sts macl, r14                  ! r14 = record[6]_high * 1000
    mov r0, r6                     ! --- decode record[6] low nibble ---
    and r5, r6                     ! r6 = record[6] & 0xF
    mov #0x64, r2                  ! r2 = 100
    mul.l r2, r6                   ! macl = record[6]_low * 100
    sts macl, r6                   ! r6 = record[6]_low * 100
    add r7, r1                     ! r1 += record[5]_low
    add r14, r1                    ! r1 += record[6]_high * 1000
    mov r13, r7                    ! --- begin record[3] high nibble extraction (for output[2]) ---
    add r6, r1                     ! r1 += record[6]_low * 100 (combined index complete)
    shar r7                        ! r7 = record[3] >> 4 (via 4x shar)
    mov.w   DAT_0601f5c6, r6      ! r6 = 0xF844 (base offset)
    shar r7
    add r1, r6                    ! r6 = base + combined index
    shar r7
    mov.b r6, @r4                 ! output[0] = (byte)(base + index)
    shar r7
    mov r10, r6                   ! --- output[1]: record[4] low nibble ---
    and r5, r7                    ! r7 = record[3]_high
    and r5, r6                    ! r6 = record[4] & 0xF
    mov r7, r3
    extu.b r6, r0
    shll r7
    shll2 r3
    mov r10, r6                   ! --- output[5]: record[4] high nibble ---
    mov.b r0, @(1, r4)           ! output[1] = record[4] & 0xF
    shar r6                       ! r6 = record[4] >> 4 (via 4x shar)
    shar r6
    shar r6
    shar r6
    and r5, r6                    ! r6 = (record[4]>>4) & 0xF
    extu.b r6, r0
    mov.b r0, @(5, r4)           ! output[5] = record[4]_high
    shll r3                       ! --- output[2]: BCD decode record[3] ---
    add r3, r7                    ! r7 = record[3]_high * 10  (tens*2 + tens*8)
    mov r13, r6
    and r5, r6                    ! r6 = record[3] & 0xF
    add r7, r6                    ! r6 = record[3]_high*10 + record[3]_low
    extu.b r6, r0
    mov r11, r7                   ! --- output[3]: record[2] nibble decode ---
    mov r11, r6
    mov.b r0, @(2, r4)           ! output[2] = record[3] nibble combined
    shar r7                       ! r7 = record[2] >> 4 (via 4x shar)
    and r5, r6                    ! r6 = record[2] & 0xF
    shar r7
    shar r7
    shar r7
    and r5, r7                    ! r7 = (record[2]>>4) & 0xF
    mov r7, r3                    ! --- high*10 pattern again ---
    shll r7
    shll2 r3
    shll r3
    add r3, r7                    ! r7 = record[2]_high * 10
    add r7, r6                    ! r6 = record[2]_high*10 + record[2]_low
    extu.b r6, r0
    mov r12, r7                   ! --- output[4]: record[1] nibble decode ---
    mov.b r0, @(3, r4)           ! output[3] = record[2] nibble combined
    shar r7                       ! r7 = record[1] >> 4 (via 4x shar)
    shar r7
    shar r7
    shar r7
    and r5, r7                    ! r7 = (record[1]>>4) & 0xF
    mov r7, r3                    ! --- high*10 pattern ---
    shll r7
    shll2 r3
    shll r3
    add r3, r7                    ! r7 = record[1]_high * 10
    mov r12, r6
    and r5, r6                    ! r6 = record[1] & 0xF
    add r7, r6                    ! r6 = record[1]_high*10 + record[1]_low
    extu.b r6, r0
    mov.b r0, @(4, r4)           ! output[4] = record[1] nibble combined
    add #0x1C, r15                ! deallocate stack frame
    lds.l @r15+, macl              ! restore callee-saved regs
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_const_1000:                     /* [HIGH] 0x03E8 = 1000, multiplier for record[6] high nibble */
    .2byte  0x03E8

    .global DAT_0601f5c6
DAT_0601f5c6:                      /* [HIGH] 0xF844 = -1980 signed, base display coord offset */
    .2byte  0xF844
.L_ptr_cmd_cache:                  /* [HIGH] sym_060877E4 = cached raw geom command pointer (written by this fn) */
    .4byte  sym_060877E4
.L_ptr_cmd_source:                 /* [MEDIUM] sym_060A4C98 = indirect ptr to current geom display record */
    .4byte  sym_060A4C98
