/* course1_bg_load -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06018834 - 0x06018938
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Course 1 (Dinosaur Canyon) background data loader -- copies palette,
 * tile, and map data to Work RAM Low and VDP2 VRAM, then patches offset
 * tables for the rendering pipeline.
 *
 * Data copies (via memcpy_long_idx):
 *   1. Palette data   -> WRAM Low               (0x0CC8 bytes)
 *   2. Tile set A     -> WRAM Low + 0x0CC8       (0x7A00 bytes)
 *   3. Base BG data   -> WRAM Low + 0x86C8       (0xBD00 bytes)
 *   4. Map data       -> 0x240000                 (0x19000 bytes = 100KB)
 *   5. Tile set B     -> 0x240000 + 0x1C0B8      (0x3000 bytes)
 *   6. Tile set C     -> 0x240000 + 0x180B8      (0x4000 bytes)
 *   7. Data block D   -> 0x240000 + 0x1DFE8      (0x3000 bytes)
 *
 * After copying: patches offset tables (4 entry pairs), calls
 * sound_init_sequence(race_end_state), tail-calls projection_mgr.
 *
 * Persistent registers:
 *   r9  = WRAM Low base (0x200000) / then VDP VRAM base (0x240000)
 *   r10 = loop limit (8 entries)
 *   r11 = offset table A (sym_0605D1FC)
 *   r12 = offset table B (sym_06085FD0)
 *   r13 = memcpy_long_idx function
 *   r14 = BG data base address (sym_060D6900)
 */

    .section .text.FUN_06018834


    .global course1_bg_load
    .type course1_bg_load, @function
course1_bg_load:
    mov.l r14, @-r15                       ! save r14
    mov.l r13, @-r15                       ! save r13
    mov.l r12, @-r15                       ! save r12
    mov.l r11, @-r15                       ! save r11
    mov.l r10, @-r15                       ! save r10
    mov #0x8, r10                          ! loop limit = 8 (4 entry pairs)
    mov.l r9, @-r15                        ! save r9
    sts.l pr, @-r15                        ! save return address
    mov.l   .L_offset_table_a, r11        ! r11 = BG offset source table
    mov.l   .L_offset_table_b, r12        ! r12 = BG offset dest table
    mov.l   .L_bg_data_base, r14          ! r14 = BG data base address
    mov.l   .L_fn_memcpy_long, r13        ! r13 = memcpy_long_idx
    mov.w   .L_palette_size, r6           ! r6 = 0x0CC8 (palette size)
    mov.l   .L_wram_low, r9              ! r9 = 0x200000 (WRAM Low base)
    mov.l   .L_palette_src, r4           ! r4 = palette source addr
    jsr @r13                               ! memcpy(palette_src, WRAM_Low, 0xCC8)
    mov r9, r5                             ! (delay) r5 = WRAM Low dest
    mov.w   .L_tile_a_size, r6            ! r6 = 0x7A00 (tile set A size)
    mov.w   .L_palette_size, r5           ! r5 = 0x0CC8 (dest offset)
    mov.l   .L_tile_a_src, r4            ! r4 = tile set A source addr
    jsr @r13                               ! memcpy(tile_a, WRAM+0xCC8, 0x7A00)
    add r9, r5                             ! (delay) r5 = WRAM_Low + 0xCC8
    mov.l   .L_bg_base_size, r6          ! r6 = 0xBD00 (base BG data size)
    mov.l   .L_bg_base_offset, r5        ! r5 = 0x86C8 (dest offset)
    add r9, r5                             ! r5 = WRAM_Low + 0x86C8
    jsr @r13                               ! memcpy(bg_base, WRAM+0x86C8, 0xBD00)
    mov r14, r4                            ! (delay) r4 = BG data base as source
    mov.l   .L_map_size, r6              ! r6 = 0x19000 (map data size = 100KB)
    mov.l   .L_vram_dest_base, r9        ! r9 = 0x240000 (VRAM dest base)
    mov.l   .L_map_src, r4              ! r4 = map data source addr
    jsr @r13                               ! memcpy(map_src, 0x240000, 0x19000)
    mov r9, r5                             ! (delay) r5 = VRAM dest base
    mov.w   .L_tile_bd_size, r6           ! r6 = 0x3000 (tile set B size)
    mov.l   .L_tile_b_offset, r5         ! r5 = 0x1C0B8 (tile B VRAM offset)
    mov.l   .L_tile_b_src, r4           ! r4 = tile set B source addr
    jsr @r13                               ! memcpy(tile_b, VRAM+0x1C0B8, 0x3000)
    add r9, r5                             ! (delay) r5 = VRAM + 0x1C0B8
    mov.w   .L_tile_c_size, r6            ! r6 = 0x4000 (tile set C size)
    mov.l   .L_tile_c_offset, r5         ! r5 = 0x180B8 (tile C VRAM offset)
    mov.l   .L_tile_c_src, r4           ! r4 = tile set C source addr
    jsr @r13                               ! memcpy(tile_c, VRAM+0x180B8, 0x4000)
    add r9, r5                             ! (delay) r5 = VRAM + 0x180B8
    mov.w   .L_tile_bd_size, r6           ! r6 = 0x3000 (data block D size)
    mov.l   .L_data_d_offset, r5         ! r5 = 0x1DFE8 (data D VRAM offset)
    mov.l   .L_data_d_src, r4           ! r4 = data block D source addr
    jsr @r13                               ! memcpy(data_d, VRAM+0x1DFE8, 0x3000)
    add r9, r5                             ! (delay) r5 = VRAM + 0x1DFE8
    mov #0x0, r6                           ! === Patch offset tables ===
    mov r6, r5                             ! pair_idx = 0
    mov r6, r4                             ! table_offset = 0
.L_patch_loop:                              ! --- loop: patch 4 entry pairs ---
    mov r4, r2                             ! r2 = table_offset (even entry)
    mov r4, r3                             ! r3 = table_offset (even entry)
    add #0x2, r5                           ! pair_idx += 2
    add r11, r2                            ! r2 = &offset_table_a[even]
    add r12, r3                            ! r3 = &offset_table_b[even]
    add #0x4, r4                           ! advance to odd entry
    mov.l @r2, r1                          ! r1 = raw offset from table A
    mov r4, r6                             ! r6 = next table_offset (unused temp)
    add r14, r1                            ! r1 = bg_base + raw offset
    mov r4, r2                             ! r2 = table_offset (odd entry)
    mov.l r1, @r3                          ! table_b[even] = bg_base + offset
    add r11, r2                            ! r2 = &offset_table_a[odd]
    mov r4, r3                             ! r3 = table_offset (odd entry)
    mov.l @r2, r1                          ! r1 = raw offset from table A
    add r12, r3                            ! r3 = &offset_table_b[odd]
    add r14, r1                            ! r1 = bg_base + raw offset
    mov.l r1, @r3                          ! table_b[odd] = bg_base + offset
    cmp/ge r10, r5                         ! pair_idx >= 8?
    bf/s    .L_patch_loop                  ! loop if not done
    add #0x4, r4                           ! (delay) table_offset += 4
    mov.l   .L_race_end_state, r4        ! === Sound init + tail call ===
    mov.l   .L_fn_sound_init, r3         ! r3 = sound_init_sequence
    jsr @r3                                ! sound_init_sequence(*race_end_state)
    mov.l @r4, r4                          ! (delay) r4 = *race_end_state
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r9                        ! restore r9
    mov.l @r15+, r10                       ! restore r10
    mov.l @r15+, r11                       ! restore r11
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    mov.l   .L_fn_projection_mgr, r3     ! r3 = projection_mgr
    jmp @r3                                ! tail call -> projection_mgr()
    mov.l @r15+, r14                       ! (delay) restore r14
.L_palette_size:
    .2byte  0x0CC8                         /* palette data: 3272 bytes */
.L_tile_a_size:
    .2byte  0x7A00                         /* tile set A: 31232 bytes */
.L_tile_bd_size:
    .2byte  0x3000                         /* tile set B/D: 12288 bytes */
.L_tile_c_size:
    .2byte  0x4000                         /* tile set C: 16384 bytes */
    .2byte  0xFFFF                         /* alignment padding */
.L_offset_table_a:
    .4byte  sym_0605D1FC                   /* BG offset source table (course 1) */
.L_offset_table_b:
    .4byte  sym_06085FD0                   /* BG offset dest table */
.L_bg_data_base:
    .4byte  sym_060D6900                   /* BG data base address */
.L_fn_memcpy_long:
    .4byte  memcpy_long_idx                /* long-indexed memory copy */
.L_wram_low:
    .4byte  0x00200000                     /* Work RAM Low base */
.L_palette_src:
    .4byte  sym_060D5840                   /* palette source data */
.L_tile_a_src:
    .4byte  sym_060C6000                   /* tile set A source */
.L_bg_base_size:
    .4byte  0x0000BD00                     /* base BG data: 48384 bytes */
.L_bg_base_offset:
    .4byte  0x000086C8                     /* WRAM offset for base BG */
.L_map_size:
    .4byte  0x00019000                     /* map data: 100KB */
.L_vram_dest_base:
    .4byte  0x00240000                     /* VDP2 VRAM destination base */
.L_map_src:
    .4byte  sym_060A6000                   /* map data source */
.L_tile_b_offset:
    .4byte  0x0001C0B8                     /* VRAM offset for tile set B */
.L_tile_b_src:
    .4byte  sym_060BF000                   /* tile set B source */
.L_tile_c_offset:
    .4byte  0x000180B8                     /* VRAM offset for tile set C */
.L_tile_c_src:
    .4byte  sym_060C2000                   /* tile set C source */
.L_data_d_offset:
    .4byte  0x0001DFE8                     /* VRAM offset for data block D */
.L_data_d_src:
    .4byte  0x002F8000                     /* data block D source address */
.L_race_end_state:
    .4byte  sym_0607EAD8                   /* pointer to race end state variable */
.L_fn_sound_init:
    .4byte  sound_init_sequence            /* sound initialization for course */
.L_fn_projection_mgr:
    .4byte  projection_mgr                 /* projection manager (tail call) */
