#include "game.h"

extern int DAT_06038106;
extern int DAT_06038108;
extern int DAT_0603881a;
extern int DAT_06038932;
extern int DAT_060389f2;
extern int DAT_06038a9a;
extern int DAT_06038a9e;
extern int DAT_06038cc8;
extern int DAT_06038cca;
extern int DAT_06038cce;
extern int DAT_06038cd0;
extern int DAT_06038cd2;
extern int DAT_06038cd4;
extern int DAT_06038cd6;
extern int DAT_06038e1a;
extern int DAT_06038efa;
extern int DAT_06038efc;
extern int DAT_0603918c;
extern int DAT_0603918e;
extern int DAT_060392e6;
extern int DAT_060395b6;
extern int DAT_060397f4;
extern int DAT_060397f6;
extern int DAT_060397f8;
extern void FUN_060388c0();
extern void FUN_06038a48();
extern void FUN_06038ac8();
extern unsigned short FUN_0603931c(unsigned short, unsigned short, short);
extern void FUN_060393fc(short, unsigned short, unsigned short, short, unsigned short);
extern void FUN_060394f0();
extern int FUN_0603a6c0();
extern int FUN_0603a72c();
extern int FUN_0603a766();
extern int PTR_DAT_060388b4;
extern int PTR_DAT_06038934;
extern int PTR_DAT_06038e20;
extern int PTR_DAT_06039190;
extern int PTR_DAT_0603923c;
extern int PTR_DAT_060392e8;
extern void FUN_06039fe8();

/* cd_toc_table_init -- Initialize CD table-of-contents data structure.
 * param_1 = TOC buffer pointer. Clears first 16 bytes (flags/counters),
 * initializes 64 FAD entries at +DAT_06038108. For each of 0x200 entries,
 * converts position data via softfloat (FUN_06035BC8 = uint-to-double),
 * processes through double multiply and divide chain. */
#if 0 /* FUN_0603806C -- replaced by ASM import */
void FUN_0603806c(param_1)
    char *param_1;
{
  char *puVar1;
  int uVar2;
  char *puVar3;
  int extraout_r3 = 0;
  int uVar4;
  unsigned int uVar5;
  int iVar6;
  int iVar7;
  char *puVar8;
  int *piVar9;
  int local_30 [8];
  char local_10 [4];

  puVar1 = (char *)0x00010000;
  puVar8 = local_10;
  iVar7 = 0x200;
  uVar4 = 0;
  param_1[2] = 0;
  param_1[1] = 0;
  *param_1 = 0;
  param_1[3] = 0;
  *(int *)(param_1 + 8) = 0;
  *(int *)(param_1 + 0xc) = 0;
  param_1[4] = 0;
  uVar5 = 0;
  do {
    if ((uVar5 & 0xffff) < 0x40) {
      *(int *)(param_1 + ((uVar5 & 0xffff) << 2) + (int)DAT_06038108) = uVar4;
    }
    iVar6 = (int)(short)((short)uVar5 * 0xc);
    *(int *)(param_1 + iVar6 + 0x10) = uVar4;
    *(char **)(puVar8 + -0x14) = puVar8 + -0x14;
    (*(int(*)())0x06035BC8)();
    *(int *)(puVar8 + -0x18) = 0;
    *(int *)(puVar8 + -0x1c) = 0x40F00000;
    puVar3 = puVar8 + -0xc;
    piVar9 = (int *)(puVar8 + -0x20);
    puVar8 = puVar8 + -0x20;
    *piVar9 = (int)puVar3;
    (*(int(*)())0x060359E4)();
    uVar2 = (*(int(*)())0x060357B8)();
    uVar5 = uVar5 + 1;
    *(int *)(extraout_r3 + 4) = uVar2;
    *(char **)(param_1 + iVar6 + 0x18) = puVar1;
  } while ((int)(uVar5 & 0xffff) < iVar7);
  return;
}
#endif

/* FUN_0603806C -- original binary (180 bytes) */
__asm__(
    ".section .text.FUN_0603806C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0603806C\n"
    ".global _FUN_0603806c\n"
    ".type _FUN_0603806C, @function\n"
    "_FUN_0603806C:\n"
    "_FUN_0603806c:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0xEC, 0x40, 0x9D, 0x46, 0xDE, 0x24, 0xE5, 0x00\n"  /* 0x0603806C */
    ".byte 0x60, 0x5C, 0x80, 0x42, 0x60, 0x5C, 0x80, 0x41, 0x24, 0x50, 0x62, 0x5C, 0x60, 0x23, 0x80, 0x43\n"  /* 0x0603807C */
    ".byte 0x14, 0x52, 0x14, 0x53, 0x63, 0x5C, 0x60, 0x33, 0x80, 0x44, 0x66, 0x5D, 0x63, 0x6D, 0x33, 0xC3\n"  /* 0x0603808C */
    ".byte 0x89, 0x05, 0x63, 0x6D, 0x43, 0x08, 0x92, 0x31, 0x32, 0x4C, 0x33, 0x2C, 0x23, 0x52, 0x67, 0x63\n"  /* 0x0603809C */
    ".byte 0x63, 0x63, 0x62, 0x43, 0x60, 0x63, 0x47, 0x08, 0x43, 0x08, 0x72, 0x10, 0x60, 0x0D, 0x43, 0x00\n"  /* 0x060380AC */
    ".byte 0x37, 0x3C, 0x67, 0x7F, 0x63, 0x43, 0x32, 0x7C, 0x73, 0x10, 0x22, 0x52, 0x33, 0x7C, 0x7F, 0xF0\n"  /* 0x060380BC */
    ".byte 0xD2, 0x10, 0x42, 0x0B, 0x2F, 0xF6, 0xE1, 0x00, 0x2F, 0x16, 0xD1, 0x0F, 0x2F, 0x16, 0x62, 0xF3\n"  /* 0x060380CC */
    ".byte 0xD1, 0x0E, 0x72, 0x10, 0x41, 0x0B, 0x2F, 0x26, 0xD2, 0x0D, 0x42, 0x0B, 0x00, 0x09, 0x76, 0x01\n"  /* 0x060380DC */
    ".byte 0x13, 0x01, 0x62, 0x6D, 0x63, 0x43, 0x73, 0x10, 0x37, 0x3C, 0x32, 0xD3, 0x8F, 0xCE, 0x17, 0xE2\n"  /* 0x060380EC */
    ".byte 0x4F, 0x26, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x02, 0x00, 0x18, 0x10, 0xFF, 0xFF\n"  /* 0x060380FC */
    ".byte 0x00, 0x01, 0x00, 0x00, 0x06, 0x03, 0x5B, 0xC8, 0x40, 0xF0, 0x00, 0x00, 0x06, 0x03, 0x59, 0xE4\n"  /* 0x0603810C */
    ".byte 0x06, 0x03, 0x57, 0xB8\n"  /* 0x0603811C */
);


/* vdp2_state_init -- Initialize all VDP2 shadow register tables.
 * Resets framebuffer state, clears display list flags, DMA flags,
 * then zeroes all VDP2 register shadow arrays (scroll params, color calc,
 * rotation params, window coords). Sets VDP2 base to 0x25F80000.
 * Triggers VDP1_BATCH_FLAG for first frame. */
/* vdp2_subsystem_init -- Initialize all VDP2 shadow register tables.
 * Calls hardware reset (0x06038F34), zeroes scroll/rotation/line-scroll
 * state, then initializes: VDP2 VRAM base (0x25F80000 at 0x060A3D84),
 * scroll regs (0x060A3D88), rotation table (0x060A3DB0), coordinate
 * table (0x060A3DF8 — scale defaults 0x10000 = 1.0 in 16.16),
 * color calc regs (0x060A3E38), and window table (0x060A3E48).
 * Triggers VDP1_BATCH_FLAG for next frame commit. */
#if 0 /* vdp2_subsystem_init -- redirected to ASM import via linker PROVIDE */
void vdp2_subsystem_init(void)
{
    char *scroll_regs;
    char *rotation_tbl;
    char *coord_tbl;
    unsigned int i;
    unsigned short j;

    (*(int(*)())0x06038F34)();                          /* hardware reset */
    *(int *)0x060A4C60 = 0;  *(int *)0x060A4C64 = 0;   /* scroll offset A/B */
    *(int *)0x060A4C68 = 0;  *(int *)0x060A4C6C = 0;   /* scroll offset C/D */
    *(int *)0x060A4C78 = 0;  *(int *)0x060A4C7C = 0;   /* line scroll A/B */
    *(short *)0x060A4C40 = 0;  *(short *)0x060A4C42 = 0; /* rotation flags */
    *(short *)0x060A4C54 = 0;  *(short *)0x060A4C56 = 0; /* rotation flags 2 */
    *(int *)0x060A4C44 = 0;  *(int *)0x060A4C48 = 0;   /* line scroll enable A/B */
    *(int *)0x060A4C4C = 0;  *(int *)0x060A4C50 = 0;   /* line scroll mode A/B */
    (*(int(*)())0x0603C104)();                          /* additional reset */

    scroll_regs = (char *)0x060A3D88;                   /* VDP2 scroll shadow */
    rotation_tbl = (char *)0x060A3DB0;                  /* VDP2 rotation shadow */
    *(char **)0x060A3D84 = 0x25F80000;                  /* VDP2 VRAM base */
    *(short *)scroll_regs = (short)0x00008000;          /* CHCTLA: 8bpp mode */
    *(short *)(scroll_regs + 2) = 0;                    /* BMPNA */
    *(short *)(scroll_regs + 6) = 0;                    /* PNCN0 */
    *(short *)(scroll_regs + 0xc) = 0;                  /* PLSZ */
    *(short *)(scroll_regs + 0xe) = (short)(0x8000 >> 2); /* MPOFR */
    for (i = 0; i < 8; i++) {
        *(short *)(scroll_regs + (i << 1) + 0x10) = (short)0xFFFF; /* MPA-MPH: all banks */
    }
    *(short *)(scroll_regs + 0x20) = 0;                /* SCXIN0 */
    *(short *)(scroll_regs + 0x22) = 0;                /* SCXDN0 */
    *(short *)(scroll_regs + 0x24) = 0;                /* SCYIN0 */
    *(short *)(scroll_regs + 0x26) = 0;                /* SCYDN0 */

    /* Clear rotation table A (0x060A3DB0, 24 shorts + loops) */
    *(short *)(rotation_tbl + 0) = 0;   *(short *)(rotation_tbl + 2) = 0;
    *(short *)(rotation_tbl + 4) = 0;   *(short *)(rotation_tbl + 6) = 0;
    *(short *)(rotation_tbl + 8) = 0;   *(short *)(rotation_tbl + 10) = 0;
    *(short *)(rotation_tbl + 0xc) = 0; *(short *)(rotation_tbl + 0xe) = 0;
    *(short *)(rotation_tbl + 0x10) = 0; *(short *)(rotation_tbl + 0x12) = 0;
    *(short *)(rotation_tbl + 0x14) = 0; *(short *)(rotation_tbl + 0x16) = 0;
    for (i = 0; i < 8; i++) {
        *(short *)(rotation_tbl + (i << 1) + 0x18) = 0; /* rot matrix entries */
    }
    for (j = 0; j < 0x10; j++) {
        *(short *)(rotation_tbl + ((unsigned int)j << 1) + 0x28) = 0; /* rot coeff tbl */
    }

    /* Coordinate table (0x060A3DF8): pos=0, scale=1.0 (0x10000 in 16.16) */
    coord_tbl = (char *)0x060A3DF8;
    *(int *)(coord_tbl + 0) = 0;                        /* NBG0 scroll X */
    *(int *)(coord_tbl + 4) = 0;                        /* NBG0 scroll Y */
    *(char **)(coord_tbl + 8) = 0x00010000;             /* NBG0 scale X (1.0) */
    *(char **)(coord_tbl + 0xc) = 0x00010000;           /* NBG0 scale Y (1.0) */
    *(int *)(coord_tbl + 0x10) = 0;                     /* NBG1 scroll X */
    *(int *)(coord_tbl + 0x14) = 0;                     /* NBG1 scroll Y */
    *(char **)(coord_tbl + 0x18) = 0x00010000;          /* NBG1 scale X (1.0) */
    *(char **)(coord_tbl + 0x1c) = 0x00010000;          /* NBG1 scale Y (1.0) */
    *(short *)(coord_tbl + 0x20) = 0;  *(short *)(coord_tbl + 0x22) = 0; /* NBG2 X/Y */
    *(short *)(coord_tbl + 0x24) = 0;  *(short *)(coord_tbl + 0x26) = 0; /* NBG3 X/Y */
    *(short *)(coord_tbl + 0x28) = 0;  *(short *)(coord_tbl + 0x2a) = 0; /* reserved */
    *(int *)(coord_tbl + 0x2c) = 0;    *(int *)(coord_tbl + 0x30) = 0;
    *(int *)(coord_tbl + 0x34) = 0;    *(int *)(coord_tbl + 0x38) = 0;
    *(int *)(coord_tbl + 0x3c) = 0;

    /* Color calculation shadow regs (0x060A3E38) */
    *(short *)0x060A3E38 = 0;  *(short *)0x060A3E3A = 0; /* CCRSA/CCRSB */
    *(short *)0x060A3E3C = 0;  *(short *)0x060A3E3E = 0; /* CLOFEN/CLOFSL */
    *(short *)0x060A3E40 = 0;  *(short *)0x060A3E42 = 0; /* COAR/COAG */
    *(int *)0x060A3E44 = 0;                              /* COAB + padding */

    /* Window coordinate table (0x060A3E48) */
    *(short *)0x060A3E48 = 0;  *(short *)0x060A3E4A = 0; /* W0 left X/Y */
    *(short *)0x060A3E4C = 0;  *(short *)0x060A3E4E = 0; /* W0 right X/Y */
    *(short *)0x060A3E50 = 0;  *(short *)0x060A3E52 = 0; /* W1 left X/Y */
    *(short *)0x060A3E54 = 0;  *(short *)0x060A3E56 = 0; /* W1 right X/Y */
    *(short *)0x060A3E58 = 0;  *(short *)0x060A3E5A = 0; /* window flags */
    *(short *)0x060A3E5C = 0;  *(short *)0x060A3E5E = 0; /* window flags 2 */
    *(int *)0x060A3E60 = 0;    *(int *)0x060A3E64 = 0;   /* window CC params */

    if (VDP1_BATCH_FLAG == 0) {
        VDP1_BATCH_FLAG = 1;
    }
}
#endif /* vdp2_subsystem_init */
/* REMOVED: conflicting alias */ // void FUN_06038300(void) __attribute__((alias("vdp2_subsystem_init")));

/* vdp1_batch_complete -- Mark VDP1 batch as complete and set render target.
 * Clears batch flag if it was pending (1), stores new render target address. */
void FUN_0603850c(int render_target)
{
    if (VDP1_BATCH_FLAG == 1) {
        VDP1_BATCH_FLAG = 0;
    }
    *(int *)0x060635A8 = render_target;
}

/* vdp1_batch_request -- Request VDP1 batch processing if not already queued */
void FUN_06038520(void)
{
    if (VDP1_BATCH_FLAG == 0) {
        VDP1_BATCH_FLAG = 1;
    }
}

/* vdp2_scroll_set -- Set VDP2 scroll position for the active render target.
 * Dispatches by render target selector (0x060635A8):
 *   1: scroll plane A — set position + optional line scroll trigger
 *   2: scroll plane B — set position + optional line scroll trigger
 *   4: rotation A X/Y
 *   8: rotation B X/Y
 *   0x10/0x20: coordinate table X/Y (16-bit, upper half of params) */
#if 0 /* FUN_0603853C -- replaced by ASM import */
void FUN_0603853c(int param_1, int param_2, int param_3)
{
    char *rot_tbl_b = (char *)0x060A3EE8;   /* rotation table B */
    char *rot_tbl_a = (char *)0x060A3E68;   /* rotation table A */
    char *coord_tbl = (char *)0x060A3DF8;   /* coordinate table */
    char *line_scroll = (char *)0x060A4C78;  /* line scroll flags */
    int target = *(int *)0x060635A8;

    if (target == 1) {
        *(int *)(rot_tbl_a + 0x44) = param_1;
        *(int *)(rot_tbl_a + 0x48) = param_2;
        if ((*(int *)0x060A4C44 == 0) ||
            ((*(int *)0x060A4C4C != 0 && (*(int *)0x060A4C70 != 0)))) {
            *(int *)line_scroll = 0;
        } else {
            *(int *)line_scroll = param_3;
        }
        if (*(int *)line_scroll != 0) {
            (*(int(*)())0x0603DDFC)(0, 0);
            return;
        }
    } else if (target == 2) {
        *(int *)(rot_tbl_b + 0x44) = param_1;
        *(int *)(rot_tbl_b + 0x48) = param_2;
        if ((*(int *)0x060A4C48 == 0) ||
            ((*(int *)0x060A4C50 != 0 && (*(int *)0x060A4C74 != 0)))) {
            *(int *)(line_scroll + 4) = 0;
        } else {
            *(int *)(line_scroll + 4) = param_3;
        }
        if (*(int *)(line_scroll + 4) != 0) {
            (*(int(*)())0x0603DDFC)(0, 0);
            return;
        }
    } else if (target == 4) {
        *(int *)coord_tbl = param_1;
        *(int *)(coord_tbl + 4) = param_2;
    } else if (target == 8) {
        *(int *)(coord_tbl + 0x10) = param_1;
        *(int *)(coord_tbl + 0x14) = param_2;
    } else {
        short val_x = (short)((unsigned int)param_1 >> 0x10);
        if (target == 0x10) {
            *(short *)(coord_tbl + 0x20) = val_x;
            target = 0x22;
        } else {
            if (target != 0x20) return;
            *(short *)(coord_tbl + 0x24) = val_x;
            target = 0x26;
        }
        *(short *)(coord_tbl + target) = (short)((unsigned int)param_2 >> 0x10);
    }
}
#endif

/* FUN_0603853C -- original binary (262 bytes) */
__asm__(
    ".section .text.FUN_0603853C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0603853C\n"
    ".global _FUN_0603853c\n"
    ".type _FUN_0603853C, @function\n"
    "_FUN_0603853C:\n"
    "_FUN_0603853c:\n"
    ".byte 0x2F, 0xE6, 0xDE, 0x28, 0xD7, 0x28, 0xD0, 0x29, 0xA0, 0x6F, 0x60, 0x02, 0x27, 0x42, 0xA0, 0x78\n"  /* 0x0603853C */
    ".byte 0x17, 0x51, 0x17, 0x44, 0xA0, 0x75, 0x17, 0x55, 0x44, 0x29, 0x64, 0x4F, 0x64, 0x4D, 0xE0, 0x20\n"  /* 0x0603854C */
    ".byte 0x07, 0x45, 0x45, 0x29, 0x65, 0x5F, 0x65, 0x5D, 0xA0, 0x09, 0xE0, 0x22, 0x44, 0x29, 0x64, 0x4F\n"  /* 0x0603855C */
    ".byte 0x64, 0x4D, 0xE0, 0x24, 0x07, 0x45, 0x45, 0x29, 0x65, 0x5F, 0x65, 0x5D, 0xE0, 0x26, 0xA0, 0x60\n"  /* 0x0603856C */
    ".byte 0x07, 0x55, 0xE0, 0x44, 0xD7, 0x1A, 0x07, 0x46, 0xE0, 0x48, 0x07, 0x56, 0xD3, 0x19, 0x60, 0x32\n"  /* 0x0603857C */
    ".byte 0x20, 0x08, 0x89, 0x09, 0xD3, 0x18, 0x60, 0x32, 0x20, 0x08, 0x89, 0x03, 0xD3, 0x17, 0x60, 0x32\n"  /* 0x0603858C */
    ".byte 0x20, 0x08, 0x8B, 0x01, 0xA0, 0x02, 0x2E, 0x62, 0xE2, 0x00, 0x2E, 0x22, 0x60, 0xE2, 0x20, 0x08\n"  /* 0x0603859C */
    ".byte 0x89, 0x47, 0xE6, 0x00, 0x65, 0x63, 0x64, 0x63, 0xD3, 0x11, 0x43, 0x2B, 0x6E, 0xF6, 0xE0, 0x44\n"  /* 0x060385AC */
    ".byte 0xD7, 0x10, 0x07, 0x46, 0xE0, 0x48, 0x07, 0x56, 0xD3, 0x0F, 0x60, 0x32, 0x20, 0x08, 0x89, 0x21\n"  /* 0x060385BC */
    ".byte 0xD3, 0x0E, 0x60, 0x32, 0x20, 0x08, 0x89, 0x03, 0xD3, 0x0D, 0x60, 0x32, 0x20, 0x08, 0x8B, 0x19\n"  /* 0x060385CC */
    ".byte 0xA0, 0x1A, 0x1E, 0x61, 0x06, 0x0A, 0x4C, 0x78, 0x06, 0x0A, 0x3D, 0xF8, 0x06, 0x06, 0x35, 0xA8\n"  /* 0x060385DC */
    ".byte 0x06, 0x0A, 0x3E, 0x68, 0x06, 0x0A, 0x4C, 0x44, 0x06, 0x0A, 0x4C, 0x4C, 0x06, 0x0A, 0x4C, 0x70\n"  /* 0x060385EC */
    ".byte 0x06, 0x03, 0xDD, 0xFC, 0x06, 0x0A, 0x3E, 0xE8, 0x06, 0x0A, 0x4C, 0x48, 0x06, 0x0A, 0x4C, 0x50\n"  /* 0x060385FC */
    ".byte 0x06, 0x0A, 0x4C, 0x74, 0xE2, 0x00, 0x1E, 0x21, 0x50, 0xE1, 0x20, 0x08, 0x89, 0x11, 0xE6, 0x00\n"  /* 0x0603860C */
    ".byte 0x65, 0x63, 0x64, 0x63, 0xD3, 0x21, 0x43, 0x2B, 0x6E, 0xF6, 0x88, 0x01, 0x89, 0xA9, 0x88, 0x02\n"  /* 0x0603861C */
    ".byte 0x89, 0xC5, 0x88, 0x04, 0x89, 0x8A, 0x88, 0x08, 0x89, 0x8B, 0x88, 0x10, 0x89, 0x8C, 0x88, 0x20\n"  /* 0x0603862C */
    ".byte 0x89, 0x94, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0603863C */
);


/* vdp2_scroll_accumulate -- Accumulate (add) VDP2 scroll offset for active render target.
 * Same dispatch structure as vdp2_scroll_set but adds to existing values.
 * Returns 0 on success, or result of line scroll handler if triggered. */
/* vdp2_scroll_offset -- Add scroll offset to active VDP2 render target.
 * Dispatches by render target (0x060635A8): rotation planes (1/2) update
 * rotation table A/B scroll at +0x44/+0x48 and optionally trigger line
 * scroll via 0x0603DDFC; bitmap planes (4/8) update coordinate table
 * at 0x060A3DF8; tile planes (0x10/0x20) update NBG2/NBG3 as 16.16→int. */
#if 0 /* vdp2_scroll_offset -- redirected to ASM import via linker PROVIDE */
int vdp2_scroll_offset(int dx, int dy, int line_delta)
{
    char *rot_tbl_b = (char *)0x060A3EE8;              /* rotation table B shadow */
    char *rot_tbl_a = (char *)0x060A3E68;              /* rotation table A shadow */
    char *coord_tbl = (char *)0x060A3DF8;              /* coordinate table shadow */
    char *line_scroll = (char *)0x060A4C78;            /* line scroll accumulator */
    int target = *(int *)0x060635A8;                   /* active render target */

    if (target == 1) {                                 /* rotation plane A */
        *(int *)(rot_tbl_a + 0x44) += dx;              /* rot A scroll X */
        *(int *)(rot_tbl_a + 0x48) += dy;              /* rot A scroll Y */
        if ((*(int *)0x060A4C44 == 0) ||
            ((*(int *)0x060A4C4C != 0 && (*(int *)0x060A4C70 != 0)))) {
            *(int *)line_scroll = 0;                   /* line scroll disabled */
        } else {
            *(int *)line_scroll += line_delta;          /* accumulate line scroll */
        }
        target = 0;
        if (*(int *)line_scroll != 0) {
            target = (*(int(*)())0x0603DDFC)(0, 0);    /* apply line scroll */
            return target;
        }
    } else if (target == 2) {                          /* rotation plane B */
        *(int *)(rot_tbl_b + 0x44) += dx;              /* rot B scroll X */
        *(int *)(rot_tbl_b + 0x48) += dy;              /* rot B scroll Y */
        if ((*(int *)0x060A4C48 == 0) ||
            ((*(int *)0x060A4C50 != 0 && (*(int *)0x060A4C74 != 0)))) {
            *(int *)(line_scroll + 4) = 0;
        } else {
            *(int *)(line_scroll + 4) += line_delta;
        }
        target = 0;
        if (*(int *)(line_scroll + 4) != 0) {
            target = (*(int(*)())0x0603DDFC)(0, 0);    /* apply line scroll */
            return target;
        }
    } else if (target == 4) {                          /* NBG0 bitmap */
        *(int *)coord_tbl += dx;                       /* NBG0 scroll X */
        *(int *)(coord_tbl + 4) += dy;                 /* NBG0 scroll Y */
    } else if (target == 8) {                          /* NBG1 bitmap */
        *(int *)(coord_tbl + 0x10) += dx;              /* NBG1 scroll X */
        *(int *)(coord_tbl + 0x14) += dy;              /* NBG1 scroll Y */
    } else {
        short sdx = (short)((unsigned int)dx >> 0x10); /* 16.16 → integer */
        short sdy = (short)((unsigned int)dy >> 0x10);
        if (target == 0x10) {                          /* NBG2 tile */
            *(short *)(coord_tbl + 0x20) += sdx;
            *(short *)(coord_tbl + 0x22) += sdy;
            target = 0x22;
        } else if (target == 0x20) {                   /* NBG3 tile */
            *(short *)(coord_tbl + 0x24) += sdx;
            *(short *)(coord_tbl + 0x26) += sdy;
            target = 0x26;
        }
    }
    return target;
}
#endif /* vdp2_scroll_offset */
/* REMOVED: conflicting alias */ // void FUN_0603853C(void) __attribute__((alias("vdp2_scroll_offset")));

/* vdp2_scale_set -- Set VDP2 zoom/scale for active render target.
 * For rotation targets (4/8), clamps scale to [DAT_0603881a..0x00FF0000],
 * defaulting to 0x10000 (1.0 in 16.16) if zero.
 * Divides 0x10000 by clamped values via 0x0603C0A0 (fixed-point divide).
 * Dispatches by render target (1/2/4/8) to appropriate VDP2 shadow regs.
 * Targets 1/2 may trigger line scroll handler if scale flag is set. */
#if 0 /* FUN_06038794 -- replaced by ASM import */
void FUN_06038794(char *param_1, char *param_2)
{
    char *scale_x = param_1;
    char *scale_y = param_2;
    char *min_scale = (char *)(int)DAT_0603881a;
    int target = *(int *)0x060635A8;

    if ((target != 1) && (target != 2)) {
        if ((target != 4) && (target != 8)) goto LAB_06038802;
        /* Clamp scale_x to [min_scale..0x00FF0000], default 0x10000 if zero */
        scale_x = (char *)0x00FF0000;
        if ((((int)param_1 <= (int)0x00FF0000) &&
             (scale_x = min_scale, (int)min_scale <= (int)param_1)) &&
            (scale_x = param_1, param_1 == (char *)0x0)) {
            scale_x = (char *)0x00010000;
        }
        scale_y = (char *)0x00FF0000;
        if ((((int)param_2 <= (int)0x00FF0000) &&
             (scale_y = min_scale, (int)min_scale <= (int)param_2)) &&
            (scale_y = param_2, param_2 == (char *)0x0)) {
            scale_y = (char *)0x00010000;
        }
    }
    param_1 = (char *)(*(int(*)())0x0603C0A0)(0x00010000, scale_x);  /* reciprocal X */
    param_2 = (char *)(*(int(*)())0x0603C0A0)(0x00010000, scale_y);  /* reciprocal Y */

LAB_06038802:
    ;
    short plane_b_off = PTR_DAT_060388b4;
    char *coord_tbl = (char *)0x060A3DF8;
    char *rot_tbl_a = (char *)0x060A3E68;
    char *color_calc = (char *)0x060A3E38;
    target = *(int *)0x060635A8;

    if (target == 1) {
        *(char **)(rot_tbl_a + 0x4c) = param_1;
        *(char **)(rot_tbl_a + 0x50) = param_2;
        if ((*(unsigned short *)(color_calc + 4) & 0xff) != 0) {
            (*(int(*)())0x0603DDFC)(0, 0);
            return;
        }
    } else if (target == 2) {
        *(char **)(rot_tbl_a + plane_b_off + 0x4c) = param_1;
        *(char **)(rot_tbl_a + plane_b_off + 0x50) = param_2;
        if (((unsigned int)*(unsigned short *)(color_calc + 4) & (unsigned int)0x0000FF00) != 0) {
            (*(int(*)())0x0603DDFC)(0, 0);
            return;
        }
    } else if (target == 4) {
        *(char **)(coord_tbl + 8) = param_1;
        *(char **)(coord_tbl + 0xc) = param_2;
    } else if (target == 8) {
        *(char **)(coord_tbl + 0x18) = param_1;
        *(char **)(coord_tbl + 0x1c) = param_2;
    }
}
#endif

/* FUN_06038794 -- original binary (300 bytes) */
__asm__(
    ".section .text.FUN_06038794, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06038794\n"
    ".type _FUN_06038794, @function\n"
    "_FUN_06038794:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x4F, 0x22, 0xD9, 0x1E\n"  /* 0x06038794 */
    ".byte 0xDA, 0x1E, 0x9B, 0x38, 0xDC, 0x1E, 0x6E, 0x43, 0x6D, 0x53, 0xD0, 0x1E, 0xA0, 0x1F, 0x60, 0x02\n"  /* 0x060387A4 */
    ".byte 0x3E, 0x97, 0x8B, 0x01, 0xA0, 0x07, 0x6E, 0x93, 0x3E, 0xB3, 0x89, 0x01, 0xA0, 0x03, 0x6E, 0xB3\n"  /* 0x060387B4 */
    ".byte 0x2E, 0xE8, 0x8B, 0x00, 0x6E, 0xC3, 0x3D, 0x97, 0x8B, 0x01, 0xA0, 0x07, 0x6D, 0x93, 0x3D, 0xB3\n"  /* 0x060387C4 */
    ".byte 0x89, 0x01, 0xA0, 0x03, 0x6D, 0xB3, 0x2D, 0xD8, 0x8B, 0x00, 0x6D, 0xC3, 0x65, 0xE3, 0x4A, 0x0B\n"  /* 0x060387D4 */
    ".byte 0x64, 0xC3, 0x6E, 0x03, 0x65, 0xD3, 0x4A, 0x0B, 0x64, 0xC3, 0xA0, 0x08, 0x6D, 0x03, 0x88, 0x01\n"  /* 0x060387E4 */
    ".byte 0x89, 0xF4, 0x88, 0x02, 0x89, 0xF2, 0x88, 0x04, 0x89, 0xDA, 0x88, 0x08, 0x89, 0xD8, 0xD6, 0x0A\n"  /* 0x060387F4 */
    ".byte 0xD5, 0x0A, 0xD4, 0x0B, 0xD0, 0x07, 0xA0, 0x43, 0x60, 0x02, 0x14, 0xE2, 0xA0, 0x48, 0x14, 0xD3\n"  /* 0x06038804 */
    ".byte 0x14, 0xE6, 0xA0, 0x45, 0x14, 0xD7, 0x40, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x06, 0x03, 0xC0, 0xA0\n"  /* 0x06038814 */
    ".byte 0x00, 0x01, 0x00, 0x00, 0x06, 0x06, 0x35, 0xA8, 0x06, 0x0A, 0x3E, 0x38, 0x06, 0x0A, 0x3E, 0x68\n"  /* 0x06038824 */
    ".byte 0x06, 0x0A, 0x3D, 0xF8, 0x64, 0x53, 0xE0, 0x4C, 0x04, 0xE6, 0xE0, 0x50, 0x04, 0xD6, 0x85, 0x62\n"  /* 0x06038834 */
    ".byte 0x60, 0x0D, 0xC8, 0xFF, 0x89, 0x2C, 0xE6, 0x00, 0x65, 0x63, 0x64, 0x63, 0x4F, 0x26, 0x69, 0xF6\n"  /* 0x06038844 */
    ".byte 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xD3, 0x16, 0x43, 0x2B, 0x6E, 0xF6, 0xE0, 0x4C\n"  /* 0x06038854 */
    ".byte 0x94, 0x26, 0x34, 0x5C, 0x04, 0xE6, 0xE0, 0x50, 0x04, 0xD6, 0x85, 0x62, 0xD2, 0x12, 0x63, 0x03\n"  /* 0x06038864 */
    ".byte 0x63, 0x3D, 0x23, 0x29, 0x23, 0x38, 0x89, 0x13, 0xE6, 0x00, 0x65, 0x63, 0x64, 0x63, 0x4F, 0x26\n"  /* 0x06038874 */
    ".byte 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xD3, 0x0A, 0x43, 0x2B, 0x6E, 0xF6\n"  /* 0x06038884 */
    ".byte 0x88, 0x01, 0x89, 0xCF, 0x88, 0x02, 0x89, 0xE2, 0x88, 0x04, 0x89, 0xB6, 0x88, 0x08, 0x89, 0xB7\n"  /* 0x06038894 */
    ".byte 0x4F, 0x26, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x060388A4 */
    ".byte 0x00, 0x80, 0xFF, 0xFF, 0x06, 0x03, 0xDD, 0xFC, 0x00, 0x00, 0xFF, 0x00\n"  /* 0x060388B4 */
);


/* dma_transfer_batch -- Execute batch of word copies to VDP2 hardware.
 * Conditionally copies display-list segments if flags are set,
 * then copies render state, scroll, coordinate, color, and attribute
 * tables from work RAM (0x060A3xxx) to VDP2 base at *(0x060A3D84). */
#if 0 /* FUN_060388C0 -- replaced by ASM import */
void FUN_060388c0(void)
{
    if ((*(short *)0x060A4C40 != 0) && (*(int *)0x060A4C44 != 0)) {
        FUN_06038a48(*(int *)0x060A4C44, 0x060A3F68, *(int *)0x060A4C38 << 1);
        *(short *)0x060A4C40 = 0;
    }
    if ((*(short *)0x060A4C42 != 0) && (*(int *)0x060A4C48 != 0)) {
        FUN_06038a48(*(int *)0x060A4C48, 0x060A45D0, *(int *)0x060A4C3C << 1);
        *(short *)0x060A4C42 = 0;
    }
    if (*(int *)0x060635B2 == 1) {
        FUN_06038a48(*(int *)0x060A4C5C, 0x060A3E68, 0x80);
    } else if (*(int *)0x060635B2 == 2) {
        FUN_06038a48(*(int *)0x060A4C5C, 0x060A3E68, 0x100);
    }
    FUN_06038a48(*(int *)0x060A3D84, 0x060A3D88, 0x28);
    FUN_06038a48(*(int *)0x060A3D84 + 0x28, 0x060A3DB0, 0x48);
    FUN_06038a48(*(int *)0x060A3D84 + 0x70, 0x060A3DF8, 0x40);
    FUN_06038a48(*(int *)0x060A3D84 + (int)0x00B000C0, 0x060A3E38, 0x10);
    FUN_06038a48(*(int *)0x060A3D84 + 0xc0, 0x060A3E48, 0x20);
}
#endif

/* vdp1_batch_dispatch -- Dispatch VDP1 batch transfer based on batch flag.
 * flag=1: run DMA transfers directly.
 * flag=2: copy object/sprite tables first, then run DMA.
 * Clears dispatch flag 0x060635AC after transfer, then runs peripheral DMA. */
#if 0 /* FUN_060389A6 -- replaced by ASM import */
void FUN_060389a6(void)
{
    if (VDP1_BATCH_FLAG == 1) {
        FUN_060388c0();
    } else {
        if (VDP1_BATCH_FLAG != 2) goto LAB_06038a42;
        FUN_06038a48(*(int *)0x060A3D70, *(int *)0x060A3D74,
                     (unsigned int)*(unsigned short *)0x060635A0 * 0xc);
        FUN_06038a48(*(int *)0x060A3D78, *(int *)0x060A3D7C,
                     (unsigned int)*(unsigned short *)0x060635A2 << 2);
        FUN_060388c0();
    }
    *(short *)0x060635AC = 0;
LAB_06038a42:
    FUN_06038ac8();
}
#endif

/* word_copy -- Copy byte_count/2 words from src to dst.
 * 16-bit (short) granularity memcpy used for DMA-style block transfers. */
void FUN_06038a48(short *dst, short *src, unsigned int byte_count)
{
    unsigned int i = 0;
    if (byte_count >> 1 != 0) {
        do {
            i = i + 1;
            *dst = *src;
            dst = dst + 1;
            src = src + 1;
        } while (i < byte_count >> 1);
    }
}

/* fbcr_mode_set -- Set FBCR display mode from selector.
 * mode 0: keep existing bits masked by DAT_06038a9a.
 * mode 1: set interlace bits 0x10002000.
 * mode 2: set alternative mode bits (DAT_06038a9e).
 * Triggers VDP1_BATCH_FLAG for next frame update. */
unsigned int FUN_06038a64(unsigned int mode)
{
    unsigned short uVar1;
    if (mode == 0) {
        uVar1 = *(unsigned short *)(0x060A3D88 + 0xe) & DAT_06038a9a;
    } else if (mode == 1) {
        uVar1 = *(unsigned short *)(0x060A3D88 + 0xe) & DAT_06038a9a | 0x10002000;
    } else {
        if (mode != 2) goto LAB_06038ab0;
        uVar1 = *(unsigned short *)(0x060A3D88 + 0xe) & DAT_06038a9a | DAT_06038a9e;
    }
    mode = (unsigned int)uVar1;
    *(unsigned short *)(0x060A3D88 + 0xe) = uVar1;
LAB_06038ab0:
    if (VDP1_BATCH_FLAG == 0) {
        VDP1_BATCH_FLAG = 1;
    }
    return mode;
}

/* peripheral_dma_dispatch -- Transfer peripheral data blocks based on flag bits.
 * Reads control byte at 0x060A4D58 and dispatches up to 6 DMA copies
 * for SCSP/peripheral registers. Each bit (0x80..0x04) triggers a
 * word_copy from work RAM to hardware, followed by a sync call. */
#if 0 /* FUN_06038AC8 -- replaced by ASM import */
void FUN_06038ac8(void)
{
    char *flags = (char *)0x060A4D58;
    (*(int(*)())0x0603C728)();
    if (((int)(char)*flags & 0x80U) != 0) {
        FUN_06038a48(*(int *)0x0606360C, 0x060A4D18, 0x10);
        (*(int(*)())0x06034F78)();
    }
    if ((*flags & 0x40) != 0) {
        FUN_06038a48(*(int *)0x06063610, 0x060A4D28, 8);
        (*(int(*)())0x06034F78)();
    }
    if ((*flags & 0x20) != 0) {
        FUN_06038a48(*(int *)0x06063614, 0x060A4D30, 6);
        (*(int(*)())0x06034F78)();
    }
    if ((*flags & 0x10) != 0) {
        FUN_06038a48(*(int *)0x06063618, 0x060A4D36, 8);
        (*(int(*)())0x06034F78)();
    }
    if ((*flags & 8) != 0) {
        FUN_06038a48(*(int *)0x0606361C, 0x060A4D3E, 8);
        (*(int(*)())0x06034F78)();
    }
    if ((*flags & 4) != 0) {
        FUN_06038a48(*(int *)0x06063620, 0x060A4D46, 0x10);
        (*(int(*)())0x06034F78)();
    }
}
#endif

/* FUN_06038AC8 -- original binary (268 bytes) */
__asm__(
    ".section .text.FUN_06038AC8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06038AC8\n"
    ".global _FUN_06038ac8\n"
    ".type _FUN_06038AC8, @function\n"
    "_FUN_06038AC8:\n"
    "_FUN_06038ac8:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x4F, 0x22, 0xDE, 0x2B, 0xD3, 0x2B, 0x43, 0x0B, 0xED, 0x00, 0x60, 0xE3\n"  /* 0x06038AC8 */
    ".byte 0x60, 0x00, 0xC8, 0x80, 0x89, 0x09, 0xE6, 0x10, 0xD5, 0x28, 0xD4, 0x29, 0xBF, 0xB0, 0x64, 0x42\n"  /* 0x06038AD8 */
    ".byte 0x60, 0xD3, 0x62, 0xE3, 0xD3, 0x27, 0x43, 0x0B, 0xE1, 0x01, 0x60, 0xE3, 0x60, 0x00, 0xC8, 0x40\n"  /* 0x06038AE8 */
    ".byte 0x89, 0x09, 0xE6, 0x08, 0xD5, 0x24, 0xD4, 0x25, 0xBF, 0xA2, 0x64, 0x42, 0x60, 0xD3, 0x91, 0x35\n"  /* 0x06038AF8 */
    ".byte 0xD3, 0x20, 0x43, 0x0B, 0x62, 0xE3, 0x60, 0xE3, 0x60, 0x00, 0xC8, 0x20, 0x89, 0x09, 0xE6, 0x06\n"  /* 0x06038B08 */
    ".byte 0xD5, 0x1F, 0xD4, 0x20, 0xBF, 0x94, 0x64, 0x42, 0x60, 0xD3, 0x91, 0x28, 0xD3, 0x19, 0x43, 0x0B\n"  /* 0x06038B18 */
    ".byte 0x62, 0xE3, 0x60, 0xE3, 0x60, 0x00, 0xC8, 0x10, 0x89, 0x09, 0xE6, 0x08, 0xD5, 0x1A, 0xD4, 0x1B\n"  /* 0x06038B28 */
    ".byte 0xBF, 0x86, 0x64, 0x42, 0x60, 0xD3, 0x91, 0x1B, 0xD3, 0x12, 0x43, 0x0B, 0x62, 0xE3, 0x60, 0xE3\n"  /* 0x06038B38 */
    ".byte 0x60, 0x00, 0xC8, 0x08, 0x89, 0x09, 0xE6, 0x08, 0xD5, 0x15, 0xD4, 0x16, 0xBF, 0x78, 0x64, 0x42\n"  /* 0x06038B48 */
    ".byte 0x60, 0xD3, 0x91, 0x0E, 0xD3, 0x0B, 0x43, 0x0B, 0x62, 0xE3, 0x60, 0xE3, 0x60, 0x00, 0xC8, 0x04\n"  /* 0x06038B58 */
    ".byte 0x89, 0x2D, 0xE6, 0x10, 0xD5, 0x10, 0xD4, 0x11, 0xA0, 0x22, 0x64, 0x42, 0x01, 0x01, 0x02, 0x01\n"  /* 0x06038B68 */
    ".byte 0x03, 0x01, 0x04, 0x01, 0x06, 0x0A, 0x4D, 0x58, 0x06, 0x03, 0xC7, 0x28, 0x06, 0x0A, 0x4D, 0x18\n"  /* 0x06038B78 */
    ".byte 0x06, 0x06, 0x36, 0x0C, 0x06, 0x03, 0x4F, 0x78, 0x06, 0x0A, 0x4D, 0x28, 0x06, 0x06, 0x36, 0x10\n"  /* 0x06038B88 */
    ".byte 0x06, 0x0A, 0x4D, 0x30, 0x06, 0x06, 0x36, 0x14, 0x06, 0x0A, 0x4D, 0x36, 0x06, 0x06, 0x36, 0x18\n"  /* 0x06038B98 */
    ".byte 0x06, 0x0A, 0x4D, 0x3E, 0x06, 0x06, 0x36, 0x1C, 0x06, 0x0A, 0x4D, 0x46, 0x06, 0x06, 0x36, 0x20\n"  /* 0x06038BA8 */
    ".byte 0xBF, 0x46, 0x00, 0x09, 0x60, 0xD3, 0x91, 0x06, 0xD3, 0x03, 0x43, 0x0B, 0x62, 0xE3, 0x4F, 0x26\n"  /* 0x06038BB8 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x05, 0x01, 0x06, 0x03, 0x4F, 0x78\n"  /* 0x06038BC8 */
);


/* vdp2_priority_set -- Set VDP2 layer priority and color calculation registers.
 * param_1 is a bitmask selecting which register fields to update.
 * param_2 (low byte) is the value to write. Each bit dispatches to a
 * different VDP2 shadow register nibble at 0x060A4D28 (PRISA-PRISD)
 * or 0x060A4D30 (CCRSA/CCRSB/CCRSC):
 *   Bits 8-15: priority registers A-D (low/high nibble per pair)
 *   Bits 1-5,7,0x80: color calculation registers
 *   Bit 0: direct write to CCRS offset +4
 * Calls sync (0x06034F78) before each register update. */
#if 0 /* vdp2_priority_set -- redirected to ASM import via linker PROVIDE */
void vdp2_priority_set(param_1, param_2)
    unsigned int param_1;
    unsigned int param_2;
{
    unsigned short lo_mask = (unsigned short)0x0000FFF0;
    unsigned short hi_mask = (unsigned short)0x0000F0FF;
    unsigned short cc_lo_mask = (unsigned short)0x0000FF00;
    unsigned short cc_hi_mask = DAT_06038cc8;
    unsigned short *pris_base = (unsigned short *)0x060A4D28;  /* VDP2 PRISA shadow */
    char *ccrs_base = (char *)0x060A4D30;                     /* VDP2 CCRSA shadow */
    short val;

    param_2 = param_2 & 0xff;

    /* Priority register A low nibble (NBG0) */
    if ((0x100 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        *pris_base = *pris_base & lo_mask | (unsigned short)param_2;
    }
    /* Priority register A high nibble (NBG1) */
    if ((0x200 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        *pris_base = *pris_base & hi_mask | (unsigned short)((param_2 & 0xffff) << 8);
    }
    /* Priority register B low (NBG2) */
    if ((0x400 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        pris_base[1] = pris_base[1] & lo_mask | (unsigned short)param_2;
    }
    /* Priority register B high (NBG3) */
    if ((0x800 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        pris_base[1] = pris_base[1] & hi_mask | (unsigned short)((param_2 & 0xff) << 8);
    }
    /* Priority register C low (RBG0) */
    if (((int)DAT_06038cd4 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        pris_base[2] = pris_base[2] & lo_mask | (unsigned short)param_2;
    }
    /* Priority register C high */
    if (((int)DAT_06038cd6 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        pris_base[2] = pris_base[2] & hi_mask | (unsigned short)((param_2 & 0xff) << 8);
    }
    /* Priority register D low */
    if (((int)DAT_06038e1a & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        pris_base[3] = pris_base[3] & lo_mask | (unsigned short)param_2;
    }
    /* Priority register D high */
    if (((unsigned int)0x00008000 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        pris_base[3] = pris_base[3] & hi_mask | (unsigned short)((param_2 & 0xff) << 8);
    }
    /* Color calculation A low (bit 2: NBG0, bit 4: NBG2) */
    if ((param_1 & 4) != 0) {
        (*(int(*)())0x06034F78)();
        *(unsigned short *)ccrs_base = *(unsigned short *)ccrs_base & cc_lo_mask | (unsigned short)param_2;
    }
    /* Color calculation A low (bit 1: sprite) */
    if ((param_1 & 2) != 0) {
        (*(int(*)())0x06034F78)();
        *(unsigned short *)ccrs_base = *(unsigned short *)ccrs_base & cc_lo_mask | (unsigned short)param_2;
    }
    /* Color calculation A high (bit 3: NBG1) */
    if ((param_1 & 8) != 0) {
        (*(int(*)())0x06034F78)();
        *(unsigned short *)ccrs_base = *(unsigned short *)ccrs_base & cc_hi_mask | (unsigned short)((param_2 & 0xffff) << 8);
    }
    /* Color calculation A high (bit 7: RBG0) */
    if ((0x80 & param_1) != 0) {
        (*(int(*)())0x06034F78)();
        *(unsigned short *)ccrs_base = *(unsigned short *)ccrs_base & cc_hi_mask | (unsigned short)((param_2 & 0xffff) << 8);
    }
    /* Color calculation B low (bit 4: NBG3) */
    if ((param_1 & 0x10) != 0) {
        (*(int(*)())0x06034F78)();
        *(unsigned short *)(ccrs_base + 2) = *(unsigned short *)(ccrs_base + 2) & cc_lo_mask | (unsigned short)param_2;
    }
    /* Color calculation B high (bit 5) */
    val = (short)param_2;
    if ((param_1 & 0x20) != 0) {
        (*(int(*)())0x06034F78)();
        val = (short)param_2;
        *(unsigned short *)(ccrs_base + 2) = *(unsigned short *)(ccrs_base + 2) & cc_hi_mask | (unsigned short)((param_2 & 0xff) << 8);
    }
    /* Direct color calc write (bit 0) */
    if ((param_1 & 1) != 0) {
        (*(int(*)())0x06034F78)();
        *(short *)(ccrs_base + 4) = val;
    }
}
#endif /* vdp2_priority_set */

/* fb_state_control -- Set framebuffer state and VDP1 FBCR from mode param.
 * 0xFFFF: freeze mode (FB_STATE=2), force manual erase.
 * 0xFFFE: alt freeze mode (FB_STATE=3), force manual erase.
 * Other: extract swap/interlace bits from param to set VDP1 display mode.
 * Writes VDP1 FBCR register at 0x25D00002. */
#if 0 /* FUN_06038E54 -- replaced by ASM import */
void FUN_06038e54(unsigned short param_1)
{
    unsigned int uVar6;
    if ((unsigned int)param_1 == 0xFFFF) {
        FB_STATE = 2;
        *(int *)0x060635B8 = 0;
        *(unsigned short *)0x25D00002 = *(unsigned short *)0x060A4C92 | 3;
        *(unsigned int *)0x060635BC = (unsigned int)param_1;
    } else if ((unsigned int)param_1 == 0xFFFE) {
        FB_STATE = 3;
        *(int *)0x060635B8 = 0;
        *(unsigned short *)0x25D00002 = *(unsigned short *)0x060A4C92 | 3;
        *(unsigned int *)0x060635BC = (unsigned int)param_1;
    } else {
        if ((param_1 & DAT_06038efa) == 0) {
            *(int *)0x060635B8 = 1;
        } else {
            *(int *)0x060635B8 = 0;
        }
        uVar6 = (unsigned int)(param_1 & DAT_06038efc);
        if (uVar6 == 0) {
            *(short *)0x060635B4 = 0;
        } else {
            *(unsigned short *)0x060635B4 = (unsigned short)(uVar6 != 1);
        }
        *(unsigned int *)0x060635BC = uVar6;
        if (*(short *)0x060635B4 == 0) {
            *(short *)0x25D00002 = *(short *)0x060A4C92;
        } else {
            *(unsigned short *)0x25D00002 = *(unsigned short *)0x060A4C92 | 3;
        }
    }
}
#endif

/* FUN_06038E54 -- original binary (280 bytes) */
__asm__(
    ".section .text.FUN_06038E54, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06038E54\n"
    ".global _FUN_06038e54\n"
    ".type _FUN_06038E54, @function\n"
    "_FUN_06038E54:\n"
    "_FUN_06038e54:\n"
    ".byte 0x2F, 0xE6, 0x63, 0x4D, 0x2F, 0xD6, 0xED, 0x03, 0x2F, 0xB6, 0xDB, 0x28, 0xDE, 0x28, 0xD7, 0x29\n"  /* 0x06038E54 */
    ".byte 0xD5, 0x29, 0xD1, 0x2A, 0xD2, 0x2A, 0x33, 0x20, 0x8F, 0x0B, 0xE6, 0x00, 0xE2, 0x02, 0x25, 0x21\n"  /* 0x06038E64 */
    ".byte 0x21, 0x62, 0x63, 0xE1, 0x63, 0x3D, 0x23, 0xDB, 0x63, 0x3D, 0x27, 0x31, 0x64, 0x4D, 0xA0, 0x36\n"  /* 0x06038E74 */
    ".byte 0x2B, 0x42, 0x62, 0x4D, 0xD3, 0x23, 0x32, 0x30, 0x8B, 0x0A, 0x63, 0xDD, 0x25, 0x31, 0x21, 0x62\n"  /* 0x06038E84 */
    ".byte 0x62, 0xE1, 0x62, 0x2D, 0x22, 0xDB, 0x62, 0x2D, 0x27, 0x21, 0x64, 0x4D, 0xA0, 0x27, 0x2B, 0x42\n"  /* 0x06038E94 */
    ".byte 0x62, 0x4D, 0x93, 0x28, 0x22, 0x39, 0x22, 0x28, 0x89, 0x01, 0xA0, 0x02, 0x21, 0x62, 0xE2, 0x01\n"  /* 0x06038EA4 */
    ".byte 0x21, 0x22, 0x93, 0x21, 0x24, 0x39, 0x64, 0x4D, 0x24, 0x48, 0x89, 0x07, 0x60, 0x4D, 0x88, 0x01\n"  /* 0x06038EB4 */
    ".byte 0x8B, 0x01, 0xA0, 0x01, 0x62, 0x6D, 0xE2, 0x01, 0xA0, 0x02, 0x25, 0x21, 0x62, 0x6D, 0x25, 0x21\n"  /* 0x06038EC4 */
    ".byte 0x64, 0x4D, 0x2B, 0x42, 0x63, 0x51, 0x63, 0x3D, 0x23, 0x38, 0x8B, 0x03, 0x63, 0xE1, 0x27, 0x31\n"  /* 0x06038ED4 */
    ".byte 0xA0, 0x05, 0x00, 0x09, 0x62, 0xE1, 0x62, 0x2D, 0x22, 0xDB, 0x62, 0x2D, 0x27, 0x21, 0x6B, 0xF6\n"  /* 0x06038EE4 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x40, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x06, 0x35, 0xBC\n"  /* 0x06038EF4 */
    ".byte 0x06, 0x0A, 0x4C, 0x92, 0x25, 0xD0, 0x00, 0x02, 0x06, 0x06, 0x35, 0xB4, 0x06, 0x06, 0x35, 0xB8\n"  /* 0x06038F04 */
    ".byte 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFE, 0xD4, 0x0D, 0xD0, 0x0E, 0x60, 0x02, 0x20, 0x08\n"  /* 0x06038F14 */
    ".byte 0x89, 0x04, 0xE3, 0x01, 0x24, 0x32, 0x60, 0x42, 0x20, 0x08, 0x8B, 0xFC, 0x00, 0x0B, 0x00, 0x09\n"  /* 0x06038F24 */
    ".byte 0xE4, 0x00, 0xE1, 0x01, 0xD2, 0x08, 0x22, 0x41, 0xD2, 0x08, 0x22, 0x12, 0xD2, 0x05, 0x22, 0x42\n"  /* 0x06038F34 */
    ".byte 0xD2, 0x07, 0x22, 0x42, 0xD2, 0x02, 0x22, 0x42, 0xD2, 0x06, 0x00, 0x0B, 0x22, 0x42, 0xFF, 0xFF\n"  /* 0x06038F44 */
    ".byte 0x06, 0x06, 0x35, 0xC4, 0x06, 0x06, 0x35, 0xBC, 0x06, 0x06, 0x35, 0xB4, 0x06, 0x06, 0x35, 0xB8\n"  /* 0x06038F54 */
    ".byte 0x06, 0x06, 0x35, 0xC0, 0x06, 0x06, 0x35, 0xC8\n"  /* 0x06038F64 */
);


/* framebuffer_state_reset -- Reset all framebuffer/frame timing state.
 * Clears FB_STATE, enables FBCR swap mode, resets all frame counters. */
void FUN_06038f34(void)
{
    FB_STATE = 0;
    FBCR_SWAP_MODE = 1;
    FBCR_SWAP_THRESHOLD = 0;
    FRAME_SEC_COUNTER = 0;
    FRAME_READY_FLAG = 0;
    *(int *)0x060635C8 = 0;
}

/* vdp2_window_config -- Configure VDP2 display window coordinates and color calc.
 * param_1: window index (0 = window A, 1 = window B; others return early).
 * Sets window left/right/top/bottom coords, doubling X if resolution <= 352.
 * Applies color calculation parameters via function at 0x0603EDC4.
 * Sets color calc mode (shadow=3 if bit 16 of param_3 set).
 * Triggers VDP1_BATCH_FLAG for next frame update. */
unsigned int FUN_06039100(unsigned int param_1, int param_2, unsigned int param_3,
                          int param_4, short param_5, short param_6, short param_7, short param_8)
{
    unsigned int result;
    short *win_right;
    short *win_left;
    int base_idx;
    int step;
    int next_idx;
    char *win_tbl = (char *)0x060A3E48;  /* window coordinate table */
    char cc_mode;

    param_1 = param_1 & 0xff;
    if (param_1 == 0) {
        *(int *)(win_tbl + 0x18) = 0;
        win_right = (short *)(win_tbl + 4);
        cc_mode = 2;
        base_idx = (int)DAT_0603918c;
        step = 1;
        next_idx = base_idx + 1;
        win_left = (short *)win_tbl;
    } else {
        if (param_1 != 1) return param_1;
        *(int *)(win_tbl + 0x1c) = 0;
        win_right = (short *)(win_tbl + 0xc);
        cc_mode = 8;
        base_idx = (int)DAT_0603918e;
        step = 4;
        next_idx = base_idx + 4;
        win_left = (short *)(win_tbl + 8);
    }

    win_tbl = win_tbl + 0x10;  /* advance to color calc sub-table */

    if (0x160 < (int)(unsigned int)*(unsigned short *)0x060635AE) {
        *win_left = param_5;      /* high-res: use coords directly */
        *win_right = param_7;
    } else {
        *win_left = param_5 << 1; /* low-res: double X coords */
        *win_right = param_7 << 1;
    }
    win_left[1] = param_6;       /* top Y */
    win_right[1] = param_8;      /* bottom Y */

    if (param_2 != 0 || param_3 != 0) {
        (*(int(*)())0x0603EDC4)(param_2, param_3, win_tbl, 0x80, 0x7f);
    }
    if (param_4 != 0 || param_3 != 0) {
        (*(int(*)())0x0603EDC4)(param_4, param_3, win_tbl, step, next_idx);
    }
    result = (*(int(*)())0x0603EDC4)(param_3, 0xffffffff, win_tbl, cc_mode, base_idx);

    if ((param_3 & (unsigned int)0x00010000) == 0) {
        *(short *)0x060A3E38 = *(short *)0x060A4C80;
    } else {
        *(short *)0x060A3E38 = 3;  /* shadow color calc mode */
    }
    if (VDP1_BATCH_FLAG == 0) {
        VDP1_BATCH_FLAG = 1;
    }
    return result;
}

/* vdp1_init -- Initialize VDP1 command table and display registers.
 * Sets FBCR to single-buffer, TV mode 0, default erase window,
 * then writes initial command at VDP1 VRAM base (0x25C00000).
 * param_1 receives the VDP1 VRAM base pointer. */
unsigned int FUN_06039250(int *param_1)
{
    unsigned int in_sr = 0;
    unsigned int uVar3 = in_sr & -241 & 0xfff0fff | 0xf0;
    FUN_060394f0(0);
    FUN_0603931c(0, 0, 0);
    VDP1_FBCR = FBCR_SHADOW;
    VDP1_PTMR = 2;
    VDP1_EWDR = (short)0x00008000;
    VDP1_EWLR = 0;
    VDP1_EWRR = (short)0x0000FFFF;
    FUN_060393fc(0x00008000, 0, 0, *(int *)0x060A4C88 - 1U & 0xffff,
                 *(int *)0x060A4C8C - 1U & 0xffff);
    *param_1 = (int)0x25C00000;
    *(char *)0x25C00000 = (char)PTR_DAT_060392e8;
    *(char *)(*param_1 + 1) = 0;
    *(int *)0x060635CC = 1;
    return (in_sr >> 4 & 0xf) << 4 | uVar3 & (unsigned int)DAT_060392e6;
}

/* tv_mode_select -- Configure VDP1 TV mode, resolution, and palette bank.
 * Sets TVMR register (bits 0-2), looks up resolution from mode table,
 * selects 16-color (bank=1) or 256-color (bank=0) palette mode.
 * param_3=1 doubles vertical resolution (interlace). */
unsigned short FUN_0603931c(unsigned short param_1, unsigned short param_2, short param_3)
{
    short *psVar2;
    TVMR_SHADOW = param_1 & 7;
    VDP1_TVMR = param_1 & 7;
    if (7 < param_2) {
        param_2 = 0;
    }
    psVar2 = (short *)(0x060635E0 + (unsigned int)(param_2 << 2));
    *(int *)0x060A4C88 = (int)*psVar2;
    *(int *)0x060A4C8C = (int)psVar2[1];
    if (param_3 == 1) {
        *(int *)0x060A4C8C = *(int *)0x060A4C8C << 1;
    }
    if ((param_1 == 1) || (param_1 == 3)) {
        PALETTE_BANK_SEL = 1;
    } else {
        PALETTE_BANK_SEL = 0;
    }
    if (param_3 == 0) {
        *(short *)0x060A4C94 = 0;
    } else {
        *(short *)0x060A4C94 = 8;
    }
    *(short *)0x060A4C96 = 0;
    return param_1;
}

/* erase_window_config -- Set VDP1 erase window (EWDR/EWLR/EWRR).
 * Stores shadow copies of all params, then computes EWLR/EWRR
 * from X coords (shifted by palette bank: >>3 or >>4) and Y coords
 * (halved if interlace mode is active at 0x060A4C94). */
void FUN_060393fc(short erase_data, unsigned short x_left, unsigned short y_top,
                  short x_right, unsigned short y_bottom)
{
    unsigned short uVar1;
    *(short *)0x060635D4 = erase_data;
    *(unsigned short *)0x060635D6 = x_left;
    *(unsigned short *)0x060635D8 = y_top;
    *(short *)0x060635DA = x_right;
    *(unsigned short *)0x060635DC = y_bottom;
    VDP1_EWDR = erase_data;
    if (PALETTE_BANK_SEL == 0) {
        x_left = x_left >> 3;
    } else {
        x_left = x_left >> 4;
    }
    if (*(short *)0x060A4C94 != 0) {
        y_top = y_top >> 1;
    }
    *(unsigned short *)0x060635D0 = (x_left << 9) + y_top;
    VDP1_EWLR = *(short *)0x060635D0;
    if (PALETTE_BANK_SEL == 0) {
        uVar1 = (unsigned short)(x_right + 1U) >> 3;
    } else {
        uVar1 = (unsigned short)(x_right + 1U) >> 4;
    }
    if (*(short *)0x060A4C94 != 0) {
        y_bottom = y_bottom >> 1;
    }
    *(unsigned short *)0x060635D2 = (uVar1 << 9) + y_bottom;
    VDP1_EWRR = *(short *)0x060635D2;
}

/* fbcr_mode_select -- Set VDP1 frame buffer control shadow.
 * param_1=0: single buffer mode (FBCR=0).
 * param_1!=0: manual erase mode (FBCR=0x10). */
void FUN_060394f0(int param_1)
{
    FBCR_SHADOW = (param_1 == 0) ? 0 : 0x10;
}

/* display_mode_init -- Initialize VDP display mode and timing configuration.
 * Clears VDP status registers (0x20100079..7F), installs VBlank handler
 * (0x0603990E via BIOS 0x47), sets interrupt mask. Configures display mode
 * at 0x060A4CAA (0=off, 1=non-interlace, 2=interlace), frame timing params,
 * and computes stride offsets for the 5-slot display config ring buffer
 * based on resolution mode (0x060A4CAF). Performs initial field swap. */
#if 0 /* display_mode_init -- redirected to ASM import via linker PROVIDE */
void display_mode_init(char mode, short line_count, char res_mode, char scan_lines,
                       int base_addr, int frame_threshold)
{
  char mode_val;
  unsigned short res;
  int stride;
  char *display_flags = (char *)0x06063602;             /* display mode flags */
  char *scan_cfg = (char *)0x060A4CAE;                  /* scan line config */

  /* Clear VDP status registers */
  *(int *)0x20100079 = 0;
  *(int *)0x2010007B = 0;                               /* +2 */
  *(int *)0x2010007F = 0;                               /* +6 */
  *(int *)0x2010007D = 0;                               /* +4 */

  /* Install VBlank interrupt handler */
  (*(int(*)())(BIOS_FUNC_0300))(0x47, 0x0603990E);
  (*(int(*)())(BIOS_FUNC_0344))(-129, 0);              /* set interrupt mask */

  *(int *)0x060A4CAA = mode;                            /* display mode */
  mode_val = *(char *)0x060A4CAA;

  if (mode_val == '\0') {                               /* mode 0: display off */
    *display_flags = 1;
    display_flags[1] = 0;
    *(int *)0x060A4CA8 = 0;
    (*(int(*)())0x0603A72C)();                          /* query display state */
    return;
  }

  if (mode_val == '\x01') {                             /* mode 1: non-interlace */
    *display_flags = 0;
    display_flags[1] = 8;
  }
  else if (mode_val == '\x02') {                        /* mode 2: interlace */
    *display_flags = 1;
    display_flags[1] = 8;
    *(int *)0x060A4CD8 = 0;                             /* interlace field counter */
  }

  /* Store timing parameters */
  *scan_cfg = scan_lines;
  *(short *)0x060A4CAC = line_count;                    /* lines per frame */
  *(int *)0x060A4CAB = frame_threshold;                 /* frame count threshold */
  *(int *)0x060A4CAF = res_mode;                        /* resolution mode */
  *(int *)0x060A4CB0 = base_addr;                       /* display buffer base */
  *(int *)0x060A4CB8 = 0;                               /* frame counter: reset */

  if (0xf < (unsigned char)*scan_cfg) {
    display_flags[1] = display_flags[1] | 0x50;        /* hi-res scan flag */
  }

  /* Initialize display config ring buffer pointers */
  *(char **)0x060A4CE8 = 0x060A4CD9;                   /* slot[4] = config base */
  *(char **)0x060A4C98 = (char *)0x060A4CD9 + 7;       /* slot[0] = base + 7 */
  *(int *)0x060A4CBC = *(int *)0x060A4CB0;              /* slot[2] = base_addr */

  /* Compute stride offsets based on resolution mode */
  res = (unsigned short)(unsigned char)*(int *)0x060A4CAF;
  if (res == 0) {                                       /* 320×224 */
    *(unsigned int *)0x060A4CC0 = (unsigned int)*(unsigned short *)0x060A4CAC * 6 + *(int *)0x060A4CB0;
    *(unsigned int *)0x060A4CC8 = (unsigned int)*(unsigned short *)0x060A4CAC * 0xc + *(int *)0x060A4CB0;
  }
  else if (res == 0x10) {                               /* 352×224 */
    *(unsigned int *)0x060A4CC0 = (unsigned int)*(unsigned short *)0x060A4CAC * 0x12 + *(int *)0x060A4CB0;
    *(unsigned int *)0x060A4CC8 = (unsigned int)*(unsigned short *)0x060A4CAC * 0x24 + *(int *)0x060A4CB0;
  }
  else if (res == 0x20) {                               /* 640×224 */
    *(unsigned int *)0x060A4CC0 = (unsigned int)*(unsigned short *)0x060A4CAC * 0x12 + *(int *)0x060A4CB0;
    *(unsigned int *)0x060A4CC8 = (unsigned int)*(unsigned short *)0x060A4CAC * 0x24 + *(int *)0x060A4CB0;
  }
  else if (res == 0x30) {                               /* 704×224 */
    *(unsigned int *)0x060A4CC0 = (unsigned int)*(unsigned short *)0x060A4CAC * 10 + *(int *)0x060A4CB0;
    *(unsigned int *)0x060A4CC8 = (unsigned int)*(unsigned short *)0x060A4CAC * 0x14 + *(int *)0x060A4CB0;
  }
  else if (res == DAT_060397f4) {                       /* custom mode A */
    *(unsigned int *)0x060A4CC0 = (unsigned int)*(unsigned short *)0x060A4CAC * 3 + *(int *)0x060A4CB0;
    *(unsigned int *)0x060A4CC8 = (unsigned int)*(unsigned short *)0x060A4CAC * 6 + *(int *)0x060A4CB0;
  }
  else if (res == DAT_060397f6) {                       /* custom mode B */
    *(unsigned int *)0x060A4CC0 = (unsigned int)*(unsigned short *)0x060A4CAC * 6 + *(int *)0x060A4CB0;
    *(unsigned int *)0x060A4CC8 = (unsigned int)*(unsigned short *)0x060A4CAC * 0xc + *(int *)0x060A4CB0;
  }
  else if (res == DAT_060397f8) {                       /* custom mode C */
    stride = ((unsigned char)*scan_cfg + 1) * (unsigned int)*(unsigned short *)0x060A4CAC;
    *(int *)0x060A4CC0 = *(int *)0x060A4CB0 + stride;
    *(int *)0x060A4CC8 = (stride << 1) + *(int *)0x060A4CB0;
  }

  /* Perform initial field swap and display commit */
  *(int *)0x060A4CB4 = 0;
  (*(int(*)())0x0603A766)();                            /* field swap */
  *(int *)0x060A4CC4 = *(int *)0x060A4CC0;              /* rotate ring: slot[1] = slot[3] */
  *(int *)0x060A4CC0 = *(int *)0x060A4CBC;              /* slot[3] = slot[2] */
  *(int *)0x060A4CBC = *(int *)0x060A4CC4;              /* slot[2] = slot[1] */
  *(int *)0x060A4CB4 = 0;
  (*(int(*)())0x0603A766)();                            /* field swap again */
  FUN_0603a6c0();                                       /* commit display config */
  FUN_0603a72c();                                       /* query display mode */
  return;
}
#endif /* display_mode_init */

/* framebuffer_vsync_poll -- Poll VDP vsync and advance frame timing.
 * Monitors interlace mode (0x060A4CAA) and VDP status register bit 4
 * (0x20100061) to count vsync events. When frame counter (0x060A4CB8)
 * reaches threshold (0x060A4CAB), rotates the 5-slot display config
 * ring buffer (0x060A4CBC..CE8) and commits the new display params.
 * Returns: 0 = still counting, 1 = inactive mode, or display query result. */
int framebuffer_vsync_poll(param_1)
    int *param_1;
{
  int vsync_count;
  int result;
  int display_mode = *(int *)0x060A4CAA;               /* interlace mode */
  if (display_mode == 1 || display_mode == 2) {
    if ((*(int *)0x20100061 & 0x10) == 0x10) {         /* VDP status: vsync active */
      vsync_count = *(int *)0x06063608;                 /* vsync frame counter */
      *(int *)0x06063608 = vsync_count + 1;
      if (2 < vsync_count + 1) {
        *(int *)0x06063601 = 1;                         /* vsync flag: ready */
        *(int *)0x06063608 = *(int *)0x06063608 + -1;
      }
    }
    else {
      *(int *)0x06063601 = 0;                           /* vsync flag: reset */
      *(int *)0x06063608 = 0;                           /* vsync counter: reset */
    }
    if ((int)(unsigned int)(unsigned char)*(int *)0x060A4CAB <= *(int *)0x060A4CB8) {
      *(int *)0x060A4CB8 = 0;                           /* frame counter: reset */
      if (*(int *)0x060A4CB4 < (int)(unsigned int)*(unsigned short *)0x060A4CAC) {
        *(int *)0x06063600 = *(int *)0x06063600 + 1;    /* interlace field counter */
        if (2 < (unsigned char)*(int *)0x06063600) {
          FUN_0603a766();                               /* interlace field swap */
          *(int *)0x06063600 = *(int *)0x06063600 + -1;
        }
      }
      else {
        *(int *)0x06063600 = 0;                         /* field counter: reset */
      }
      /* rotate 5-slot display config ring buffer */
      *(int *)0x060A4CC4 = *(int *)0x060A4CE8;         /* slot[1] = slot[4] */
      *(int *)0x060A4CE8 = *(int *)0x060A4C98;         /* slot[4] = slot[0] (base) */
      *(int *)0x060A4C98 = *(int *)0x060A4CC4;         /* slot[0] = slot[1] */
      *(int *)0x060A4CC4 = *(int *)0x060A4CC0;         /* slot[1] = slot[3] */
      *(int *)0x060A4CC0 = *(int *)0x060A4CBC;         /* slot[3] = slot[2] */
      result = *(int *)0x060A4CC4;
      *(int *)0x060A4CBC = result;                      /* slot[2] = slot[1] */
      *param_1 = result;
      FUN_0603a6c0();                                   /* commit display config */
      result = FUN_0603a72c();                          /* query display mode */
      return result;
    }
    *(int *)0x060A4CB8 = *(int *)0x060A4CB8 + 1;       /* frame counter++ */
    result = 0;
  }
  else {
    *param_1 = 0;
    result = 1;
  }
  return result;
}


/* --- FUN_06038300 (L1 import from src/FUN_06038300.c) --- */

#if 0 /* FUN_06038300 -- replaced by ASM import */
void FUN_06038300()
{

  char *puVar1;

  char *puVar2;

  char *puVar3;

  char *puVar4;

  unsigned int uVar5;

  unsigned short uVar6;

  unsigned short uVar7;

  (*(int(*)())0x06038F34)();

  puVar1 = (char *)0x060A4C60;

  *(int *)0x060A4C60 = 0;

  *(int *)(puVar1 + 4) = 0;

  puVar1 = (char *)0x060A4C68;

  *(int *)0x060A4C68 = 0;

  *(int *)(puVar1 + 4) = 0;

  puVar1 = (char *)0x060A4C78;

  *(int *)0x060A4C78 = 0;

  *(int *)(puVar1 + 4) = 0;

  puVar1 = (char *)0x060A4C40;

  *(short *)0x060A4C40 = 0;

  *(short *)(puVar1 + 2) = 0;

  puVar1 = (char *)0x060A4C54;

  *(short *)0x060A4C54 = 0;

  *(short *)(puVar1 + 2) = 0;

  puVar1 = (char *)0x060A4C44;

  *(int *)0x060A4C44 = 0;

  *(int *)(puVar1 + 4) = 0;

  puVar1 = (char *)0x060A4C4C;

  *(int *)0x060A4C4C = 0;

  puVar2 = (char *)0x0603C104;

  *(int *)(puVar1 + 4) = 0;

  (*(int(*)())puVar2)();

  puVar3 = (char *)0x060A3DB0;

  puVar2 = (char *)0x060A3D88;

  puVar1 = (char *)0x0000FFFF;

  *(char **)0x060A3D84 = 0x25F80000;

  puVar4 = (char *)0x00008000;

  *(short *)puVar2 = (short)0x00008000;

  *(short *)(puVar2 + 2) = 0;

  *(short *)(puVar2 + 6) = 0;

  *(short *)(puVar2 + 0xc) = 0;

  *(short *)(puVar2 + 0xe) = (short)((unsigned int)puVar4 >> 2);

  uVar7 = 0;

  do {

    uVar5 = (unsigned int)uVar7;

    uVar7 = uVar7 + 1;

    *(short *)(puVar2 + (uVar5 << 1) + 0x10) = (short)puVar1;

  } while (uVar7 < 8);

  *(short *)(puVar2 + 0x20) = 0;

  *(short *)(puVar2 + 0x22) = 0;

  *(short *)(puVar2 + 0x24) = 0;

  *(short *)(puVar2 + 0x26) = 0;

  *(short *)puVar3 = 0;

  *(short *)(puVar3 + 2) = 0;

  *(short *)(puVar3 + 4) = 0;

  *(short *)(puVar3 + 6) = 0;

  *(short *)(puVar3 + 8) = 0;

  *(short *)(puVar3 + 10) = 0;

  *(short *)(puVar3 + 0xc) = 0;

  *(short *)(puVar3 + 0xe) = 0;

  *(short *)(puVar3 + 0x10) = 0;

  *(short *)(puVar3 + 0x12) = 0;

  uVar6 = 0;

  *(short *)(puVar3 + 0x14) = 0;

  *(short *)(puVar3 + 0x16) = 0;

  uVar7 = uVar6;

  do {

    uVar5 = (unsigned int)uVar7;

    uVar7 = uVar7 + 1;

    *(short *)(puVar3 + (uVar5 << 1) + 0x18) = 0;

  } while (uVar7 < 8);

  do {

    uVar5 = (unsigned int)uVar6;

    uVar6 = uVar6 + 1;

    *(short *)(puVar3 + (uVar5 << 1) + 0x28) = 0;

    puVar1 = (char *)0x060A3DF8;

  } while (uVar6 < 0x10);

  *(int *)0x060A3DF8 = 0;

  *(int *)(puVar1 + 4) = 0;

  puVar2 = (char *)0x00010000;

  *(char **)(puVar1 + 8) = 0x00010000;

  *(char **)(puVar1 + 0xc) = puVar2;

  *(int *)(puVar1 + 0x10) = 0;

  *(int *)(puVar1 + 0x14) = 0;

  *(char **)(puVar1 + 0x18) = puVar2;

  *(char **)(puVar1 + 0x1c) = puVar2;

  *(short *)(puVar1 + 0x20) = 0;

  *(short *)(puVar1 + 0x22) = 0;

  *(short *)(puVar1 + 0x24) = 0;

  *(short *)(puVar1 + 0x26) = 0;

  *(short *)(puVar1 + 0x28) = 0;

  *(short *)(puVar1 + 0x2a) = 0;

  *(int *)(puVar1 + 0x2c) = 0;

  *(int *)(puVar1 + 0x30) = 0;

  *(int *)(puVar1 + 0x34) = 0;

  *(int *)(puVar1 + 0x38) = 0;

  *(int *)(puVar1 + 0x3c) = 0;

  puVar1 = (char *)0x060A3E38;

  *(short *)0x060A3E38 = 0;

  *(short *)(puVar1 + 2) = 0;

  *(short *)(puVar1 + 4) = 0;

  *(short *)(puVar1 + 6) = 0;

  *(short *)(puVar1 + 8) = 0;

  *(short *)(puVar1 + 10) = 0;

  *(int *)(puVar1 + 0xc) = 0;

  puVar1 = (char *)0x060A3E48;

  *(short *)0x060A3E48 = 0;

  *(short *)(puVar1 + 2) = 0;

  *(short *)(puVar1 + 4) = 0;

  *(short *)(puVar1 + 6) = 0;

  *(short *)(puVar1 + 8) = 0;

  *(short *)(puVar1 + 10) = 0;

  *(short *)(puVar1 + 0xc) = 0;

  *(short *)(puVar1 + 0xe) = 0;

  *(short *)(puVar1 + 0x10) = 0;

  *(short *)(puVar1 + 0x12) = 0;

  *(short *)(puVar1 + 0x14) = 0;

  *(short *)(puVar1 + 0x16) = 0;

  *(int *)(puVar1 + 0x18) = 0;

  *(int *)(puVar1 + 0x1c) = 0;

  if (*(short *)0x060635AC == 0) {

    *(short *)0x060635AC = 1;

  }

  return;

}
#endif

/* --- FUN_06038642 (L1 import from src/FUN_06038642.c) --- */

#if 0 /* FUN_06038642 -- replaced by ASM import */
int FUN_06038642(param_1, param_2, param_3)
    int param_1;
    int param_2;
    int param_3;
{

  char *puVar1;

  char *puVar2;

  char *puVar3;

  char *puVar4;

  int iVar5;

  short sVar6;

  short sVar7;

  puVar4 = (char *)0x060A3EE8;

  puVar3 = (char *)0x060A3E68;

  puVar2 = (char *)0x060A3DF8;

  puVar1 = (char *)0x060A4C78;

  iVar5 = *(int *)0x060635A8;

  if (iVar5 == 1) {

    *(int *)(0x060A3E68 + 0x44) = *(int *)(0x060A3E68 + 0x44) + param_1;

    *(int *)(puVar3 + 0x48) = *(int *)(puVar3 + 0x48) + param_2;

    if ((*(int *)0x060A4C44 == 0) ||

       ((*(int *)0x060A4C4C != 0 && (*(int *)0x060A4C70 != 0)))) {

      *(int *)puVar1 = 0;

    }

    else {

      *(int *)puVar1 = *(int *)puVar1 + param_3;

    }

    iVar5 = 0;

    if (*(int *)puVar1 != 0) {

      iVar5 = (*(int(*)())0x0603DDFC)(0,0);

      return iVar5;

    }

  }

  else if (iVar5 == 2) {

    *(int *)(0x060A3EE8 + 0x44) = *(int *)(0x060A3EE8 + 0x44) + param_1;

    *(int *)(puVar4 + 0x48) = *(int *)(puVar4 + 0x48) + param_2;

    if ((*(int *)0x060A4C48 == 0) ||

       ((*(int *)0x060A4C50 != 0 && (*(int *)0x060A4C74 != 0)))) {

      *(int *)(puVar1 + 4) = 0;

    }

    else {

      *(int *)(puVar1 + 4) = *(int *)(puVar1 + 4) + param_3;

    }

    iVar5 = 0;

    if (*(int *)(puVar1 + 4) != 0) {

      iVar5 = (*(int(*)())0x0603DDFC)(0,0);

      return iVar5;

    }

  }

  else if (iVar5 == 4) {

    *(int *)0x060A3DF8 = *(int *)0x060A3DF8 + param_1;

    *(int *)(puVar2 + 4) = *(int *)(puVar2 + 4) + param_2;

  }

  else if (iVar5 == 8) {

    *(int *)(0x060A3DF8 + 0x10) = *(int *)(0x060A3DF8 + 0x10) + param_1;

    *(int *)(puVar2 + 0x14) = *(int *)(puVar2 + 0x14) + param_2;

  }

  else {

    sVar6 = (short)((unsigned int)param_1 >> 0x10);

    sVar7 = (short)((unsigned int)param_2 >> 0x10);

    if (iVar5 == 0x10) {

      *(short *)(0x060A3DF8 + 0x20) = *(short *)(0x060A3DF8 + 0x20) + sVar6;

      *(short *)(puVar2 + 0x22) = *(short *)(puVar2 + 0x22) + sVar7;

      iVar5 = 0x22;

    }

    else if (iVar5 == 0x20) {

      *(short *)(0x060A3DF8 + 0x24) = *(short *)(0x060A3DF8 + 0x24) + sVar6;

      *(short *)(puVar2 + 0x26) = *(short *)(puVar2 + 0x26) + sVar7;

      iVar5 = 0x26;

    }

  }

  return iVar5;

}
#endif

/* FUN_06038642 -- original binary (338 bytes) */
__asm__(
    ".section .text.FUN_06038642, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06038642\n"
    ".type _FUN_06038642, @function\n"
    "_FUN_06038642:\n"
    ".byte 0x2F, 0xE6, 0xDE, 0x19, 0xD7, 0x1A, 0xD0, 0x1A, 0xA0, 0x7F, 0x60, 0x02, 0x62, 0x72, 0x32, 0x4C\n"  /* 0x06038642 */
    ".byte 0x27, 0x22, 0x53, 0x71, 0x33, 0x5C, 0x17, 0x31, 0xA0, 0x87, 0x00, 0x09, 0x52, 0x74, 0x32, 0x4C\n"  /* 0x06038652 */
    ".byte 0x17, 0x24, 0x53, 0x75, 0x33, 0x5C, 0x17, 0x35, 0xA0, 0x7F, 0x00, 0x09, 0x44, 0x29, 0x64, 0x4F\n"  /* 0x06038662 */
    ".byte 0xE0, 0x20, 0x02, 0x7D, 0x32, 0x4C, 0x07, 0x25, 0x45, 0x29, 0x65, 0x5F, 0xE0, 0x22, 0x03, 0x7D\n"  /* 0x06038672 */
    ".byte 0x33, 0x5C, 0x07, 0x35, 0xA0, 0x71, 0x00, 0x09, 0x44, 0x29, 0x64, 0x4F, 0xE0, 0x24, 0x02, 0x7D\n"  /* 0x06038682 */
    ".byte 0x32, 0x4C, 0x07, 0x25, 0x45, 0x29, 0x65, 0x5F, 0xE0, 0x26, 0x03, 0x7D, 0x33, 0x5C, 0x07, 0x35\n"  /* 0x06038692 */
    ".byte 0xA0, 0x63, 0x00, 0x09, 0xFF, 0xFF, 0x06, 0x03, 0xDD, 0xFC, 0x06, 0x0A, 0x4C, 0x78, 0x06, 0x0A\n"  /* 0x060386A2 */
    ".byte 0x3D, 0xF8, 0x06, 0x06, 0x35, 0xA8, 0xD7, 0x2D, 0xE0, 0x44, 0x02, 0x7E, 0x32, 0x4C, 0x07, 0x26\n"  /* 0x060386B2 */
    ".byte 0xE0, 0x48, 0x03, 0x7E, 0x33, 0x5C, 0x07, 0x36, 0xD3, 0x2A, 0x60, 0x32, 0x20, 0x08, 0x89, 0x0C\n"  /* 0x060386C2 */
    ".byte 0xD3, 0x29, 0x60, 0x32, 0x20, 0x08, 0x89, 0x03, 0xD3, 0x28, 0x60, 0x32, 0x20, 0x08, 0x8B, 0x04\n"  /* 0x060386D2 */
    ".byte 0x63, 0xE2, 0x33, 0x6C, 0x2E, 0x32, 0xA0, 0x02, 0x00, 0x09, 0xE2, 0x00, 0x2E, 0x22, 0x60, 0xE2\n"  /* 0x060386E2 */
    ".byte 0x20, 0x08, 0x89, 0x3A, 0xE6, 0x00, 0x65, 0x63, 0x64, 0x63, 0xD3, 0x20, 0x43, 0x2B, 0x6E, 0xF6\n"  /* 0x060386F2 */
    ".byte 0xE0, 0x44, 0xD7, 0x1F, 0x02, 0x7E, 0x32, 0x4C, 0x07, 0x26, 0xE0, 0x48, 0x03, 0x7E, 0x33, 0x5C\n"  /* 0x06038702 */
    ".byte 0x07, 0x36, 0xD3, 0x1C, 0x60, 0x32, 0x20, 0x08, 0x89, 0x0C, 0xD3, 0x1B, 0x60, 0x32, 0x20, 0x08\n"  /* 0x06038712 */
    ".byte 0x89, 0x03, 0xD3, 0x1A, 0x60, 0x32, 0x20, 0x08, 0x8B, 0x04, 0x53, 0xE1, 0x33, 0x6C, 0x1E, 0x31\n"  /* 0x06038722 */
    ".byte 0xA0, 0x02, 0x00, 0x09, 0xE2, 0x00, 0x1E, 0x21, 0x50, 0xE1, 0x20, 0x08, 0x89, 0x15, 0xE6, 0x00\n"  /* 0x06038732 */
    ".byte 0x65, 0x63, 0x64, 0x63, 0xD3, 0x0E, 0x43, 0x2B, 0x6E, 0xF6, 0x88, 0x01, 0x89, 0xB3, 0x88, 0x02\n"  /* 0x06038742 */
    ".byte 0x89, 0xD6, 0x88, 0x04, 0x8B, 0x01, 0xAF, 0x79, 0x00, 0x09, 0x88, 0x08, 0x8B, 0x01, 0xAF, 0x7D\n"  /* 0x06038752 */
    ".byte 0x00, 0x09, 0x88, 0x10, 0x89, 0x82, 0x88, 0x20, 0x89, 0x8E, 0x00, 0x0B, 0x6E, 0xF6, 0x06, 0x0A\n"  /* 0x06038762 */
    ".byte 0x3E, 0x68, 0x06, 0x0A, 0x4C, 0x44, 0x06, 0x0A, 0x4C, 0x4C, 0x06, 0x0A, 0x4C, 0x70, 0x06, 0x03\n"  /* 0x06038772 */
    ".byte 0xDD, 0xFC, 0x06, 0x0A, 0x3E, 0xE8, 0x06, 0x0A, 0x4C, 0x48, 0x06, 0x0A, 0x4C, 0x50, 0x06, 0x0A\n"  /* 0x06038782 */
    ".byte 0x4C, 0x74\n"  /* 0x06038792 */
);


/* --- FUN_0603950C (L1 import from src/FUN_0603950C.c) --- */

#if 0 /* FUN_0603950C -- replaced by ASM import */
void FUN_0603950c(char param_1,short param_2,char param_3,char param_4,int param_5,int param_6)
{

  char cVar1;

  char *puVar2;

  char *puVar3;

  char *puVar4;

  char *puVar5;

  char *puVar6;

  char *puVar7;

  char *puVar8;

  unsigned short uVar9;

  int iVar10;

  puVar8 = (char *)0x20100079;

  puVar7 = (char *)0x060A4CB0;

  puVar6 = (char *)0x060A4CAC;

  puVar5 = (char *)0x060A4CC0;

  puVar4 = (char *)0x06063602;

  puVar3 = (char *)0x060A4CBC;

  puVar2 = (char *)0x060A4CAE;

  *(int *)0x20100079 = 0;

  puVar8[2] = 0;

  puVar8[6] = 0;

  puVar8[4] = 0;

  (*(int(*)())(*(int *)0x06000300))(0x47,0x0603990E);

  (*(int(*)())(*(int *)0x06000344))(-129,0);

  puVar8 = (char *)0x060A4CAA;

  *(int *)0x060A4CAA = param_1;

  cVar1 = *puVar8;

  if (cVar1 == '\0') {

    *puVar4 = 1;

    puVar4[1] = 0;

    *(int *)0x060A4CA8 = 0;

    (*(int(*)())0x0603A72C)();

    return;

  }

  if (cVar1 == '\x01') {

    *puVar4 = 0;

    puVar4[1] = 8;

  }

  else if (cVar1 == '\x02') {

    *puVar4 = 1;

    puVar4[1] = 8;

    *(int *)0x060A4CD8 = 0;

  }

  *puVar2 = param_4;

  *(short *)puVar6 = param_2;

  *(int *)0x060A4CAB = param_6;

  *(int *)0x060A4CAF = param_3;

  *(int *)puVar7 = param_5;

  *(int *)0x060A4CB8 = 0;

  if (0xf < (unsigned char)*puVar2) {

    puVar4[1] = puVar4[1] | 0x50;

  }

  puVar4 = (char *)0x060A4CD9;

  *(char **)0x060A4CE8 = 0x060A4CD9;

  *(char **)0x060A4C98 = puVar4 + 7;

  *(int *)puVar3 = *(int *)puVar7;

  puVar4 = (char *)0x060A4CC8;

  uVar9 = (unsigned short)(unsigned char)*(int *)0x060A4CAF;

  if (uVar9 == 0) {

    *(unsigned int *)puVar5 = (unsigned int)*(unsigned short *)puVar6 * 6 + *(int *)puVar7;

    *(unsigned int *)puVar4 = (unsigned int)*(unsigned short *)puVar6 * 0xc + *(int *)puVar7;

  }

  else if (uVar9 == 0x10) {

    *(unsigned int *)puVar5 = (unsigned int)*(unsigned short *)puVar6 * 0x12 + *(int *)puVar7;

    *(unsigned int *)puVar4 = (unsigned int)*(unsigned short *)puVar6 * 0x24 + *(int *)puVar7;

  }

  else if (uVar9 == 0x20) {

    *(unsigned int *)puVar5 = (unsigned int)*(unsigned short *)puVar6 * 0x12 + *(int *)puVar7;

    *(unsigned int *)puVar4 = (unsigned int)*(unsigned short *)puVar6 * 0x24 + *(int *)puVar7;

  }

  else if (uVar9 == 0x30) {

    *(unsigned int *)puVar5 = (unsigned int)*(unsigned short *)puVar6 * 10 + *(int *)puVar7;

    *(unsigned int *)puVar4 = (unsigned int)*(unsigned short *)puVar6 * 0x14 + *(int *)puVar7;

  }

  else if (uVar9 == DAT_060397f4) {

    *(unsigned int *)puVar5 = (unsigned int)*(unsigned short *)puVar6 * 3 + *(int *)puVar7;

    *(unsigned int *)puVar4 = (unsigned int)*(unsigned short *)puVar6 * 6 + *(int *)puVar7;

  }

  else if (uVar9 == DAT_060397f6) {

    *(unsigned int *)puVar5 = (unsigned int)*(unsigned short *)puVar6 * 6 + *(int *)puVar7;

    *(unsigned int *)puVar4 = (unsigned int)*(unsigned short *)puVar6 * 0xc + *(int *)puVar7;

  }

  else if (uVar9 == DAT_060397f8) {

    iVar10 = ((unsigned char)*puVar2 + 1) * (unsigned int)*(unsigned short *)puVar6;

    *(int *)puVar5 = *(int *)puVar7 + iVar10;

    *(int *)puVar4 = (iVar10 << 1) + *(int *)puVar7;

  }

  *(int *)0x060A4CB4 = 0;

  (*(int(*)())0x0603A766)();

  puVar2 = (char *)0x060A4CC4;

  *(int *)0x060A4CC4 = *(int *)puVar5;

  *(int *)puVar5 = *(int *)puVar3;

  *(int *)puVar3 = *(int *)puVar2;

  *(int *)0x060A4CB4 = 0;

  (*(int(*)())0x0603A766)();

  FUN_0603a6c0();

  FUN_0603a72c();

  return;

}
#endif

/* FUN_0603950C -- original binary (764 bytes) */
__asm__(
    ".section .text.FUN_0603950C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0603950C\n"
    ".global _FUN_0603950c\n"
    ".type _FUN_0603950C, @function\n"
    "_FUN_0603950C:\n"
    "_FUN_0603950c:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x4F, 0x22\n"  /* 0x0603950C */
    ".byte 0x4F, 0x12, 0x7F, 0xF0, 0xD8, 0x25, 0xD9, 0x26, 0xDA, 0x26, 0xDB, 0x27, 0xEC, 0x00, 0xDD, 0x27\n"  /* 0x0603951C */
    ".byte 0xDE, 0x27, 0x60, 0x43, 0x80, 0xFC, 0x60, 0x53, 0x81, 0xF4, 0x2F, 0x60, 0x60, 0x73, 0x80, 0xF4\n"  /* 0x0603952C */
    ".byte 0xD2, 0x24, 0x22, 0xC0, 0x72, 0x02, 0x22, 0xC0, 0x72, 0x04, 0x22, 0xC0, 0x63, 0xCC, 0x72, 0xFE\n"  /* 0x0603953C */
    ".byte 0x22, 0x30, 0xD3, 0x21, 0xD5, 0x21, 0x63, 0x32, 0x43, 0x0B, 0xE4, 0x47, 0xD2, 0x20, 0x94, 0x2C\n"  /* 0x0603954C */
    ".byte 0x62, 0x22, 0x42, 0x0B, 0x65, 0xC3, 0xD6, 0x1F, 0x84, 0xFC, 0x63, 0x03, 0x26, 0x30, 0xE5, 0x08\n"  /* 0x0603955C */
    ".byte 0xE4, 0x01, 0x60, 0x60, 0xA0, 0x3E, 0x60, 0x0C, 0x64, 0x4C, 0x2A, 0x40, 0x60, 0xCC, 0x80, 0xA1\n"  /* 0x0603956C */
    ".byte 0xD2, 0x19, 0x22, 0xC0, 0x7F, 0x10, 0x4F, 0x16, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6\n"  /* 0x0603957C */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xD2, 0x15, 0x42, 0x2B, 0x6E, 0xF6, 0x2A, 0xC0, 0x65, 0x5C\n"  /* 0x0603958C */
    ".byte 0x60, 0x53, 0xA0, 0x2D, 0x80, 0xA1, 0x64, 0x4C, 0x2A, 0x40, 0x65, 0x5C, 0x60, 0x53, 0x80, 0xA1\n"  /* 0x0603959C */
    ".byte 0x63, 0xCC, 0xD2, 0x0F, 0x22, 0x30, 0xA0, 0x23, 0x00, 0x09, 0xFF, 0x7F, 0x06, 0x0A, 0x4C, 0xAE\n"  /* 0x060395AC */
    ".byte 0x06, 0x0A, 0x4C, 0xBC, 0x06, 0x06, 0x36, 0x02, 0x06, 0x0A, 0x4C, 0xC0, 0x06, 0x0A, 0x4C, 0xAC\n"  /* 0x060395BC */
    ".byte 0x06, 0x0A, 0x4C, 0xB0, 0x20, 0x10, 0x00, 0x79, 0x06, 0x00, 0x03, 0x00, 0x06, 0x03, 0x99, 0x0E\n"  /* 0x060395CC */
    ".byte 0x06, 0x00, 0x03, 0x44, 0x06, 0x0A, 0x4C, 0xAA, 0x06, 0x0A, 0x4C, 0xA8, 0x06, 0x03, 0xA7, 0x2C\n"  /* 0x060395DC */
    ".byte 0x06, 0x0A, 0x4C, 0xD8, 0x88, 0x00, 0x89, 0xBF, 0x88, 0x01, 0x89, 0xCF, 0x88, 0x02, 0x89, 0xD2\n"  /* 0x060395EC */
    ".byte 0x84, 0xF4, 0x63, 0x03, 0x28, 0x30, 0x85, 0xF4, 0x63, 0x03, 0xE0, 0x3B, 0x2D, 0x31, 0x03, 0xFC\n"  /* 0x060395FC */
    ".byte 0xD2, 0x38, 0x22, 0x30, 0x63, 0xF0, 0xD2, 0x38, 0x22, 0x30, 0x53, 0xFD, 0x2E, 0x32, 0xD3, 0x37\n"  /* 0x0603960C */
    ".byte 0x23, 0xC2, 0xE3, 0x0F, 0x62, 0x80, 0x62, 0x2C, 0x32, 0x37, 0x89, 0x01, 0xA0, 0x03, 0x00, 0x09\n"  /* 0x0603961C */
    ".byte 0x84, 0xA1, 0xCB, 0x50, 0x80, 0xA1, 0xD4, 0x32, 0xD3, 0x32, 0x23, 0x42, 0x74, 0x07, 0xD3, 0x32\n"  /* 0x0603962C */
    ".byte 0x23, 0x42, 0x62, 0xE2, 0x29, 0x22, 0xD4, 0x31, 0xD0, 0x2B, 0x60, 0x00, 0xA0, 0x9F, 0x60, 0x0C\n"  /* 0x0603963C */
    ".byte 0x65, 0x80, 0x63, 0xD1, 0x62, 0xE2, 0x65, 0x5C, 0x63, 0x3D, 0x75, 0x01, 0x05, 0x37, 0x05, 0x1A\n"  /* 0x0603964C */
    ".byte 0x32, 0x5C, 0x2B, 0x22, 0x45, 0x00, 0x63, 0xE2, 0x35, 0x3C, 0xA0, 0xA7, 0x24, 0x52, 0x62, 0xD1\n"  /* 0x0603965C */
    ".byte 0x61, 0xE2, 0x62, 0x2D, 0x63, 0x23, 0x42, 0x00, 0x43, 0x08, 0x32, 0x3C, 0x32, 0x1C, 0x2B, 0x22\n"  /* 0x0603966C */
    ".byte 0x63, 0xD1, 0x63, 0x3D, 0x43, 0x00, 0x62, 0x33, 0x43, 0x00, 0x42, 0x08, 0x33, 0x2C, 0x61, 0xE2\n"  /* 0x0603967C */
    ".byte 0x33, 0x1C, 0x24, 0x32, 0xA0, 0x92, 0x00, 0x09, 0x62, 0xD1, 0x61, 0xE2, 0x62, 0x2D, 0x63, 0x23\n"  /* 0x0603968C */
    ".byte 0x42, 0x00, 0x43, 0x08, 0x43, 0x08, 0x32, 0x3C, 0x32, 0x1C, 0x2B, 0x22, 0x63, 0xD1, 0x63, 0x3D\n"  /* 0x0603969C */
    ".byte 0x43, 0x00, 0x62, 0x33, 0x43, 0x00, 0x42, 0x08, 0x42, 0x08, 0x33, 0x2C, 0x61, 0xE2, 0x33, 0x1C\n"  /* 0x060396AC */
    ".byte 0x24, 0x32, 0xA0, 0x7B, 0x00, 0x09, 0x62, 0xD1, 0x61, 0xE2, 0x62, 0x2D, 0x63, 0x23, 0x42, 0x00\n"  /* 0x060396BC */
    ".byte 0x43, 0x08, 0x43, 0x08, 0x32, 0x3C, 0x32, 0x1C, 0x2B, 0x22, 0x63, 0xD1, 0x63, 0x3D, 0x43, 0x00\n"  /* 0x060396CC */
    ".byte 0x62, 0x33, 0x43, 0x00, 0x42, 0x08, 0x42, 0x08, 0x33, 0x2C, 0x61, 0xE2, 0x33, 0x1C, 0x24, 0x32\n"  /* 0x060396DC */
    ".byte 0xA0, 0x64, 0x00, 0x09, 0x06, 0x0A, 0x4C, 0xAB, 0x06, 0x0A, 0x4C, 0xAF, 0x06, 0x0A, 0x4C, 0xB8\n"  /* 0x060396EC */
    ".byte 0x06, 0x0A, 0x4C, 0xD9, 0x06, 0x0A, 0x4C, 0xE8, 0x06, 0x0A, 0x4C, 0x98, 0x06, 0x0A, 0x4C, 0xC8\n"  /* 0x060396FC */
    ".byte 0x62, 0xD1, 0x61, 0xE2, 0x62, 0x2D, 0x63, 0x23, 0x42, 0x00, 0x43, 0x08, 0x43, 0x00, 0x32, 0x3C\n"  /* 0x0603970C */
    ".byte 0x32, 0x1C, 0x2B, 0x22, 0x63, 0xD1, 0x63, 0x3D, 0x43, 0x00, 0x62, 0x33, 0x43, 0x00, 0x42, 0x08\n"  /* 0x0603971C */
    ".byte 0x42, 0x00, 0x33, 0x2C, 0x61, 0xE2, 0x33, 0x1C, 0x24, 0x32, 0xA0, 0x3F, 0x00, 0x09, 0x62, 0xD1\n"  /* 0x0603972C */
    ".byte 0x61, 0xE2, 0x62, 0x2D, 0x63, 0x23, 0x42, 0x00, 0x32, 0x3C, 0x32, 0x1C, 0x2B, 0x22, 0x63, 0xD1\n"  /* 0x0603973C */
    ".byte 0x63, 0x3D, 0x43, 0x00, 0x62, 0x33, 0x43, 0x00, 0x33, 0x2C, 0x61, 0xE2, 0x33, 0x1C, 0x24, 0x32\n"  /* 0x0603974C */
    ".byte 0xA0, 0x2C, 0x00, 0x09, 0x62, 0xD1, 0x61, 0xE2, 0x62, 0x2D, 0x63, 0x23, 0x42, 0x00, 0x43, 0x08\n"  /* 0x0603975C */
    ".byte 0x32, 0x3C, 0x32, 0x1C, 0x2B, 0x22, 0x63, 0xD1, 0x63, 0x3D, 0x43, 0x00, 0x62, 0x33, 0x43, 0x00\n"  /* 0x0603976C */
    ".byte 0x42, 0x08, 0x33, 0x2C, 0x61, 0xE2, 0x33, 0x1C, 0x24, 0x32, 0xA0, 0x17, 0x00, 0x09, 0x88, 0x00\n"  /* 0x0603977C */
    ".byte 0x8B, 0x01, 0xAF, 0x6C, 0x00, 0x09, 0x88, 0x10, 0x8B, 0x01, 0xAF, 0x7D, 0x00, 0x09, 0x88, 0x20\n"  /* 0x0603978C */
    ".byte 0x89, 0x91, 0x88, 0x30, 0x89, 0xB4, 0x91, 0x27, 0x30, 0x10, 0x89, 0xC8, 0x91, 0x25, 0x30, 0x10\n"  /* 0x0603979C */
    ".byte 0x89, 0xD8, 0x91, 0x23, 0x30, 0x10, 0x8B, 0x01, 0xAF, 0x4A, 0x00, 0x09, 0xD3, 0x10, 0x23, 0xC2\n"  /* 0x060397AC */
    ".byte 0xD3, 0x10, 0x43, 0x0B, 0x00, 0x09, 0xD4, 0x10, 0x62, 0xB2, 0x24, 0x22, 0x63, 0x92, 0x2B, 0x32\n"  /* 0x060397BC */
    ".byte 0x62, 0x42, 0x29, 0x22, 0xD3, 0x0A, 0x23, 0xC2, 0xD3, 0x0A, 0x43, 0x0B, 0x00, 0x09, 0xB7, 0x71\n"  /* 0x060397CC */
    ".byte 0x00, 0x09, 0x7F, 0x10, 0x4F, 0x16, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6\n"  /* 0x060397DC */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0xA7, 0x9C, 0x6E, 0xF6, 0x00, 0xE1, 0x00, 0xE2, 0x00, 0xFF, 0xFF, 0xFF\n"  /* 0x060397EC */
    ".byte 0x06, 0x0A, 0x4C, 0xB4, 0x06, 0x03, 0xA7, 0x66, 0x06, 0x0A, 0x4C, 0xC4\n"  /* 0x060397FC */
);


/* --- FUN_06039808 (L1 import from src/FUN_06039808.c) --- */

#if 0 /* FUN_06039808 -- replaced by ASM import */
int FUN_06039808(param_1)
    int *param_1;
{

  char *puVar1;

  char *puVar2;

  char *puVar3;

  int uVar4;

  int iVar5;

  puVar2 = (char *)0x06063608;

  puVar1 = (char *)0x06063601;

  if ((*(int *)0x060A4CAA == '\x01') || (*(int *)0x060A4CAA == '\x02')) {

    if ((*(int *)0x20100061 & 0x10) == 0x10) {

      iVar5 = *(int *)0x06063608;

      *(int *)0x06063608 = iVar5 + 1;

      if (2 < iVar5 + 1) {

        *puVar1 = 1;

        *(int *)puVar2 = *(int *)puVar2 + -1;

      }

    }

    else {

      *(int *)0x06063601 = 0;

      *(int *)puVar2 = 0;

    }

    if ((int)(unsigned int)(unsigned char)*(int *)0x060A4CAB <= *(int *)0x060A4CB8) {

      *(int *)0x060A4CB8 = 0;

      puVar1 = (char *)0x06063600;

      if (*(int *)0x060A4CB4 < (int)(unsigned int)*(unsigned short *)0x060A4CAC) {

        *(int *)0x06063600 = *(int *)0x06063600 + '\x01';

        if (2 < (unsigned char)*puVar1) {

          FUN_0603a766();

          *puVar1 = *puVar1 + -1;

        }

      }

      else {

        *(int *)0x06063600 = 0;

      }

      puVar2 = (char *)0x060A4CC4;

      puVar1 = (char *)0x060A4CE8;

      *(int *)0x060A4CC4 = *(int *)0x060A4CE8;

      puVar3 = (char *)0x060A4C98;

      *(int *)puVar1 = *(int *)0x060A4C98;

      *(int *)puVar3 = *(int *)puVar2;

      puVar1 = (char *)0x060A4CC0;

      *(int *)puVar2 = *(int *)0x060A4CC0;

      puVar3 = (char *)0x060A4CBC;

      *(int *)puVar1 = *(int *)0x060A4CBC;

      uVar4 = *(int *)puVar2;

      *(int *)puVar3 = uVar4;

      *param_1 = uVar4;

      FUN_0603a6c0();

      uVar4 = FUN_0603a72c();

      return uVar4;

    }

    *(int *)0x060A4CB8 = *(int *)0x060A4CB8 + 1;

    uVar4 = 0;

  }

  else {

    *param_1 = 0;

    uVar4 = 1;

  }

  return uVar4;

}
#endif

/* FUN_06038300 -- original binary (108 bytes) */
__asm__(
    ".section .text.FUN_06038300, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06038300\n"
    ".type _FUN_06038300, @function\n"
    "_FUN_06038300:\n"
    ".byte 0x4F, 0x22, 0xD3, 0x11, 0x43, 0x0B, 0x00, 0x09, 0xD5, 0x10, 0xE4, 0x00, 0x25, 0x42, 0x60, 0x4D\n"  /* 0x06038300 */
    ".byte 0x63, 0x4D, 0x15, 0x41, 0xD5, 0x0E, 0x25, 0x42, 0x15, 0x41, 0xD5, 0x0E, 0x25, 0x42, 0x15, 0x41\n"  /* 0x06038310 */
    ".byte 0xD5, 0x0D, 0x25, 0x41, 0x81, 0x51, 0x60, 0x4D, 0xD5, 0x0C, 0x25, 0x31, 0x81, 0x51, 0x63, 0x43\n"  /* 0x06038320 */
    ".byte 0xD5, 0x0B, 0x62, 0x33, 0x25, 0x42, 0x15, 0x31, 0xD5, 0x0A, 0x25, 0x22, 0xD3, 0x0A, 0x43, 0x0B\n"  /* 0x06038330 */
    ".byte 0x15, 0x21, 0xA0, 0x13, 0x4F, 0x26, 0xFF, 0xFF, 0x06, 0x03, 0x8F, 0x34, 0x06, 0x0A, 0x4C, 0x60\n"  /* 0x06038340 */
    ".byte 0x06, 0x0A, 0x4C, 0x68, 0x06, 0x0A, 0x4C, 0x78, 0x06, 0x0A, 0x4C, 0x40, 0x06, 0x0A, 0x4C, 0x54\n"  /* 0x06038350 */
    ".byte 0x06, 0x0A, 0x4C, 0x44, 0x06, 0x0A, 0x4C, 0x4C, 0x06, 0x03, 0xC1, 0x04\n"  /* 0x06038360 */
);

/* FUN_060389A6 -- original binary (290 bytes) */
__asm__(
    ".section .text.FUN_060389A6, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060389A6\n"
    ".global _FUN_060389a6\n"
    ".global _smpc_intback_trigger\n"
    ".type _FUN_060389A6, @function\n"
    "_FUN_060389A6:\n"
    "_FUN_060389a6:\n"
    "_smpc_intback_trigger:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0xDE, 0x18, 0x60, 0xE1, 0xA0, 0x3B, 0x60, 0x0D, 0xBF, 0x85, 0x00, 0x09\n"  /* 0x060389A6 */
    ".byte 0xA0, 0x18, 0x00, 0x09, 0xD6, 0x15, 0xD5, 0x15, 0xD4, 0x16, 0x66, 0x61, 0x65, 0x52, 0x66, 0x6D\n"  /* 0x060389B6 */
    ".byte 0x63, 0x63, 0x46, 0x08, 0x43, 0x08, 0x43, 0x00, 0x36, 0x3C, 0xB0, 0x3A, 0x64, 0x42, 0xD6, 0x11\n"  /* 0x060389C6 */
    ".byte 0xD5, 0x12, 0xD4, 0x12, 0x66, 0x61, 0x65, 0x52, 0x66, 0x6D, 0x46, 0x08, 0xB0, 0x31, 0x64, 0x42\n"  /* 0x060389D6 */
    ".byte 0xBF, 0x6B, 0x00, 0x09, 0xE2, 0x00, 0xA0, 0x29, 0x2E, 0x21, 0x00, 0xB0, 0x00, 0xC0, 0x06, 0x0A\n"  /* 0x060389E6 */
    ".byte 0x3D, 0x84, 0x06, 0x0A, 0x3D, 0x88, 0x06, 0x0A, 0x3D, 0xB0, 0x06, 0x0A, 0x3D, 0xF8, 0x06, 0x0A\n"  /* 0x060389F6 */
    ".byte 0x3E, 0x38, 0x06, 0x0A, 0x3E, 0x48, 0x06, 0x06, 0x35, 0xAC, 0x06, 0x06, 0x35, 0xA0, 0x06, 0x0A\n"  /* 0x06038A06 */
    ".byte 0x3D, 0x74, 0x06, 0x0A, 0x3D, 0x70, 0x06, 0x06, 0x35, 0xA2, 0x06, 0x0A, 0x3D, 0x7C, 0x06, 0x0A\n"  /* 0x06038A16 */
    ".byte 0x3D, 0x78, 0x88, 0x01, 0x89, 0xC2, 0x88, 0x02, 0x89, 0xC4, 0x88, 0x03, 0x89, 0x06, 0x88, 0x04\n"  /* 0x06038A26 */
    ".byte 0x89, 0x04, 0x88, 0x05, 0x89, 0x02, 0x88, 0x06, 0x89, 0x00, 0x88, 0x07, 0x4F, 0x26, 0xA0, 0x40\n"  /* 0x06038A36 */
    ".byte 0x6E, 0xF6, 0x46, 0x01, 0xE7, 0x00, 0x63, 0x73, 0x33, 0x62, 0x89, 0x06, 0x77, 0x01, 0x63, 0x51\n"  /* 0x06038A46 */
    ".byte 0x24, 0x31, 0x74, 0x02, 0x37, 0x62, 0x8F, 0xF9, 0x75, 0x02, 0x00, 0x0B, 0x00, 0x09, 0x96, 0x19\n"  /* 0x06038A56 */
    ".byte 0xD5, 0x0E, 0xA0, 0x1C, 0x60, 0x43, 0x85, 0x57, 0x62, 0x03, 0x62, 0x2D, 0xA0, 0x0E, 0x22, 0x69\n"  /* 0x06038A66 */
    ".byte 0x85, 0x57, 0x62, 0x03, 0x62, 0x2D, 0x22, 0x69, 0x93, 0x0D, 0x22, 0x3B, 0xA0, 0x06, 0x00, 0x09\n"  /* 0x06038A76 */
    ".byte 0x85, 0x57, 0x62, 0x03, 0x62, 0x2D, 0x22, 0x69, 0x93, 0x06, 0x22, 0x3B, 0x62, 0x2D, 0x60, 0x23\n"  /* 0x06038A86 */
    ".byte 0xA0, 0x0B, 0x81, 0x57, 0x0F, 0xFF, 0x10, 0x00, 0x20, 0x00, 0x06, 0x0A, 0x3D, 0x88, 0x88, 0x00\n"  /* 0x06038A96 */
    ".byte 0x89, 0xE1, 0x88, 0x01, 0x89, 0xE4, 0x88, 0x02, 0x89, 0xEA, 0xD4, 0x04, 0x62, 0x41, 0x62, 0x2D\n"  /* 0x06038AA6 */
    ".byte 0x22, 0x28, 0x8B, 0x01, 0xE3, 0x01, 0x24, 0x31, 0x00, 0x0B, 0x00, 0x09, 0xFF, 0xFF, 0x06, 0x06\n"  /* 0x06038AB6 */
    ".byte 0x35, 0xAC\n"  /* 0x06038AC6 */
);

/* FUN_060388C0 -- original binary (230 bytes) */
__asm__(
    ".section .text.FUN_060388C0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060388C0\n"
    ".global _FUN_060388c0\n"
    ".type _FUN_060388C0, @function\n"
    "_FUN_060388C0:\n"
    "_FUN_060388c0:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x4F, 0x22, 0xDD, 0x1C, 0x60, 0xD1, 0x60, 0x0D, 0x20, 0x08, 0x89, 0x0C\n"  /* 0x060388C0 */
    ".byte 0xD3, 0x1A, 0x60, 0x32, 0x20, 0x08, 0x89, 0x08, 0xD6, 0x19, 0xD5, 0x1A, 0xD4, 0x17, 0x66, 0x62\n"  /* 0x060388D0 */
    ".byte 0x46, 0x00, 0xB0, 0xB1, 0x64, 0x42, 0xE2, 0x00, 0x2D, 0x21, 0x85, 0xD1, 0x60, 0x0D, 0x20, 0x08\n"  /* 0x060388E0 */
    ".byte 0x89, 0x0D, 0xD3, 0x15, 0x60, 0x32, 0x20, 0x08, 0x89, 0x09, 0xD6, 0x14, 0xD5, 0x14, 0xD4, 0x12\n"  /* 0x060388F0 */
    ".byte 0x66, 0x62, 0x46, 0x00, 0xB0, 0xA0, 0x64, 0x42, 0xE2, 0x00, 0x60, 0x23, 0x81, 0xD1, 0xD0, 0x11\n"  /* 0x06038900 */
    ".byte 0x60, 0x01, 0xA0, 0x25, 0x60, 0x0D, 0x96, 0x0C, 0xD5, 0x0F, 0xD4, 0x10, 0xB0, 0x94, 0x64, 0x42\n"  /* 0x06038910 */
    ".byte 0xA0, 0x22, 0x00, 0x09, 0x96, 0x06, 0xD5, 0x0C, 0xD4, 0x0C, 0xB0, 0x8D, 0x64, 0x42, 0xA0, 0x1B\n"  /* 0x06038920 */
    ".byte 0x00, 0x09, 0x01, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x06, 0x0A, 0x4C, 0x40, 0x06, 0x0A, 0x4C, 0x44\n"  /* 0x06038930 */
    ".byte 0x06, 0x0A, 0x4C, 0x38, 0x06, 0x0A, 0x3F, 0x68, 0x06, 0x0A, 0x4C, 0x48, 0x06, 0x0A, 0x4C, 0x3C\n"  /* 0x06038940 */
    ".byte 0x06, 0x0A, 0x45, 0xD0, 0x06, 0x06, 0x35, 0xB2, 0x06, 0x0A, 0x3E, 0x68, 0x06, 0x0A, 0x4C, 0x5C\n"  /* 0x06038950 */
    ".byte 0x88, 0x01, 0x89, 0xDF, 0x88, 0x02, 0x89, 0xD6, 0xDE, 0x22, 0xE6, 0x28, 0xD5, 0x22, 0xB0, 0x6B\n"  /* 0x06038960 */
    ".byte 0x64, 0xE2, 0xE6, 0x48, 0xD5, 0x21, 0x64, 0xE2, 0xB0, 0x66, 0x74, 0x28, 0xE6, 0x40, 0xD5, 0x20\n"  /* 0x06038970 */
    ".byte 0x64, 0xE2, 0xB0, 0x61, 0x74, 0x70, 0xE6, 0x10, 0xD5, 0x1E, 0x64, 0xE2, 0x92, 0x30, 0xB0, 0x5B\n"  /* 0x06038980 */
    ".byte 0x34, 0x2C, 0xE6, 0x20, 0xD5, 0x1C, 0x64, 0xE2, 0x92, 0x2B, 0xB0, 0x55, 0x34, 0x2C, 0x4F, 0x26\n"  /* 0x06038990 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x060389A0 */
);

/* FUN_06039808 -- original binary (262 bytes) */
__asm__(
    ".section .text.FUN_06039808, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06039808\n"
    ".type _FUN_06039808, @function\n"
    "_FUN_06039808:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x4F, 0x22, 0x7F, 0xFC, 0x2F, 0x42, 0xD4, 0x25, 0x64, 0x40, 0x64, 0x4C\n"  /* 0x06039808 */
    ".byte 0x60, 0x43, 0x88, 0x01, 0x8D, 0x07, 0xED, 0x00, 0x60, 0x43, 0x88, 0x02, 0x89, 0x03, 0x63, 0xF2\n"  /* 0x06039818 */
    ".byte 0x23, 0xD2, 0xA0, 0x6B, 0xE0, 0x01, 0xE6, 0x10, 0xD5, 0x1E, 0xD4, 0x1F, 0xD3, 0x1F, 0x63, 0x30\n"  /* 0x06039828 */
    ".byte 0x63, 0x3C, 0x23, 0x69, 0x33, 0x60, 0x8B, 0x0C, 0x63, 0x42, 0x73, 0x01, 0x62, 0x33, 0x24, 0x32\n"  /* 0x06039838 */
    ".byte 0xE3, 0x03, 0x32, 0x33, 0x8B, 0x08, 0xE3, 0x01, 0x25, 0x30, 0x62, 0x42, 0x72, 0xFF, 0xA0, 0x03\n"  /* 0x06039848 */
    ".byte 0x24, 0x22, 0x62, 0xDC, 0x25, 0x20, 0x24, 0xD2, 0xD4, 0x15, 0xD3, 0x16, 0x62, 0x42, 0x63, 0x30\n"  /* 0x06039858 */
    ".byte 0x63, 0x3C, 0x32, 0x33, 0x89, 0x04, 0x62, 0x42, 0x72, 0x01, 0x24, 0x22, 0xA0, 0x46, 0xE0, 0x00\n"  /* 0x06039868 */
    ".byte 0x24, 0xD2, 0xDE, 0x11, 0xD3, 0x11, 0xD2, 0x12, 0x63, 0x31, 0x62, 0x22, 0x63, 0x3D, 0x32, 0x33\n"  /* 0x06039878 */
    ".byte 0x89, 0x20, 0x62, 0xE0, 0x72, 0x01, 0x2E, 0x20, 0xE2, 0x03, 0x63, 0xE0, 0x63, 0x3C, 0x33, 0x23\n"  /* 0x06039888 */
    ".byte 0x8B, 0x1A, 0xB7, 0x64, 0x00, 0x09, 0x62, 0xE0, 0x72, 0xFF, 0xA0, 0x15, 0x2E, 0x20, 0xFF, 0xFF\n"  /* 0x06039898 */
    ".byte 0x06, 0x0A, 0x4C, 0xAA, 0x06, 0x06, 0x36, 0x01, 0x06, 0x06, 0x36, 0x08, 0x20, 0x10, 0x00, 0x61\n"  /* 0x060398A8 */
    ".byte 0x06, 0x0A, 0x4C, 0xB8, 0x06, 0x0A, 0x4C, 0xAB, 0x06, 0x06, 0x36, 0x00, 0x06, 0x0A, 0x4C, 0xAC\n"  /* 0x060398B8 */
    ".byte 0x06, 0x0A, 0x4C, 0xB4, 0x62, 0xDC, 0x2E, 0x20, 0xD5, 0x1F, 0xD4, 0x20, 0x63, 0x52, 0x24, 0x32\n"  /* 0x060398C8 */
    ".byte 0xD6, 0x1F, 0x62, 0x62, 0x25, 0x22, 0x63, 0x42, 0x26, 0x32, 0xD6, 0x1E, 0x62, 0x62, 0x24, 0x22\n"  /* 0x060398D8 */
    ".byte 0xD5, 0x1D, 0x63, 0x52, 0x26, 0x32, 0x62, 0x42, 0x25, 0x22, 0x63, 0xF2, 0x23, 0x22, 0xB6, 0xE3\n"  /* 0x060398E8 */
    ".byte 0x00, 0x09, 0x7F, 0x04, 0x4F, 0x26, 0x6D, 0xF6, 0xA7, 0x14, 0x6E, 0xF6, 0x7F, 0x04, 0x4F, 0x26\n"  /* 0x060398F8 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x06039908 */
);
