/* save_deserialize -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BD1C - 0x0603BDAC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Deserializes a save/command block by dispatching to the appropriate
 * handler function from a table indexed by the block's type byte.
 *
 * Checks whether another block is already active in the global command
 * state.  If a different block is active, returns error code 5 without
 * processing.  Otherwise, looks up the block's type byte at offset +0x10,
 * uses it as an index into a handler function table starting at
 * cmd_state_ptr + 4, and calls that handler with the block's first
 * longword field as the argument.
 *
 * On success (handler returns 0), registers this block as the active
 * block at cmd_state_ptr + 0xA8.  If the handler returns 2 and this
 * block is the currently active one, clears the active slot.
 *
 * Args:
 *   r4 = block pointer (save/command block to deserialize)
 *
 * Returns:
 *   r0 = handler result code (0 = success, 2 = done/clear, 5 = busy)
 *
 * Calls (via function table):
 *   handler_fn(block[0])   — dispatched by block type byte at +0x10
 *
 * Pool references:
 *   sym_060A4D14            global command state pointer
 *   sym_060401E4            trivial setter (dest[+24] = value)
 *   nop_stub_evt            no-op event stub
 *   sym_06040C50            returns 0 stub
 *   event_priority_set      set event priority
 *   evt_status_flag_set     set event status flags
 *   evt_cmd_enqueue         enqueue event command
 *   sym_0603F8B8            cmd descriptor field initializer
 */

    .section .text.FUN_0603BD1C


    .global save_deserialize
    .type save_deserialize, @function
save_deserialize:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r13, @-r15                    ! save r13 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    mov r4, r13                         ! r13 = block pointer (preserve across calls)
    add #-0x4, r15                      ! allocate 4 bytes on stack (local var)
    mov.l   .L_pool_cmd_state_ptr, r14  ! r14 = &cmd_state_ptr (global state base pointer)
    mov.w   .L_wpool_0603BD64, r0       ! r0 = 0x00A8 (active block slot offset)
    mov.l @r14, r4                      ! r4 = cmd_state_ptr (dereference pointer-to-pointer)
    mov.l @(r0, r4), r4                 ! r4 = cmd_state[+0xA8] (currently active block)
    tst r4, r4                          ! active block == NULL?
    bt      .no_conflict                ! if NULL, no conflict — proceed
    cmp/eq r13, r4                      ! active block == our block?
    bt      .no_conflict                ! if same block, no conflict — proceed
    bra     .return_result              ! different block is active — return error
    mov #0x5, r0                        ! delay: r0 = 5 (error: another block is busy)
.no_conflict:
    mov #0x10, r0                       ! r0 = 0x10 (type byte offset in block)
    mov.l @r14, r2                      ! r2 = cmd_state_ptr
    mov.b @(r0, r13), r3                ! r3 = block[+0x10] (type/index byte, signed)
    add #0x4, r2                        ! r2 = cmd_state_ptr + 4 (function table base)
    extu.b r3, r3                       ! zero-extend type byte to 32 bits
    shll2 r3                            ! r3 *= 4 (each table entry is 4 bytes)
    shll2 r3                            ! r3 *= 4 (total: type * 16, stride = 16 bytes per entry)
    add r2, r3                          ! r3 = &fn_table[type] (pointer to handler entry)
    mov r3, r2                          ! r2 = handler entry pointer (copy for stack save)
    mov.l r3, @r15                      ! store handler entry pointer on stack
    mov.l @r2, r3                       ! r3 = fn_table[type].handler (function pointer)
    jsr @r3                             ! call handler(r4)
    mov.l @r13, r4                      ! delay: r4 = block[0] (first longword field)
    mov r0, r4                          ! r4 = handler return value
    tst r4, r4                          ! result == 0? (success)
    bf      .check_result_2             ! if nonzero, check if result is 2
    mov.l @r14, r3                      ! r3 = cmd_state_ptr
    mov.w   .L_wpool_0603BD64, r0       ! r0 = 0x00A8 (active block slot offset)
    mov.l r13, @(r0, r3)               ! cmd_state[+0xA8] = our block (register as active)
    bra     .set_return_code            ! jump to return with r4 as result
    nop                                 ! delay slot
.L_wpool_0603BD64:
    .2byte  0x00A8                      ! constant: active block slot offset (+0xA8)
    .2byte  0xFFFF                      ! padding / alignment
    .4byte  sym_060401E4                ! pool: trivial setter (dest[+24] = value)
    .4byte  nop_stub_evt                ! pool: no-op event stub
    .4byte  sym_06040C50                ! pool: returns-zero stub
    .4byte  event_priority_set          ! pool: set event priority
    .4byte  evt_status_flag_set         ! pool: set event status flags
    .4byte  evt_cmd_enqueue             ! pool: enqueue event command
    .4byte  sym_0603F8B8               ! pool: cmd descriptor field initializer
.L_pool_cmd_state_ptr:
    .4byte  sym_060A4D14                ! pool: global command state pointer
.check_result_2:
    mov r4, r0                          ! r0 = handler result
    cmp/eq #0x2, r0                     ! result == 2? (block done, clear active slot)
    bf      .set_return_code            ! if not 2, skip clearing — just return result
    mov.l @r14, r3                      ! r3 = cmd_state_ptr
    .byte   0x90, 0x3D    /* mov.w .L_wpool_0603BE0E, r0 */  ! r0 = 0x00A8 (active slot offset)
    mov.l @(r0, r3), r2                 ! r2 = cmd_state[+0xA8] (currently active block)
    cmp/eq r13, r2                      ! active block == our block?
    bf      .set_return_code            ! if not our block, don't clear — return result
    mov.l @r14, r2                      ! r2 = cmd_state_ptr
    mov #0x0, r3                        ! r3 = 0 (NULL, clear value)
    .byte   0x90, 0x37    /* mov.w .L_wpool_0603BE0E, r0 */  ! r0 = 0x00A8 (active slot offset)
    mov.l r3, @(r0, r2)                 ! cmd_state[+0xA8] = NULL (deregister active block)
.set_return_code:
    mov r4, r0                          ! r0 = result code (return value)
.return_result:
    add #0x4, r15                       ! deallocate stack local
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! delay: restore r14
