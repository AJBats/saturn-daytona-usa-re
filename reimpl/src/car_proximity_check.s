/* car_proximity_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600A914 - 0x0600AA98
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ==========================================================================
 * Car-to-Car Proximity Detection & Collision Dispatch
 * ==========================================================================
 *
 * Checks all car pairs for spatial proximity and dispatches collision
 * response when two cars are close enough. Called once per frame from
 * the main physics update loop.
 *
 * Two phases:
 *   Phase 1 (AI-vs-AI): Nested loop over car pairs (i=1..N-1, j=i+1..N).
 *     For each pair, checks if cars are close enough for collision response.
 *     Calls sym_060316C4 (collision_pair register-save wrapper) which
 *     falls through to collision_impulse for elastic XZ-plane collision.
 *
 *   Phase 2 (player-vs-all): Player car (index 0, stored at car_struct_ptr)
 *     is checked against all AI cars (1..N-1).
 *     Calls sym_06030FC0 (player_proximity register-save wrapper) for
 *     player-specific collision handling.
 *
 * Proximity algorithm (same for both phases):
 *   1. Track position filter: |segment_delta| <= 20
 *      (car[+0x1EC] = track segment index; early-out if cars are too
 *       far apart along the track to possibly collide)
 *   2. Compute 3D position deltas: dX = |X_a - X_b|, dZ = |Z_a - Z_b|
 *   3. Weighted Manhattan distance (octagonal approximation):
 *        if dX > dZ: dist = dX + dZ/4
 *        else:       dist = dZ + dX/4
 *   4. Compare against threshold 0x4B333 (~4.7 in 16.16 fixed-point)
 *   5. Collision cooldown check: car[+0x1B4] < 1.0 (16.16 fixed-point)
 *   6. If close and not cooling down: dispatch to collision handler
 *
 * Persistent registers:
 *   r8  = proximity threshold (0x0004B333)
 *   r9  = loop counter (outer in phase 1, sole counter in phase 2)
 *   r10 = &car_count (pointer to total number of cars)
 *   r11 = inner car struct ptr (phase 1) / player car struct ptr (phase 2)
 *   r12 = car array base address (sym_06078900)
 *   r13 = car struct stride (0x0268 = 616 bytes)
 *   r14 = outer car struct ptr (phase 1) / current AI car ptr (phase 2)
 *
 * Car struct offsets used:
 *   +0x00  flags word (bits 23:21 = active flags, mask 0x00E00000)
 *   +0x10  X position (32-bit 16.16 fixed-point)
 *   +0x18  Z position (32-bit 16.16 fixed-point)
 *   +0x1B4 collision cooldown timer (16.16; >= 1.0 means still cooling)
 *   +0x1EC track segment index (integer, for coarse proximity filter)
 *
 * Car struct stride: 0x268 (616 bytes per car).
 */

    .section .text.FUN_0600A914


    .global car_proximity_check
    .type car_proximity_check, @function
car_proximity_check:
    mov.l r14, @-r15                     ! save r14 (outer car ptr)
    mov.l r13, @-r15                     ! save r13 (car struct stride)
    mov.l r12, @-r15                     ! save r12 (car array base)
    mov.l r11, @-r15                     ! save r11 (inner car / player ptr)
    mov.l r10, @-r15                     ! save r10 (&car_count)
    mov.l r9, @-r15                      ! save r9  (loop counter)
    mov.l r8, @-r15                      ! save r8  (proximity threshold)
    sts.l pr, @-r15                      ! save return address
    sts.l macl, @-r15                    ! save MACL (mul result register)
    mov.l   .L_proximity_threshold, r8   ! r8 = 0x4B333 (~4.7 distance threshold)
    mov.l   .L_car_count, r10            ! r10 = &car_count (sym_0607EA98)
    mov.l   .L_car_array_base, r12       ! r12 = car_array[0] base (sym_06078900)
    mov.w   .L_car_struct_stride, r13    ! r13 = 0x0268 (616 bytes per car)
    mov.l   .L_skip_flag, r0             ! r0 = &skip_flag (sym_0607EAE0)
    mov.l @r0, r0                        ! r0 = skip_flag value
    tst r0, r0                           ! test if skip_flag == 0
    bt      .L_phase1_begin              ! skip_flag clear -> proceed to phase 1
    bra     .L_epilogue                  ! skip_flag set -> exit immediately
    nop                                  ! (delay slot)
.L_phase1_begin:                         ! === Phase 1: AI-vs-AI pair checks ===
    bra     .L_outer_loop_cond           ! jump to outer loop condition test
    mov #0x1, r9                         ! r9 = 1 (start at car index 1; delay slot)
.L_outer_loop_body:                      ! --- outer loop body (car i) ---
    mul.l r13, r9                        ! MACL = stride * i (byte offset to car i)
    mov.l   .L_car_struct_ptr, r3        ! r3 = &car_struct_ptr (sym_0607E940)
    sts macl, r14                        ! r14 = byte offset of car i
    add r12, r14                         ! r14 = &car_array[i] (absolute address)
    mov.l r14, @r3                       ! car_struct_ptr = &car_array[i]
    mov.l @r14, r2                       ! r2 = car_array[i].flags (word at +0x00)
    mov.l   .L_active_flag_mask, r3      ! r3 = 0x00E00000 (bits 23:21)
    and r3, r2                           ! r2 = flags & active_mask
    tst r2, r2                           ! test if any active bits set
    bf      .L_inner_loop_entry          ! nonzero -> car is active, enter inner loop
    bra     .L_outer_loop_incr           ! zero -> car inactive, skip to next outer
    nop                                  ! (delay slot)
.L_inner_loop_entry:                     ! --- inner loop setup (car j) ---
    bra     .L_inner_loop_cond           ! jump to inner loop condition test
    mov r9, r11                          ! r11 = j = i (will be incremented; delay slot)
.L_inner_loop_body:                      ! --- inner loop body (car j vs car i) ---
    mul.l r13, r11                       ! MACL = stride * j (byte offset to car j)
    mov.w   .L_off_track_position, r0    ! r0 = 0x01EC (offset to track segment index)
    sts macl, r5                         ! r5 = byte offset of car j
    mov.l @(r0, r14), r4                 ! r4 = car_i.track_segment (car_i[+0x1EC])
    add r12, r5                          ! r5 = &car_array[j] (absolute address)
    mov.l @(r0, r5), r3                  ! r3 = car_j.track_segment (car_j[+0x1EC])
    sub r3, r4                           ! r4 = segment_delta = seg_i - seg_j
    mov #0x14, r3                        ! r3 = 20 (max segment distance)
    cmp/gt r3, r4                        ! T = (delta > 20)?
    bt      .L_inner_loop_cond           ! delta > 20 -> too far ahead, skip pair
    mov #-0x14, r3                       ! r3 = -20
    cmp/ge r3, r4                        ! T = (delta >= -20)?
    bt      .L_p1_calc_3d_dist           ! delta in [-20, 20] -> within range, check XZ
    bra     .L_inner_loop_cond           ! delta < -20 -> too far behind, skip pair
    nop                                  ! (delay slot)
.L_p1_calc_3d_dist:                      ! --- phase 1: 3D weighted distance check ---
    mov.l @(16, r5), r6                  ! r6 = car_j.X (car_j[+0x10])
    mov.l @(16, r14), r2                 ! r2 = car_i.X (car_i[+0x10])
    mov.l @(24, r5), r4                  ! r4 = car_j.Z (car_j[+0x18])
    mov.l @(24, r14), r3                 ! r3 = car_i.Z (car_i[+0x18])
    sub r2, r6                           ! r6 = dX = X_j - X_i
    cmp/pz r6                            ! T = (dX >= 0)?
    bt/s    .L_p1_dx_positive            ! dX >= 0 -> keep sign
    sub r3, r4                           ! r4 = dZ = Z_j - Z_i (delay slot)
    neg r6, r6                           ! dX < 0 -> r6 = |dX|
.L_p1_dx_positive:                       ! r6 = |dX|, r4 = dZ (may be negative)
    cmp/pz r4                            ! T = (dZ >= 0)?
    bt      .L_p1_dz_positive            ! dZ >= 0 -> keep sign
    neg r4, r4                           ! dZ < 0 -> r4 = |dZ|
.L_p1_dz_positive:                       ! r6 = |dX|, r4 = |dZ|
    cmp/gt r4, r6                        ! T = (|dX| > |dZ|)?
    bf      .L_p1_dz_dominant            ! |dX| <= |dZ| -> Z is larger component
    shar r4                              ! |dZ| >> 1 (first shift of divide-by-4)
    bra     .L_p1_combine_dist           ! -> combine: dist = |dX| + |dZ|/4
    shar r4                              ! |dZ| >> 2 (second shift; delay slot)
.L_car_struct_stride:
    .2byte  0x0268                        /* car struct size (616 bytes) */
.L_off_track_position:
    .2byte  0x01EC                        /* car offset: track segment index */
    .2byte  0xFFFF
.L_proximity_threshold:
    .4byte  0x0004B333                  /* distance threshold (~4.7 in 16.16) */
.L_car_count:
    .4byte  sym_0607EA98               /* total car count */
.L_car_array_base:
    .4byte  sym_06078900               /* car array start address */
.L_skip_flag:
    .4byte  sym_0607EAE0               /* proximity check skip flag */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_active_flag_mask:
    .4byte  0x00E00000                  /* bits 23:21: car active flags */
.L_p1_dz_dominant:                       ! |dZ| >= |dX|: X is the smaller component
    mov r6, r2                           ! r2 = |dX| (copy for shifting)
    shar r2                              ! |dX| >> 1 (first shift of divide-by-4)
    shar r2                              ! |dX| >> 2 (second shift; r2 = |dX|/4)
    mov r2, r6                           ! r6 = |dX|/4 (smaller component / 4)
.L_p1_combine_dist:                      ! r6 = larger, r4 = smaller/4 (or vice versa after dz_dominant)
    add r4, r6                           ! r6 = weighted distance (larger + smaller/4)
    cmp/ge r8, r6                        ! T = (dist >= threshold)?
    bt      .L_inner_loop_cond           ! distance >= 0x4B333 -> too far, skip pair
    mov.w   DAT_0600aa7e, r0             ! r0 = 0x01B4 (offset to collision cooldown)
    mov.l   .L_fp_one, r3                ! r3 = 0x00010000 (1.0 in 16.16 fixed-point)
    mov.l @(r0, r5), r2                  ! r2 = car_j.cooldown (car_j[+0x1B4])
    cmp/ge r3, r2                        ! T = (cooldown >= 1.0)?
    bt      .L_inner_loop_cond           ! cooldown active -> skip pair (still cooling)
    mov.l   .L_fn_collision_pair, r3     ! r3 = &collision_pair_wrapper (sym_060316C4)
    jsr @r3                              ! call collision_pair(car_i, car_j)
    mov r14, r4                          ! r4 = car_i ptr (arg 1; delay slot)
.L_inner_loop_cond:                      ! --- inner loop increment & condition ---
    add #0x1, r11                        ! j++
    mov.l @r10, r2                       ! r2 = car_count
    cmp/hs r2, r11                       ! T = (j >= car_count)? (unsigned)
    bf      .L_inner_loop_body           ! j < car_count -> next inner iteration
.L_outer_loop_incr:                      ! --- outer loop increment ---
    add #0x1, r9                         ! i++
.L_outer_loop_cond:                      ! --- outer loop condition ---
    mov.l @r10, r2                       ! r2 = car_count
    add #-0x1, r2                        ! r2 = car_count - 1
    cmp/hs r2, r9                        ! T = (i >= car_count - 1)? (unsigned)
    bf      .L_outer_loop_body           ! i < car_count-1 -> next outer iteration
    mov.l   .L_car_struct_ptr_2, r3      ! === Phase 2: player-vs-all AI cars ===
    mov.l r12, @r3                       ! car_struct_ptr = car_array base (player = car[0])
    mov r3, r11                          ! r11 = &car_struct_ptr
    mov.l @r11, r11                      ! r11 = car_array[0] (player car struct ptr)
    bra     .L_p2_loop_cond              ! jump to phase 2 loop condition test
    mov #0x1, r9                         ! r9 = 1 (start at AI car index 1; delay slot)
.L_p2_loop_body:                         ! --- phase 2 loop body (player vs car i) ---
    mul.l r13, r9                        ! MACL = stride * i (byte offset to car i)
    mov.l   .L_active_flag_mask_2, r2    ! r2 = 0x00E00000 (active flag mask)
    sts macl, r14                        ! r14 = byte offset of car i
    add r12, r14                         ! r14 = &car_array[i] (absolute address)
    mov.l @r14, r3                       ! r3 = car_array[i].flags (word at +0x00)
    and r2, r3                           ! r3 = flags & active_mask
    tst r3, r3                           ! test if any active bits set
    bf      .L_p2_check_track_pos        ! nonzero -> car active, check proximity
    bra     .L_p2_loop_incr              ! zero -> car inactive, skip to next
    nop                                  ! (delay slot)
.L_p2_check_track_pos:                   ! --- phase 2: track position filter ---
    mov.w   .L_off_track_position_2, r0  ! r0 = 0x01EC (offset to track segment index)
    mov #0x14, r3                        ! r3 = 20 (max segment distance)
    mov.l @(r0, r11), r4                 ! r4 = player.track_segment (player[+0x1EC])
    mov.l @(r0, r14), r2                 ! r2 = car_i.track_segment (car_i[+0x1EC])
    sub r2, r4                           ! r4 = segment_delta = player_seg - car_seg
    cmp/gt r3, r4                        ! T = (delta > 20)?
    bt      .L_p2_loop_incr              ! delta > 20 -> too far ahead, skip
    mov #-0x14, r3                       ! r3 = -20
    cmp/ge r3, r4                        ! T = (delta >= -20)?
    bt      .L_p2_calc_3d_dist           ! delta in [-20, 20] -> within range, check XZ
    bra     .L_p2_loop_incr              ! delta < -20 -> too far behind, skip
    nop                                  ! (delay slot)
.L_p2_calc_3d_dist:                      ! --- phase 2: 3D weighted distance check ---
    mov.l @(16, r14), r6                 ! r6 = car_i.X (car_i[+0x10])
    mov.l @(16, r11), r2                 ! r2 = player.X (player[+0x10])
    mov.l @(24, r14), r4                 ! r4 = car_i.Z (car_i[+0x18])
    mov.l @(24, r11), r3                 ! r3 = player.Z (player[+0x18])
    sub r2, r6                           ! r6 = dX = car_X - player_X
    cmp/pz r6                            ! T = (dX >= 0)?
    bt/s    .L_p2_dx_positive            ! dX >= 0 -> keep sign
    sub r3, r4                           ! r4 = dZ = car_Z - player_Z (delay slot)
    neg r6, r6                           ! dX < 0 -> r6 = |dX|
.L_p2_dx_positive:                       ! r6 = |dX|, r4 = dZ (may be negative)
    cmp/pz r4                            ! T = (dZ >= 0)?
    bt      .L_p2_dz_positive            ! dZ >= 0 -> keep sign
    neg r4, r4                           ! dZ < 0 -> r4 = |dZ|
.L_p2_dz_positive:                       ! r6 = |dX|, r4 = |dZ|
    cmp/gt r4, r6                        ! T = (|dX| > |dZ|)?
    bf      .L_p2_dz_dominant            ! |dX| <= |dZ| -> Z is larger component
    shar r4                              ! |dZ| >> 1 (first shift of divide-by-4)
    bra     .L_p2_combine_dist           ! -> combine: dist = |dX| + |dZ|/4
    shar r4                              ! |dZ| >> 2 (second shift; delay slot)
.L_p2_dz_dominant:                       ! |dZ| >= |dX|: X is the smaller component
    mov r6, r2                           ! r2 = |dX| (copy for shifting)
    shar r2                              ! |dX| >> 1 (first shift of divide-by-4)
    shar r2                              ! |dX| >> 2 (second shift; r2 = |dX|/4)
    mov r2, r6                           ! r6 = |dX|/4 (smaller component / 4)
.L_p2_combine_dist:                      ! r6 = weighted distance
    add r4, r6                           ! r6 = weighted distance (larger + smaller/4)
    cmp/ge r8, r6                        ! T = (dist >= threshold)?
    bt      .L_p2_loop_incr              ! distance >= 0x4B333 -> too far, skip
    mov.w   DAT_0600aa7e, r0             ! r0 = 0x01B4 (offset to collision cooldown)
    mov.l   .L_fp_one, r3                ! r3 = 0x00010000 (1.0 in 16.16 fixed-point)
    mov.l @(r0, r14), r2                 ! r2 = car_i.cooldown (car_i[+0x1B4])
    cmp/ge r3, r2                        ! T = (cooldown >= 1.0)?
    bt      .L_p2_loop_incr              ! cooldown active -> skip (still cooling)
    mov r14, r5                          ! r5 = car_i ptr (arg 2)
    mov.l   .L_fn_player_proximity, r3   ! r3 = &player_proximity_wrapper (sym_06030FC0)
    jsr @r3                              ! call player_proximity(player, car_i)
    mov r11, r4                          ! r4 = player ptr (arg 1; delay slot)
.L_p2_loop_incr:                         ! --- phase 2 loop increment ---
    add #0x1, r9                         ! i++
.L_p2_loop_cond:                         ! --- phase 2 loop condition ---
    mov.l @r10, r2                       ! r2 = car_count
    cmp/hs r2, r9                        ! T = (i >= car_count)? (unsigned)
    bf      .L_p2_loop_body              ! i < car_count -> next phase 2 iteration
.L_epilogue:                             ! === function epilogue: restore registers ===
    lds.l @r15+, macl                    ! restore MACL
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r8                      ! restore r8
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return to caller
    mov.l @r15+, r14                     ! restore r14 (delay slot)

    .global DAT_0600aa7e
DAT_0600aa7e:
    .2byte  0x01B4                        /* car offset: collision cooldown timer */
.L_off_track_position_2:
    .2byte  0x01EC                        /* car offset: track segment index (dup) */
    .2byte  0xFFFF
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_fn_collision_pair:
    .4byte  sym_060316C4               /* car-to-car collision response wrapper */
.L_car_struct_ptr_2:
    .4byte  sym_0607E940               /* car struct pointer (dup for phase 2) */
.L_active_flag_mask_2:
    .4byte  0x00E00000                  /* active flag mask (dup for phase 2) */
.L_fn_player_proximity:
    .4byte  sym_06030FC0               /* player proximity collision wrapper */
