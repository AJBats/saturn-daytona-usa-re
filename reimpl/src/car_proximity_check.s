/* car_proximity_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600A914 - 0x0600AA98
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Car-to-car proximity detection — checks all car pairs for spatial
 * proximity and dispatches collision response when cars are close enough.
 *
 * Two phases:
 *   Phase 1 (car-to-car): Nested loop over car pairs (i=1..N-1, j=i+1..N).
 *     For each pair, check if cars are close enough for collision response.
 *   Phase 2 (player vs all): Player car (stored via car_struct_ptr) is
 *     checked against all other cars.
 *
 * Proximity algorithm (same for both phases):
 *   1. Check track position delta (car[+0x1EC]): |delta| <= 20 segments
 *   2. Compute 3D position deltas: dX = |X_a - X_b|, dZ = |Z_a - Z_b|
 *   3. Weighted distance: if dX > dZ → dist = dZ/4 + dX
 *                         else      → dist = dX/4 + dZ
 *   4. Compare against threshold (0x4B333 ≈ 4.7 in 16.16 fixed-point)
 *   5. Check car[+0x1B4] < 1.0 (not in collision cooldown)
 *   6. If close: call collision_pair (phase 1) or player_proximity (phase 2)
 *
 * Persistent registers:
 *   r8  = proximity threshold (0x0004B333)
 *   r9  = loop counter (outer)
 *   r10 = &car_count
 *   r11 = inner car struct / player struct (phase 2)
 *   r12 = car array base address (sym_06078900)
 *   r13 = car struct stride (0x0268 = 616 bytes)
 *   r14 = outer car struct
 *
 * Car struct stride confirmed: 0x268 (616 bytes per car).
 */

    .section .text.FUN_0600A914


    .global car_proximity_check
    .type car_proximity_check, @function
car_proximity_check:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    mov.l   .L_proximity_threshold, r8  /* 0x4B333 ≈ 4.7 (16.16 distance) */
    mov.l   .L_car_count, r10
    mov.l   .L_car_array_base, r12
    mov.w   .L_car_struct_stride, r13   /* 0x0268 = 616 bytes per car */
    mov.l   .L_skip_flag, r0
    mov.l @r0, r0
    tst r0, r0
    bt      .L_0600A93A              /* skip flag clear → proceed */
    bra     .L_0600AA6A              /* skip flag set → exit */
    nop
.L_0600A93A:                              /* === Phase 1: car-to-car pairs === */
    bra     .L_0600A9E0              /* → outer loop condition */
    mov #0x1, r9                      /* r9 = 1 (start at car 1) */
.L_0600A93E:                              /* --- outer loop body --- */
    mul.l r13, r9                     /* offset = stride * index */
    mov.l   .L_car_struct_ptr, r3
    sts macl, r14
    add r12, r14                      /* r14 = &car_array[i] */
    mov.l r14, @r3                    /* store as current car */
    mov.l @r14, r2                    /* car[0] = flags word */
    mov.l   .L_active_flag_mask, r3
    and r3, r2                        /* check bits 23:21 (active) */
    tst r2, r2
    bf      .L_0600A956              /* car active → inner loop */
    bra     .L_0600A9DE              /* car inactive → next outer */
    nop
.L_0600A956:                              /* --- inner loop start --- */
    bra     .L_0600A9D6              /* → inner loop condition */
    mov r9, r11                       /* r11 = j (starts at i) */
.L_0600A95A:                              /* --- inner loop body --- */
    mul.l r13, r11
    mov.w   .L_off_track_position, r0 /* +0x1EC = track position */
    sts macl, r5
    mov.l @(r0, r14), r4             /* car_i track position */
    add r12, r5                       /* r5 = &car_array[j] */
    mov.l @(r0, r5), r3              /* car_j track position */
    sub r3, r4                        /* delta = pos_i - pos_j */
    mov #0x14, r3                     /* 20 = max segment distance */
    cmp/gt r3, r4
    bt      .L_0600A9D6              /* delta > 20 → too far */
    mov #-0x14, r3
    cmp/ge r3, r4
    bt      .L_0600A978              /* delta >= -20 → within range */
    bra     .L_0600A9D6              /* delta < -20 → too far */
    nop
.L_0600A978:                              /* --- 3D distance calculation --- */
    mov.l @(16, r5), r6              /* car_j X position */
    mov.l @(16, r14), r2             /* car_i X position */
    mov.l @(24, r5), r4              /* car_j Z position */
    mov.l @(24, r14), r3             /* car_i Z position */
    sub r2, r6                        /* dX = X_j - X_i */
    cmp/pz r6
    bt/s    .L_0600A98A              /* dX >= 0 → keep */
    sub r3, r4                        /* dZ = Z_j - Z_i */
    neg r6, r6                        /* dX = |dX| */
.L_0600A98A:
    cmp/pz r4
    bt      .L_0600A990
    neg r4, r4                        /* dZ = |dZ| */
.L_0600A990:
    cmp/gt r4, r6                     /* dX > dZ? */
    bf      .L_0600A9B8              /* no → dZ is larger */
    shar r4                           /* dZ >> 2 (divide by 4) */
    bra     .L_0600A9C0
    shar r4
.L_car_struct_stride:
    .2byte  0x0268                        /* car struct size (616 bytes) */
.L_off_track_position:
    .2byte  0x01EC                        /* car offset: track position */
    .2byte  0xFFFF
.L_proximity_threshold:
    .4byte  0x0004B333                  /* distance threshold (~4.7 in 16.16) */
.L_car_count:
    .4byte  sym_0607EA98               /* total car count */
.L_car_array_base:
    .4byte  sym_06078900               /* car array start address */
.L_skip_flag:
    .4byte  sym_0607EAE0               /* proximity check skip flag */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_active_flag_mask:
    .4byte  0x00E00000                  /* bits 23:21: car active flags */
.L_0600A9B8:                              /* dZ >= dX: dX is smaller component */
    mov r6, r2
    shar r2                           /* dX >> 2 (divide by 4) */
    shar r2
    mov r2, r6                        /* r6 = dX/4 */
.L_0600A9C0:                              /* r6 = smaller/4, r4 = larger (or vice versa) */
    add r4, r6                        /* weighted distance = larger + smaller/4 */
    cmp/ge r8, r6
    bt      .L_0600A9D6              /* distance >= threshold → too far */
    mov.w   DAT_0600aa7e, r0         /* +0x1B4 = collision cooldown */
    mov.l   .L_fp_one, r3            /* 1.0 in 16.16 */
    mov.l @(r0, r5), r2              /* car_j cooldown */
    cmp/ge r3, r2
    bt      .L_0600A9D6              /* cooldown >= 1.0 → skip (still cooling) */
    mov.l   .L_fn_collision_pair, r3
    jsr @r3                            /* collision_pair(car_i) */
    mov r14, r4
.L_0600A9D6:                              /* --- inner loop increment --- */
    add #0x1, r11
    mov.l @r10, r2
    cmp/hs r2, r11
    bf      .L_0600A95A              /* j < count → next inner */
.L_0600A9DE:                              /* --- outer loop increment --- */
    add #0x1, r9
.L_0600A9E0:                              /* --- outer loop condition --- */
    mov.l @r10, r2
    add #-0x1, r2
    cmp/hs r2, r9
    bf      .L_0600A93E              /* i < count-1 → next outer */
    mov.l   .L_car_struct_ptr_2, r3  /* === Phase 2: player vs all === */
    mov.l r12, @r3                    /* set car_struct_ptr = array base */
    mov r3, r11
    mov.l @r11, r11                   /* r11 = player car struct */
    bra     .L_0600AA64              /* → loop condition */
    mov #0x1, r9                      /* start at car 1 */
.L_0600A9F4:                              /* --- phase 2 loop body --- */
    mul.l r13, r9
    mov.l   .L_active_flag_mask_2, r2
    sts macl, r14
    add r12, r14                      /* r14 = &car_array[i] */
    mov.l @r14, r3                    /* car flags */
    and r2, r3
    tst r3, r3
    bf      .L_0600AA08              /* car active → check proximity */
    bra     .L_0600AA62              /* inactive → next */
    nop
.L_0600AA08:                              /* --- track position check (player vs car) --- */
    mov.w   .L_off_track_position_2, r0
    mov #0x14, r3
    mov.l @(r0, r11), r4             /* player track position */
    mov.l @(r0, r14), r2             /* car_i track position */
    sub r2, r4
    cmp/gt r3, r4
    bt      .L_0600AA62              /* delta > 20 → too far */
    mov #-0x14, r3
    cmp/ge r3, r4
    bt      .L_0600AA20
    bra     .L_0600AA62
    nop
.L_0600AA20:                              /* --- 3D distance (player vs car) --- */
    mov.l @(16, r14), r6             /* car X */
    mov.l @(16, r11), r2             /* player X */
    mov.l @(24, r14), r4             /* car Z */
    mov.l @(24, r11), r3             /* player Z */
    sub r2, r6
    cmp/pz r6
    bt/s    .L_0600AA32
    sub r3, r4
    neg r6, r6
.L_0600AA32:
    cmp/pz r4
    bt      .L_0600AA38
    neg r4, r4
.L_0600AA38:
    cmp/gt r4, r6
    bf      .L_0600AA42
    shar r4
    bra     .L_0600AA4A
    shar r4
.L_0600AA42:
    mov r6, r2
    shar r2
    shar r2
    mov r2, r6
.L_0600AA4A:
    add r4, r6                        /* weighted distance */
    cmp/ge r8, r6
    bt      .L_0600AA62              /* too far */
    mov.w   DAT_0600aa7e, r0
    mov.l   .L_fp_one, r3
    mov.l @(r0, r14), r2
    cmp/ge r3, r2
    bt      .L_0600AA62              /* cooling down */
    mov r14, r5
    mov.l   .L_fn_player_proximity, r3
    jsr @r3                            /* player_proximity(player, car_i) */
    mov r11, r4
.L_0600AA62:
    add #0x1, r9
.L_0600AA64:
    mov.l @r10, r2
    cmp/hs r2, r9
    bf      .L_0600A9F4
.L_0600AA6A:
    lds.l @r15+, macl
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14

    .global DAT_0600aa7e
DAT_0600aa7e:
    .2byte  0x01B4                        /* car offset: collision cooldown timer */
.L_off_track_position_2:
    .2byte  0x01EC                        /* car offset: track position (dup) */
    .2byte  0xFFFF
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_fn_collision_pair:
    .4byte  sym_060316C4               /* car-to-car collision response */
.L_car_struct_ptr_2:
    .4byte  sym_0607E940               /* car struct pointer (dup for phase 2) */
.L_active_flag_mask_2:
    .4byte  0x00E00000                  /* active flag mask (dup for phase 2) */
.L_fn_player_proximity:
    .4byte  sym_06030FC0               /* player proximity collision handler */
