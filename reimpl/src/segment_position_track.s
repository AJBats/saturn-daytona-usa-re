/* segment_position_track -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06005ECC - 0x060061C8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Updates track segment position tracking across 8 geometry channels.
 * For each channel, transforms position parameters through a Y-rotation
 * matrix, accumulates X/Y/Z deltas from the car array, then computes
 * per-channel atan2 heading and stores via scene_render_alt.
 *
 * After channel updates, averages Y-positions across 4 primary channels,
 * transforms the averaged vector, and computes yaw (offset +0x1C) and
 * pitch (offset +0x24) angles via atan2.  The angle scale factor is
 * chosen based on attract cycle state and a segment distance threshold:
 *   - Close scale (0x0002CCCC) when segments are nearby
 *   - Wide scale  (0x000D6666) otherwise
 *
 * Finally decrements the global position counter by 0x30.
 *
 * Register plan:
 *   r8  = geom channel 3 data ptr
 *   r9  = geom channel 0 data ptr
 *   r10 = geom channel 2 data ptr
 *   r12 = geom channel 1 data ptr
 *   r13 = X delta from car array (offset +0x10)
 *   r11 = Z delta from car array (offset +0x18)
 *   r14 = car array entry pointer
 *   @r15 = Y delta from car array (offset +0x14)
 */

    .section .text.FUN_06005ECC


    .global segment_position_track
    .type segment_position_track, @function
segment_position_track:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x1C, r15                    ! allocate 0x1C bytes of local frame
    mov.l   .L_geom_ch3_data, r8       ! r8 = &geom_ch3
    mov.l   .L_geom_ch0_data, r9       ! r9 = &geom_ch0
    mov.l   .L_geom_ch2_data, r10      ! r10 = &geom_ch2
    mov.l   .L_geom_ch1_data, r12      ! r12 = &geom_ch1
    mov.l   .L_car_array_base_ptr, r14
    mov.l @r14, r14                     ! r14 = car array entry
    mov.l @(16, r14), r13              ! r13 = delta_x (16.16 fixed)
    mov.l @(20, r14), r3
    mov.l r3, @r15                      ! @r15 = delta_y
    mov.l   .L_fn_pre_transform_setup, r3
    jsr @r3                             ! pre_transform_setup()
    mov.l @(24, r14), r11              ! r11 = delta_z (delay slot)
    mov.l   .L_fn_transform_push, r3
    jsr @r3                             ! transform_push() — save current matrix
    nop
    mov.l @(32, r14), r4               ! r4 = base heading angle
    mov.l   .L_rotation_angle_src, r2
    mov.l   .L_fn_mat_rot_y, r3
    mov.l @r2, r2                       ! r2 = rotation offset
    jsr @r3                             ! mat_rot_y(heading + offset)
    add r2, r4                          ! r4 = heading + offset (delay slot)
    ! --- Transform 8 position vectors through rotated matrix ---
    mov.l   .L_xform_params_ch1, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch1_params, ch0_data)
    mov r9, r5
    mov.l   .L_xform_params_ch0, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch0_params, ch1_data)
    mov r12, r5
    mov.l   .L_xform_params_ch3, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch3_params, ch3_data)
    mov r8, r5
    mov.l   .L_xform_params_ch2, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch2_params, ch2_data)
    mov r10, r5
    mov.l   .L_geom_ch4_data, r5
    mov.l   .L_xform_params_ch4, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch4_params, ch4_data)
    nop
    mov.l   .L_geom_ch5_data, r5
    mov.l   .L_xform_params_ch5, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch5_params, ch5_data)
    nop
    mov.l   .L_geom_ch7_data, r5
    mov.l   .L_xform_params_ch7, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch7_params, ch7_data)
    nop
    mov.l   .L_geom_ch6_data, r5
    mov.l   .L_xform_params_ch6, r4
    mov.l   .L_fn_mat_vec_transform, r3
    jsr @r3                             ! mat_vec_transform(ch6_params, ch6_data)
    nop
    ! --- Accumulate X/Y/Z deltas into channels 0-3 ---
    mov.l @r9, r2                       ! ch0.x += delta_x
    add r13, r2
    mov.l r2, @r9
    mov.l @r15, r3
    mov.l @(4, r9), r2                  ! ch0.y += delta_y
    add r3, r2
    mov.l r2, @(4, r9)
    mov.l @(8, r9), r3                  ! ch0.z += delta_z
    add r11, r3
    mov.l r3, @(8, r9)
    mov.l @r12, r2                      ! ch1.x += delta_x
    add r13, r2
    mov.l r2, @r12
    mov.l @r15, r3
    mov.l @(4, r12), r2                 ! ch1.y += delta_y
    add r3, r2
    mov.l r2, @(4, r12)
    mov.l @(8, r12), r3                 ! ch1.z += delta_z
    add r11, r3
    mov.l r3, @(8, r12)
    mov.l @r8, r2                       ! ch3.x += delta_x
    add r13, r2
    mov.l r2, @r8
    mov.l @r15, r3
    mov.l @(4, r8), r2                  ! ch3.y += delta_y
    add r3, r2
    mov.l r2, @(4, r8)
    mov.l @(8, r8), r3                  ! ch3.z += delta_z
    add r11, r3
    mov.l r3, @(8, r8)
    mov.l @r10, r2                      ! ch2.x += delta_x
    add r13, r2
    mov.l r2, @r10
    mov.l @r15, r3
    mov.l @(4, r10), r2                 ! ch2.y += delta_y
    add r3, r2
    mov.l r2, @(4, r10)
    mov.l @(8, r10), r3                 ! ch2.z += delta_z
    add r11, r3
    mov.l r3, @(8, r10)
    ! --- Accumulate X/Z deltas into channels 4-5 (Y skipped) ---
    mov.l   .L_geom_ch4_data, r4
    mov.l @r4, r2                       ! ch4.x += delta_x
    add r13, r2
    mov.l r2, @r4
    mov.l @(8, r4), r3                  ! ch4.z += delta_z
    add r11, r3
    mov.l r3, @(8, r4)
    mov.l   .L_geom_ch5_data, r4
    mov.l @r4, r2                       ! ch5.x += delta_x
    add r13, r2
    mov.l r2, @r4
    mov.l @(8, r4), r3                  ! ch5.z += delta_z
    add r11, r3
    bra     .L_continue_delta_accum
    nop
    .2byte  0xFFFF
    ! --- Constant pool 1: channel data + transform parameters ---
.L_geom_ch3_data:
    .4byte  sym_06063E88                /* geometry channel 3 position data */
.L_geom_ch0_data:
    .4byte  sym_06063E4C                /* geometry channel 0 position data */
.L_geom_ch2_data:
    .4byte  sym_06063E74                /* geometry channel 2 position data */
.L_geom_ch1_data:
    .4byte  sym_06063E60                /* geometry channel 1 position data */
.L_car_array_base_ptr:
    .4byte  sym_0607E944                /* car array base pointer (ptr-to-ptr) */
.L_fn_pre_transform_setup:
    .4byte  sym_06026DBC                /* per-object pre-transform setup */
.L_fn_transform_push:
    .4byte  sym_06026E0C                /* push/save current transform state */
.L_rotation_angle_src:
    .4byte  sym_06063F10                /* global Y-rotation angle offset */
.L_fn_mat_rot_y:
    .4byte  mat_rot_y                   /* build Y-axis rotation matrix */
.L_xform_params_ch1:
    .4byte  sym_0604464C                /* channel 1 XYZ transform params */
.L_fn_mat_vec_transform:
    .4byte  mat_vec_transform           /* matrix-vector transform */
.L_xform_params_ch0:
    .4byte  sym_06044640                /* channel 0 XYZ transform params */
.L_xform_params_ch3:
    .4byte  sym_06044658                /* channel 3 XYZ transform params */
.L_xform_params_ch2:
    .4byte  sym_06044664                /* channel 2 XYZ transform params */
.L_geom_ch4_data:
    .4byte  sym_06063E9C                /* geometry channel 4 position data */
.L_xform_params_ch4:
    .4byte  sym_06044688                /* channel 4 XYZ transform params */
.L_geom_ch5_data:
    .4byte  sym_06063EB0                /* geometry channel 5 position data */
.L_xform_params_ch5:
    .4byte  sym_0604467C                /* channel 5 XYZ transform params */
.L_geom_ch7_data:
    .4byte  sym_06063ED8                /* geometry channel 7 position data */
.L_xform_params_ch7:
    .4byte  sym_06044694                /* channel 7 XYZ transform params */
.L_geom_ch6_data:
    .4byte  sym_06063EC4                /* geometry channel 6 position data */
.L_xform_params_ch6:
    .4byte  sym_060446A0                /* channel 6 XYZ transform params */
    ! --- Accumulate X/Z deltas into channels 6-7 ---
.L_continue_delta_accum:
    mov.l r3, @(8, r4)                  ! store ch5.z (from before bra)
    mov r9, r6                          ! r6 = ch0 data ptr
    mov.l   .L_geom_ch7_data_2, r4
    add #0xE, r6                        ! r6 = &ch0.heading (offset +0xE)
    mov.l @r4, r2                       ! ch7.x += delta_x
    add r13, r2
    mov.l r2, @r4
    mov.l @(8, r4), r3                  ! ch7.z += delta_z
    add r11, r3
    mov.l r3, @(8, r4)
    mov.l   .L_geom_ch6_data_2, r4
    mov.l @r4, r2                       ! ch6.x += delta_x
    add r13, r2
    mov.l r2, @r4
    mov.l @(8, r4), r3                  ! ch6.z += delta_z
    add r11, r3
    mov.l r3, @(8, r4)
    ! --- Compute heading for each primary channel: atan2(x, z) + render ---
    mov.l r6, @-r15                     ! push &ch0.heading
    mov.l @(8, r9), r5                  ! r5 = ch0.z
    mov.l   .L_fn_atan2_xy, r3
    jsr @r3                             ! r0 = atan2(ch0.x, ch0.z)
    mov.l @r9, r4                       ! r4 = ch0.x (delay slot)
    mov r0, r4                          ! r4 = heading angle
    mov r9, r5                          ! r5 = &ch0
    mov.l   .L_fn_scene_render_alt, r3
    jsr @r3                             ! scene_render_alt(heading, &ch0, &ch0.heading)
    mov.l @r15+, r6                     ! r6 = &ch0.heading (delay slot)
    mov r12, r6                         ! r6 = &ch1
    add #0xE, r6                        ! r6 = &ch1.heading
    mov.l r6, @-r15
    mov.l @(8, r12), r5
    mov.l   .L_fn_atan2_xy, r3
    jsr @r3                             ! r0 = atan2(ch1.x, ch1.z)
    mov.l @r12, r4
    mov r0, r4
    mov r12, r5
    mov.l   .L_fn_scene_render_alt, r3
    jsr @r3                             ! scene_render_alt(heading, &ch1, &ch1.heading)
    mov.l @r15+, r6
    mov r8, r6
    add #0xE, r6                        ! r6 = &ch3.heading
    mov.l r6, @-r15
    mov.l @(8, r8), r5
    mov.l   .L_fn_atan2_xy, r3
    jsr @r3                             ! r0 = atan2(ch3.x, ch3.z)
    mov.l @r8, r4
    mov r0, r4
    mov r8, r5
    mov.l   .L_fn_scene_render_alt, r3
    jsr @r3                             ! scene_render_alt(heading, &ch3, &ch3.heading)
    mov.l @r15+, r6
    mov r10, r6
    add #0xE, r6                        ! r6 = &ch2.heading
    mov.l r6, @-r15
    mov.l @(8, r10), r5
    mov.l   .L_fn_atan2_xy, r3
    jsr @r3                             ! r0 = atan2(ch2.x, ch2.z)
    mov.l @r10, r4
    mov r0, r4
    mov r10, r5
    mov.l   .L_fn_scene_render_alt, r3
    jsr @r3                             ! scene_render_alt(heading, &ch2, &ch2.heading)
    mov.l @r15+, r6
    ! --- Average Y-positions across 4 primary channels ---
    mov r15, r5
    mov.l @(4, r12), r2                 ! r2 = ch1.y
    mov.l @(4, r9), r3                  ! r3 = ch0.y
    mov.l @(4, r8), r1                  ! r1 = ch3.y
    add r3, r2                          ! r2 = ch1.y + ch0.y
    add r1, r2                          ! r2 += ch3.y
    mov.l @(4, r10), r3                 ! r3 = ch2.y
    add r3, r2                          ! r2 = sum of all 4 Y values
    mov r2, r3
    shar r3                             ! r3 >>= 1 (arithmetic)
    shar r3                             ! r3 >>= 1 → avg = sum / 4
    mov.l r3, @r15                      ! store avg_y on stack
    mov.l r3, @(20, r14)               ! car_array[5] = avg_y
    mov.l   .L_xform_params_avg, r4
    mov.l   .L_fn_mat_vec_transform_2, r3
    jsr @r3                             ! mat_vec_transform(avg_params, &stack[4])
    add #0x10, r5                       ! r5 = &stack[0x10] (delay slot)
    ! --- Accumulate deltas into averaged position on stack ---
    mov.l @(16, r15), r2               ! stack[4].x
    mov r15, r6
    add r13, r2                         ! += delta_x
    add #0x4, r6                        ! r6 = &stack[1]
    mov.l r2, @(16, r15)
    mov.l @r15, r3                      ! avg_y
    mov.l @(20, r15), r2               ! stack[5].y
    add r3, r2                          ! += avg_y
    mov.l r2, @(20, r15)
    mov.l @(24, r15), r2               ! stack[6].z
    add r11, r2                         ! += delta_z
    mov.l r2, @(24, r15)
    ! --- Compute heading for averaged position ---
    mov.l r6, @-r15                     ! push &stack[1]
    mov r15, r5
    add #0x14, r5
    mov.l r5, @-r15                     ! push &stack[5]
    mov.l @(32, r15), r5               ! r5 = stack[6].z (adjusted for pushes)
    mov.l   .L_fn_atan2_xy, r2
    jsr @r2                             ! r0 = atan2(avg.x, avg.z)
    mov.l @(24, r15), r4               ! r4 = stack[4].x (delay slot)
    mov r0, r4                          ! r4 = average heading
    mov.l @r15+, r5
    mov.l   .L_fn_scene_render_alt, r3
    jsr @r3                             ! scene_render_alt(heading, &stack[5], &stack[1])
    mov.l @r15+, r6
    ! --- Select angle scale: close vs wide ---
    mov.l @r15, r2                      ! r2 = avg_y (on stack)
    mov.l @(20, r15), r3               ! r3 = stack[5].y (transformed)
    cmp/eq r3, r2                       ! if avg_y == transformed_y
    bt      .L_use_close_scale          !   → use close scale
    mov.l   .L_attract_cycle_counter, r0
    mov.l @r0, r0                       ! r0 = attract cycle state
    cmp/eq #0x1, r0                     ! if state != 1
    bf      .L_use_wide_scale           !   → use wide scale
    mov.w   DAT_06006116, r0           ! r0 = 0x01EC (offset into car array)
    mov.w   .L_min_segment_threshold, r2 ! r2 = 0x00DC (threshold)
    mov.l @(r0, r14), r3               ! r3 = car_array[0x01EC / 4]
    cmp/ge r2, r3                       ! if segment_dist >= threshold
    bf      .L_use_wide_scale           !   else → wide scale
.L_use_close_scale:
    mov.l @(4, r9), r5                  ! r5 = ch0.y
    mov.l @(4, r12), r2                 ! r2 = ch1.y
    mov.l   .L_fp_half, r4             ! r4 = 0.5 (16.16)
    mov.l   .L_fn_fpmul, r3
    jsr @r3                             ! r0 = fpmul(ch0.y + ch1.y, 0.5)
    add r2, r5                          ! r5 = ch0.y + ch1.y (delay slot)
    mov.l   .L_close_angle_scale, r13  ! r13 = 0x0002CCCC (close scale)
    bra     .L_compute_lateral_angles
    mov r0, r11                         ! r11 = half_y_01 (delay slot)

    .global DAT_06006116
DAT_06006116:
    .2byte  0x01EC                      /* car array offset for segment distance */
.L_min_segment_threshold:
    .2byte  0x00DC                      /* 220 — min segment distance for close scale */
    .2byte  0xFFFF                      /* alignment padding */
    ! --- Constant pool 2: heading calc + scale selection ---
.L_geom_ch7_data_2:
    .4byte  sym_06063ED8                /* geometry channel 7 (dup for pool 2) */
.L_geom_ch6_data_2:
    .4byte  sym_06063EC4                /* geometry channel 6 (dup for pool 2) */
.L_fn_atan2_xy:
    .4byte  sym_06006838                /* atan2(x, z) — heading computation */
.L_fn_scene_render_alt:
    .4byte  scene_render_alt            /* store heading + trigger render update */
.L_xform_params_avg:
    .4byte  sym_060446AC                /* averaged position transform params */
.L_fn_mat_vec_transform_2:
    .4byte  mat_vec_transform           /* matrix-vector transform (dup) */
.L_attract_cycle_counter:
    .4byte  sym_0607EAD8                /* attract mode cycle counter (0/1/2) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_fn_fpmul:
    .4byte  fpmul                       /* 16.16 fixed-point multiply */
.L_close_angle_scale:
    .4byte  0x0002CCCC                  /* ~2.8 (16.16) — close angle scale */
.L_use_wide_scale:
    mov.l @(20, r15), r11              ! r11 = stack[5].y (from averaged transform)
    mov.l   .L_wide_angle_scale, r13   ! r13 = 0x000D6666 (wide scale)
    ! --- Compute lateral pair averages and yaw/pitch angles ---
.L_compute_lateral_angles:
    mov.l @(4, r10), r5                 ! r5 = ch2.y
    mov.l @(4, r8), r3                  ! r3 = ch3.y
    mov.l   .L_fp_half_2, r4           ! r4 = 0.5
    add r3, r5                          ! r5 = ch2.y + ch3.y
    mov.l   .L_fn_fpmul_2, r3
    jsr @r3                             ! r0 = fpmul(ch2.y + ch3.y, 0.5)
    nop
    mov.l r0, @(8, r15)               ! stack[2] = half_y_23
    mov.l @(4, r10), r5                 ! r5 = ch2.y
    mov.l @(4, r9), r3                  ! r3 = ch0.y
    mov.l   .L_fp_half_2, r4
    add r3, r5                          ! r5 = ch2.y + ch0.y
    mov.l   .L_fn_fpmul_2, r3
    jsr @r3                             ! r0 = fpmul(ch2.y + ch0.y, 0.5)
    nop
    mov.l r0, @r15                      ! stack[0] = half_y_20
    mov.l @(4, r8), r5                  ! r5 = ch3.y
    mov.l @(4, r12), r3                 ! r3 = ch1.y
    mov.l   .L_fp_half_2, r4
    add r3, r5                          ! r5 = ch3.y + ch1.y
    mov.l   .L_fn_fpmul_2, r3
    jsr @r3                             ! r0 = fpmul(ch3.y + ch1.y, 0.5)
    nop
    ! --- Yaw angle: atan2(half_y_01 - half_y_23, angle_scale) ---
    mov r11, r4                         ! r4 = half_y_01 (from close/wide path)
    mov.l r0, @(12, r15)              ! stack[3] = half_y_31
    mov.l @(8, r15), r3                ! r3 = half_y_23
    sub r3, r4                          ! r4 = half_y_01 - half_y_23
    mov.l   .L_fn_atan2, r3
    jsr @r3                             ! r0 = atan2(y_diff, angle_scale)
    mov r13, r5                         ! r5 = angle_scale (delay slot)
    mov.l r0, @(28, r14)              ! car_array[7] = yaw angle
    ! --- Pitch angle: atan2(half_y_20 - half_y_31, pitch_divisor) ---
    mov.l @r15, r4                      ! r4 = half_y_20
    mov.l @(12, r15), r2              ! r2 = half_y_31
    mov.l   .L_pitch_divisor, r5       ! r5 = 0x00011998 (~1.1 fixed)
    mov.l   .L_fn_atan2, r3
    jsr @r3                             ! r0 = atan2(y_diff, pitch_divisor)
    sub r2, r4                          ! r4 = half_y_20 - half_y_31 (delay slot)
    mov.l r0, @(36, r14)              ! car_array[9] = pitch angle
    ! --- Decrement position counter and return ---
    mov.l   .L_position_counter, r4
    mov.l @r4, r2
    add #-0x30, r2                      ! counter -= 0x30
    mov.l r2, @r4
    add #0x1C, r15                      ! deallocate local frame
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
    ! --- Constant pool 3: lateral angle computation ---
.L_wide_angle_scale:
    .4byte  0x000D6666                  /* ~13.4 (16.16) — wide angle scale */
.L_fp_half_2:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_fn_fpmul_2:
    .4byte  fpmul                       /* 16.16 fixed-point multiply (dup) */
.L_fn_atan2:
    .4byte  atan2                       /* atan2(y, x) — angle computation */
.L_pitch_divisor:
    .4byte  0x00011998                  /* ~1.1 (16.16) — pitch angle divisor */
.L_position_counter:
    .4byte  sym_06089EDC                /* global position counter (decremented by 0x30) */
