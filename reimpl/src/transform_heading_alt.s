/* transform_heading_alt -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060263EC - 0x0602648E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Iterates 8 render slots in slot data table B (sym_0606107C) and
 * dispatches each slot's heading transform based on its render_type
 * field (+6 offset). Skips the slot whose index equals r4 (the player
 * or active car index). Clears course identifier words A and B at the
 * start.  Mirror of transform_heading_apply which operates on table A
 * (sym_06060F2C, 10 slots).
 *
 * Register layout on entry:
 *   r4 = player/active car slot index (slot to skip)
 *
 * Persistent registers:
 *   r10 = slot_data_table_b base (sym_0606107C, 8-byte stride)
 *   r12 = 0x8 (slot count for table B)
 *   r13 = &course_id_a (sym_06089ED6, word)
 *   r14 = &course_id_b (sym_06089ED4, word)
 *   r5  = current slot index (loop counter)
 */

    .section .text.FUN_060263EC


    .global transform_heading_alt
    .type transform_heading_alt, @function
transform_heading_alt:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    mov.l r13, @-r15                        ! save r13 (callee-saved)
    mov.l r12, @-r15                        ! save r12 (callee-saved)
    mov.l r10, @-r15                        ! save r10 (callee-saved)
    mov.l   .L_pool_slot_data_table_b, r10  ! r10 = slot_data_table_b base (sym_0606107C)
    mov #0x8, r12                           ! r12 = 8 (slot count for table B)
    mov.l   .L_pool_course_id_a, r13        ! r13 = &course_id_a (sym_06089ED6)
    mov.l   .L_pool_course_id_b, r14        ! r14 = &course_id_b (sym_06089ED4)
    mov #0x1, r7                            ! r7 = 1 (unused setup constant)
    mov #0x2, r6                            ! r6 = 2 (unused setup constant)
    mov #0x0, r0                            ! r0 = 0 (zero for clearing)
    extu.w r0, r3                           ! r3 = 0 (zero-extend for word store)
    mov.w r3, @r13                          ! course_id_a = 0 (clear word)
    extu.w r0, r2                           ! r2 = 0 (zero-extend for word store)
    mov.w r2, @r14                          ! course_id_b = 0 (clear word)
    bra     .L_loop_test                    ! jump to loop condition check
    extu.w r0, r5                           ! r5 = 0 (slot index init, delay slot)
.L_loop_body:
    extu.w r5, r2                           ! r2 = slot_index (zero-extend word)
    cmp/eq r4, r2                           ! slot_index == player_slot?
    bf      .L_not_player_slot              ! no → process this slot
    bra     .L_next_slot                    ! yes → skip (this is the player car)
    nop
.L_not_player_slot:
    extu.w r5, r0                           ! r0 = slot_index (zero-extend)
    shll2 r0                                ! r0 = slot_index × 4
    shll r0                                 ! r0 = slot_index × 8 (8-byte stride)
    add r10, r0                             ! r0 → slot_data_table_b[slot_index]
    mov.w @(6, r0), r0                      ! r0 = slot.render_type (word at offset +6)
    bra     .L_dispatch_setup               ! jump past embedded dispatch byte-data
    extu.w r0, r0                           ! r0 = render_type (zero-extend, delay slot)
    .2byte  0xA001                          /* branch instruction embedded in stream (not executed inline) */
    .4byte  0x627D626D                      /* embedded dispatch path bytes */
    .4byte  0xA0262D21                      /* embedded dispatch path bytes */
    .4byte  0xA001627D                      /* embedded dispatch path bytes */
    .4byte  0x626DA021                      /* embedded dispatch path bytes */
    .2byte  0x2E21                          /* embedded dispatch path bytes */
.L_dispatch_out_of_range:
    bra     .L_next_slot                    ! render_type out of range → skip slot
    nop
    .2byte  0xFFFF                          /* alignment padding */
.L_pool_slot_data_table_b:
    .4byte  sym_0606107C                    /* [HIGH] slot data table B (8-byte stride, 8 slots) */
.L_pool_course_id_a:
    .4byte  sym_06089ED6                    /* [HIGH] &course_id_a word */
.L_pool_course_id_b:
    .4byte  sym_06089ED4                    /* [HIGH] &course_id_b word */
.L_dispatch_setup:
    mov.w   .L_wpool_heading_base_offset, r1           ! r1 = 0x008A (dispatch base offset)
    sub r1, r0                              ! r0 = render_type - 0x008A (relative index)
    mov #0xC, r1                            ! r1 = 12 (number of dispatch entries)
    cmp/hs r1, r0                           ! (unsigned) render_type_rel >= 12?
    bt      .L_dispatch_out_of_range        ! yes → out of range, skip slot
    shll r0                                 ! r0 = relative_index × 2 (word table index)
    mov r0, r1                              ! r1 = word table index (base for indexed load)
    .word 0xC702 /* UNKNOWN */              /* mova: load PC-relative address of dispatch table into r0 */
    mov.w @(r0, r1), r0                     ! r0 = dispatch_table[rel_idx] (PC-relative offset)
    braf r0                                 ! dispatch: PC + r0 (relative jump to handler)
    nop
.L_wpool_heading_base_offset:
    .2byte  0x008A                          /* [HIGH] dispatch base: lowest valid render_type */
    .4byte  0xFFC4FFC4                      /* dispatch offsets for render_type 0x008A and 0x008C */
    .4byte  0xFFCEFFCE                      /* dispatch offsets for render_type 0x008E and 0x0090 */
    .4byte  0xFFC8FFC8                      /* dispatch offsets for render_type 0x0092 and 0x0094 */
    .4byte  0xFFC8FFC8                      /* dispatch offsets for render_type 0x0096 and 0x0098 */
    .4byte  0xFFD2FFD2                      /* dispatch offsets for render_type 0x009A and 0x009C */
    .4byte  0xFFD2FFD2                      /* dispatch offsets for render_type 0x009E and 0x00A0 */
.L_next_slot:
    add #0x1, r5                            ! slot_index++
.L_loop_test:
    extu.w r5, r2                           ! r2 = slot_index (zero-extend word)
    cmp/ge r12, r2                          ! (signed) slot_index >= 8?
    bf      .L_loop_body                    ! no → process next slot
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
