/* race_pos_interp -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CB90 - 0x0600CC38
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Race position interpolation â€” reads track segment data and writes
 * interpolated position + angle values to an output buffer.
 *
 * Called from geom_final_output with:
 *   r4 = output buffer pointer (receives interpolated XZ + 3 angles)
 *   r5 = segment index (unsigned 16-bit)
 *
 * Segment index semantics:
 *   - Bit 0 selects interpolation mode:
 *       even = direct copy from one segment entry
 *       odd  = average two adjacent segment entries (midpoint interp)
 *   - Bits 15..1 = actual segment number (index >> 1)
 *
 * Data sources:
 *   sym_0607EB88 = pointer to course segment data array
 *   sym_0607E940 = pointer to current car struct
 *   sym_0607EA9C = track section count (wrap limit for odd-index case)
 *
 * Car struct field used:
 *   car[+0x01F8] = segment table base (upper 24 bits after shlr8)
 *
 * Course segment data: 16 bytes per entry
 *   +0x00 = X position (32-bit)
 *   +0x04 = Z position (32-bit)
 *   +0x08 = heading angle A (16-bit)
 *   +0x0A = heading angle B (16-bit, scaled x4 on output)
 *   +0x0C = heading angle C (16-bit)
 *
 * Output buffer layout (written to r4):
 *   +0x00 = X position (32-bit)          [interpolated or direct]
 *   +0x08 = Z position (32-bit)          [interpolated or direct]
 *   +0x0C = heading angle A (16-bit)
 *   +0x0E = heading angle B x4 (16-bit)
 *   +0x10 = heading angle C (16-bit)
 *   +0x12 = zero (16-bit padding)
 */

    .section .text.FUN_0600CB90


    .global race_pos_interp
    .type race_pos_interp, @function
race_pos_interp:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    extu.w r5, r0                           ! r0 = segment index (zero-extended)
    mov.l   .L_p_seg_data_array, r14        ! r14 = &course_seg_data_ptr (sym_0607EB88)
    mov.l   .L_p_car_struct, r7             ! r7 = &car_struct_ptr (sym_0607E940)
    tst #0x1, r0                            ! test bit 0: is segment index even?
    bt/s    .L_even_index                   ! branch if even (direct copy, no interpolation)
    mov.l @r7, r7                           ! (delay slot) r7 = car_struct_base (dereference ptr)
    extu.w r5, r6                           ! r6 = segment index (zero-extended copy for second seg)
    mov.l   .L_p_section_count, r3          ! r3 = &section_count (sym_0607EA9C)
    shlr r6                                 ! r6 = segment_index >> 1 (actual seg number)
    mov.l @r3, r3                           ! r3 = section_count (dereference)
    add #0x1, r6                            ! r6 = seg_number + 1 (next segment for interp)
    cmp/hi r3, r6                           ! compare: (seg_number + 1) > section_count?
    bf      .L_no_wrap                      ! branch if no wrap needed (r6 <= section_count)
    mov #0x0, r6                            ! r6 = 0 (wrap to first segment)
.L_no_wrap:
    extu.w r5, r5                           ! r5 = segment index (zero-extended for first seg)
    shll2 r6                                ! r6 *= 4 (second seg: entry index * 4)
    mov.w   .L_w_seg_table_off, r0           ! r0 = 0x01F8 (car struct offset: seg table base)
    mov.l @r14, r3                          ! r3 = seg_data_array (dereference pointer)
    shlr r5                                 ! r5 = segment_index >> 1 (first seg number)
    shll r6                                 ! r6 *= 2 (second seg: entry index * 8)
    mov.l @(r0, r7), r1                     ! r1 = car[+0x01F8] (packed seg table base)
    shll2 r5                                ! r5 *= 4 (first seg: entry index * 4)
    shlr8 r1                                ! r1 >>= 8 (extract upper 24 bits as base offset)
    shll r5                                 ! r5 *= 2 (first seg: entry index * 8)
    mov r1, r7                              ! r7 = base offset (copy for first seg calc)
    add r5, r7                              ! r7 = base_offset + first_seg_entry_offset
    add r6, r1                              ! r1 = base_offset + second_seg_entry_offset
    mov r7, r5                              ! r5 = first seg combined offset
    mov r1, r6                              ! r6 = second seg combined offset
    shll2 r5                                ! r5 *= 4 } total: offset * 16
    shll2 r6                                ! r6 *= 4 } (16 bytes per segment entry)
    shll2 r5                                ! r5 *= 4 } first_seg_byte_offset = combined * 16
    shll2 r6                                ! r6 *= 4 } second_seg_byte_offset = combined * 16
    add r3, r5                              ! r5 = &seg_data[first_seg] (absolute pointer)
    add r3, r6                              ! r6 = &seg_data[second_seg] (absolute pointer)
    mov.l @r5, r2                           ! r2 = seg_data[first].x_pos
    mov.l @r6, r3                           ! r3 = seg_data[second].x_pos
    add r3, r2                              ! r2 = first.x + second.x (sum for average)
    shar r2                                 ! r2 = (first.x + second.x) / 2 (arithmetic shift)
    mov.l r2, @r4                           ! output[+0x00] = interpolated X position
    mov.l @(4, r5), r2                      ! r2 = seg_data[first].z_pos
    mov.l @(4, r6), r3                      ! r3 = seg_data[second].z_pos
    add r3, r2                              ! r2 = first.z + second.z (sum for average)
    shar r2                                 ! r2 = (first.z + second.z) / 2 (arithmetic shift)
    bra     .L_write_angles                 ! jump to shared angle output code
    mov.l r2, @(8, r4)                      ! (delay slot) output[+0x08] = interpolated Z position
.L_even_index:
    extu.w r5, r5                           ! r5 = segment index (zero-extended)
    mov.w   .L_w_seg_table_off, r0           ! r0 = 0x01F8 (car struct offset: seg table base)
    shlr r5                                 ! r5 = segment_index >> 1 (actual seg number)
    mov.l @(r0, r7), r6                     ! r6 = car[+0x01F8] (packed seg table base)
    shll2 r5                                ! r5 *= 4 (entry index * 4)
    shlr8 r6                                ! r6 >>= 8 (extract upper 24 bits as base offset)
    shll r5                                 ! r5 *= 2 (entry index * 8)
    add r5, r6                              ! r6 = base_offset + entry_offset
    mov r6, r5                              ! r5 = combined offset
    shll2 r5                                ! r5 *= 4 } total: offset * 16
    shll2 r5                                ! r5 *= 4 } byte_offset = combined * 16
    mov.l @r14, r3                          ! r3 = seg_data_array (dereference pointer)
    add r3, r5                              ! r5 = &seg_data[segment] (absolute pointer)
    mov.l @r5, r2                           ! r2 = seg_data[segment].x_pos
    mov.l r2, @r4                           ! output[+0x00] = X position (direct copy)
    mov.l @(4, r5), r3                      ! r3 = seg_data[segment].z_pos
    mov.l r3, @(8, r4)                      ! output[+0x08] = Z position (direct copy)
.L_write_angles:
    mov.w @(8, r5), r0                      ! r0 = seg_data.angle_a (heading angle A, 16-bit)
    mov.w r0, @(12, r4)                     ! output[+0x0C] = heading angle A
    mov.w @(10, r5), r0                     ! r0 = seg_data.angle_b (heading angle B, 16-bit)
    mov r0, r3                              ! r3 = angle_b (copy for scaling)
    shll2 r3                                ! r3 = angle_b * 4 (scale factor)
    exts.w r3, r0                           ! r0 = sign-extend scaled angle_b to 32-bit
    mov.w r0, @(14, r4)                     ! output[+0x0E] = heading angle B * 4
    mov.w @(12, r5), r0                     ! r0 = seg_data.angle_c (heading angle C, 16-bit)
    mov.w r0, @(16, r4)                     ! output[+0x10] = heading angle C
    mov #0x0, r0                            ! r0 = 0 (padding value)
    mov.w r0, @(18, r4)                     ! output[+0x12] = 0 (zero padding)
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! (delay slot) restore r14
.L_w_seg_table_off:
    .2byte  0x01F8                     /* [HIGH] car struct offset: segment table base (+0x1F8) */
.L_p_seg_data_array:
    .4byte  sym_0607EB88               /* [HIGH] course segment data array ptr */
.L_p_car_struct:
    .4byte  sym_0607E940               /* [HIGH] current car struct pointer (player) */
.L_p_section_count:
    .4byte  sym_0607EA9C               /* [HIGH] track section count (wrap limit) */
