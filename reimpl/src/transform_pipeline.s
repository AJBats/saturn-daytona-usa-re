/* transform_pipeline -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060279B0 - 0x06027CA4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * 3-Vertex Clip Interpolation (Sutherland-Hodgman style)
 * ======================================================
 *
 * Called from the clip dispatch table (Pipeline A) when exactly 3 of 4 quad
 * vertices lie behind the far clip plane. This function iteratively blends
 * each clipped vertex toward the clip boundary using exponential smoothing.
 *
 * Parameters:
 *   r4 -> vertex buffer: 4 transformed vertices, each 12 bytes (X, Y, Z as
 *         32-bit 16.16 fixed-point). Total: 48 bytes.
 *         [0]  vtxA.X  [4]  vtxA.Y  [8]  vtxA.Z
 *         [12] vtxB.X  [16] vtxB.Y  [20] vtxB.Z
 *         [24] vtxC.X  [28] vtxC.Y  [32] vtxC.Z
 *         [36] vtxD.X  [40] vtxD.Y  [44] vtxD.Z
 *   r5 -> edge activity flags: 4 x int16. Each is 1 (active/clipped) or 0 (done).
 *         [0] edgeAB  [2] edgeBC  [4] edgeCD  [6] edgeDA
 *
 * Algorithm:
 *   Copies edge flags to stack as local working state.
 *   Main loop iterates over all 4 edges. For each active edge (flag == 1):
 *     - The clipped vertex is blended toward a neighbor:
 *         new = current * 0.9 + neighbor * 0.1  (16.16 fixed-point)
 *     - The neighbor direction depends on whether the adjacent edge is also
 *       clipped: mode flag == 0 → blend toward next vertex (forward neighbor),
 *       mode flag != 0 → blend toward previous vertex (backward neighbor).
 *     - After blending, Z component gets a +4 bias (sub-pixel correction).
 *     - If Z exceeds the far clip threshold, the edge is marked done (flag = 0).
 *   Loop exits when all 4 edge flags are 0 (all vertices converged).
 *
 * Constants:
 *   0x0000E666 = ~0.9 in 16.16 (retention/friction factor)
 *   0x00001999 = ~0.1 in 16.16 (target blend factor)
 *   0xE666 + 0x1999 = 0xFFFF ≈ 1.0  → weighted blend preserves magnitude
 *
 * Registers (persistent across loop):
 *   r1  = 0xE666 (0.9 blend weight)
 *   r2  = 0x1999 (0.1 blend weight)
 *   r4  -> vertex buffer (parameter, unchanged)
 *   r12 -> edge flags source (original r5 parameter)
 *   r14 = far clip threshold (loaded from sym_06063F08)
 *   r15 -> stack: 8 bytes of working edge flags [0..6]
 */

    .section .text.FUN_060279B0


    .global transform_pipeline
    .type transform_pipeline, @function
transform_pipeline:

/* =========================================================================
 * Prologue — save callee-saved registers and allocate stack frame
 * ========================================================================= */

    mov.l r14, @-r15                    ! save r14 (will hold clip threshold)
    mov.l r12, @-r15                    ! save r12 (will hold edge flags ptr)
    mov.l r10, @-r15                    ! save r10 (unused but part of ABI)
    mov.l r9, @-r15                     ! save r9 (scratch for blend results)
    mov.l r8, @-r15                     ! save r8 (scratch for blend results)
    sts.l pr, @-r15                     ! save return address
    add #-0x8, r15                      ! allocate 8 bytes: 4 working edge flags

/* =========================================================================
 * Initialize blend constants and clip threshold
 * ========================================================================= */

    mov.l   .L_pool_blend_09, r1       ! r1 = 0xE666 (~0.9 in 16.16 fp)
    mov.l   .L_pool_blend_01, r2       ! r2 = 0x1999 (~0.1 in 16.16 fp)
    mov.l   .L_pool_clip_threshold_ptr, r14 ! r14 -> ptr to far clip distance
    mov.l @r14, r14                     ! r14 = far clip threshold value

/* =========================================================================
 * Copy edge activity flags from input (r5) to stack working copy
 * ========================================================================= */

    mov r5, r12                         ! r12 = edge flags source pointer
    mov.w @r12, r0                      ! r0 = edgeAB flag
    mov.w r0, @r15                      ! stack[0] = edgeAB working flag
    mov.w @(2, r12), r0                 ! r0 = edgeBC flag
    mov.w r0, @(2, r15)                ! stack[2] = edgeBC working flag
    mov.w @(4, r12), r0                 ! r0 = edgeCD flag
    mov.w r0, @(4, r15)                ! stack[4] = edgeCD working flag
    mov.w @(6, r12), r0                 ! r0 = edgeDA flag
    mov.w r0, @(6, r15)                ! stack[6] = edgeDA working flag

/* =========================================================================
 * Main interpolation loop — iterate until all edges converge
 * ========================================================================= */

.L_main_loop:
    mov.w @r15, r0                      ! r0 = edgeAB active flag
    cmp/eq #0x1, r0                     ! is edge AB still active?
    bf      .L_edge_ab_done             ! no: skip to edge BC

/* =========================================================================
 * Edge AB — interpolate vertex A toward clip boundary
 *   Checks edgeBC flag to determine blend neighbor direction:
 *     edgeBC == 0 → blend vtxA toward vtxB (forward: offsets 12,16,20)
 *     edgeBC != 0 → blend vtxA toward vtxD (backward: offsets 36,40,44)
 * ========================================================================= */

    mov.w @(2, r12), r0                ! r0 = edgeBC direction flag
    cmp/eq #0x0, r0                     ! is edgeBC inactive (neighbor B visible)?
    bf      .L_edge_ab_blend_backward   ! no: B also clipped, blend toward D instead

/* --- Edge AB, forward blend: vtxA = vtxA * 0.9 + vtxB * 0.1 --- */
    mov.l @r4, r7                       ! r7 = vtxA.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxA.X * 0.9
    mov.l @(12, r4), r6                 ! r6 = vtxB.X (forward neighbor)
    sts mach, r7                        ! r7 = high 32 bits of vtxA.X * 0.9
    sts macl, r8                        ! r8 = low 32 bits of vtxA.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxB.X * 0.1
    xtrct r7, r8                        ! r8 = middle 32 bits = vtxA.X * 0.9 (16.16)
    mov.l @(4, r4), r7                  ! r7 = vtxA.Y
    sts mach, r6                        ! r6 = high 32 bits of vtxB.X * 0.1
    sts macl, r9                        ! r9 = low 32 bits of vtxB.X * 0.1
    xtrct r6, r9                        ! r9 = vtxB.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxA.Y * 0.9
    add r8, r9                          ! r9 = vtxA.X * 0.9 + vtxB.X * 0.1
    mov.l r9, @r4                       ! store new vtxA.X
    mov.l @(16, r4), r6                 ! r6 = vtxB.Y (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxA.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxA.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxB.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxA.Y * 0.9 (16.16)
    mov.l @(8, r4), r7                  ! r7 = vtxA.Z
    sts mach, r6                        ! r6 = high of vtxB.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxB.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxB.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxA.Z * 0.9
    add r8, r9                          ! r9 = vtxA.Y * 0.9 + vtxB.Y * 0.1
    mov.l r9, @(4, r4)                  ! store new vtxA.Y
    mov.l @(20, r4), r6                 ! r6 = vtxB.Z (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxA.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxA.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxB.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxA.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxB.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxB.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxB.Z * 0.1 (16.16)
    bra     .L_edge_ab_clamp            ! jump to clamp check (delay: add blend)
    add r8, r9                          ! r9 = vtxA.Z * 0.9 + vtxB.Z * 0.1

/* --- Constant pool (must be within PC-relative reach of above mov.l) --- */
.L_pool_blend_09:
    .4byte  0x0000E666                  ! ~0.9 in 16.16 fixed-point (58982/65536)
.L_pool_blend_01:
    .4byte  0x00001999                  ! ~0.1 in 16.16 fixed-point (6553/65536)
.L_pool_clip_threshold_ptr:
    .4byte  sym_06063F08                ! -> far clip plane distance threshold

/* --- Edge AB, backward blend: vtxA = vtxA * 0.9 + vtxD * 0.1 --- */
.L_edge_ab_blend_backward:
    mov.l @r4, r7                       ! r7 = vtxA.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxA.X * 0.9
    mov.l @(36, r4), r6                 ! r6 = vtxD.X (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxA.X * 0.9
    sts macl, r8                        ! r8 = low of vtxA.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxD.X * 0.1
    xtrct r7, r8                        ! r8 = vtxA.X * 0.9 (16.16)
    mov.l @(4, r4), r7                  ! r7 = vtxA.Y
    sts mach, r6                        ! r6 = high of vtxD.X * 0.1
    sts macl, r9                        ! r9 = low of vtxD.X * 0.1
    xtrct r6, r9                        ! r9 = vtxD.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxA.Y * 0.9
    add r8, r9                          ! r9 = vtxA.X * 0.9 + vtxD.X * 0.1
    mov.l r9, @r4                       ! store new vtxA.X
    mov.l @(40, r4), r6                 ! r6 = vtxD.Y (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxA.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxA.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxD.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxA.Y * 0.9 (16.16)
    mov.l @(8, r4), r7                  ! r7 = vtxA.Z
    sts mach, r6                        ! r6 = high of vtxD.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxD.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxD.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxA.Z * 0.9
    add r8, r9                          ! r9 = vtxA.Y * 0.9 + vtxD.Y * 0.1
    mov.l r9, @(4, r4)                  ! store new vtxA.Y
    mov.l @(44, r4), r6                 ! r6 = vtxD.Z (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxA.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxA.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxD.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxA.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxD.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxD.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxD.Z * 0.1 (16.16)
    add r8, r9                          ! r9 = vtxA.Z * 0.9 + vtxD.Z * 0.1

/* --- Edge AB clamp: apply bias and check against clip threshold --- */
.L_edge_ab_clamp:
    add #0x4, r9                        ! r9 += 4 (sub-pixel Z bias toward camera)
    mov.l r9, @(8, r4)                  ! store new vtxA.Z
    cmp/gt r14, r9                      ! vtxA.Z > clip threshold?
    bf      .L_edge_ab_done             ! no: vertex still behind clip, keep iterating
    mov #0x0, r0                        ! yes: vertex has crossed clip plane
    mov.w r0, @r15                      ! clear edgeAB flag (convergence reached)

/* =========================================================================
 * Edge BC — interpolate vertex B toward clip boundary
 *   Checks edgeCD flag to determine blend neighbor direction:
 *     edgeCD == 0 → blend vtxB toward vtxC (forward: offsets 24,28,32)
 *     edgeCD != 0 → blend vtxB toward vtxA (backward: offsets 0,4,8)
 * ========================================================================= */

.L_edge_ab_done:
    mov.w @(2, r15), r0                ! r0 = edgeBC active flag
    cmp/eq #0x1, r0                     ! is edge BC still active?
    bf      .L_edge_bc_done             ! no: skip to edge CD

    mov.w @(4, r12), r0                ! r0 = edgeCD direction flag
    cmp/eq #0x0, r0                     ! is edgeCD inactive (neighbor C visible)?
    bf      .L_edge_bc_blend_backward   ! no: C also clipped, blend toward A instead

/* --- Edge BC, forward blend: vtxB = vtxB * 0.9 + vtxC * 0.1 --- */
    mov.l @(12, r4), r7                ! r7 = vtxB.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxB.X * 0.9
    mov.l @(24, r4), r6                 ! r6 = vtxC.X (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxB.X * 0.9
    sts macl, r8                        ! r8 = low of vtxB.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxC.X * 0.1
    xtrct r7, r8                        ! r8 = vtxB.X * 0.9 (16.16)
    mov.l @(16, r4), r7                 ! r7 = vtxB.Y
    sts mach, r6                        ! r6 = high of vtxC.X * 0.1
    sts macl, r9                        ! r9 = low of vtxC.X * 0.1
    xtrct r6, r9                        ! r9 = vtxC.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxB.Y * 0.9
    add r8, r9                          ! r9 = vtxB.X * 0.9 + vtxC.X * 0.1
    mov.l r9, @(12, r4)                ! store new vtxB.X
    mov.l @(28, r4), r6                 ! r6 = vtxC.Y (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxB.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxB.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxC.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxB.Y * 0.9 (16.16)
    mov.l @(20, r4), r7                 ! r7 = vtxB.Z
    sts mach, r6                        ! r6 = high of vtxC.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxC.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxC.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxB.Z * 0.9
    add r8, r9                          ! r9 = vtxB.Y * 0.9 + vtxC.Y * 0.1
    mov.l r9, @(16, r4)                ! store new vtxB.Y
    mov.l @(32, r4), r6                 ! r6 = vtxC.Z (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxB.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxB.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxC.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxB.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxC.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxC.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxC.Z * 0.1 (16.16)
    bra     .L_edge_bc_clamp            ! jump to clamp check (delay: add blend)
    add r8, r9                          ! r9 = vtxB.Z * 0.9 + vtxC.Z * 0.1

/* --- Edge BC, backward blend: vtxB = vtxB * 0.9 + vtxA * 0.1 --- */
.L_edge_bc_blend_backward:
    mov.l @(12, r4), r7                ! r7 = vtxB.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxB.X * 0.9
    mov.l @r4, r6                       ! r6 = vtxA.X (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxB.X * 0.9
    sts macl, r8                        ! r8 = low of vtxB.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxA.X * 0.1
    xtrct r7, r8                        ! r8 = vtxB.X * 0.9 (16.16)
    mov.l @(16, r4), r7                 ! r7 = vtxB.Y
    sts mach, r6                        ! r6 = high of vtxA.X * 0.1
    sts macl, r9                        ! r9 = low of vtxA.X * 0.1
    xtrct r6, r9                        ! r9 = vtxA.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxB.Y * 0.9
    add r8, r9                          ! r9 = vtxB.X * 0.9 + vtxA.X * 0.1
    mov.l r9, @(12, r4)                ! store new vtxB.X
    mov.l @(4, r4), r6                  ! r6 = vtxA.Y (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxB.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxB.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxA.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxB.Y * 0.9 (16.16)
    mov.l @(20, r4), r7                 ! r7 = vtxB.Z
    sts mach, r6                        ! r6 = high of vtxA.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxA.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxA.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxB.Z * 0.9
    add r8, r9                          ! r9 = vtxB.Y * 0.9 + vtxA.Y * 0.1
    mov.l r9, @(16, r4)                ! store new vtxB.Y
    mov.l @(8, r4), r6                  ! r6 = vtxA.Z (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxB.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxB.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxA.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxB.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxA.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxA.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxA.Z * 0.1 (16.16)
    add r8, r9                          ! r9 = vtxB.Z * 0.9 + vtxA.Z * 0.1

/* --- Edge BC clamp: apply bias and check against clip threshold --- */
.L_edge_bc_clamp:
    add #0x4, r9                        ! r9 += 4 (sub-pixel Z bias toward camera)
    mov.l r9, @(20, r4)                ! store new vtxB.Z
    cmp/gt r14, r9                      ! vtxB.Z > clip threshold?
    bf      .L_edge_bc_done             ! no: vertex still behind clip, keep iterating
    mov #0x0, r0                        ! yes: vertex has crossed clip plane
    mov.w r0, @(2, r15)                ! clear edgeBC flag (convergence reached)

/* =========================================================================
 * Edge CD — interpolate vertex C toward clip boundary
 *   Checks edgeDA flag to determine blend neighbor direction:
 *     edgeDA == 0 → blend vtxC toward vtxD (forward: offsets 36,40,44)
 *     edgeDA != 0 → blend vtxC toward vtxB (backward: offsets 12,16,20)
 * ========================================================================= */

.L_edge_bc_done:
    mov.w @(4, r15), r0                ! r0 = edgeCD active flag
    cmp/eq #0x1, r0                     ! is edge CD still active?
    bf      .L_edge_cd_done             ! no: skip to edge DA

    mov.w @(6, r12), r0                ! r0 = edgeDA direction flag
    cmp/eq #0x0, r0                     ! is edgeDA inactive (neighbor D visible)?
    bf      .L_edge_cd_blend_backward   ! no: D also clipped, blend toward B instead

/* --- Edge CD, forward blend: vtxC = vtxC * 0.9 + vtxD * 0.1 --- */
    mov.l @(24, r4), r7                ! r7 = vtxC.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxC.X * 0.9
    mov.l @(36, r4), r6                 ! r6 = vtxD.X (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxC.X * 0.9
    sts macl, r8                        ! r8 = low of vtxC.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxD.X * 0.1
    xtrct r7, r8                        ! r8 = vtxC.X * 0.9 (16.16)
    mov.l @(28, r4), r7                 ! r7 = vtxC.Y
    sts mach, r6                        ! r6 = high of vtxD.X * 0.1
    sts macl, r9                        ! r9 = low of vtxD.X * 0.1
    xtrct r6, r9                        ! r9 = vtxD.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxC.Y * 0.9
    add r8, r9                          ! r9 = vtxC.X * 0.9 + vtxD.X * 0.1
    mov.l r9, @(24, r4)                ! store new vtxC.X
    mov.l @(40, r4), r6                 ! r6 = vtxD.Y (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxC.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxC.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxD.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxC.Y * 0.9 (16.16)
    mov.l @(32, r4), r7                 ! r7 = vtxC.Z
    sts mach, r6                        ! r6 = high of vtxD.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxD.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxD.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxC.Z * 0.9
    add r8, r9                          ! r9 = vtxC.Y * 0.9 + vtxD.Y * 0.1
    mov.l r9, @(28, r4)                ! store new vtxC.Y
    mov.l @(44, r4), r6                 ! r6 = vtxD.Z (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxC.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxC.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxD.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxC.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxD.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxD.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxD.Z * 0.1 (16.16)
    bra     .L_edge_cd_clamp            ! jump to clamp check (delay: add blend)
    add r8, r9                          ! r9 = vtxC.Z * 0.9 + vtxD.Z * 0.1

/* --- Edge CD, backward blend: vtxC = vtxC * 0.9 + vtxB * 0.1 --- */
.L_edge_cd_blend_backward:
    mov.l @(24, r4), r7                ! r7 = vtxC.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxC.X * 0.9
    mov.l @(12, r4), r6                 ! r6 = vtxB.X (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxC.X * 0.9
    sts macl, r8                        ! r8 = low of vtxC.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxB.X * 0.1
    xtrct r7, r8                        ! r8 = vtxC.X * 0.9 (16.16)
    mov.l @(28, r4), r7                 ! r7 = vtxC.Y
    sts mach, r6                        ! r6 = high of vtxB.X * 0.1
    sts macl, r9                        ! r9 = low of vtxB.X * 0.1
    xtrct r6, r9                        ! r9 = vtxB.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxC.Y * 0.9
    add r8, r9                          ! r9 = vtxC.X * 0.9 + vtxB.X * 0.1
    mov.l r9, @(24, r4)                ! store new vtxC.X
    mov.l @(16, r4), r6                 ! r6 = vtxB.Y (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxC.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxC.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxB.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxC.Y * 0.9 (16.16)
    mov.l @(32, r4), r7                 ! r7 = vtxC.Z
    sts mach, r6                        ! r6 = high of vtxB.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxB.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxB.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxC.Z * 0.9
    add r8, r9                          ! r9 = vtxC.Y * 0.9 + vtxB.Y * 0.1
    mov.l r9, @(28, r4)                ! store new vtxC.Y
    mov.l @(20, r4), r6                 ! r6 = vtxB.Z (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxC.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxC.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxB.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxC.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxB.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxB.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxB.Z * 0.1 (16.16)
    add r8, r9                          ! r9 = vtxC.Z * 0.9 + vtxB.Z * 0.1

/* --- Edge CD clamp: apply bias and check against clip threshold --- */
.L_edge_cd_clamp:
    add #0x4, r9                        ! r9 += 4 (sub-pixel Z bias toward camera)
    mov.l r9, @(32, r4)                ! store new vtxC.Z
    cmp/gt r14, r9                      ! vtxC.Z > clip threshold?
    bf      .L_edge_cd_done             ! no: vertex still behind clip, keep iterating
    mov #0x0, r0                        ! yes: vertex has crossed clip plane
    mov.w r0, @(4, r15)                ! clear edgeCD flag (convergence reached)

/* =========================================================================
 * Edge DA — interpolate vertex D toward clip boundary
 *   Checks edgeAB flag to determine blend neighbor direction:
 *     edgeAB == 0 → blend vtxD toward vtxA (forward: offsets 0,4,8)
 *     edgeAB != 0 → blend vtxD toward vtxC (backward: offsets 24,28,32)
 * ========================================================================= */

.L_edge_cd_done:
    mov.w @(6, r15), r0                ! r0 = edgeDA active flag
    cmp/eq #0x1, r0                     ! is edge DA still active?
    bf      .L_edge_da_done             ! no: skip to convergence check

    mov.w @r12, r0                      ! r0 = edgeAB direction flag
    cmp/eq #0x0, r0                     ! is edgeAB inactive (neighbor A visible)?
    bf      .L_edge_da_blend_backward   ! no: A also clipped, blend toward C instead

/* --- Edge DA, forward blend: vtxD = vtxD * 0.9 + vtxA * 0.1 --- */
    mov.l @(36, r4), r7                ! r7 = vtxD.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxD.X * 0.9
    mov.l @r4, r6                       ! r6 = vtxA.X (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxD.X * 0.9
    sts macl, r8                        ! r8 = low of vtxD.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxA.X * 0.1
    xtrct r7, r8                        ! r8 = vtxD.X * 0.9 (16.16)
    mov.l @(40, r4), r7                 ! r7 = vtxD.Y
    sts mach, r6                        ! r6 = high of vtxA.X * 0.1
    sts macl, r9                        ! r9 = low of vtxA.X * 0.1
    xtrct r6, r9                        ! r9 = vtxA.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxD.Y * 0.9
    add r8, r9                          ! r9 = vtxD.X * 0.9 + vtxA.X * 0.1
    mov.l r9, @(36, r4)                ! store new vtxD.X
    mov.l @(4, r4), r6                  ! r6 = vtxA.Y (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxD.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxD.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxA.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxD.Y * 0.9 (16.16)
    mov.l @(44, r4), r7                 ! r7 = vtxD.Z
    sts mach, r6                        ! r6 = high of vtxA.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxA.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxA.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxD.Z * 0.9
    add r8, r9                          ! r9 = vtxD.Y * 0.9 + vtxA.Y * 0.1
    mov.l r9, @(40, r4)                ! store new vtxD.Y
    mov.l @(8, r4), r6                  ! r6 = vtxA.Z (forward neighbor)
    sts mach, r7                        ! r7 = high of vtxD.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxD.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxA.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxD.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxA.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxA.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxA.Z * 0.1 (16.16)
    bra     .L_edge_da_clamp            ! jump to clamp check (delay: add blend)
    add r8, r9                          ! r9 = vtxD.Z * 0.9 + vtxA.Z * 0.1

/* --- Edge DA, backward blend: vtxD = vtxD * 0.9 + vtxC * 0.1 --- */
.L_edge_da_blend_backward:
    mov.l @(36, r4), r7                ! r7 = vtxD.X
    dmuls.l r7, r1                      ! MACH:MACL = vtxD.X * 0.9
    mov.l @(24, r4), r6                 ! r6 = vtxC.X (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxD.X * 0.9
    sts macl, r8                        ! r8 = low of vtxD.X * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxC.X * 0.1
    xtrct r7, r8                        ! r8 = vtxD.X * 0.9 (16.16)
    mov.l @(40, r4), r7                 ! r7 = vtxD.Y
    sts mach, r6                        ! r6 = high of vtxC.X * 0.1
    sts macl, r9                        ! r9 = low of vtxC.X * 0.1
    xtrct r6, r9                        ! r9 = vtxC.X * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxD.Y * 0.9
    add r8, r9                          ! r9 = vtxD.X * 0.9 + vtxC.X * 0.1
    mov.l r9, @(36, r4)                ! store new vtxD.X
    mov.l @(28, r4), r6                 ! r6 = vtxC.Y (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxD.Y * 0.9
    sts macl, r8                        ! r8 = low of vtxD.Y * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxC.Y * 0.1
    xtrct r7, r8                        ! r8 = vtxD.Y * 0.9 (16.16)
    mov.l @(44, r4), r7                 ! r7 = vtxD.Z
    sts mach, r6                        ! r6 = high of vtxC.Y * 0.1
    sts macl, r9                        ! r9 = low of vtxC.Y * 0.1
    xtrct r6, r9                        ! r9 = vtxC.Y * 0.1 (16.16)
    dmuls.l r7, r1                      ! MACH:MACL = vtxD.Z * 0.9
    add r8, r9                          ! r9 = vtxD.Y * 0.9 + vtxC.Y * 0.1
    mov.l r9, @(40, r4)                ! store new vtxD.Y
    mov.l @(32, r4), r6                 ! r6 = vtxC.Z (backward neighbor)
    sts mach, r7                        ! r7 = high of vtxD.Z * 0.9
    sts macl, r8                        ! r8 = low of vtxD.Z * 0.9
    dmuls.l r6, r2                      ! MACH:MACL = vtxC.Z * 0.1
    xtrct r7, r8                        ! r8 = vtxD.Z * 0.9 (16.16)
    sts mach, r6                        ! r6 = high of vtxC.Z * 0.1
    sts macl, r9                        ! r9 = low of vtxC.Z * 0.1
    xtrct r6, r9                        ! r9 = vtxC.Z * 0.1 (16.16)
    add r8, r9                          ! r9 = vtxD.Z * 0.9 + vtxC.Z * 0.1

/* --- Edge DA clamp: apply bias and check against clip threshold --- */
.L_edge_da_clamp:
    add #0x4, r9                        ! r9 += 4 (sub-pixel Z bias toward camera)
    mov.l r9, @(44, r4)                ! store new vtxD.Z
    cmp/gt r14, r9                      ! vtxD.Z > clip threshold?
    bf      .L_edge_da_done             ! no: vertex still behind clip, keep iterating
    mov #0x0, r0                        ! yes: vertex has crossed clip plane
    mov.w r0, @(6, r15)                ! clear edgeDA flag (convergence reached)

/* =========================================================================
 * Convergence check — sum all 4 edge flags
 * If any flag is still nonzero, loop back for another iteration.
 * ========================================================================= */

.L_edge_da_done:
    mov.w @r15, r7                      ! r7 = edgeAB flag
    mov.w @(2, r15), r0                ! r0 = edgeBC flag
    add r0, r7                          ! r7 = edgeAB + edgeBC
    mov.w @(4, r15), r0                ! r0 = edgeCD flag
    add r0, r7                          ! r7 = edgeAB + edgeBC + edgeCD
    mov.w @(6, r15), r0                ! r0 = edgeDA flag
    add r7, r0                          ! r0 = total active edges
    cmp/eq #0x0, r0                     ! all edges converged?
    bt      .L_epilogue                 ! yes: all vertices on clip boundary, exit
    bra     .L_main_loop                ! no: iterate again
    nop                                 ! (delay slot)

/* =========================================================================
 * Epilogue — restore registers and return
 * ========================================================================= */

.L_epilogue:
    add #0x8, r15                       ! free stack frame (4 edge flag words)
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r12                    ! restore r12
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .2byte  0x0000                      ! alignment padding
