/* scene_finalize_a -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06025070 - 0x06025148
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Builds scene output table A from render channel descriptors.
 *
 * Phase 1 (init): Clears 10 slots in scene output table A — zeroes the
 *   longword at +0, writes the slot index at +4, writes 0x00B4 (default
 *   render attribute) at +6, and clears the channel descriptor's state
 *   word via its +4 pointer.
 *
 * Phase 2 (merge): Nested loop — outer iterates 14 render channels,
 *   inner iterates 10 output slots. For each (channel, slot) pair,
 *   tests whether the channel's state word ANDed with the slot's
 *   bitmask is non-zero. If so, copies the channel descriptor's +4
 *   field (source data ptr) into the output slot's +0, the slot's
 *   bitmask into +4, the channel's +8 attribute into +6, then OR's
 *   the bitmask into the destination's state word.
 *
 * This is the "A" counterpart of scene_finalize_b, which does the same
 * for output table B using 8 slots and a different bitmask array.
 *
 * Persistent registers:
 *   r7  = 0xA (10 = output table A slot count, inner loop limit)
 *   r10 = slot element / render channel descriptor table (12-byte stride)
 *   r11 = scene output table A base (8-byte stride)
 *   r12 = render bitmask array A (2-byte entries)
 */

    .section .text.FUN_06025070


    .global scene_finalize_a
    .type scene_finalize_a, @function
scene_finalize_a:
    mov.l r14, @-r15                    ! push r14 (callee-save)
    mov.l r13, @-r15                    ! push r13 (callee-save)
    mov.l r12, @-r15                    ! push r12 (callee-save)
    mov.l r11, @-r15                    ! push r11 (callee-save)
    mov.l r10, @-r15                    ! push r10 (callee-save)
    mov.l r9, @-r15                     ! push r9 (callee-save)
    mov.l r8, @-r15                     ! push r8 (callee-save)
    mov.l   .L_pool_channel_desc_table, r10 ! r10 = sym_060610BC: render channel descriptor table (12-byte entries)
    mov.l   .L_pool_output_table_a, r11 ! r11 = sym_06060F2C: scene output table A (8-byte entries)
    mov.l   .L_pool_bitmask_array_a, r12 ! r12 = sym_06059094: render bitmask array A (2-byte entries)
    mov #0xA, r7                        ! r7 = 10 (output table A has 10 slots)
    mov #0x0, r4                        ! r4 = 0 (zero value for clearing fields)
    extu.w r4, r5                       ! r5 = 0 (init loop slot index)
.L_init_slot_loop:
    extu.w r5, r6                       ! r6 = slot index (zero-extended word)
    extu.w r4, r0                       ! r0 = 0 (zero-extended, for writing slot index)
    extu.b r5, r3                       ! r3 = slot index (low byte)
    shll2 r6                            ! r6 = slot * 4
    mov r3, r2                          ! r2 = slot index (byte copy for 12-byte stride calc)
    add #0x1, r5                        ! r5++ (advance slot index)
    shll r6                             ! r6 = slot * 8 (byte offset into output table A)
    shll2 r3                            ! r3 = slot * 4
    shll2 r2                            ! r2 = slot * 4
    add r11, r6                         ! r6 = &output_table_a[slot]
    shll r2                             ! r2 = slot * 8
    mov.l r4, @r6                       ! output_table_a[slot].field0 = 0 (clear longword)
    add r2, r3                          ! r3 = slot * 4 + slot * 8 = slot * 12
    mov.w r0, @(4, r6)                  ! output_table_a[slot].mask = 0 (clear word at +4)
    extu.b r3, r3                       ! r3 = (slot * 12) & 0xFF (keep low byte for index)
    extu.w r4, r2                       ! r2 = 0
    mov.w   DAT_06025136, r0            ! r0 = 0x00B4 (default render attribute value)
    add r10, r3                         ! r3 = &channel_desc[slot] (base + 12-byte offset)
    mov.w r0, @(6, r6)                  ! output_table_a[slot].attr = 0x00B4 (default attribute)
    mov.l @(4, r3), r3                  ! r3 = channel_desc[slot].state_ptr (+4)
    mov.w r2, @r3                       ! *state_ptr = 0 (clear channel state word)
    extu.w r5, r3                       ! r3 = slot index (after increment)
    cmp/ge r7, r3                       ! slot >= 10?
    bf      .L_init_slot_loop           ! no -> continue clearing slots
    bra     .L_outer_loop_test          ! jump to outer loop test (first entry)
    extu.w r4, r13                      ! (delay slot) r13 = 0 (outer channel index)
.L_outer_loop_body:
    extu.w r4, r5                       ! r5 = 0 (reset inner slot index for this channel)
    extu.w r13, r8                      ! r8 = channel index (zero-extended word)
    extu.b r13, r14                     ! r14 = channel index (low byte)
    mov.l   .L_pool_data_table_a, r3    ! r3 = sym_06060D7C: scene data table A (8-byte entries)
    shll2 r8                            ! r8 = channel * 4
    mov r14, r2                         ! r2 = channel index (byte copy)
    shll r8                             ! r8 = channel * 8 (byte offset into data table A)
    shll2 r14                           ! r14 = channel * 4
    shll2 r2                            ! r2 = channel * 4
    add r3, r8                          ! r8 = &data_table_a[channel]
    shll r2                             ! r2 = channel * 8
    add r2, r14                         ! r14 = channel * 4 + channel * 8 = channel * 12
    extu.b r14, r14                     ! r14 = (channel * 12) & 0xFF (low byte)
    add r10, r14                        ! r14 = &channel_desc[channel] (12-byte entry)
.L_inner_slot_loop:
    extu.w r5, r0                       ! r0 = slot index (zero-extended word)
    mov.l @r8, r2                       ! r2 = data_table_a[channel].ptr (+0) — channel state word dest
    shll r0                             ! r0 = slot * 2 (word index into bitmask array)
    mov.w @r2, r1                       ! r1 = *data_ptr (channel's current state word)
    mov.w @(r0, r12), r3                ! r3 = bitmask_array_a[slot] (slot's enable bitmask)
    extu.w r1, r1                       ! r1 zero-extended (unsigned state word)
    extu.w r3, r3                       ! r3 zero-extended (unsigned bitmask)
    and r1, r3                          ! r3 = state & bitmask (test if slot enabled for this channel)
    tst r3, r3                          ! is result zero? (slot not enabled)
    bt      .L_skip_slot                ! yes -> skip this slot
    extu.w r5, r6                       ! r6 = slot index (zero-extended word)
    extu.w r5, r9                       ! r9 = slot index (for bitmask address calc)
    mov.l @(4, r14), r3                 ! r3 = channel_desc[channel].data_ptr (+4) — source data
    shll2 r6                            ! r6 = slot * 4
    shll r6                             ! r6 = slot * 8 (byte offset into output table A)
    add r11, r6                         ! r6 = &output_table_a[slot]
    mov.l r3, @r6                       ! output_table_a[slot].field0 = channel desc data_ptr
    shll r9                             ! r9 = slot * 2 (word offset for bitmask)
    add r12, r9                         ! r9 = &bitmask_array_a[slot]
    mov.w @r9, r0                       ! r0 = bitmask_array_a[slot] (slot's bitmask)
    mov.w r0, @(4, r6)                  ! output_table_a[slot].mask = bitmask (store at +4)
    mov.w @(8, r14), r0                 ! r0 = channel_desc[channel].attr (+8) — render attribute
    mov.w r0, @(6, r6)                  ! output_table_a[slot].attr = channel attr (store at +6)
    mov.l @r6, r3                       ! r3 = output_table_a[slot].field0 (reload dest ptr)
    mov.w @r9, r2                       ! r2 = bitmask_array_a[slot] (reload bitmask)
    extu.w r2, r2                       ! r2 zero-extended
    mov.w @r3, r1                       ! r1 = *dest_ptr (current state word at destination)
    or r2, r1                           ! r1 = current | bitmask (OR-in the slot's enable bit)
    mov.w r1, @r3                       ! *dest_ptr = r1 (write back with bit set)
.L_skip_slot:
    add #0x1, r5                        ! r5++ (advance inner slot index)
    extu.w r5, r3                       ! r3 = slot index (zero-extended)
    cmp/ge r7, r3                       ! slot >= 10?
    bf      .L_inner_slot_loop          ! no -> test next output slot
    add #0x1, r13                       ! r13++ (advance outer channel index)
.L_outer_loop_test:
    extu.w r13, r3                      ! r3 = channel index (zero-extended)
    mov #0xE, r2                        ! r2 = 14 (number of render channels)
    cmp/ge r2, r3                       ! channel >= 14?
    bf      .L_outer_loop_body          ! no -> process next channel
    mov.l @r15+, r8                     ! pop r8 (callee-restore)
    mov.l @r15+, r9                     ! pop r9 (callee-restore)
    mov.l @r15+, r10                    ! pop r10 (callee-restore)
    mov.l @r15+, r11                    ! pop r11 (callee-restore)
    mov.l @r15+, r12                    ! pop r12 (callee-restore)
    mov.l @r15+, r13                    ! pop r13 (callee-restore)
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay slot) pop r14 (callee-restore)

    .global DAT_06025136
DAT_06025136:
    .2byte  0x00B4
.L_pool_channel_desc_table:
    .4byte  sym_060610BC                /* render channel descriptor table: 14 entries x 12 bytes */
.L_pool_output_table_a:
    .4byte  sym_06060F2C                /* scene output table A: 10 slots x 8 bytes */
.L_pool_bitmask_array_a:
    .4byte  sym_06059094                /* render bitmask array A: 10 x 2-byte slot enable masks */
.L_pool_data_table_a:
    .4byte  sym_06060D7C                /* scene data table A: 14 entries x 8 bytes (ptr, data_ptr) */
