/* sys_timer_tick -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060406BC - 0x06040724
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Timer tick handler -- processes one tick of the system timer event.
 *
 * Validates the current event state via the init check (BSR to the
 * validate+init entry at 0x06040666), acquires the event boundary
 * lock, computes a position offset via the timer overflow helper
 * (fallthrough to timer_overflow_handler with field index 0x1E),
 * validates the section, then releases the lock.
 *
 * Arguments:
 *   r5  = event source data pointer (saved to stack, passed to helpers)
 *   r13 = game state context pointer (callee-preserved from caller)
 *
 * Returns:
 *   r0 = 1 on success (section validated and lock released)
 *   r0 = 0 if validation check passed early or lock acquire failed
 *
 * Calls:
 *   BSR 0x06040666       -- validate+init check (sets r5=0, falls into
 *                           sys_timer_init which calls evt_validate_multi)
 *   sym_06040FB8          -- acquire event boundary lock (returns seq or -5)
 *   timer_overflow_handler -- compute position offset (via fallthrough from
 *                             .L_compute_offset, r0=0x1E field index)
 *   ai_section_check      -- validate section against lock sequence
 *   sym_06040FEA          -- release event boundary lock
 *
 * Stack frame (0x0C bytes):
 *   sp+0x00: saved r5 (event source pointer)
 *   sp+0x04: sub-batch flag (set to 1)
 *   sp+0x08: computed position offset result
 */

    .section .text.FUN_060406BC


    .global sys_timer_tick
    .type sys_timer_tick, @function
sys_timer_tick:
    sts.l pr, @-r15                       ! save return address
    add #-0xC, r15                        ! allocate 0x0C bytes of local stack
    .byte   0xBF, 0xD1    /* bsr 0x06040666 (external) */  ! call validate+init check
    mov.l r5, @r15                        ! [delay slot] save r5 (source ptr) to stack
    tst r0, r0                            ! test init check result
    bf      .L_init_check_passed          ! if nonzero (needs processing), branch
    bra     .L_epilogue                   ! validation says nothing to do
    mov #0x0, r0                          ! [delay slot] return 0 (no work)
.L_init_check_passed:
    mov.l   .L_ptr_boundary_acquire, r3   ! r3 = &sym_06040FB8 (acquire lock fn)
    jsr @r3                               ! call sym_06040FB8() -- acquire boundary lock
    nop                                   ! [delay slot]
    mov r0, r14                           ! r14 = lock handle (seq counter or -5)
    cmp/pz r14                            ! lock handle >= 0? (acquired OK?)
    bt      .L_lock_acquired              ! if non-negative, lock acquired successfully
    bra     .L_epilogue                   ! lock acquire failed
    mov #0x0, r0                          ! [delay slot] return 0 (failed)
    .4byte  sym_060409DE                  ! pool: position calc helper (unused ref)
    .4byte  evt_checkpoint_handler        ! pool: checkpoint handler (unused ref)
.L_ptr_boundary_acquire:
    .4byte  sym_06040FB8                  ! pool: boundary lock acquire function
.L_lock_acquired:
    mov r15, r3                           ! r3 = sp
    mov #0x1, r2                          ! r2 = 1 (sub-batch active flag)
    add #0x4, r3                          ! r3 = sp+4
    mov.l r2, @r3                         ! *(sp+4) = 1 (mark sub-batch active)
    mov r15, r3                           ! r3 = sp
    mov.l @r15, r5                        ! r5 = saved source data pointer (from stack)
    add #0x4, r3                          ! r3 = sp+4
    mov r3, r8                            ! r8 = sp+4
    add #0x4, r8                          ! r8 = sp+8 (output slot for offset result)
    bsr     .L_compute_offset             ! call offset helper (r0=0x1E -> timer_overflow_handler)
    mov r13, r4                           ! [delay slot] r4 = game state context
    mov r14, r5                           ! r5 = lock handle (for ai_section_check)
    mov r15, r4                           ! r4 = sp (local struct base)
    mov.l @(4, r13), r2                   ! r2 = game_state->accumulated_offset (+0x04)
    add r2, r0                            ! r0 = computed offset + accumulated offset
    mov.l r0, @r8                         ! *(sp+8) = final position offset
    .byte   0xD3, 0x18    /* mov.l .L_pool_0604076C, r3 */  ! r3 = &ai_section_check (cross-TU pool)
    jsr @r3                               ! call ai_section_check(sp+4, lock_handle)
    add #0x4, r4                          ! [delay slot] r4 = sp+4 (sub-batch struct)
    .byte   0xD3, 0x18    /* mov.l .L_pool_06040770, r3 */  ! r3 = &sym_06040FEA (cross-TU pool)
    jsr @r3                               ! call sym_06040FEA(lock_handle) -- release lock
    mov r14, r4                           ! [delay slot] r4 = lock handle
    mov #0x1, r0                          ! r0 = 1 (success)
.L_epilogue:
    add #0xC, r15                         ! deallocate 0x0C local frame
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r8                       ! restore r8
    mov.l @r15+, r13                      ! restore r13
    rts                                   ! return to caller
    mov.l @r15+, r14                      ! [delay slot] restore r14
.L_compute_offset:
    mov #0x1E, r0                         ! r0 = 0x1E (field index 30; falls through to timer_overflow_handler)
