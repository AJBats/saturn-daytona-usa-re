/* hud_menu_logic -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060127E0 - 0x06012AC4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Menu state machine for the HUD menu flow (mode select -> car select ->
 * course select -> race start). Driven by a state counter stored at
 * sym_060788F4:
 *
 *   State 0  = draw initial menu items (scroll display elements)
 *   State 1  = wait for selection input (0x52 = confirm, else redraw)
 *   State 2  = wait for mode confirm input (0x58)
 *   State 3  = wait for course confirm input (0x5D)
 *   State 4  = wait for race start input (0x61)
 *   State 19 = cleanup/reset all display elements, clear scroll state
 *   Default  = increment state counter (advance to next frame)
 *
 * Each state advances the counter on completion and issues display commands
 * and/or sound commands for the transition.
 *
 * Registers (persistent across states):
 *   r8  = fn_disp_cmd_write (sym_060283E0)
 *   r9  = sound_cmd_dispatch
 *   r10 = menu element stride offset (0x0090)
 *   r11 = &menu_elem_data (sym_0605ACDD)
 *   r12 = fn_disp_list_load (sym_06028400)
 *   r13 = &replay_struct (sym_06063750) â€” used as base for display list offsets
 *   r14 = &menu_state_counter (sym_060788F4)
 */

    .section .text.FUN_060127E0


    .global hud_menu_logic
    .type hud_menu_logic, @function
hud_menu_logic:
    mov.l r14, @-r15                        ! save callee-saved registers
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x4, r15                          ! allocate 4 bytes for local (temp ptr)
    mov.l   .L_ptr_scroll_offset, r4       ! r4 = &scroll_offset
    mov.l @r4, r3                           ! r3 = current scroll position
    mov.l   .L_ptr_prev_scroll, r2         ! r2 = &prev_scroll
    mov.l r3, @r2                           ! save previous scroll position
    mov.l   .L_ptr_render_flags, r5        ! r5 = &render_mode_flags
    mov.l @r5, r0                           ! r0 = current flags
    or #0x80, r0                            ! set bit 7 (menu active flag)
    mov.l r0, @r5                           ! store updated flags
    mov.l   .L_scroll_speed_delta, r3      ! r3 = 0x0004CCCC (16.16 fixed-point scroll speed)
    mov.l @r4, r2                           ! r2 = current scroll offset
    add r3, r2                              ! r2 += scroll speed delta
    mov.l r2, @r4                           ! update scroll offset
    mov.l   .L_ptr_car_array_base, r4      ! r4 = &car_array_ptr
    mov.l @r4, r4                           ! r4 = car_array_base
    mov.w   DAT_06012884, r0               ! r0 = 0x01EC (offset to input cmd field)
    mov.l @(r0, r4), r4                    ! r4 = car_array[0x01EC] = current input command
    mov.l   .L_fn_disp_cmd_write, r8      ! r8 = fn_disp_cmd_write
    mov.l   .L_fn_sound_cmd, r9           ! r9 = sound_cmd_dispatch
    mov.w   .L_menu_elem_stride, r10      ! r10 = 0x0090 (menu element stride)
    mov.l   .L_ptr_menu_elem_data, r11    ! r11 = &menu_elem_data
    mov.l   .L_fn_disp_list_load, r12     ! r12 = fn_disp_list_load
    mov.l   .L_ptr_replay_struct, r13     ! r13 = &replay_struct (display list base)
    mov.l   .L_ptr_menu_state_ctr, r14    ! r14 = &menu_state_counter
    bra     .L_state_dispatch              ! jump to state dispatch
    mov.l @r14, r0                          ! (delay) r0 = current state
.L_state0_draw_items:                       ! --- State 0: draw initial menu elements ---
    mov.w   DAT_06012888, r7               ! r7 = 0x0098 (first display list offset)
    add r13, r7                             ! r7 = replay_struct + 0x0098
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data ptr)
    mov.w   .L_disp_cmd_id_a, r6           ! r6 = 0x0880 (display command ID A)
    mov.l @r15, r5                          ! r5 = struct ptr
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load(0xC, target, cmd_id, data)
    mov #0xC, r4                            ! (delay) r4 = 0xC (command size)
    mov.w   DAT_0601288c, r7               ! r7 = 0x00A0 (second display list offset)
    add r13, r7                             ! r7 = replay_struct + 0x00A0
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data ptr)
    mov.w   DAT_0601288e, r6               ! r6 = 0x088C (display command ID B)
    mov.l @r15, r5                          ! r5 = struct ptr
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load
    mov #0xC, r4                            ! (delay) r4 = 0xC (command size)
    mov.l @r14, r3                          ! r3 = state counter
    add #0x1, r3                            ! r3++
    mov.l r3, @r14                          ! advance state counter
    bra     .L_epilogue                     ! return
    nop
.L_state1_check_input:                      ! --- State 1: wait for selection input ---
    mov r4, r0                              ! r0 = input command
    cmp/eq #0x52, r0                        ! input == 0x52 (confirm)?
    bt      .L_handle_confirm_sel           ! yes -> handle confirmation
    mov.l   .L_ptr_game_status, r3         ! r3 = &game_status
    mov.w @r3, r2                           ! r2 = game_status (16-bit)
    extu.w r2, r2                           ! zero-extend
    mov.l   .L_ptr_status_mask, r3         ! r3 = &status_mask
    mov.w @r3, r3                           ! r3 = status_mask (16-bit)
    extu.w r3, r3                           ! zero-extend
    and r3, r2                              ! r2 = game_status & mask
    tst r2, r2                              ! any status bits set?
    bf      .L_draw_highlight_sel           ! yes -> draw highlighted selection
    mov.l   .L_ptr_render_enable, r0       ! r0 = &special_render_enable
    mov.w @r0, r0                           ! r0 = render_enable (16-bit)
    extu.w r0, r0                           ! zero-extend
    tst r0, r0                              ! render enabled?
    bt      .L_draw_default_item            ! no -> draw default (non-highlighted) item
.L_draw_highlight_sel:                      ! draw highlighted menu selection
    mov r13, r7                             ! r7 = &replay_struct
    add r10, r7                             ! r7 += stride offset (0x0090)
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data)
    mov.w   DAT_06012890, r3               ! r3 = 0x4000 (highlight offset)
    add r3, r7                              ! r7 += highlight offset
    bra     .L_issue_sel_disp_cmd           ! issue display command
    nop

    .global DAT_06012884
DAT_06012884:
    .2byte  0x01EC                          /* car_array offset to input cmd field */
.L_menu_elem_stride:
    .2byte  0x0090                          /* menu element struct stride */

    .global DAT_06012888
DAT_06012888:
    .2byte  0x0098                          /* replay_struct offset: first display list */
.L_disp_cmd_id_a:
    .2byte  0x0880                          /* display command ID: menu item A */

    .global DAT_0601288c
DAT_0601288c:
    .2byte  0x00A0                          /* replay_struct offset: second display list */

    .global DAT_0601288e
DAT_0601288e:
    .2byte  0x088C                          /* display command ID: menu item B */

    .global DAT_06012890
DAT_06012890:
    .2byte  0x4000                          /* highlight display data offset */
    .2byte  0xFFFF                          /* alignment padding */
.L_ptr_scroll_offset:
    .4byte  sym_060788F8                    /* menu scroll position (32-bit) */
.L_ptr_prev_scroll:
    .4byte  sym_0605B714                    /* previous scroll position backup */
.L_ptr_render_flags:
    .4byte  sym_0605B6D8                    /* render mode flags (32-bit bitmask) */
.L_scroll_speed_delta:
    .4byte  0x0004CCCC                      /* 16.16 fixed-point scroll speed */
.L_ptr_car_array_base:
    .4byte  sym_0607E944                    /* car array base pointer */
.L_fn_disp_cmd_write:
    .4byte  sym_060283E0                    /* display command writer function */
.L_fn_sound_cmd:
    .4byte  sound_cmd_dispatch              /* sound command dispatch function */
.L_ptr_menu_elem_data:
    .4byte  sym_0605ACDD                    /* menu element data base */
.L_fn_disp_list_load:
    .4byte  sym_06028400                    /* display list loader function */
.L_ptr_replay_struct:
    .4byte  sym_06063750                    /* replay/display struct base */
.L_ptr_menu_state_ctr:
    .4byte  sym_060788F4                    /* menu state counter (32-bit) */
.L_ptr_game_status:
    .4byte  sym_06063D98                    /* game status word (16-bit) */
.L_ptr_status_mask:
    .4byte  sym_0608188C                    /* status mask for input filtering */
.L_ptr_render_enable:
    .4byte  sym_0607ED8C                    /* special render enable (16-bit) */
.L_draw_default_item:                       ! draw non-highlighted (default) menu item
    mov.w   DAT_0601299a, r7               ! r7 = 0x0088 (default item struct offset)
    add r13, r7                             ! r7 = replay_struct + 0x0088
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data)
    mov.w   DAT_0601299c, r3               ! r3 = 0x4000 (base display offset)
    add r3, r7                              ! r7 += base offset
.L_issue_sel_disp_cmd:                      ! common path: issue selection display command
    mov.w   DAT_0601299e, r6               ! r6 = 0x061C (display command ID)
    mov.l @r15, r5                          ! r5 = struct ptr
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load(0x8, target, cmd_id, data)
    mov #0x8, r4                            ! (delay) r4 = 0x8 (command size)
    bra     .L_epilogue                     ! return
    nop
.L_handle_confirm_sel:                      ! --- input 0x52: confirm current selection ---
    mov r11, r7                             ! r7 = &menu_elem_data
    mov.l @r14, r2                          ! r2 = state counter
    add #0x1, r2                            ! r2++
    mov.l r2, @r14                          ! advance state counter
    mov.l   .L_mask_nibble3, r6            ! r6 = 0x0000F000 (nibble 3 mask)
    mov.w   DAT_0601299e, r5               ! r5 = 0x061C (display cmd slot 1)
    jsr @r8                                 ! call fn_disp_cmd_write(0x8, slot, mask, data)
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r11, r7                             ! r7 = &menu_elem_data
    mov.l   .L_mask_nibble3, r6            ! r6 = 0x0000F000
    mov.w   DAT_060129a0, r5               ! r5 = 0x069C (display cmd slot 2)
    jsr @r8                                 ! call fn_disp_cmd_write
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r11, r7                             ! r7 = &menu_elem_data
    mov.l   .L_mask_nibble3, r6            ! r6 = 0x0000F000
    mov.w   DAT_060129a2, r5               ! r5 = 0x071C (display cmd slot 3)
    jsr @r8                                 ! call fn_disp_cmd_write
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r13, r7                             ! r7 = &replay_struct
    add #0x78, r7                           ! r7 += 0x78 (selection confirm list offset)
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data)
    mov.w   DAT_060129a4, r3               ! r3 = 0x3000 (overlay offset)
    mov.w   DAT_060129a6, r6               ! r6 = 0x0626 (display command ID)
    mov.l @r15, r5                          ! r5 = struct ptr
    add r3, r7                              ! r7 += overlay offset
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov.l   .L_snd_cmd_menu_select, r5    ! r5 = 0xAE1122FF (menu select sound)
    jsr @r9                                 ! call sound_cmd_dispatch(0, snd_cmd)
    mov #0x0, r4                            ! (delay) r4 = 0 (channel)
    bra     .L_epilogue                     ! return
    nop
.L_state2_check_mode:                       ! --- State 2: wait for mode confirm input ---
    mov r4, r0                              ! r0 = input command
    cmp/eq #0x58, r0                        ! input == 0x58 (mode confirm)?
    bt      .L_handle_mode_confirm          ! yes -> handle mode confirmation
    bra     .L_epilogue                     ! no -> return (wait for next frame)
    nop
.L_handle_mode_confirm:                     ! --- input 0x58: mode selected ---
    mov.l @r14, r3                          ! r3 = state counter
    mov r13, r7                             ! r7 = &replay_struct
    add #0x1, r3                            ! r3++ (advance state)
    add #0x70, r7                           ! r7 += 0x70 (mode confirm list offset)
    mov.l r3, @r14                          ! store updated state counter
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data)
    mov.w   DAT_060129a4, r3               ! r3 = 0x3000 (overlay offset)
    mov.w   DAT_060129a6, r6               ! r6 = 0x0626 (display command ID)
    mov.l @r15, r5                          ! r5 = struct ptr
    add r3, r7                              ! r7 += overlay offset
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov #0x1, r3                            ! r3 = 1
    mov.l   .L_ptr_lap_count, r2           ! r2 = &lap_count
    mov.b r3, @r2                           ! lap_count = 1 (initial value)
    mov.l   .L_ptr_car_array_base_b, r3   ! r3 = &car_array_ptr
    mov.l   .L_ptr_yaw_angle_store, r1    ! r1 = &camera_yaw_angle
    mov.l @r3, r3                           ! r3 = car_array_base
    mov.l @(48, r3), r2                     ! r2 = car_array[48] (car yaw angle)
    mov.l r2, @r1                           ! store initial camera yaw from car
    mov.l   .L_snd_cmd_mode_confirm, r5   ! r5 = 0xAE1123FF (mode confirm sound)
    jsr @r9                                 ! call sound_cmd_dispatch(0, snd_cmd)
    mov #0x0, r4                            ! (delay) r4 = 0 (channel)
    bra     .L_epilogue                     ! return
    nop
.L_state3_check_course:                     ! --- State 3: wait for course confirm input ---
    mov r4, r0                              ! r0 = input command
    cmp/eq #0x5D, r0                        ! input == 0x5D (course confirm)?
    bt      .L_handle_course_confirm        ! yes -> handle course confirmation
    bra     .L_epilogue                     ! no -> return (wait for next frame)
    nop
.L_handle_course_confirm:                   ! --- input 0x5D: course selected ---
    mov.l @r14, r3                          ! r3 = state counter
    mov r13, r7                             ! r7 = &replay_struct
    add #0x1, r3                            ! r3++ (advance state)
    add #0x68, r7                           ! r7 += 0x68 (course confirm list offset)
    mov.l r3, @r14                          ! store updated state counter
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data)
    mov.w   DAT_060129a4, r3               ! r3 = 0x3000 (overlay offset)
    mov.w   DAT_060129a6, r6               ! r6 = 0x0626 (display command ID)
    mov.l @r15, r5                          ! r5 = struct ptr
    add r3, r7                              ! r7 += overlay offset
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov.l   .L_snd_cmd_course_confirm, r5 ! r5 = 0xAE1124FF (course confirm sound)
    jsr @r9                                 ! call sound_cmd_dispatch(0, snd_cmd)
    mov #0x0, r4                            ! (delay) r4 = 0 (channel)
    bra     .L_epilogue                     ! return
    nop

    .global DAT_0601299a
DAT_0601299a:
    .2byte  0x0088                          /* replay_struct offset: default item list */

    .global DAT_0601299c
DAT_0601299c:
    .2byte  0x4000                          /* base display data offset */

    .global DAT_0601299e
DAT_0601299e:
    .2byte  0x061C                          /* display cmd: selection slot 1 */

    .global DAT_060129a0
DAT_060129a0:
    .2byte  0x069C                          /* display cmd: selection slot 2 */

    .global DAT_060129a2
DAT_060129a2:
    .2byte  0x071C                          /* display cmd: selection slot 3 */

    .global DAT_060129a4
DAT_060129a4:
    .2byte  0x3000                          /* overlay base offset */

    .global DAT_060129a6
DAT_060129a6:
    .2byte  0x0626                          /* display cmd: overlay layer */
.L_mask_nibble3:
    .4byte  0x0000F000                      /* nibble 3 mask for display element */
.L_snd_cmd_menu_select:
    .4byte  0xAE1122FF                      /* sound cmd: menu selection confirm */
.L_ptr_lap_count:
    .4byte  sym_06078654                    /* lap count (byte) */
.L_ptr_car_array_base_b:
    .4byte  sym_0607E944                    /* car array base pointer (dup) */
.L_ptr_yaw_angle_store:
    .4byte  sym_06063EF0                    /* camera yaw angle storage */
.L_snd_cmd_mode_confirm:
    .4byte  0xAE1123FF                      /* sound cmd: mode selection confirm */
.L_snd_cmd_course_confirm:
    .4byte  0xAE1124FF                      /* sound cmd: course selection confirm */
.L_state4_race_start:                       ! --- State 4: wait for race start input ---
    mov r4, r0                              ! r0 = input command
    cmp/eq #0x61, r0                        ! input == 0x61 (race start)?
    bf      .L_epilogue                     ! no -> return (wait for next frame)
    mov.l @r14, r3                          ! r3 = state counter
    add #0x1, r3                            ! r3++ (advance state)
    mov.l r3, @r14                          ! store updated state counter
    mov.w   DAT_06012a92, r7               ! r7 = 0x0080 (race start list offset)
    add r13, r7                             ! r7 = replay_struct + 0x0080
    mov.l r7, @r15                          ! save struct ptr to local
    mov.l @(4, r7), r7                      ! r7 = struct[4] (display data)
    mov.w   DAT_06012a94, r3               ! r3 = 0x3000 (overlay offset)
    mov.w   .L_disp_cmd_elem_a, r6         ! r6 = 0x0520 (race start display cmd)
    mov.l @r15, r5                          ! r5 = struct ptr
    add r3, r7                              ! r7 += overlay offset
    mov.l @r5, r5                           ! r5 = struct[0] (display target)
    jsr @r12                                ! call fn_disp_list_load
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov.l   .L_snd_cmd_race_start, r5     ! r5 = 0xAE1125FF (race start sound)
    jsr @r9                                 ! call sound_cmd_dispatch(0, snd_cmd)
    mov #0x0, r4                            ! (delay) r4 = 0 (channel)
    mov #0x14, r3                           ! r3 = 0x14 (20 frames)
    mov.l   .L_ptr_countdown_timer, r2     ! r2 = &countdown_timer
    mov.w r3, @r2                           ! countdown_timer = 20 frames
    mov #0x1, r3                            ! r3 = 1
    mov.l   .L_ptr_race_ready_flag, r2     ! r2 = &race_ready_flag
    mov.b r3, @r2                           ! race_ready_flag = 1 (race is ready)
    bra     .L_epilogue                     ! return
    nop
.L_state19_cleanup:                         ! --- State 19 (0x13): reset all display elements ---
    mov.l   .L_fn_disp_elem_render, r14   ! r14 = fn_disp_elem_render (repurpose r14)
    mov r11, r7                             ! r7 = &menu_elem_data
    mov r10, r6                             ! r6 = stride offset (0x0090)
    mov.w   .L_disp_cmd_elem_a, r5         ! r5 = 0x0520 (clear elem A)
    jsr @r14                                ! call fn_disp_elem_render(0x8, slot, stride, data)
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r11, r7                             ! r7 = &menu_elem_data
    mov r10, r6                             ! r6 = stride offset
    mov.w   .L_disp_cmd_elem_b, r5         ! r5 = 0x0620 (clear elem B)
    jsr @r14                                ! call fn_disp_elem_render
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r11, r7                             ! r7 = &menu_elem_data
    mov r10, r6                             ! r6 = stride offset
    mov.w   .L_disp_cmd_elem_c, r5         ! r5 = 0x0720 (clear elem C)
    jsr @r14                                ! call fn_disp_elem_render
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r11, r7                             ! r7 = &menu_elem_data
    mov.l   .L_mask_nibble3_b, r6          ! r6 = 0x0000F000 (nibble 3 mask)
    mov.w   .L_disp_cmd_elem_d, r5         ! r5 = 0x0820 (clear elem D, masked)
    jsr @r8                                 ! call fn_disp_cmd_write (different fn for masked)
    mov #0x8, r4                            ! (delay) r4 = 0x8
    mov r10, r6                             ! r6 = stride offset
    mov.w   .L_disp_cmd_elem_e, r5         ! r5 = 0x0880 (clear text elem E)
    mov.l   .L_ptr_text_sprite_data, r7   ! r7 = &text_sprite_data
    jsr @r14                                ! call fn_disp_elem_render
    mov #0xC, r4                            ! (delay) r4 = 0xC (larger command)
    mov.l   .L_ptr_text_sprite_data, r7   ! r7 = &text_sprite_data
    mov r10, r6                             ! r6 = stride offset
    mov.w   .L_disp_cmd_elem_f, r5         ! r5 = 0x0980 (clear text elem F)
    jsr @r14                                ! call fn_disp_elem_render
    mov #0xC, r4                            ! (delay) r4 = 0xC
    mov #0x0, r4                            ! r4 = 0
    mov.l   .L_ptr_prev_scroll_b, r3      ! r3 = &prev_scroll
    mov.l r4, @r3                           ! prev_scroll = 0 (reset scroll state)
    exts.b r4, r4                           ! sign-extend byte (still 0)
    mov.l   .L_ptr_replay_mode_flag, r3   ! r3 = &replay_mode_flag
    mov.b r4, @r3                           ! replay_mode_flag = 0 (clear replay mode)
    bra     .L_epilogue                     ! return
    nop
.L_default_inc_counter:                     ! --- Default: unhandled state, just advance ---
    mov.l @r14, r2                          ! r2 = state counter
    add #0x1, r2                            ! r2++
    bra     .L_epilogue                     ! return
    mov.l r2, @r14                          ! (delay) store updated counter
.L_state_dispatch:                          ! --- State dispatch (switch on r0) ---
    cmp/eq #0x0, r0                         ! state == 0?
    bf      .L_chk_state1
    bra     .L_state0_draw_items            ! -> draw initial menu items
    nop
.L_chk_state1:
    cmp/eq #0x1, r0                         ! state == 1?
    bf      .L_chk_state2
    bra     .L_state1_check_input           ! -> wait for selection input
    nop
.L_chk_state2:
    cmp/eq #0x2, r0                         ! state == 2?
    bf      .L_chk_state3
    bra     .L_state2_check_mode            ! -> wait for mode confirm
    nop
.L_chk_state3:
    cmp/eq #0x3, r0                         ! state == 3?
    bf      .L_chk_state4_or_19
    bra     .L_state3_check_course          ! -> wait for course confirm
    nop
.L_chk_state4_or_19:
    cmp/eq #0x4, r0                         ! state == 4?
    bt      .L_state4_race_start            ! -> wait for race start
    cmp/eq #0x13, r0                        ! state == 19 (0x13)?
    bt      .L_state19_cleanup              ! -> cleanup/reset display
    bra     .L_default_inc_counter          ! -> default: just advance counter
    nop
.L_epilogue:                                ! --- Epilogue: restore and return ---
    add #0x4, r15                           ! free local temp
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! (delay) restore last register

    .global DAT_06012a92
DAT_06012a92:
    .2byte  0x0080                          /* replay_struct offset: race start list */

    .global DAT_06012a94
DAT_06012a94:
    .2byte  0x3000                          /* overlay base offset */
.L_disp_cmd_elem_a:
    .2byte  0x0520                          /* display cmd: cleanup elem A */
.L_disp_cmd_elem_b:
    .2byte  0x0620                          /* display cmd: cleanup elem B */
.L_disp_cmd_elem_c:
    .2byte  0x0720                          /* display cmd: cleanup elem C */
.L_disp_cmd_elem_d:
    .2byte  0x0820                          /* display cmd: cleanup elem D (masked) */
.L_disp_cmd_elem_e:
    .2byte  0x0880                          /* display cmd: cleanup text elem E */
.L_disp_cmd_elem_f:
    .2byte  0x0980                          /* display cmd: cleanup text elem F */
    .2byte  0xFFFF                          /* alignment padding */
.L_snd_cmd_race_start:
    .4byte  0xAE1125FF                      /* sound cmd: race start */
.L_ptr_countdown_timer:
    .4byte  sym_06086056                    /* countdown timer (16-bit) */
.L_ptr_race_ready_flag:
    .4byte  sym_0608605A                    /* race ready flag (byte) */
.L_fn_disp_elem_render:
    .4byte  sym_060284AE                    /* display element render function */
.L_mask_nibble3_b:
    .4byte  0x0000F000                      /* nibble 3 mask (dup for pool reach) */
.L_ptr_text_sprite_data:
    .4byte  sym_0605AC9C                    /* text/sprite data base */
.L_ptr_prev_scroll_b:
    .4byte  sym_0605B714                    /* previous scroll position (dup) */
.L_ptr_replay_mode_flag:
    .4byte  sym_06078636                    /* replay mode flag (byte) */
