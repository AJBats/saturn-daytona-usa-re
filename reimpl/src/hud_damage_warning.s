/* hud_damage_warning -- HUD damage indicator rotated-quad writer
 * Translation unit: 0x06011B08 - 0x06011DC0
 *
 * Computes rotated screen coordinates for a damage/warning HUD element
 * quad (4 corners of a rectangle) and writes them into a HUD record.
 * The rectangle half-extents are variable (passed via callee-saved regs
 * r8=cx, r9=cy), unlike hud_main_draw which uses hardcoded 56x30.
 *
 * Each corner is rotated by the given angle, multiplied by a scale
 * factor, and offset by the base position (r4=x_base, r5=y_base).
 * Results are stored as 16-bit screen coords at offsets 0x08..0x16
 * of a 24-byte HUD record, plus byte flags at 0x04/0x05 (both 0)
 * and a 16-bit parameter at 0x06.
 *
 * Inputs (caller pushes r8-r14 and sets regs before call):
 *   r0 = stack offset to 16-bit angle word (in caller frame)
 *   r4 = x_base (16.16 fixed-point), saved to sp+12
 *   r5 = y_base (16.16 fixed-point), saved to sp+8
 *   r8 = cx half-extent (16.16, set by caller)
 *   r9 = cy half-extent (16.16, set by caller)
 *   r10 = scale factor (loaded from caller stack at sp+60)
 *
 * HUD record layout (24 bytes at sym_060786CC + index*24):
 *   +0x04  byte  visibility flag A (written 0)
 *   +0x05  byte  visibility flag B (written 0)
 *   +0x06  word  parameter (from caller stack at sp+66)
 *   +0x08  word  corner0 X
 *   +0x0A  word  corner0 Y
 *   +0x0C  word  corner1 X
 *   +0x0E  word  corner1 Y
 *   +0x10  word  corner2 X
 *   +0x12  word  corner2 Y
 *   +0x14  word  corner3 X
 *   +0x16  word  corner3 Y
 *
 * Record counter at sym_0605AAA0 is incremented at exit.
 *
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06011B08


    .global hud_damage_warning
    .type hud_damage_warning, @function
hud_damage_warning:
    sts.l pr, @-r15                     ! save return address
    add #-0x18, r15                     ! allocate 24 bytes of local stack space
    mov.l r4, @(12, r15)               ! save x_base to sp[12]
    mov r15, r6                         ! r6 = sp (cos output pointer base)
    mov.l r5, @(8, r15)                ! save y_base to sp[8]
    add #0x4, r6                        ! r6 = sp+4 (cos output pointer)
    mov.l @(60, r15), r10              ! r10 = scale factor from caller stack
    mov r15, r5                         ! r5 = sp (sin output pointer)
    mov.l   .L_fn_sincos, r3           ! r3 = sincos_pair function address
    jsr @r3                             ! sincos_pair(angle, &sin_out, &cos_out)
    mov.w @(r0, r15), r4               ! (delay) r4 = angle word from caller stack at sp+r0

    /* --- Load persistent registers for all corner computations --- */
    neg r8, r4                          ! r4 = -cx (negated half-extent X)
    mov.l   .L_hud_record_base, r11    ! r11 = sym_060786CC (HUD record array base)
    mov.l   .L_hud_record_count, r12   ! r12 = sym_0605AAA0 (HUD record index pointer)
    mov.l   .L_fn_swap_sign_ext, r13   ! r13 = swap_sign_ext (extract int16 from 16.16)
    mov.l   .L_fn_fpmul, r14          ! r14 = fpmul (16.16 fixed-point multiply)

    /* ====== Corner 0: fields 0x08 (X), 0x0A (Y) ====== */
    /* --- Field 0x08: corner0 X = base_x + (cx*cos + cy*sin)*scale --- */
    mov.w @r12, r2                      ! r2 = record_index
    mov r2, r3                          ! r3 = index copy
    shll2 r2                            ! r2 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r2                             ! r2 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r2                          ! r2 = index * 24 (record stride)
    exts.w r2, r2                       ! sign-extend offset to 32 bits
    mov #0x8, r3                        ! r3 = field offset 0x08 (corner0 X)
    add r11, r2                         ! r2 = &record[index]
    add r2, r3                          ! r3 = &record[index].corner0_x
    mov.l r3, @-r15                     ! push dest_ptr for corner0_x
    mov.l @(8, r15), r5                ! r5 = cos value (sp+8 after push = orig sp+4)
    jsr @r14                            ! fpmul(-cx, cos)
    mov.l r4, @(24, r15)               ! (delay) save -cx to stack for reuse
    mov.l r0, @-r15                     ! push result: -cx*cos
    mov.l @(8, r15), r5                ! r5 = sin value (sp+8 after 2 pushes = orig sp+0)
    jsr @r14                            ! fpmul(cy, sin)
    mov r9, r4                          ! (delay) r4 = cy
    mov.l @r15+, r4                     ! pop (-cx*cos)
    sub r0, r4                          ! r4 = (-cx*cos) - (cy*sin) = -(cx*cos + cy*sin)
    jsr @r14                            ! fpmul(-(cx*cos + cy*sin), scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    neg r0, r0                          ! negate: now +(cx*cos + cy*sin)*scale
    mov.l r0, @-r15                     ! push rotated_x
    jsr @r13                            ! swap_sign_ext(x_base)
    mov.l @(20, r15), r4               ! (delay) r4 = x_base from sp[12] (adjusted for pushes)
    mov.l @r15+, r3                     ! pop rotated_x
    add r3, r0                          ! r0 = rotated_x + int16(x_base)
    mov.l @r15+, r2                     ! pop dest_ptr (&record.corner0_x)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.w r0, @r2                       ! write record[idx].corner0_x

    /* --- Field 0x0A: corner0 Y --- */
    mov.w @r12, r3                      ! r3 = record_index
    mov r3, r2                          ! r2 = index copy
    shll2 r3                            ! r3 = index * 4
    shll2 r2                            ! r2 = index * 4
    shll r3                             ! r3 = index * 8
    shll2 r2                            ! r2 = index * 16
    add r2, r3                          ! r3 = index * 24
    exts.w r3, r3                       ! sign-extend offset
    mov #0xA, r2                        ! r2 = field offset 0x0A (corner0 Y)
    add r11, r3                         ! r3 = &record[index]
    add r3, r2                          ! r2 = &record[index].corner0_y
    mov.l r2, @-r15                     ! push dest_ptr for corner0_y
    mov.l @(4, r15), r5                ! r5 = sin value (sp+4 after push = orig sp+0)
    jsr @r14                            ! fpmul(-cx, sin)
    mov.l @(24, r15), r4               ! (delay) r4 = -cx (saved earlier)
    mov.l r0, @-r15                     ! push result: -cx*sin
    mov.l @(12, r15), r5              ! r5 = cos value (sp+12 after 2 pushes = orig sp+4)
    jsr @r14                            ! fpmul(cy, cos)
    mov r9, r4                          ! (delay) r4 = cy
    mov.l @r15+, r4                     ! pop (-cx*sin)
    add r0, r4                          ! r4 = (-cx*sin) + (cy*cos)
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    mov.l r0, @-r15                     ! push int16(rotated_y)
    jsr @r13                            ! swap_sign_ext(y_base)
    mov.l @(16, r15), r4               ! (delay) r4 = y_base from sp[8] (adjusted for pushes)
    mov.l @r15+, r3                     ! pop int16(rotated_y)
    add r3, r0                          ! r0 = int16(rotated_y) + int16(y_base)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.l @r15+, r3                     ! pop dest_ptr (&record.corner0_y)
    mov.w r0, @r3                       ! write record[idx].corner0_y

    /* ====== Corner 1: fields 0x0C (X), 0x0E (Y) ====== */
    /* --- Field 0x0C: corner1 X = base_x - (cx*cos + cy*sin)*scale --- */
    mov.w @r12, r2                      ! r2 = record_index
    mov r2, r3                          ! r3 = index copy
    shll2 r2                            ! r2 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r2                             ! r2 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r2                          ! r2 = index * 24
    exts.w r2, r2                       ! sign-extend offset
    mov #0xC, r3                        ! r3 = field offset 0x0C (corner1 X)
    add r11, r2                         ! r2 = &record[index]
    add r2, r3                          ! r3 = &record[index].corner1_x
    mov.l r3, @-r15                     ! push dest_ptr for corner1_x
    mov.l @(8, r15), r5                ! r5 = cos value
    jsr @r14                            ! fpmul(cx, cos) -- r4=cx (positive, from r8)
    mov r8, r4                          ! (delay) r4 = cx
    mov.l r0, @-r15                     ! push result: cx*cos
    mov.l @(8, r15), r5                ! r5 = sin value
    jsr @r14                            ! fpmul(cy, sin)
    mov r9, r4                          ! (delay) r4 = cy
    mov.l @r15+, r4                     ! pop (cx*cos)
    sub r0, r4                          ! r4 = (cx*cos) - (cy*sin)
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    neg r0, r0                          ! negate rotated_x
    mov.l r0, @-r15                     ! push -int16(rotated_x)
    jsr @r13                            ! swap_sign_ext(x_base)
    mov.l @(20, r15), r4               ! (delay) r4 = x_base (adjusted for pushes)
    mov.l @r15+, r3                     ! pop -int16(rotated_x)
    add r3, r0                          ! r0 = int16(x_base) - int16(rotated_x)
    mov.l @r15+, r2                     ! pop dest_ptr (&record.corner1_x)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.w r0, @r2                       ! write record[idx].corner1_x

    /* --- Field 0x0E: corner1 Y --- */
    mov.w @r12, r3                      ! r3 = record_index
    mov r3, r2                          ! r2 = index copy
    shll2 r3                            ! r3 = index * 4
    shll2 r2                            ! r2 = index * 4
    shll r3                             ! r3 = index * 8
    shll2 r2                            ! r2 = index * 16
    add r2, r3                          ! r3 = index * 24
    exts.w r3, r3                       ! sign-extend offset
    mov #0xE, r2                        ! r2 = field offset 0x0E (corner1 Y)
    add r11, r3                         ! r3 = &record[index]
    add r3, r2                          ! r2 = &record[index].corner1_y
    mov.l r2, @-r15                     ! push dest_ptr for corner1_y
    mov.l @(4, r15), r5                ! r5 = sin value
    jsr @r14                            ! fpmul(cx, sin)
    mov r8, r4                          ! (delay) r4 = cx
    mov.l r0, @-r15                     ! push result: cx*sin
    bra     .L_after_pool               ! jump over constant pool
    nop                                 ! (delay) alignment
    .2byte  0xFFFF                      /* padding to align pool */
.L_fn_sincos:
    .4byte  sincos_pair                 /* sin/cos lookup function */
.L_hud_record_base:
    .4byte  sym_060786CC                /* HUD record array base address */
.L_hud_record_count:
    .4byte  sym_0605AAA0                /* HUD record count/index (16-bit) */
.L_fn_swap_sign_ext:
    .4byte  swap_sign_ext               /* extract int16 from 16.16 fixed-point */
.L_fn_fpmul:
    .4byte  fpmul                       /* 16.16 fixed-point multiply */

    /* --- Continue corner1 Y computation after pool --- */
.L_after_pool:
    mov.l @(12, r15), r5              ! r5 = cos value (adjusted for pushes)
    jsr @r14                            ! fpmul(cy, cos)
    mov r9, r4                          ! (delay) r4 = cy
    mov.l @r15+, r4                     ! pop (cx*sin)
    add r0, r4                          ! r4 = (cx*sin) + (cy*cos)
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    mov.l r0, @-r15                     ! push int16(rotated_y)
    jsr @r13                            ! swap_sign_ext(y_base)
    mov.l @(16, r15), r4               ! (delay) r4 = y_base (adjusted for pushes)
    mov.l @r15+, r3                     ! pop int16(rotated_y)
    add r3, r0                          ! r0 = int16(rotated_y) + int16(y_base)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.l @r15+, r3                     ! pop dest_ptr (&record.corner1_y)
    mov.w r0, @r3                       ! write record[idx].corner1_y

    /* ====== Corner 2: fields 0x10 (X), 0x12 (Y) ====== */
    /* --- Field 0x10: corner2 X --- */
    mov.w @r12, r2                      ! r2 = record_index
    mov r2, r3                          ! r3 = index copy
    shll2 r2                            ! r2 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r2                             ! r2 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r2                          ! r2 = index * 24
    exts.w r2, r2                       ! sign-extend offset
    mov #0x10, r3                       ! r3 = field offset 0x10 (corner2 X)
    add r11, r2                         ! r2 = &record[index]
    add r2, r3                          ! r3 = &record[index].corner2_x
    mov.l r3, @-r15                     ! push dest_ptr for corner2_x
    mov.l @(8, r15), r5                ! r5 = cos value
    jsr @r14                            ! fpmul(cx, cos)
    mov r8, r4                          ! (delay) r4 = cx
    mov.l r0, @-r15                     ! push result: cx*cos
    neg r9, r4                          ! r4 = -cy (negated half-extent Y)
    mov.l @(8, r15), r5                ! r5 = sin value
    jsr @r14                            ! fpmul(-cy, sin)
    mov.l r4, @(24, r15)               ! (delay) save -cy to stack for Y field reuse
    mov.l @r15+, r4                     ! pop (cx*cos)
    sub r0, r4                          ! r4 = (cx*cos) - (-cy*sin) = cx*cos + cy*sin
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    neg r0, r0                          ! negate rotated_x
    mov.l r0, @-r15                     ! push -int16(rotated_x)
    jsr @r13                            ! swap_sign_ext(x_base)
    mov.l @(20, r15), r4               ! (delay) r4 = x_base (adjusted for pushes)
    mov.l @r15+, r3                     ! pop -int16(rotated_x)
    add r3, r0                          ! r0 = int16(x_base) - int16(rotated_x)
    mov.l @r15+, r2                     ! pop dest_ptr (&record.corner2_x)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.w r0, @r2                       ! write record[idx].corner2_x

    /* --- Field 0x12: corner2 Y --- */
    mov.w @r12, r3                      ! r3 = record_index
    mov r3, r2                          ! r2 = index copy
    shll2 r3                            ! r3 = index * 4
    shll2 r2                            ! r2 = index * 4
    shll r3                             ! r3 = index * 8
    shll2 r2                            ! r2 = index * 16
    add r2, r3                          ! r3 = index * 24
    exts.w r3, r3                       ! sign-extend offset
    mov #0x12, r2                       ! r2 = field offset 0x12 (corner2 Y)
    add r11, r3                         ! r3 = &record[index]
    add r3, r2                          ! r2 = &record[index].corner2_y
    mov.l r2, @-r15                     ! push dest_ptr for corner2_y
    mov.l @(4, r15), r5                ! r5 = sin value
    jsr @r14                            ! fpmul(cx, sin)
    mov r8, r4                          ! (delay) r4 = cx
    mov.l r0, @-r15                     ! push result: cx*sin
    mov.l @(12, r15), r5              ! r5 = cos value (adjusted for pushes)
    jsr @r14                            ! fpmul(-cy, cos)
    mov.l @(24, r15), r4               ! (delay) r4 = -cy (saved earlier)
    mov.l @r15+, r4                     ! pop (cx*sin)
    add r0, r4                          ! r4 = (cx*sin) + (-cy*cos)
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    mov.l r0, @-r15                     ! push int16(rotated_y)
    jsr @r13                            ! swap_sign_ext(y_base)
    mov.l @(16, r15), r4               ! (delay) r4 = y_base (adjusted for pushes)
    mov.l @r15+, r3                     ! pop int16(rotated_y)
    add r3, r0                          ! r0 = int16(rotated_y) + int16(y_base)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.l @r15+, r3                     ! pop dest_ptr (&record.corner2_y)
    mov.w r0, @r3                       ! write record[idx].corner2_y

    /* ====== Corner 3: fields 0x14 (X), 0x16 (Y) ====== */
    /* --- Field 0x14: corner3 X --- */
    mov.w @r12, r2                      ! r2 = record_index
    mov r2, r3                          ! r3 = index copy
    shll2 r2                            ! r2 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r2                             ! r2 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r2                          ! r2 = index * 24
    exts.w r2, r2                       ! sign-extend offset
    mov #0x14, r3                       ! r3 = field offset 0x14 (corner3 X)
    add r11, r2                         ! r2 = &record[index]
    add r2, r3                          ! r3 = &record[index].corner3_x
    mov.l r3, @-r15                     ! push dest_ptr for corner3_x
    mov.l @(8, r15), r5                ! r5 = cos value
    jsr @r14                            ! fpmul(-cx, cos)
    mov.l @(24, r15), r4               ! (delay) r4 = -cx (saved earlier)  [Note: reuses -cy save slot; by this point r4 was re-saved as -cx]
    mov.l r0, @-r15                     ! push result: -cx*cos
    mov.l @(8, r15), r5                ! r5 = sin value
    jsr @r14                            ! fpmul(-cy, sin)
    mov.l @(24, r15), r4               ! (delay) r4 = -cy (from stack)
    mov.l @r15+, r4                     ! pop (-cx*cos)
    sub r0, r4                          ! r4 = (-cx*cos) - (-cy*sin) = -cx*cos + cy*sin
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    neg r0, r0                          ! negate rotated_x
    mov.l r0, @-r15                     ! push -int16(rotated_x)
    jsr @r13                            ! swap_sign_ext(x_base)
    mov.l @(20, r15), r4               ! (delay) r4 = x_base (adjusted for pushes)
    mov.l @r15+, r3                     ! pop -int16(rotated_x)
    add r3, r0                          ! r0 = int16(x_base) - int16(rotated_x)
    mov.l @r15+, r2                     ! pop dest_ptr (&record.corner3_x)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.w r0, @r2                       ! write record[idx].corner3_x

    /* --- Field 0x16: corner3 Y --- */
    mov.w @r12, r3                      ! r3 = record_index
    mov r3, r2                          ! r2 = index copy
    shll2 r3                            ! r3 = index * 4
    shll2 r2                            ! r2 = index * 4
    shll r3                             ! r3 = index * 8
    shll2 r2                            ! r2 = index * 16
    add r2, r3                          ! r3 = index * 24
    exts.w r3, r3                       ! sign-extend offset
    mov #0x16, r2                       ! r2 = field offset 0x16 (corner3 Y)
    add r11, r3                         ! r3 = &record[index]
    add r3, r2                          ! r2 = &record[index].corner3_y
    mov.l r2, @-r15                     ! push dest_ptr for corner3_y
    mov.l @(4, r15), r5                ! r5 = sin value
    jsr @r14                            ! fpmul(-cx, sin)
    mov.l @(24, r15), r4               ! (delay) r4 = -cx (from stack)
    mov.l r0, @-r15                     ! push result: -cx*sin
    mov.l @(12, r15), r5              ! r5 = cos value (adjusted for pushes)
    jsr @r14                            ! fpmul(-cy, cos)
    mov.l @(24, r15), r4               ! (delay) r4 = -cy (from stack)
    mov.l @r15+, r4                     ! pop (-cx*sin)
    add r0, r4                          ! r4 = (-cx*sin) + (-cy*cos)
    jsr @r14                            ! fpmul(result, scale)
    mov r10, r5                         ! (delay) r5 = scale
    jsr @r13                            ! swap_sign_ext => int16(result)
    mov r0, r4                          ! (delay) r4 = scaled result
    mov.l r0, @-r15                     ! push int16(rotated_y)
    jsr @r13                            ! swap_sign_ext(y_base)
    mov.l @(16, r15), r4               ! (delay) r4 = y_base (adjusted for pushes)
    mov #0x0, r4                        ! r4 = 0 (overrides delay slot; used for flag bytes below)
    mov.l @r15+, r3                     ! pop int16(rotated_y)
    add r3, r0                          ! r0 = int16(rotated_y) + int16(y_base)
    exts.w r0, r0                       ! sign-extend to 32 bits
    mov.l @r15+, r3                     ! pop dest_ptr (&record.corner3_y)
    mov.w r0, @r3                       ! write record[idx].corner3_y

    /* ====== Write parameter word at record+0x06 ====== */
    mov #0x42, r0                       ! r0 = 0x42 = 66 (offset to caller's param on stack)
    mov.w @r12, r2                      ! r2 = record_index
    mov.w @(r0, r15), r0               ! r0 = 16-bit parameter word from caller stack
    mov r2, r3                          ! r3 = index copy
    shll2 r2                            ! r2 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r2                             ! r2 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r2                          ! r2 = index * 24
    exts.w r2, r2                       ! sign-extend offset
    add r11, r2                         ! r2 = &record[index]
    mov.w r0, @(6, r2)                 ! record[idx].field_0x06 = parameter word

    /* ====== Write visibility flags at record+0x04, +0x05 ====== */
    mov.w @r12, r3                      ! r3 = record_index
    mov r3, r2                          ! r2 = index copy
    shll2 r3                            ! r3 = index * 4
    shll r3                             ! r3 = index * 8
    shll2 r2                            ! r2 = index * 4
    shll2 r2                            ! r2 = index * 16
    bra     .L_write_flags              ! branch to flag writes (compiler artifact: target is next insn)
    nop                                 ! (delay)
.L_write_flags:
    add r2, r3                          ! r3 = index * 24
    extu.b r4, r0                       ! r0 = (byte)r4 = 0 (flag value)
    exts.w r3, r3                       ! sign-extend offset
    add r11, r3                         ! r3 = &record[index]
    mov.b r0, @(4, r3)                 ! record[idx].field_0x04 = 0 (visibility flag A)

    mov.w @r12, r3                      ! r3 = record_index (reload)
    extu.b r4, r0                       ! r0 = (byte)r4 = 0 (flag value)
    mov r3, r2                          ! r2 = index copy
    shll2 r3                            ! r3 = index * 4
    shll2 r2                            ! r2 = index * 4
    shll r3                             ! r3 = index * 8
    shll2 r2                            ! r2 = index * 16
    add r2, r3                          ! r3 = index * 24
    exts.w r3, r3                       ! sign-extend offset
    add r11, r3                         ! r3 = &record[index]
    mov.b r0, @(5, r3)                 ! record[idx].field_0x05 = 0 (visibility flag B)

    /* ====== Increment record counter and return ====== */
    mov.w @r12, r3                      ! r3 = current record_index
    add #0x1, r3                        ! r3 = record_index + 1
    mov.w r3, @r12                      ! store incremented record count
    add #0x18, r15                      ! deallocate 24 bytes of local stack
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8 (caller-saved)
    mov.l @r15+, r9                     ! restore r9 (caller-saved)
    mov.l @r15+, r10                    ! restore r10 (caller-saved)
    mov.l @r15+, r11                    ! restore r11 (caller-saved)
    mov.l @r15+, r12                    ! restore r12 (caller-saved)
    mov.l @r15+, r13                    ! restore r13 (caller-saved)
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14 (caller-saved)
