/* timer_overflow_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040724 - 0x0604077C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Computes a position offset from game state context fields.
 *
 * If the field byte at (r0 + r4) is zero, returns r5 unchanged (no overflow).
 * Otherwise reads the base value at offset 0x1E, divides r5 by that value
 * (signed), reads an adjustment byte at offset 0x1F, computes
 * (base + adjustment) * quotient, then takes the signed modulo to get the
 * remainder, and returns quotient + remainder.
 *
 * Arguments:
 *   r0  = field byte index into game state context (e.g. 0x1E)
 *   r4  = game state context pointer
 *   r5  = event source value (dividend)
 *
 * Returns:
 *   r0  = computed position offset, or r5 if field byte is zero
 *
 * Calls:
 *   sym_06034FFC (signed_div_32) -- r0 = r1 / r0 (signed 32-bit divide)
 *   sym_06036BE4 (signed_mod_32) -- r0 = r1 % r0 (signed 32-bit modulo)
 */

    .section .text.FUN_06040724


    .global timer_overflow_handler
    .type timer_overflow_handler, @function
timer_overflow_handler:
    sts.l pr, @-r15                     ! save return address
    sts.l macl, @-r15                   ! save macl (used by mul.l below)
    mov.b @(r0, r4), r3                 ! r3 = context[field_index] (field byte)
    extu.b r3, r3                       ! zero-extend byte to word
    tst r3, r3                          ! field byte == 0?
    bf      .L_field_nonzero            ! if nonzero, compute offset
    mov r5, r0                          ! r0 = r5 (return source value unchanged)
    lds.l @r15+, macl                   ! restore macl
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return r5 (no overflow)
    nop                                 ! [delay slot]
.L_field_nonzero:
    mov #0x1E, r0                       ! r0 = 0x1E (base value field offset)
    mov r5, r1                          ! r1 = event source value (dividend)
    mov.l   .L_fn_signed_div, r3        ! r3 = &signed_div_32
    mov.b @(r0, r4), r6                 ! r6 = context[0x1E] (base divisor)
    extu.b r6, r6                       ! zero-extend to word
    jsr @r3                             ! r0 = r1 / r6 (signed divide)
    mov r6, r0                          ! [delay slot] r0 = divisor
    mov #0x1F, r2                       ! r2 = 0x1F (adjustment field offset)
    mov r6, r3                          ! r3 = base divisor value
    mov r5, r1                          ! r1 = event source value (for modulo)
    add r4, r2                          ! r2 = &context[0x1F]
    mov.b @r2, r2                       ! r2 = context[0x1F] (adjustment byte)
    extu.b r2, r2                       ! zero-extend to word
    add r2, r3                          ! r3 = base + adjustment
    mul.l r3, r0                        ! macl = (base + adjustment) * quotient
    mov.l   .L_fn_signed_mod, r2        ! r2 = &signed_mod_32
    sts macl, r0                        ! r0 = (base + adjustment) * quotient
    mov r0, r3                          ! r3 = product (save for later add)
    jsr @r2                             ! r0 = r1 % r6 (signed modulo)
    mov r6, r0                          ! [delay slot] r0 = divisor
    add r3, r0                          ! r0 = remainder + product (final offset)
    lds.l @r15+, macl                   ! restore macl
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return computed offset
    nop                                 ! [delay slot]
    .4byte  ai_section_check            ! pool: cross-TU ref (used by sys_timer_tick)
    .4byte  sym_06040FEA                ! pool: boundary lock release (used by sys_timer_tick)
.L_fn_signed_div:
    .4byte  sym_06034FFC                ! signed_div_32: r0 = r1 / r0
.L_fn_signed_mod:
    .4byte  sym_06036BE4                ! signed_mod_32: r0 = r1 % r0
