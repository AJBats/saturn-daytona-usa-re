/* sys_timer_config -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B7C0 - 0x0603B8B4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Menu element flag search.
 *
 * Walks an array of display elements (stride-12 or stride-16 depending on
 * the config struct's mode flag at @r13) and returns the 1-based index of
 * the first element whose flags byte (offset 11 in the element record) has
 * bit 0x0080 set.  Returns 0 if the search passes the last element without
 * finding a match.
 *
 * Args:
 *   r4 = pointer to search config struct:
 *          @+0x00  = mode flag  (0 = stride-12 / sprite_batch_emit,
 *                               !0 = stride-16 / sym_0603F216)
 *          @+0x04  = element count (loop limit)
 *          @+0x08  = array base pointer (passed as r5 to accessor)
 *
 * Returns:
 *   r0 = 1-based index of first element with flags & 0x0080 set,
 *        or 0 if no match found within count.
 *
 * Calls:
 *   sym_0603F216     -- element accessor, stride-16: byte @offset-11
 *   sprite_batch_emit -- element accessor, stride-12: byte @offset-11
 */

    .section .text.FUN_0603B7C0


    .global sys_timer_config
    .type sys_timer_config, @function
sys_timer_config:
    mov.l r14, @-r15                    ! push r14 (callee-saved)
    mov.l r13, @-r15                    ! push r13 (callee-saved)
    mov.l r12, @-r15                    ! push r12 (callee-saved)
    mov.l r11, @-r15                    ! push r11 (callee-saved)
    mov.l r10, @-r15                    ! push r10 (callee-saved)
    sts.l pr, @-r15                     ! push PR (return address)
    mov.l   .L_pool_elem_accessor_16, r10  ! r10 = sym_0603F216 (stride-16 element accessor)
    mov.l   .L_pool_elem_accessor_12, r11  ! r11 = sprite_batch_emit (stride-12 element accessor)
    mov.w   DAT_0603b838, r12           ! r12 = 0x0080 (flag bit mask: bit 7)
    mov r4, r13                         ! r13 = config struct pointer
    bra     .L_loop_check               ! jump to loop condition first (do-while structure)
    mov #0x0, r14                       ! r14 = 0 (element index counter; delay slot)
.L_loop_body:
    mov.l @r13, r0                      ! r0 = config->mode (0 = stride-12, nonzero = stride-16)
    tst r0, r0                          ! test mode flag: is it zero?
    bf      .L_use_stride16             ! if nonzero (T=0): use stride-16 accessor
    mov.l @(8, r13), r5                 ! r5 = config->array_base (passed to stride-12 accessor)
    jsr @r11                            ! call sprite_batch_emit(r4=index, r5=base) → flags byte
    mov r14, r4                         ! r4 = current element index (delay slot)
    bra     .L_check_flag               ! skip stride-16 branch
    nop                                 ! delay slot
.L_use_stride16:
    mov.l @(8, r13), r5                 ! r5 = config->array_base (passed to stride-16 accessor)
    jsr @r10                            ! call sym_0603F216(r4=index, r5=base) → flags byte
    mov r14, r4                         ! r4 = current element index (delay slot)
.L_check_flag:
    mov r0, r4                          ! r4 = returned flags byte
    and r12, r4                         ! r4 = flags & 0x0080 (isolate bit 7)
    tst r4, r4                          ! test if bit 7 is set
    bt      .L_flag_clear               ! if zero (bit not set): continue loop
    bra     .L_post_loop                ! bit set: stop search
    nop                                 ! delay slot
.L_flag_clear:
    add #0x1, r14                       ! index++ (advance to next element)
.L_loop_check:
    mov.l @(4, r13), r2                 ! r2 = config->count (element limit)
    cmp/ge r2, r14                      ! test: r14 >= count?
    bf      .L_loop_body                ! if r14 < count: continue iterating
.L_post_loop:
    mov.l @(4, r13), r2                 ! r2 = config->count (reload for final comparison)
    cmp/gt r2, r14                      ! T = (r14 > count); true only if count was negative
    bf      .L_found_in_range           ! if r14 <= count: return r14+1 (found or not-found sentinel)
    bra     .L_return                   ! r14 > count (count negative): return 0 as error sentinel
    mov #0x0, r0                        ! r0 = 0 (error return; delay slot)
.L_found_in_range:
    mov r14, r0                         ! r0 = element index r14 (0-based)
    add #0x1, r0                        ! r0 = r14 + 1 (1-based: found index, or count+1 if exhausted)
.L_return:
    lds.l @r15+, pr                     ! pop PR (return address)
    mov.l @r15+, r10                    ! pop r10
    mov.l @r15+, r11                    ! pop r11
    mov.l @r15+, r12                    ! pop r12
    mov.l @r15+, r13                    ! pop r13
    rts                                 ! return (r0 = 1-based index or 0)
    mov.l @r15+, r14                    ! pop r14 (delay slot)
    .2byte  0xE700                      ! literal pool padding / next-function code data
    .4byte  0xD6096462                  ! next-function code data
    .4byte  0x9309343C                  ! next-function code data
    .4byte  0xA0136573                  ! next-function code data
    .4byte  0x9006004E                  ! next-function code data
    .4byte  0x20088B0B                  ! next-function code data
    .4byte  0xA0110009                  ! next-function code data

    .global DAT_0603b838
DAT_0603b838:
    .2byte  0x0080                      ! bit mask: test bit 7 (0x0080) of element flags byte

    .global DAT_0603b83a
DAT_0603b83a:
    .2byte  0x0C3C                      ! word pool value used by buffer slot allocator
    .4byte  0x00ECFFFF                  ! pool data for buffer slot allocator
.L_pool_elem_accessor_16:
    .4byte  sym_0603F216                ! sym_0603F216: element accessor, stride-16
.L_pool_elem_accessor_12:
    .4byte  sprite_batch_emit           ! sprite_batch_emit: element accessor, stride-12
    .4byte  sym_060A4D14                ! pool: global state base pointer (used by embedded helpers)
    .4byte  0x921E342C                  ! next-function code data
    .4byte  0x75016362                  ! next-function code data
    .4byte  0x62323523                  ! next-function code data
    .4byte  0x8BE86262                  ! next-function code data
    .4byte  0x63223530                  ! next-function code data
    .4byte  0x8B01A003                  ! next-function code data
    .4byte  0x6473E201                  ! next-function code data
    .4byte  0x90110426                  ! next-function code data
    .4byte  0x000B6043                  ! next-function code data
    .4byte  0xE300900C                  ! next-function code data
    .4byte  0x000B0436                  ! next-function code data
    .4byte  0xD7066572                  ! next-function code data
    .4byte  0x9308353C                  ! next-function code data
    .4byte  0xA00DE600                  ! next-function code data
    .4byte  0x35408B07                  ! next-function code data
    .4byte  0xA00D0009                  ! next-function code data

    .global DAT_0603b88c
DAT_0603b88c:
    .2byte  0x00F0                      ! word pool value used by element range checker

    .global DAT_0603b88e
DAT_0603b88e:
    .2byte  0x00EC                      ! word pool value used by element range checker
    .4byte  0x0C3CFFFF                  ! pool data for element range checker
    .4byte  sym_060A4D14                ! pool: global state base pointer
    .4byte  0x923F352C                  ! next-function code data
    .4byte  0x76016372                  ! next-function code data
    .4byte  0x62323623                  ! next-function code data
    .4byte  0x8BEE6272                  ! next-function code data
    .4byte  0x63223630                  ! next-function code data
    .4byte  0x8B00E500                  ! next-function code data
    .4byte  0x000B6053                  ! next-function code data
