/* trans_select_at_mt -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06019D14 - 0x06019DB8
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06019D14


    .global trans_select_at_mt
    .type trans_select_at_mt, @function
trans_select_at_mt:
    mov.l r14, @-r15                        ! push r14 onto stack
    mov.l r13, @-r15                        ! push r13 onto stack
    mov.l   .L_pool_sel_index, r14          ! r14 = &sym_0605AD00 (selection index pointer)
    mov.l   .L_pool_btn_dpad_up, r6                  ! r6 = 0x8000 (D-pad up button mask)
    mov.l   .L_pool_btn_state, r5           ! r5 = &g_pad_state (held/new button state base)
    mov.l   .L_pool_trans_byte, r4          ! r4 = &sym_0605D243 (AT/MT selection byte)
    mov.w @(2, r5), r0                      ! r0 = *(g_pad_state + 2) = new button presses word (0x06063D9A)
    mov r0, r3                              ! r3 = new button presses
    extu.w r3, r3                           ! r3 = (unsigned word) new button presses
    and r6, r3                              ! r3 &= 0x8000; test D-pad up new press
    tst r3, r3                              ! is D-pad up newly pressed?
    bt/s    .L_check_down_new              ! if not: skip to check D-pad down new press
    mov #0x0, r13                           ! (delay slot) r13 = 0 (value to write to AT/MT byte)
    mov.l @r14, r3                          ! r3 = *sel_index (current selection 0-2)
    add #0x1, r3                            ! r3 = sel_index + 1 (move up in list)
    mov.l r3, @r14                          ! *sel_index = sel_index + 1
    exts.b r13, r2                          ! r2 = sign-extend(0) = 0 (reset hold timer)
    bra     .L_clamp_check                 ! jump to clamp/wrap check
    mov.b r2, @r4                           ! (delay slot) *(AT/MT byte) = 0 (reset hold counter)
.L_check_down_new:
    mov.w   .L_wpool_btn_dpad_down, r7           ! r7 = 0x4000 (D-pad down button mask)
    mov.w @(2, r5), r0                      ! r0 = new button presses word (0x06063D9A)
    mov r0, r2                              ! r2 = new button presses
    extu.w r2, r2                           ! r2 = (unsigned word) new button presses
    and r7, r2                              ! r2 &= 0x4000; test D-pad down new press
    tst r2, r2                              ! is D-pad down newly pressed?
    bt      .L_check_up_held               ! if not: skip to check held button state
    mov.l @r14, r3                          ! r3 = *sel_index (current selection 0-2)
    add #-0x1, r3                           ! r3 = sel_index - 1 (move down in list)
    mov.l r3, @r14                          ! *sel_index = sel_index - 1
    exts.b r13, r2                          ! r2 = sign-extend(0) = 0 (reset hold timer)
    bra     .L_clamp_check                 ! jump to clamp/wrap check
    mov.b r2, @r4                           ! (delay slot) *(AT/MT byte) = 0 (reset hold counter)
.L_check_up_held:
    mov.w @r5, r2                           ! r2 = held button state word (0x06063D98)
    extu.w r2, r2                           ! r2 = (unsigned word) held buttons
    and r6, r2                              ! r2 &= 0x8000; test D-pad up held
    tst r2, r2                              ! is D-pad up held?
    bt      .L_check_down_held             ! if not: check D-pad down held
    mov.b @r4, r0                           ! r0 = *(AT/MT byte) (hold repeat counter)
    cmp/eq #0x19, r0                        ! is hold counter == 25 (repeat threshold)?
    bf      .L_clamp_check                 ! if not yet at threshold: go to clamp (increment counter below)
    mov.l @r14, r2                          ! r2 = *sel_index
    add #0x1, r2                            ! r2 = sel_index + 1 (auto-repeat up)
    mov.l r2, @r14                          ! *sel_index = sel_index + 1
    exts.b r13, r3                          ! r3 = sign-extend(0) = 0 (reset hold timer)
    mov.b r3, @r4                           ! *(AT/MT byte) = 0 (reset hold counter after repeat)
    bra     .L_clamp_check                 ! jump to clamp/wrap check
    nop                                     ! (delay slot) no-op
.L_check_down_held:
    mov.w @r5, r2                           ! r2 = held button state word (0x06063D98)
    extu.w r2, r2                           ! r2 = (unsigned word) held buttons
    and r7, r2                              ! r2 &= 0x4000; test D-pad down held
    tst r2, r2                              ! is D-pad down held?
    bt      .L_clamp_check                 ! if not: skip to clamp (no input this frame)
    mov.b @r4, r0                           ! r0 = *(AT/MT byte) (hold repeat counter)
    cmp/eq #0x19, r0                        ! is hold counter == 25 (repeat threshold)?
    bf      .L_clamp_check                 ! if not yet at threshold: go to clamp
    mov.l @r14, r2                          ! r2 = *sel_index
    add #-0x1, r2                           ! r2 = sel_index - 1 (auto-repeat down)
    mov.l r2, @r14                          ! *sel_index = sel_index - 1
    exts.b r13, r3                          ! r3 = sign-extend(0) = 0 (reset hold timer)
    mov.b r3, @r4                           ! *(AT/MT byte) = 0 (reset hold counter after repeat)
.L_clamp_check:
    mov.l @r14, r2                          ! r2 = *sel_index (updated selection)
    mov #0x2, r3                            ! r3 = 2 (upper bound)
    cmp/gt r3, r2                           ! is sel_index > 2?
    bf      .L_clamp_lo                    ! if sel_index <= 2: check lower bound
    mov.l r13, @r14                         ! *sel_index = 0 (wrap: exceeded upper bound, reset to 0)
.L_clamp_lo:
    mov.l @r14, r3                          ! r3 = *sel_index (after possible upper clamp)
    cmp/pz r3                               ! is sel_index >= 0?
    bt      .L_done                         ! if non-negative: selection is valid, done
    mov #0x2, r3                            ! r3 = 2 (lower wrap-around value)
    mov.l r3, @r14                          ! *sel_index = 2 (wrap: went below 0, reset to 2)
.L_done:
    mov.l @r15+, r13                        ! pop r13 from stack
    .byte   0xAF, 0x11    /* bra 0x06019BC8 (external) */
    mov.l @r15+, r14                        ! (delay slot) pop r14 from stack
.L_wpool_btn_dpad_down:
    .2byte  0x4000                      /* [HIGH] D-pad down button mask */
.L_pool_sel_index:
    .4byte  sym_0605AD00                /* [HIGH] &selection index (0-2, AT/MT menu position) */
.L_pool_btn_dpad_up:
    .4byte  0x00008000                  /* [HIGH] D-pad up button mask (bit 15) */
.L_pool_btn_state:
    .4byte  g_pad_state                /* [HIGH] &held/new button state base (+0=held, +2=new) */
.L_pool_trans_byte:
    .4byte  sym_0605D243                /* [MEDIUM] &hold repeat counter byte (AT/MT selection) */
