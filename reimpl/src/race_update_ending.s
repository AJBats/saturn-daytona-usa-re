/* race_update_ending -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600E060 - 0x0600E0C0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Race ending single-car update — called from State 29 (post-race results
 * screen) to process the player car each frame during the ending sequence.
 *
 * Performs a simplified version of the per-car update pipeline:
 *   1. Load car array base pointer, compute half-car-count for
 *      visibility state, store current car and data table pointers.
 *   2. Call register-save prologue (sym_0602DC18: pushes r8-r13).
 *   3. Query terrain elevation via coord_grid_pack using car
 *      position fields (Z at offset +24, X at offset +16).
 *   4. Store elevation result to coordinate transform result.
 *   5. Call segment_position_track to update track segment.
 *   6. Submit 4 geometry channels to scene_3d_processor (channels 0-3).
 *   7. Call disp_mode_switch with pointer to car Y position (+0x14).
 *   8. Tail-branch to car_update_racing for the main car loop.
 *
 * Sibling of race_update_abort (0x0600DFD0) — same pipeline, different
 * prologue function and adds disp_mode_switch call.
 *
 * Called from: State 29 handler (FUN_0600955E) via jsr
 * Tail call: BRA to car_update_racing (0x0600E0C0)
 *
 * NOTE: Pool entries are cross-TU references into the car_update_racing
 * section (0x0600E0C0). Labels below name the data at those addresses.
 */

    .section .text.FUN_0600E060


    .global race_update_ending
    .type race_update_ending, @function
race_update_ending:
    mov.l r14, @-r15
    mov.l r13, @-r15
    sts.l pr, @-r15
    .byte   0xDE, 0x21    /* mov.l .L_pool_car_array_base_ptr, r14 */
    .byte   0xD3, 0x21    /* mov.l .L_pool_total_car_count, r3 */
    .byte   0xD2, 0x22    /* mov.l .L_pool_half_count_store, r2 */
    mov.l @r14, r14                   ! r14 = car array base (deref pointer-to-pointer)
    mov.l @r3, r3                     ! r3 = total car count value
    shar r3                           ! r3 = count >> 1 (arithmetic shift right = half)
    mov.w r3, @r2                     ! half_count_store = half car count (16-bit)
    .byte   0xD2, 0x20    /* mov.l .L_pool_cur_car_ptr, r2 */
    mov.l r14, @r2                    ! current_car_ptr = car array base
    .byte   0xD1, 0x20    /* mov.l .L_pool_car_data_table, r1 */
    .byte   0xD2, 0x21    /* mov.l .L_pool_car_data_slot, r2 */
    mov.l r1, @r2                     ! car_data_slot = car_data_table base
    .byte   0xD2, 0x21    /* mov.l .L_pool_fn_reg_save_prologue, r2 */
    jsr @r2                           ! call pipeline_reg_save — pushes r8-r13
    nop
    mov.l @(24, r14), r5              ! r5 = car.pos_z (offset +0x18)
    .byte   0xD3, 0x20    /* mov.l .L_pool_fn_coord_grid_pack, r3 */
    jsr @r3                           ! call coord_grid_pack(pos_x, pos_z) — terrain query
    mov.l @(16, r14), r4              ! r4 = car.pos_x (offset +0x10, delay slot)
    .byte   0xD3, 0x1F    /* mov.l .L_pool_coord_xform_result, r3 */
    mov.l r0, @r3                     ! store coord transform result (elevation)
    .byte   0xD3, 0x1F    /* mov.l .L_pool_fn_seg_pos_track, r3 */
    jsr @r3                           ! call segment_position_track()
    nop
    .byte   0xDD, 0x1F    /* mov.l .L_pool_fn_scene_3d_proc, r13 */
    .byte   0xD4, 0x1F    /* mov.l .L_pool_geom_channel_0, r4 */
    jsr @r13                          ! scene_3d_processor(channel_0, mode=0)
    mov #0x0, r5
    .byte   0xD4, 0x1F    /* mov.l .L_pool_geom_channel_1, r4 */
    jsr @r13                          ! scene_3d_processor(channel_1, mode=1)
    mov #0x1, r5
    .byte   0xD4, 0x1E    /* mov.l .L_pool_geom_channel_2, r4 */
    jsr @r13                          ! scene_3d_processor(channel_2, mode=2)
    mov #0x2, r5
    .byte   0xD4, 0x1E    /* mov.l .L_pool_geom_channel_3, r4 */
    jsr @r13                          ! scene_3d_processor(channel_3, mode=3)
    mov #0x3, r5
    mov r14, r4                       ! r4 = car array base
    .byte   0xD3, 0x1D    /* mov.l .L_pool_fn_disp_scroll, r3 */
    jsr @r3                           ! disp_mode_switch(&car.pos_y) — apply scroll offset
    add #0x14, r4                     ! r4 = &car.pos_y (offset +0x14, delay slot)
    lds.l @r15+, pr
    mov.l @r15+, r13
    .byte   0xA0, 0x00    /* bra 0x0600E0C0 (external) */  ! tail-branch to car_update_racing
    mov.l @r15+, r14
