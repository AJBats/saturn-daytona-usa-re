/* display_buffer_init -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036DDC - 0x06036E1C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * display_buffer_init(r4=dest, r5=src, r6=max_len):
 *   Copies bytes from src to dest, stopping at a null terminator or when
 *   max_len bytes have been written. If the source string is shorter than
 *   max_len, the remaining bytes in dest are zero-padded. Equivalent to
 *   strncpy(dest, src, max_len).
 *
 *   Args:
 *     r4 = destination buffer pointer
 *     r5 = source string pointer (null-terminated)
 *     r6 = maximum number of bytes to write
 *   Returns:
 *     r0 = original destination pointer (same as r4 on entry)
 */

    .section .text.FUN_06036DDC


    .global display_buffer_init
    .type display_buffer_init, @function
display_buffer_init:
    mov.l r14, @-r15                    ! save r14 (will use as zero constant)
    mov.l r13, @-r15                    ! save r13 (will use as source pointer)
    mov #0x0, r14                       ! r14 = 0 (zero constant for padding)
    mov r4, r7                          ! r7 = dest (working write pointer)
    mov r5, r13                         ! r13 = src (working read pointer)
    bra     .L_copy_test                ! jump to loop condition check
    mov r14, r5                         ! r5 = 0 (byte counter, delay slot)
.L_copy_byte:
    mov r7, r2                          ! r2 = current dest position
    add #0x1, r7                        ! advance dest write pointer
    mov.b @r13+, r1                     ! r1 = *src++, advance source pointer
    mov.b r1, @r2                       ! *dest_pos = copied byte
    add #0x1, r5                        ! byte_count++
.L_copy_test:
    cmp/hs r6, r5                       ! byte_count >= max_len?
    bt      .L_pad_check                ! yes -- done copying, check if padding needed
    mov.b @r13, r2                      ! r2 = peek at next source byte
    extu.b r2, r2                       ! zero-extend to 32 bits
    tst r2, r2                          ! is next source byte null?
    bf      .L_copy_byte                ! no -- keep copying
.L_pad_check:
    cmp/hs r6, r5                       ! byte_count >= max_len?
    bt      .L_done                     ! yes -- no padding needed, return
.L_pad_loop:
    extu.b r14, r3                      ! r3 = 0 (zero byte for padding)
    add #0x1, r5                        ! byte_count++
    mov.b r3, @r7                       ! *dest = 0 (write zero-pad byte)
    cmp/hs r6, r5                       ! byte_count >= max_len?
    bf/s    .L_pad_loop                 ! no -- continue zero-padding
    add #0x1, r7                        ! advance dest pointer (delay slot)
.L_done:
    mov r4, r0                          ! r0 = original dest pointer (return value)
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .4byte  0x2F362F46
