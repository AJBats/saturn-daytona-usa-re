/* smpc_cmd_helper_a -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06035C08 - 0x06035C54
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains four small utility functions:
 *   smpc_cmd_helper_a  -- strcpy wrapper: calls strcpy_unaligned(r4=dst, r5=src)
 *   sym_06035C1C       -- strlen: count bytes in null-terminated string at r4
 *   sym_06035C2C       -- hw_divide_32: r0 = r1 / r0 using SH-2 division unit
 *   sym_06035C48       -- pool_load_return: load a longword from constant pool, return it
 *   sym_06035C4E       -- read_cd_hirq: load HIRQ register address from pool, return word
 */

    .section .text.FUN_06035C08


    .global smpc_cmd_helper_a
    .type smpc_cmd_helper_a, @function
smpc_cmd_helper_a:
    sts.l pr, @-r15                     ! save return address
    mov r5, r1                          ! r1 = src (second arg becomes r1 for strcpy)
    mov.l   .L_pool_strcpy, r3          ! r3 = &strcpy_unaligned (sym_06035FEC)
    jsr @r3                             ! call strcpy_unaligned(r0=dst, r1=src)
    mov r4, r0                          ! (delay) r0 = dst (first arg becomes r0 for strcpy)
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return to caller
    nop                                 ! delay slot (no-op)
.L_pool_strcpy:
    .4byte  sym_06035FEC

    .global sym_06035C1C
sym_06035C1C:
    bra     .L_strlen_test              ! jump to loop test (check first byte)
    mov #0x0, r5                        ! (delay) r5 = 0 (length counter)
.L_strlen_inc:
    add #0x1, r5                        ! r5++ (count non-null byte)
.L_strlen_test:
    mov.b @r4+, r3                      ! r3 = *r4++ (read next byte from string)
    tst r3, r3                          ! is byte null terminator?
    bf      .L_strlen_inc               ! no → increment counter and continue
    rts                                 ! return (reached null terminator)
    mov r5, r0                          ! (delay) r0 = length (return value)

    .global sym_06035C2C
sym_06035C2C:
    mov.l r2, @-r15                     ! save r2
    mov.l r3, @-r15                     ! save r3
    mov.w   .L_wpool_06035C46, r3       ! r3 = 0xFFFFFF00 (DVSR — SH-2 division unit base)
    mov #0x0, r2                        ! r2 = 0 (clear value for DVCR)
    mov.l r0, @r3                       ! DVSR = r0 (set divisor)
    add #0x8, r3                        ! r3 = 0xFFFFFF08 (DVCR — division control register)
    mov.l r2, @r3                       ! DVCR = 0 (clear overflow flag)
    mov.l r1, @-r3                      ! r3 -= 4 → 0xFFFFFF04 (DVDNT); write r1 (triggers 32÷32 division)
    add #0xC, r3                        ! r3 = 0xFFFFFF04 + 0x0C = 0xFFFFFF10 (DVDNTH — quotient result)
    mov.l @r3, r0                       ! r0 = quotient (division result)
    mov.l @r15+, r3                     ! restore r3
    rts                                 ! return
    mov.l @r15+, r2                     ! (delay) restore r2
.L_wpool_06035C46:
    .2byte  0xFF00

    .global sym_06035C48
sym_06035C48:
    .byte   0xD0, 0x0A    /* mov.l .L_pool_06035C74, r0 */
    rts                                 ! return with pool value in r0
    nop                                 ! delay slot (no-op)

    .global sym_06035C4E
sym_06035C4E:
    .byte   0xD0, 0x0A    /* mov.l .L_pool_06035C78, r0 */
    rts                                 ! return with HIRQ status word in r0
    mov.w @r0, r0                       ! (delay) r0 = *(u16*)r0 (read HIRQ register word)
