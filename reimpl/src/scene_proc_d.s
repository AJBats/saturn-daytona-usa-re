/* scene_proc_d -- face projection & z-sort for 3D scene pipeline
 *
 * Translation unit: 0x0602B334 - 0x0602B9EC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * For each polygon in the input list:
 *   1. Transform 4 face vertices through 3x3 rotation + translation matrix
 *      using 32x32->64 MAC (fixed-point 16.16 dot products)
 *   2. Clamp projected depth (Z) to clip distance
 *   3. Test face visibility via dot product with camera normal
 *   4. Bounds-check all 4 projected vertices against screen limits
 *   5. Combine face depths (avg/min/max/max+bias) per polygon type
 *   6. Write final depth into z-sort buffer for draw-order sorting
 *
 * Called from scene graph walk with:
 *   r4 = face data array base
 *   r5 = vertex table ptr
 *   r6 = polygon group index
 *   r7 = face count
 */

    .section .text.FUN_0602B334


    .global scene_proc_d
    .type scene_proc_d, @function
scene_proc_d:
    mov.l r14, @-r15                    ! save callee-saved regs
    sts.l pr, @-r15
    mov r4, r8                          ! r8 = face data array
    mov.l   .L_ptr_clip_dist, r10
    mov.l @r10, r10                     ! r10 = max clip distance
    mov #0x18, r0                       ! 0x18 = sizeof(face_entry)
    mul.l r7, r0                        ! r7 = face count
    mov r5, r3
    mov r6, r13                         ! r13 = polygon group index
    mov r3, r14                         ! r14 = vertex table ptr
    sts macl, r0                        ! r0 = face_count * 0x18
    add r0, r8                          ! r8 -> past last face (iterate backwards)
.L_face_loop:
    mov.l r7, @-r15                     ! push remaining face count
    add #-0x18, r8                      ! step to previous face entry
    mov.w @(16, r8), r0                 ! face.vtx_idx[0] (vertex 0 index)
    extu.w r0, r4
    mov #0x6, r1                        ! 0x6 = sizeof(vertex_xyz) (3 words)
    mul.l r1, r4
    sts macl, r4
    add r14, r4                         ! r4 -> vertex data for face vtx 0
    mov.w @r4+, r0                      ! load X
    mov.w @r4+, r1                      ! load Y
    mov.w @r4+, r2                      ! load Z
    mov.l   .L_ptr_vtx_scratch, r4      ! r4 -> scratch buffer for scaled coords
    shll8 r0                            ! X <<= 0xB (shift to 16.16 fixed-point)
    shll2 r0
    shll r0
    mov.l r0, @r4                       ! scratch[0] = scaled X
    shll8 r1                            ! Y <<= 0xB
    shll2 r1
    shll r1
    mov.l r1, @(4, r4)                  ! scratch[1] = scaled Y
    shll8 r2                            ! Z <<= 0xB
    shll2 r2
    shll r2
    mov.l r2, @(8, r4)                  ! scratch[2] = scaled Z
    mov.l   .L_ptr_xform_result, r5     ! r5 -> result[0] (output xyz)
    mov.l   .L_ptr_matrix_base, r0
    mov #0x24, r7                       ! offset 0x24 = translation vector
    mov.l @r0, r6                       ! r6 -> 3x3 rotation matrix
    add r6, r7                          ! r7 -> translation[0]
    clrmac                              ! --- dot product: result.x = vtx . row0 + tx ---
    mac.l @r4+, @r6+                    ! vtx.x * m[0][0]
    mac.l @r4+, @r6+                    ! vtx.y * m[0][1]
    mov.l @r7+, r2                      ! r2 = translation.x
    mac.l @r4+, @r6+                    ! vtx.z * m[0][2]
    add #-0xC, r4                       ! rewind vtx ptr
    sts mach, r0
    sts macl, r1
    clrmac                              ! --- dot product: result.y = vtx . row1 + ty ---
    mac.l @r4+, @r6+                    ! vtx.x * m[1][0]
    xtrct r0, r1                        ! extract 32-bit result from 64-bit MAC
    add r2, r1                          ! + translation.x
    mac.l @r4+, @r6+                    ! vtx.y * m[1][1]
    mov.l r1, @r5                       ! store result.x
    mac.l @r4+, @r6+                    ! vtx.z * m[1][2]
    mov.l @r7+, r2                      ! r2 = translation.y
    add #-0xC, r4                       ! rewind vtx ptr
    sts mach, r0
    sts macl, r1
    clrmac                              ! --- dot product: result.z = vtx . row2 + tz ---
    mac.l @r4+, @r6+                    ! vtx.x * m[2][0]
    xtrct r0, r1                        ! extract 32-bit result
    add r2, r1                          ! + translation.y
    mac.l @r4+, @r6+                    ! vtx.y * m[2][1]
    mov.l r1, @(4, r5)                  ! store result.y
    mac.l @r4+, @r6+                    ! vtx.z * m[2][2]
    mov.l @r7+, r2                      ! r2 = translation.z
    sts mach, r0
    sts macl, r1
    xtrct r0, r1                        ! extract 32-bit result
    add r2, r1                          ! + translation.z
    mov.l r1, @(8, r5)                  ! store result.z
    mov.l @(8, r5), r0                  ! r0 = result.z (depth)
    cmp/ge r0, r10                      ! clip_dist >= depth?
    mov.l   .L_ptr_depth_out, r11       ! r11 -> depth output array
    .word 0x0029 /* movt r9 — clamp depth to clip distance */
    mov.w r0, @r11                      ! depth_out[0] = clamped Z
    mov.w @(12, r8), r0                 ! face.flags
    tst #0x8, r0                        ! bit3 = backface cull skip?
    bf      .L_xform_face1              ! skip visibility test if set
    mov.l   .L_ptr_dot_result, r5       ! --- backface visibility test ---
    mov r8, r4                          ! r4 -> face normal data (from face entry)
    mov.l   .L_ptr_matrix_base, r0
    clrmac                              ! --- transform face normal by rotation matrix ---
    mov.l @r0, r2                       ! r2 -> rotation matrix
    mac.l @r4+, @r2+                    ! normal.x * m[0][0]
    mac.l @r4+, @r2+                    ! normal.y * m[0][1]
    mac.l @r4+, @r2+                    ! normal.z * m[0][2]
    add #-0xC, r4                       ! rewind normal ptr
    sts mach, r0
    sts macl, r1
    clrmac
    mac.l @r4+, @r2+                    ! normal.x * m[1][0]
    xtrct r0, r1
    mov.l r1, @r5                       ! xform_normal.x
    mac.l @r4+, @r2+
    mac.l @r4+, @r2+
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac
    mac.l @r4+, @r2+                    ! normal.x * m[2][0]
    xtrct r0, r1
    mov.l r1, @(4, r5)                  ! xform_normal.y
    mac.l @r4+, @r2+
    mac.l @r4+, @r2+
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    mov.l r1, @(8, r5)                  ! xform_normal.z
    mov.l   .L_ptr_xform_result, r4     ! r4 -> transformed vertex position
    clrmac                              ! --- dot(position, normal) for backface test ---
    mac.l @r4+, @r5+                    ! pos.x * norm.x
    mac.l @r4+, @r5+                    ! pos.y * norm.y
    mac.l @r4+, @r5+                    ! pos.z * norm.z
    sts mach, r1
    sts macl, r0
    xtrct r1, r0                        ! dot product result
    cmp/pl r0                           ! facing camera? (dot > 0)
    bt      .L_xform_face1              ! yes: continue with remaining vertices
    bra     .L_next_face                ! no: backface — skip this polygon
    nop
    .2byte  0x0000                      ! alignment padding
.L_ptr_clip_dist:
    .4byte  sym_06063F08                ! ptr to max clip distance value
.L_ptr_vtx_scratch:
    .4byte  sym_06094AB0                ! scratch buffer for scaled vertex xyz
.L_ptr_xform_result:
    .4byte  sym_06094A30                ! transform result array (4 faces x xyz)
.L_ptr_matrix_base:
    .4byte  sym_06089EDC                ! ptr to ptr to 3x3 rotation matrix + translation
.L_ptr_depth_out:
    .4byte  sym_06094A28                ! depth output array (4 words, one per face)
.L_ptr_dot_result:
    .4byte  sym_06094A60                ! scratch for transformed normal (backface test)
.L_xform_face1:                             ! --- transform vertex 1 ---
    mov.w @(18, r8), r0                 ! face.vtx_idx[1]
    mov #0x6, r1
    extu.w r0, r4
    mul.l r1, r4
    sts macl, r4
    add r14, r4                         ! r4 -> vertex 1 data
    mov.w @r4+, r0                      ! X
    mov.w @r4+, r1                      ! Y
    mov.w @r4+, r2                      ! Z
    mov.l   .L_ptr_vtx_scratch_b, r4
    shll8 r0                            ! X <<= 0xB
    shll2 r0
    shll r0
    mov.l r0, @r4
    shll8 r1                            ! Y <<= 0xB
    shll2 r1
    shll r1
    mov.l r1, @(4, r4)
    shll8 r2                            ! Z <<= 0xB
    shll2 r2
    shll r2
    mov.l r2, @(8, r4)
    mov.l   .L_ptr_xform_result_b, r5
    add #0xC, r5                        ! result[1] (offset 0xC = face 1 output)
    mov.l   .L_ptr_matrix_base_b, r0     ! same 3x3 matrix multiply as face 0
    mov #0x24, r7
    mov.l @r0, r6
    add r6, r7                          ! r7 -> translation vector
    clrmac                              ! --- result[1].x = vtx1 . row0 + tx ---
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    mac.l @r4+, @r6+
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac                              ! --- result[1].y = vtx1 . row1 + ty ---
    mac.l @r4+, @r6+
    xtrct r0, r1
    add r2, r1
    mac.l @r4+, @r6+
    mov.l r1, @r5                       ! store result[1].x
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac                              ! --- result[1].z = vtx1 . row2 + tz ---
    mac.l @r4+, @r6+
    xtrct r0, r1
    add r2, r1
    mac.l @r4+, @r6+
    mov.l r1, @(4, r5)                  ! store result[1].y
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    add r2, r1
    mov.l r1, @(8, r5)                  ! store result[1].z
    mov.l @(8, r5), r0                  ! r0 = depth (z)
    cmp/ge r0, r10                      ! clamp to clip distance
    .word 0x0029 /* movt r9 — clamp depth */
    mov.w r0, @(2, r11)                 ! depth_out[1] = clamped Z
    mov.w @(20, r8), r0                 ! face.vtx_idx[2]
    mov #0x6, r1
    extu.w r0, r4
    mul.l r1, r4
    sts macl, r4
    add r14, r4                         ! r4 -> vertex 2 data
    mov.w @r4+, r0                      ! X
    mov.w @r4+, r1                      ! Y
    mov.w @r4+, r2                      ! Z
    mov.l   .L_ptr_vtx_scratch_b, r4
    shll8 r0                            ! X <<= 0xB
    shll2 r0
    shll r0
    mov.l r0, @r4
    shll8 r1                            ! Y <<= 0xB
    shll2 r1
    shll r1
    mov.l r1, @(4, r4)
    mov.l   .L_ptr_y_component, r5
    mov.l r1, @r5                       ! save scaled Y for later depth adjust
    shll8 r2                            ! Z <<= 0xB
    shll2 r2
    shll r2
    mov.l r2, @(8, r4)
    mov.l   .L_ptr_xform_result_b, r5
    add #0x18, r5                       ! result[2] (offset 0x18 = face 2 output)
    mov.l   .L_ptr_matrix_base_b, r0    ! --- 3x3 matrix multiply for vertex 2 ---
    mov #0x24, r7
    mov.l @r0, r6
    add r6, r7
    clrmac                              ! result[2].x
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    mac.l @r4+, @r6+
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac                              ! result[2].y
    mac.l @r4+, @r6+
    xtrct r0, r1
    add r2, r1
    mac.l @r4+, @r6+
    mov.l r1, @r5
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac                              ! result[2].z
    mac.l @r4+, @r6+
    xtrct r0, r1
    add r2, r1
    mac.l @r4+, @r6+
    mov.l r1, @(4, r5)
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    add r2, r1
    mov.l r1, @(8, r5)                  ! store result[2].z
    mov.l @(8, r5), r0                  ! depth
    cmp/ge r0, r10                      ! clamp to clip distance
    .word 0x0029 /* movt r9 — clamp depth */
    mov.w r0, @(4, r11)                 ! depth_out[2] = clamped Z
    mov.w @(22, r8), r0                 ! face.vtx_idx[3]
    mov #0x6, r1
    extu.w r0, r4
    mul.l r1, r4
    sts macl, r4
    add r14, r4                         ! r4 -> vertex 3 data
    mov.w @r4+, r0                      ! X
    mov.w @r4+, r1                      ! Y
    mov.w @r4+, r2                      ! Z
    mov.l   .L_ptr_vtx_scratch_b, r4
    shll8 r0                            ! X <<= 0xB
    shll2 r0
    shll r0
    mov.l r0, @r4
    shll8 r1                            ! Y <<= 0xB
    shll2 r1
    shll r1
    mov.l r1, @(4, r4)
    shll8 r2                            ! Z <<= 0xB
    shll2 r2
    shll r2
    mov.l r2, @(8, r4)
    mov.l   .L_ptr_xform_result_b, r5
    add #0x24, r5                       ! result[3] (offset 0x24 = face 3 output)
    mov.l   .L_ptr_matrix_base_b, r0    ! --- 3x3 matrix multiply for vertex 3 ---
    mov #0x24, r7
    mov.l @r0, r6
    add r6, r7
    clrmac                              ! result[3].x
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    mac.l @r4+, @r6+
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac                              ! result[3].y
    mac.l @r4+, @r6+
    xtrct r0, r1
    add r2, r1
    mac.l @r4+, @r6+
    mov.l r1, @r5
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    add #-0xC, r4
    sts mach, r0
    sts macl, r1
    clrmac                              ! result[3].z
    mac.l @r4+, @r6+
    xtrct r0, r1
    add r2, r1
    mac.l @r4+, @r6+
    mov.l r1, @(4, r5)
    mac.l @r4+, @r6+
    mov.l @r7+, r2
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    add r2, r1
    mov.l r1, @(8, r5)                  ! store result[3].z
    mov.l @(8, r5), r0                  ! depth
    cmp/ge r0, r10                      ! clamp to clip distance
    .word 0x0029 /* movt r9 — clamp depth */
    mov.w r0, @(6, r11)                 ! depth_out[3] = clamped Z
    mov.w @r11+, r2                     ! --- sum all 4 depth outputs ---
    mov.w @r11+, r3                     ! depth_out[0..3]
    mov.w @r11+, r1
    add r2, r3                          ! partial sum
    add r1, r0
    add r3, r0                          ! r0 = sum of all 4 depths
    cmp/eq #0x0, r0                     ! all zero? (all behind camera)
    bt      .L_project_faces            ! yes: still do projection
    cmp/eq #0x4, r0                     ! all four clamped to max?
    bf      .L_dispatch_combine         ! no: dispatch to combine handler
    bra     .L_next_face                ! all clipped: skip polygon
    nop
.L_ptr_vtx_scratch_b:
    .4byte  sym_06094AB0                ! scratch buffer (same as first pool)
.L_ptr_xform_result_b:
    .4byte  sym_06094A30                ! transform result array (same)
.L_ptr_matrix_base_b:
    .4byte  sym_06089EDC                ! matrix ptr (same)
.L_ptr_y_component:
    .4byte  sym_06094AE0                ! saved Y component for depth bias
.L_dispatch_combine:                        ! --- dispatch depth combine handler ---
    mov.l   .L_ptr_combine_tbl, r1     ! r1 -> function pointer table
    shll2 r0                            ! r0 * 4 = table index
    add r1, r0
    mov.l @r0, r0                       ! load handler address
    mov.l   .L_ptr_xform_data, r4      ! r4 = xform results
    mov.l   .L_ptr_depth_array, r5     ! r5 = depth output array
    jsr @r0                             ! call combine handler
    nop
.L_project_faces:                           ! --- project 4 face vertices to screen ---
    mov.l   .L_ptr_face_index, r0      ! current face output index
    mov #0x18, r1                       ! 0x18 = sizeof(output_entry)
    mov.l @r0, r0
    mul.l r0, r1
    mov.l   .L_ptr_output_base, r2     ! base of output buffer
    mov.l   .L_ptr_proj_workspace, r11 ! r11 -> projection workspace (4 x,y pairs)
    sts macl, r9
    add r2, r9                          ! r9 -> this face's output slot
    mov.l   .L_ptr_xform_data, r4      ! r4 -> transformed xyz for face 0
    mov r11, r5                         ! r5 -> workspace[0]
    mov.w   DAT_0602b64c, r1            ! --- face 0: perspective divide & screen project ---
    mov.w   DAT_0602b64e, r0            ! perspective scale factor
    mov.l @(8, r4), r2                  ! xform[0].z
    mov.l r0, @(16, r1)                 ! store scale in param struct
    mov.l r2, @(0, r1)                  ! store z in param struct
    mov #0x0, r0
    mov.l r0, @(20, r1)                 ! clear accumulator
    mov.l @(4, r4), r3                  ! xform[0].y
    mov.l @r4, r2                       ! xform[0].x
    mov.l @(28, r1), r0                 ! reciprocal Z (pre-computed)
    dmuls.l r2, r0                      ! screen_x = x * (1/z)
    neg r3, r3                          ! negate Y (screen Y is inverted)
    sts mach, r1
    dmuls.l r3, r0                      ! screen_y = -y * (1/z)
    mov.l r1, @r5                       ! workspace[0].x = projected X
    sts mach, r2
    mov.l r2, @(4, r5)                  ! workspace[0].y = projected Y
    mov.l @r5, r1                       ! r1 = screen X
    mov.l @(4, r5), r2                  ! r2 = screen Y
    mov.l   .L_ptr_clip_flags, r12      ! r12 -> clip flag array (4 words)
    mov #0x0, r0
    mov.w r0, @r12                      ! clip_flags[0] = 0 (assume visible)
    mov.w   .L_x_pos_thresh, r3         ! +X screen threshold (0x190 = 400)
    cmp/gt r3, r1                       ! screen_x > +400?
    bf      .L_f0_chk_x_neg            ! no: check negative bound
    mov #0x1, r0                        ! yes: mark as clipped
    bra     .L_f1_project               ! skip to next face
    mov.w r0, @r12                      ! clip_flags[0] = 1

    .global DAT_0602b64c
DAT_0602b64c:
    .2byte  0xFF00                      ! projection param struct offset

    .global DAT_0602b64e
DAT_0602b64e:
    .2byte  0x00A0                      ! perspective scale factor (160)
.L_x_pos_thresh:
    .2byte  0x0190                      ! +X screen bound (400)
    .2byte  0x0000                      ! alignment padding
.L_ptr_combine_tbl:
    .4byte  sym_0602B9AC                ! depth combine function table (sym_0602B9AC)
.L_ptr_xform_data:
    .4byte  sym_06094A30                ! transformed vertex results
.L_ptr_depth_array:
    .4byte  sym_06094A28                ! depth output array
.L_ptr_face_index:
    .4byte  sym_060620D0                ! current polygon output index
.L_ptr_output_base:
    .4byte  sym_0608AC20                ! polygon output buffer base
.L_ptr_proj_workspace:
    .4byte  sym_06094A90                ! projection workspace (4 screen xy pairs)
.L_ptr_clip_flags:
    .4byte  sym_06094A20                ! per-face clip flag array (4 words)
.L_f0_chk_x_neg:                            ! face 0: check -X bound
    mov.w   DAT_0602b67c, r3           ! -X threshold (0xFE70 = -400)
    cmp/gt r1, r3                       ! screen_x < -400?
    bf      .L_f0_chk_y_pos
    mov #0x1, r0
    bra     .L_f1_project
    mov.w r0, @r12                      ! clip_flags[0] = 1

    .global DAT_0602b67c
DAT_0602b67c:
    .2byte  0xFE70                      ! -X screen bound (-400)
.L_f0_chk_y_pos:                            ! face 0: check +Y bound
    mov.w   DAT_0602b68a, r3           ! +Y threshold (0x012C = 300)
    cmp/gt r3, r2                       ! screen_y > +300?
    bf      .L_f0_chk_y_neg
    mov #0x1, r0
    bra     .L_f1_project
    mov.w r0, @r12                      ! clip_flags[0] = 1

    .global DAT_0602b68a
DAT_0602b68a:
    .2byte  0x012C                      ! +Y screen bound (300)
.L_f0_chk_y_neg:                            ! face 0: check -Y bound
    mov.w   DAT_0602b6d2, r3           ! -Y threshold (0xFED0 = -400)
    cmp/gt r2, r3                       ! screen_y < -400?
    bf      .L_f1_project               ! no: face 0 is on-screen
    mov #0x1, r0
    mov.w r0, @r12                      ! clip_flags[0] = 1
.L_f1_project:                              ! --- face 1: perspective project + bounds ---
    mov r11, r5
    add #0xC, r4                        ! advance to xform[1]
    add #0x8, r5                        ! workspace[1]
    mov.w   DAT_0602b6d4, r1
    mov.w   DAT_0602b6d6, r0            ! perspective scale
    mov.l @(8, r4), r2                  ! xform[1].z
    mov.l r0, @(16, r1)
    mov.l r2, @(0, r1)
    mov #0x0, r0
    mov.l r0, @(20, r1)
    mov.l @(4, r4), r3                  ! xform[1].y
    mov.l @r4, r2                       ! xform[1].x
    mov.l @(28, r1), r0                 ! reciprocal Z
    dmuls.l r2, r0                      ! screen_x = x * (1/z)
    neg r3, r3
    sts mach, r1
    dmuls.l r3, r0                      ! screen_y = -y * (1/z)
    mov.l r1, @r5                       ! workspace[1].x
    sts mach, r2
    mov.l r2, @(4, r5)                  ! workspace[1].y
    mov.l @r5, r1                       ! r1 = screen X
    mov.l @(4, r5), r2                  ! r2 = screen Y
    mov #0x0, r0
    mov.w r0, @(2, r12)                 ! clip_flags[1] = 0
    mov.w   DAT_0602b6d8, r3           ! +X threshold
    cmp/gt r3, r1
    bf      .L_f1_chk_x_neg
    mov #0x1, r0
    bra     .L_f2_project
    mov.w r0, @(2, r12)                 ! clip_flags[1] = 1

    .global DAT_0602b6d2
DAT_0602b6d2:
    .2byte  0xFE70                      ! -Y screen bound (-400)

    .global DAT_0602b6d4
DAT_0602b6d4:
    .2byte  0xFF00                      ! projection param struct offset

    .global DAT_0602b6d6
DAT_0602b6d6:
    .2byte  0x00A0                      ! perspective scale (160)

    .global DAT_0602b6d8
DAT_0602b6d8:
    .2byte  0x0190                      ! +X screen bound (400)
.L_f1_chk_x_neg:                            ! face 1: check -X bound
    mov.w   DAT_0602b6e6, r3
    cmp/gt r1, r3
    bf      .L_f1_chk_y_pos
    mov #0x1, r0
    bra     .L_f2_project
    mov.w r0, @(2, r12)                 ! clip_flags[1] = 1

    .global DAT_0602b6e6
DAT_0602b6e6:
    .2byte  0xFE70                      ! -X bound (-400)
.L_f1_chk_y_pos:                            ! face 1: check +Y bound
    mov.w   DAT_0602b6f4, r3
    cmp/gt r3, r2
    bf      .L_f1_chk_y_neg
    mov #0x1, r0
    bra     .L_f2_project
    mov.w r0, @(2, r12)                 ! clip_flags[1] = 1

    .global DAT_0602b6f4
DAT_0602b6f4:
    .2byte  0x012C                      ! +Y bound (300)
.L_f1_chk_y_neg:                            ! face 1: check -Y bound
    mov.w   DAT_0602b73c, r3
    cmp/gt r2, r3
    bf      .L_f2_project               ! face 1 on-screen
    mov #0x1, r0
    mov.w r0, @(2, r12)                 ! clip_flags[1] = 1
.L_f2_project:                              ! --- face 2: perspective project + bounds ---
    mov r11, r5
    add #0xC, r4                        ! advance to xform[2]
    add #0x10, r5                       ! workspace[2]
    mov.w   DAT_0602b73e, r1
    mov.w   DAT_0602b740, r0            ! perspective scale
    mov.l @(8, r4), r2                  ! xform[2].z
    mov.l r0, @(16, r1)
    mov.l r2, @(0, r1)
    mov #0x0, r0
    mov.l r0, @(20, r1)
    mov.l @(4, r4), r3                  ! xform[2].y
    mov.l @r4, r2                       ! xform[2].x
    mov.l @(28, r1), r0                 ! reciprocal Z
    dmuls.l r2, r0                      ! screen_x
    neg r3, r3
    sts mach, r1
    dmuls.l r3, r0                      ! screen_y
    mov.l r1, @r5                       ! workspace[2].x
    sts mach, r2
    mov.l r2, @(4, r5)                  ! workspace[2].y
    mov.l @r5, r1
    mov.l @(4, r5), r2
    mov #0x0, r0
    mov.w r0, @(4, r12)                 ! clip_flags[2] = 0
    mov.w   DAT_0602b742, r3           ! +X threshold
    cmp/gt r3, r1
    bf      .L_f2_chk_x_neg
    mov #0x1, r0
    bra     .L_f3_project
    mov.w r0, @(4, r12)                 ! clip_flags[2] = 1

    .global DAT_0602b73c
DAT_0602b73c:
    .2byte  0xFE70                      ! -Y bound (-400)

    .global DAT_0602b73e
DAT_0602b73e:
    .2byte  0xFF00                      ! projection param offset

    .global DAT_0602b740
DAT_0602b740:
    .2byte  0x00A0                      ! perspective scale (160)

    .global DAT_0602b742
DAT_0602b742:
    .2byte  0x0190                      ! +X bound (400)
.L_f2_chk_x_neg:                            ! face 2: check -X bound
    mov.w   DAT_0602b750, r3
    cmp/gt r1, r3
    bf      .L_f2_chk_y_pos
    mov #0x1, r0
    bra     .L_f3_project
    mov.w r0, @(4, r12)                 ! clip_flags[2] = 1

    .global DAT_0602b750
DAT_0602b750:
    .2byte  0xFE70                      ! -X bound (-400)
.L_f2_chk_y_pos:                            ! face 2: check +Y bound
    mov.w   DAT_0602b75e, r3
    cmp/gt r3, r2
    bf      .L_f2_chk_y_neg
    mov #0x1, r0
    bra     .L_f3_project
    mov.w r0, @(4, r12)                 ! clip_flags[2] = 1

    .global DAT_0602b75e
DAT_0602b75e:
    .2byte  0x012C                      ! +Y bound (300)
.L_f2_chk_y_neg:                            ! face 2: check -Y bound
    mov.w   DAT_0602b7a6, r3
    cmp/gt r2, r3
    bf      .L_f3_project               ! face 2 on-screen
    mov #0x1, r0
    mov.w r0, @(4, r12)                 ! clip_flags[2] = 1
.L_f3_project:                              ! --- face 3: perspective project + bounds ---
    mov r11, r5
    add #0xC, r4                        ! advance to xform[3]
    add #0x18, r5                       ! workspace[3]
    mov.w   DAT_0602b7a8, r1
    mov.w   DAT_0602b7aa, r0            ! perspective scale
    mov.l @(8, r4), r2                  ! xform[3].z
    mov.l r0, @(16, r1)
    mov.l r2, @(0, r1)
    mov #0x0, r0
    mov.l r0, @(20, r1)
    mov.l @(4, r4), r3                  ! xform[3].y
    mov.l @r4, r2                       ! xform[3].x
    mov.l @(28, r1), r0                 ! reciprocal Z
    dmuls.l r2, r0                      ! screen_x
    neg r3, r3
    sts mach, r1
    dmuls.l r3, r0                      ! screen_y
    mov.l r1, @r5                       ! workspace[3].x
    sts mach, r2
    mov.l r2, @(4, r5)                  ! workspace[3].y
    mov.l @r5, r1
    mov.l @(4, r5), r2
    mov #0x0, r0
    mov.w r0, @(6, r12)                 ! clip_flags[3] = 0
    mov.w   DAT_0602b7ac, r3           ! +X threshold
    cmp/gt r3, r1
    bf      .L_f3_chk_x_neg
    mov #0x1, r0
    bra     .L_bounds_check
    mov.w r0, @(6, r12)                 ! clip_flags[3] = 1

    .global DAT_0602b7a6
DAT_0602b7a6:
    .2byte  0xFE70                      ! -Y bound (-400)

    .global DAT_0602b7a8
DAT_0602b7a8:
    .2byte  0xFF00                      ! projection param offset

    .global DAT_0602b7aa
DAT_0602b7aa:
    .2byte  0x00A0                      ! perspective scale (160)

    .global DAT_0602b7ac
DAT_0602b7ac:
    .2byte  0x0190                      ! +X bound (400)
.L_f3_chk_x_neg:                            ! face 3: check -X bound
    mov.w   DAT_0602b7ba, r3
    cmp/gt r1, r3
    bf      .L_f3_chk_y_pos
    mov #0x1, r0
    bra     .L_bounds_check
    mov.w r0, @(6, r12)                 ! clip_flags[3] = 1

    .global DAT_0602b7ba
DAT_0602b7ba:
    .2byte  0xFE70                      ! -X bound (-400)
.L_f3_chk_y_pos:                            ! face 3: check +Y bound
    mov.w   DAT_0602b7c8, r3
    cmp/gt r3, r2
    bf      .L_f3_chk_y_neg
    mov #0x1, r0
    bra     .L_bounds_check
    mov.w r0, @(6, r12)                 ! clip_flags[3] = 1

    .global DAT_0602b7c8
DAT_0602b7c8:
    .2byte  0x012C                      ! +Y bound (300)
.L_f3_chk_y_neg:                            ! face 3: check -Y bound
    mov.w   DAT_0602b7f8, r3
    cmp/gt r2, r3
    bf      .L_bounds_check             ! face 3 on-screen
    mov #0x1, r0
    mov.w r0, @(6, r12)                 ! clip_flags[3] = 1
.L_bounds_check:                            ! --- check if ALL 4 faces are off-screen ---
    mov.l   .L_const_x_lower, r4       ! r4 = -176 (left screen edge)
    mov.l   .L_const_x_upper, r5       ! r5 = +176 (right screen edge)
    mov.l   .L_const_y_lower, r6       ! r6 = -127 (top screen edge)
    mov.l   .L_const_y_upper, r7       ! r7 = +81  (bottom screen edge)
    mov.l @r11, r0                      ! check if ALL x coords < left edge
    cmp/gt r0, r4                       ! workspace[0].x < -176?
    bf      .L_chk_x_upper             ! no: at least one is in range
    mov.l @(8, r11), r0
    cmp/gt r0, r4                       ! workspace[1].x < -176?
    bf      .L_chk_x_upper
    mov.l @(16, r11), r0
    cmp/gt r0, r4                       ! workspace[2].x < -176?
    bf      .L_chk_x_upper
    mov.l @(24, r11), r0
    cmp/gt r0, r4                       ! workspace[3].x < -176?
    bf      .L_chk_x_upper
    bra     .L_next_face                ! all 4 are off left edge: cull
    nop

    .global DAT_0602b7f8
DAT_0602b7f8:
    .2byte  0xFE70                      ! -Y bound (-400)
    .2byte  0x0000                      ! alignment padding
.L_const_x_lower:
    .4byte  0xFFFFFF50                  ! -176 (left screen edge)
.L_const_x_upper:
    .4byte  0x000000B0                  ! +176 (right screen edge)
.L_const_y_lower:
    .4byte  0xFFFFFF81                  ! -127 (top screen edge)
.L_const_y_upper:
    .4byte  0x00000051                  ! +81  (bottom screen edge)
.L_chk_x_upper:                             ! check if ALL x coords > right edge
    mov.l @r11, r0
    cmp/gt r0, r5                       ! workspace[0].x > +176?
    bt      .L_chk_y_lower             ! no: at least one in range
    mov.l @(8, r11), r0
    cmp/gt r0, r5
    bt      .L_chk_y_lower
    mov.l @(16, r11), r0
    cmp/gt r0, r5
    bt      .L_chk_y_lower
    mov.l @(24, r11), r0
    cmp/gt r0, r5
    bt      .L_chk_y_lower
    bra     .L_next_face                ! all 4 off right edge: cull
    nop
.L_chk_y_lower:                             ! check if ALL y coords < top edge
    mov.l @(4, r11), r0                 ! y coordinates at offsets +4,+12,+20,+28
    cmp/gt r0, r6
    bf      .L_chk_y_upper
    mov.l @(12, r11), r0
    cmp/gt r0, r6
    bf      .L_chk_y_upper
    mov.l @(20, r11), r0
    cmp/gt r0, r6
    bf      .L_chk_y_upper
    mov.l @(28, r11), r0
    cmp/gt r0, r6
    bf      .L_chk_y_upper
    bra     .L_next_face                ! all 4 off top edge: cull
    nop
.L_chk_y_upper:                             ! check if ALL y coords > bottom edge
    mov.l @(4, r11), r0
    cmp/gt r0, r7
    bt      .L_sum_clip_flags           ! at least one in range: proceed
    mov.l @(12, r11), r0
    cmp/gt r0, r7
    bt      .L_sum_clip_flags
    mov.l @(20, r11), r0
    cmp/gt r0, r7
    bt      .L_sum_clip_flags
    mov.l @(28, r11), r0
    cmp/gt r0, r7
    bt      .L_sum_clip_flags
    bra     .L_next_face                ! all 4 off bottom edge: cull
    nop
.L_sum_clip_flags:                          ! --- sum per-face clip flags ---
    mov.w @r12, r1                      ! clip_flags[0]
    mov.w @(2, r12), r0                 ! clip_flags[1]
    add r0, r1
    mov.w @(4, r12), r0                 ! clip_flags[2]
    add r0, r1
    mov.w @(6, r12), r0                 ! clip_flags[3]
    add r1, r0                          ! r0 = total clips (0-4)
    cmp/eq #0x4, r0                     ! all 4 faces clipped?
    bf      .L_faces_visible
    bra     .L_next_face                ! all clipped: skip polygon entirely
    nop
.L_faces_visible:                           ! at least one face is on-screen
    cmp/eq #0x0, r0                     ! no faces clipped at all?
    bt      .L_store_proj               ! yes: skip combine handler, go straight to store
    mov r11, r4                         ! r4 = projection workspace
    shll2 r0                            ! index into combine function table
    mov.l   .L_ptr_combine_fn_tbl, r1
    add r1, r0
    mov.l @r0, r0
    jsr @r0                             ! call partial-clip combine handler
    mov r12, r5                         ! r5 = clip flags (delay slot)
.L_store_proj:                              ! --- write projected coords to output buffer ---
    mov.l @r11, r0                      ! workspace[0].x -> output[0].x
    mov.w r0, @(8, r9)
    mov.l @(4, r11), r0                 ! workspace[0].y -> output[0].y
    mov.w r0, @(10, r9)
    mov.l @(8, r11), r0                 ! workspace[1].x -> output[1].x
    mov.w r0, @(12, r9)
    mov.l @(12, r11), r0               ! workspace[1].y -> output[1].y
    mov.w r0, @(14, r9)
    mov.l @(16, r11), r0               ! workspace[2].x -> output[2].x
    mov.w r0, @(16, r9)
    mov.l @(20, r11), r0               ! workspace[2].y -> output[2].y
    mov.w r0, @(18, r9)
    mov.l @(24, r11), r0               ! workspace[3].x -> output[3].x
    mov.w r0, @(20, r9)
    mov.l @(28, r11), r0               ! workspace[3].y -> output[3].y
    mov.w r0, @(22, r9)
    mov.w @(14, r8), r0                 ! face.texture_id
    mov.w r0, @(6, r9)                  ! output.texture = face.texture_id
    mov.w @(12, r8), r0                 ! face.flags
    shlr2 r0                            ! extract bits [7:4]
    shlr2 r0
    and #0xF, r0                        ! color_mode = (flags >> 4) & 0xF
    mov.b r0, @(4, r9)                  ! output.color_mode
    mov r13, r0                         ! polygon group index
    mov.b r0, @(5, r9)                  ! output.group_id
    mov.w @(12, r8), r0                 ! face.flags again
    mov.l   .L_ptr_depth_mode_tbl, r1  ! --- dispatch to depth combine mode ---
    and #0x7, r0                        ! depth_mode = flags & 0x7
    shll2 r0                            ! table offset
    mov.l @(r0, r1), r0                 ! load jump target
    mov.l   .L_ptr_face_xforms, r1     ! r1 -> transformed face z-coords
    mov.l @(8, r1), r3                  ! r3 = xform[0].z (face 0 depth)
    mov.l @(20, r1), r4                 ! r4 = xform[1].z (face 1 depth)
    mov.l @(32, r1), r5                 ! r5 = xform[2].z (face 2 depth)
    jmp @r0                             ! jump to depth combine handler
    mov.l @(44, r1), r6                 ! r6 = xform[3].z (face 3 depth, delay slot)
.L_ptr_combine_fn_tbl:
    .4byte  sym_0602B9BC                ! partial-clip combine function table
.L_ptr_depth_mode_tbl:
    .4byte  sym_0602B9CC                ! depth combine mode jump table (5 modes)
.L_ptr_face_xforms:
    .4byte  sym_06094A30                ! transformed vertex data (z at +8,+20,+32,+44)

    .global loc_0602B8DC
loc_0602B8DC:                               ! --- depth mode 0: average of 4 face depths ---
    add r4, r3                          ! r3 += r4 (face0 + face1)
    add r5, r6                          ! r6 += r5 (face2 + face3)
    add r6, r3                          ! r3 = sum of all 4
    shlr2 r3                            ! r3 /= 4 (average)
    bra     .L_store_depth
    nop

    .global loc_0602B8E8
loc_0602B8E8:                               ! --- depth mode 1: minimum (nearest face) ---
    cmp/ge r3, r4                       ! r4 <= r3?
    bt      .L_min_chk_1
    mov r4, r3                          ! r3 = min(r3, r4)
.L_min_chk_1:
    cmp/ge r3, r5
    bt      .L_min_chk_2
    mov r5, r3                          ! r3 = min(r3, r5)
.L_min_chk_2:
    cmp/ge r3, r6
    bt      .L_min_done
    mov r6, r3                          ! r3 = min(r3, r6)
.L_min_done:
    bra     .L_store_depth
    nop

    .global loc_0602B8FE
loc_0602B8FE:                               ! --- depth mode 2: maximum (farthest face) ---
    cmp/gt r3, r4                       ! r4 > r3?
    bf      .L_max_chk_1
    mov r4, r3                          ! r3 = max(r3, r4)
.L_max_chk_1:
    cmp/gt r3, r5
    bf      .L_max_chk_2
    mov r5, r3                          ! r3 = max(r3, r5)
.L_max_chk_2:
    cmp/gt r3, r6
    bf      .L_max_done
    mov r6, r3                          ! r3 = max(r3, r6)
.L_max_done:
    bra     .L_store_depth
    nop

    .global loc_0602B914
loc_0602B914:                               ! --- depth mode 4: max + large bias (0xB.8) ---
    mov.l   .L_fp_bias_b8, r0          ! bias = 11.5 in 16.16 fixed-point
    cmp/gt r3, r4
    bf      .L_max_bias_chk_1
    mov r4, r3
.L_max_bias_chk_1:
    cmp/gt r3, r5
    bf      .L_max_bias_chk_2
    mov r5, r3
.L_max_bias_chk_2:
    cmp/gt r3, r6
    bf      .L_max_bias_done
    mov r6, r3
.L_max_bias_done:
    bra     .L_store_depth
    add r0, r3                          ! depth = max + 11.5 (push further back)
.L_fp_bias_b8:
    .4byte  0x000B8000                  ! 11.5 in 16.16 fixed-point

    .global loc_0602B930
loc_0602B930:                               ! --- depth mode 3: max + 1.0 bias ---
    mov.l   .L_fp_one, r0              ! bias = 1.0 in 16.16 fixed-point
    cmp/gt r3, r4
    bf      .L_max_fp1_chk_1
    mov r4, r3
.L_max_fp1_chk_1:
    cmp/gt r3, r5
    bf      .L_max_fp1_chk_2
    mov r5, r3
.L_max_fp1_chk_2:
    cmp/gt r3, r6
    bf      .L_max_fp1_add
    mov r6, r3
.L_max_fp1_add:
    add r0, r3                          ! depth = max + 1.0
.L_store_depth:                             ! --- apply Y-based depth bias and write z-sort ---
    mov.l   .L_ptr_y_comp_val, r1
    mov.l @r1, r1                       ! r1 = saved Y component (from vertex 2)
    mov.l   .L_ptr_scene_param, r0
    mov.l @r0, r0                       ! r0 = scene parameter threshold
    mov.l   .L_fp_two, r2              ! 2.0 in 16.16
    add r2, r1                          ! Y + 2.0
    cmp/gt r1, r0                       ! scene_param > (Y + 2.0)?
    bf      .L_write_zsort             ! no: skip extra bias
    mov.l   .L_fp_ten, r2             ! yes: add 10.0 depth bias
    add r2, r3                          ! depth += 10.0 (push polygon further back)
.L_write_zsort:                             ! --- write depth to z-sort buffer ---
    mov.l   .L_ptr_zsort_idx, r2       ! ptr to current z-sort write index
    neg r3, r3                          ! negate depth (sort order: near=large)
    mov.l   .L_ptr_zsort_buf, r1       ! z-sort buffer base
    shlr8 r3                            ! depth >> 0xC (convert to 16-bit range)
    mov.l @r2, r0                       ! r0 = current write index
    shlr2 r3
    shlr2 r3
    shll r0                             ! index * 2 (word-sized entries)
    mov.w r3, @(r0, r1)                 ! zsort_buf[index] = truncated depth
    shar r0                             ! restore index
    add #0x1, r0                        ! index++
    mov.l r0, @r2                       ! store updated write index
.L_next_face:                               ! --- loop control ---
    mov.l @r15+, r7                     ! pop remaining face count
    dt r7                               ! decrement and test
    bt      .L_epilogue                ! done: return
    bra     .L_face_loop               ! continue with next face
    nop
.L_fp_one:
    .4byte  0x00010000                  ! 1.0 (16.16 fixed-point)
.L_ptr_y_comp_val:
    .4byte  sym_06094AE0                ! saved Y component from vertex 2
.L_ptr_scene_param:
    .4byte  sym_06063F54                ! scene parameter for depth bias decision
.L_fp_two:
    .4byte  0x00020000                  ! 2.0 (16.16 fixed-point)
.L_fp_ten:
    .4byte  0x000A0000                  ! 10.0 (16.16 fixed-point)
.L_ptr_zsort_idx:
    .4byte  sym_060620D0                ! z-sort buffer write index
.L_ptr_zsort_buf:
    .4byte  sym_0606A4F8                ! z-sort buffer base (word array)
.L_epilogue:                                ! --- function epilogue ---
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r14                    ! restore callee-saved registers
    mov.l @r15+, r13
    mov.l @r15+, r12
    mov.l @r15+, r11
    mov.l @r15+, r10
    mov.l @r15+, r9
    rts
    mov.l @r15+, r8                     ! r8 restore in delay slot
    .2byte  0x0009                      ! alignment padding

    .global sym_0602B9AC                     ! --- depth combine function table A ---
sym_0602B9AC:
    .word 0x0000                        ! unused padding
    .word 0x0000
    .4byte  spring_damper               ! combine handler 1
    .4byte  transform_pipeline          ! combine handler 2
    .4byte  mega_render_func            ! combine handler 3

    .global sym_0602B9BC                     ! --- partial-clip combine function table ---
sym_0602B9BC:
    .word 0x0000                        ! unused padding
    .word 0x0000
    .4byte  vblank_frame_handler        ! clip handler 1
    .4byte  render_list_builder         ! clip handler 2
    .4byte  render_obj_processor        ! clip handler 3

    .global sym_0602B9CC                     ! --- depth mode jump table (5 entries) ---
sym_0602B9CC:
    .4byte  loc_0602B8DC                ! mode 0: average
    .4byte  loc_0602B8E8                ! mode 1: minimum (nearest)
    .4byte  loc_0602B8FE                ! mode 2: maximum (farthest)
    .4byte  loc_0602B930                ! mode 3: max + 1.0 bias
    .4byte  loc_0602B914                ! mode 4: max + 11.5 bias

    .global sym_0602B9E0                     ! --- function prologue entry (jumped to) ---
sym_0602B9E0:
    mov.l r8, @-r15                     ! save callee-saved registers
    mov.l r9, @-r15
    mov.l r10, @-r15
    mov.l r11, @-r15
    mov.l r12, @-r15
    mov.l r13, @-r15
