/* lap_progress_bar -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015D94 - 0x06015E26
 * Auto-generated by tools/generate_l3_tu.py
 *
 * lap_progress_bar:
 *   Initializes 8 HUD slot structs for the lap progress bar.
 *   Iterates slots 0..7 in the 68-byte struct array (sym_06084FC8),
 *   writing priority = 9 at offset +0x02 and bar_type = 3 at offset +0x41.
 *   Tail-calls clear_vdp2_registers (sym_060172E4) to finalize display state.
 *
 *   Args: r4 = display mode byte (passed through to tail call)
 *
 * loc_06015DE8:
 *   Reads the element_type byte at offset +0x40 from the caller's slot,
 *   uses that as an index to look up a second slot, and writes priority = 5
 *   at offset +0x02 of that target slot. Tail-calls clear_vdp2_registers.
 *
 *   Args: r4 = slot index
 */

    .section .text.FUN_06015D94


    .global lap_progress_bar
    .type lap_progress_bar, @function
lap_progress_bar:
    mov.l r14, @-r15                        ! save r14
    mov.l r13, @-r15                        ! save r13
    mov.l r12, @-r15                        ! save r12
    mov.l r11, @-r15                        ! save r11
    add #-0x4, r15                          ! allocate 4 bytes of stack for local
    mov.l   .L_pool_slot_base, r11          ! r11 = HUD slot array base (68-byte structs)
    mov #0x8, r12                           ! r12 = 8 (slot count / loop limit)
    mov #0x3, r13                           ! r13 = 3 (bar_type value)
    mov #0x9, r14                           ! r14 = 9 (priority value)
    mov.b r4, @r15                          ! save display_mode arg on stack
    mov #0x0, r4                            ! r4 = loop counter (slot index), init 0
.L_init_loop:
    extu.b r4, r5                           ! r5 = idx (zero-extended)
    extu.b r14, r0                          ! r0 = 9 (priority value)
    mov r5, r3                              ! r3 = idx (copy for stride calc)
    add #0x1, r4                            ! idx++
    shll2 r5                                ! r5 = idx * 4
    shll2 r3                                ! r3 = idx * 4
    shll2 r3                                ! r3 = idx * 16
    shll2 r3                                ! r3 = idx * 64
    add r3, r5                              ! r5 = idx * 68 (struct stride = 4 + 64)
    exts.w r5, r5                           ! sign-extend offset to word
    extu.b r4, r3                           ! r3 = next idx (for loop compare)
    add r11, r5                             ! r5 = &slot_data[idx]
    mov.b r0, @(2, r5)                      ! slot[+0x02] = 9 (priority)
    mov #0x41, r0                           ! r0 = 0x41 (bar_type offset)
    cmp/ge r12, r3                          ! next_idx >= 8?
    bf/s    .L_init_loop                    ! no â†’ continue loop
    mov.b r13, @(r0, r5)                    ! slot[+0x41] = 3 (bar_type) (delay slot)
    mov.b @r15, r4                          ! restore display_mode from stack
    extu.b r4, r4                           ! zero-extend display_mode
    add #0x4, r15                           ! free stack local
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    mov.l   .L_pool_fn_clear_vdp2, r3      ! r3 = clear_vdp2_registers
    jmp @r3                                 ! tail-call clear_vdp2_registers(display_mode)
    mov.l @r15+, r14                        ! restore r14 (delay slot)
    .2byte  0xFFFF                          ! alignment padding
.L_pool_slot_base:
    .4byte  sym_06084FC8                    ! HUD slot data array (68-byte structs)
.L_pool_fn_clear_vdp2:
    .4byte  sym_060172E4                    ! clear_vdp2_registers

    .global loc_06015DE8
loc_06015DE8:
    add #-0x4, r15                          ! allocate 4 bytes of stack for local
    mov.b r4, @r15                          ! save slot_index on stack
    .byte   0xD4, 0x20    /* mov.l .L_pool_06015E70, r4 */  ! r4 = HUD slot array base
    mov.b @r15, r3                          ! r3 = slot_index (reload from stack)
    extu.b r3, r3                           ! zero-extend slot_index
    mov r3, r2                              ! r2 = idx (copy for stride calc)
    shll2 r3                                ! r3 = idx * 4
    shll2 r2                                ! r2 = idx * 4
    shll2 r2                                ! r2 = idx * 16
    shll2 r2                                ! r2 = idx * 64
    add r2, r3                              ! r3 = idx * 68 (struct stride)
    exts.w r3, r3                           ! sign-extend offset
    add r4, r3                              ! r3 = &slot_data[idx]
    mov #0x40, r0                           ! r0 = 0x40 (element_type offset)
    mov.b @(r0, r3), r3                     ! r3 = slot[+0x40] (element_type / linked index)
    extu.b r3, r3                           ! zero-extend element_type
    mov r3, r2                              ! r2 = target_idx (copy for stride calc)
    shll2 r3                                ! r3 = target_idx * 4
    shll2 r2                                ! r2 = target_idx * 4
    shll2 r2                                ! r2 = target_idx * 16
    shll2 r2                                ! r2 = target_idx * 64
    add r2, r3                              ! r3 = target_idx * 68 (struct stride)
    exts.w r3, r3                           ! sign-extend offset
    add r4, r3                              ! r3 = &slot_data[target_idx]
    mov #0x5, r0                            ! r0 = 5 (priority value for linked slot)
    mov.b r0, @(2, r3)                      ! target_slot[+0x02] = 5 (priority)
    mov.b @r15, r4                          ! restore slot_index from stack
    extu.b r4, r4                           ! zero-extend slot_index (pass as arg)
    .byte   0xD3, 0x14    /* mov.l .L_pool_06015E74, r3 */  ! r3 = clear_vdp2_registers
    jmp @r3                                 ! tail-call clear_vdp2_registers(slot_index)
    add #0x4, r15                           ! free stack local (delay slot)
