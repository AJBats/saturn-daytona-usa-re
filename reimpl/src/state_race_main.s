/* state_race_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06009098 - 0x06009290
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Main racing state handler -- per-frame update during active race gameplay.
 * Orchestrates all subsystems: physics, camera, rendering, HUD.
 *
 * Called once per frame while the game is in the active racing state.
 * Manages a per-car iteration loop that dispatches frame_update,
 * camera_compute, render_prep, and race_state_update for each car.
 * After the car loop, selects terrain or sprite rendering path,
 * runs the camera system (full or simple perspective), invokes the
 * scene renderer, optionally draws a debug HUD, then tail-calls
 * frame_end_commit to finalize the frame.
 *
 * Car swap logic: when the car update flag is set, the first car (index 0)
 * gets activated (race_state_flag=1, pointers set to default car data),
 * while any non-first car triggers a swap-out (flag cleared, pointers
 * set to array start, race_points decremented by 2 as penalty).
 *
 * Persistent registers:
 *   r8  = &race_points (score/point counter, decremented on car swap)
 *   r9  = &car_struct_ptr (current car pointer variable)
 *   r10 = &game_state (phase: 0x10=racing, 0x12=light change, 0x15=end)
 *   r11 = &race_state_flag (per-frame race flag, 16-bit)
 *   r12 = car loop index (0..car_count-1)
 *   r13 = 0x10 (default game state constant, written back on timeout/end)
 *   r14 = &car_array_base (pointer to car array base variable)
 *
 * Frame flow:
 *   1. Check traffic light bit 11 (0x0800): on change -> set event flag=0xF,
 *      game_state=0x12
 *   2. Decrement countdown timer
 *   3. Optional menu overlay rendering (if menu flag set)
 *   4. Notify state change (if race_state_flag nonzero)
 *   5. Per-car loop (0..car_count):
 *      a. Check car update flag -> swap active car pointers
 *      b. frame_update -> camera_compute -> render_prep -> race_state_update
 *      c. If race_end_flag set -> race_end_handler
 *      d. If countdown=0 or timeout=0 -> override game_state to 0x10
 *   6. Post-loop: terrain_data_lookup or sprite_transform (by terrain mode)
 *   7. Scene prep
 *   8. Camera: full camera_system + orient_calc OR perspective_project
 *   9. scene_master -> optional debug HUD -> tail-call frame_end_commit
 */

    .section .text.FUN_06009098


    .global state_race_main
    .type state_race_main, @function
state_race_main:
    mov.l r14, @-r15                     ! save r14
    mov.l r13, @-r15                     ! save r13
    mov.l r12, @-r15                     ! save r12
    mov.l r11, @-r15                     ! save r11
    mov.l r10, @-r15                     ! save r10
    mov.l r9, @-r15                      ! save r9
    mov.l r8, @-r15                      ! save r8
    sts.l pr, @-r15                      ! save return address
    add #-0x4, r15                       ! allocate 4 bytes on stack (local var slot)
    mov.l   .L_race_points, r8           ! r8 = &race_points
    mov.l   .L_car_struct_ptr, r9        ! r9 = &car_struct_ptr
    mov.l   .L_game_state, r10           ! r10 = &game_state
    mov.l   .L_race_state_flag, r11      ! r11 = &race_state_flag
    mov.l   .L_car_array_base, r14       ! r14 = &car_array_base
    mov.l   .L_traffic_light_state, r3   ! r3 = &traffic_light_state
    mov.w @r3, r2                        ! read traffic light state (16-bit)
    mov.w   .L_bit11_mask, r3            ! r3 = 0x0800 (light change bit)
    extu.w r2, r2                        ! zero-extend to 32-bit
    and r3, r2                           ! isolate bit 11
    tst r2, r2                           ! test if light change bit is clear
    bt/s    .L_after_light_check         ! no light change -> skip event flag
    mov #0x10, r13                       ! r13 = 0x10 (default game state) [delay slot]
    mov #0xF, r3                         ! r3 = 0xF (event code: light change)
    mov.l   .L_race_event_flag, r2       ! r2 = &race_event_flag
    mov.l r3, @r2                        ! race_event_flag = 0xF
    mov #0x12, r3                        ! r3 = 0x12 (light change state)
    mov.l r3, @r10                       ! game_state = 0x12
.L_after_light_check:
    mov.l   .L_countdown_timer, r2       ! r2 = &countdown_timer (for read)
    mov.l   .L_countdown_timer, r3       ! r3 = &countdown_timer (for write)
    mov.l @r2, r2                        ! r2 = current countdown value
    add #-0x1, r2                        ! decrement countdown
    mov.l r2, @r3                        ! write back decremented countdown
    mov.l   .L_menu_overlay_flag, r0     ! r0 = &menu_overlay_flag
    mov.b @r0, r0                        ! read menu overlay flag (byte)
    tst r0, r0                           ! test if menu overlay is inactive
    bt      .L_after_menu_overlay        ! no menu -> skip overlay render
    mov.l   .L_fn_menu_overlay, r3       ! r3 = &menu_overlay_render
    jsr @r3                              ! menu_overlay_render(0)
    mov #0x0, r4                         ! arg0 = 0 [delay slot]
.L_after_menu_overlay:
    mov.w @r11, r0                       ! read race state flag (16-bit)
    extu.w r0, r0                        ! zero-extend to 32-bit
    tst r0, r0                           ! test if flag is zero
    bt      .L_init_car_loop             ! flag clear -> skip state notify
    mov.l   .L_fn_state_notify, r3       ! r3 = &state_notify_handler
    jsr @r3                              ! call state change notification
    nop                                  ! delay slot
.L_init_car_loop:
    mov #0x0, r12                        ! r12 = 0 (car loop index)
    mov.l   .L_car_data_default, r2      ! r2 = &default_car_data
    bra     .L_car_loop_cond             ! jump to loop condition check
    mov.l r2, @r15                       ! stack[0] = default car data ptr [delay slot]
.L_car_loop_body:
    mov.l   .L_car_update_flag, r0       ! r0 = &car_update_flag
    mov.b @r0, r0                        ! read car update flag (byte)
    extu.b r0, r0                        ! zero-extend to 32-bit
    tst r0, r0                           ! test if car needs update/swap
    bt      .L_subsystem_calls           ! flag clear -> skip car swap logic
    extu.b r12, r12                      ! zero-extend loop index
    tst r12, r12                         ! test if this is car index 0
    bf      .L_swap_car_out              ! not first car -> swap out path
    mov #0x1, r3                         ! r3 = 1 (activate flag)
    mov.w r3, @r11                       ! race_state_flag = 1 (car activated)
    mov.l @r15, r2                       ! r2 = default car data ptr (from stack)
    mov.l r2, @r14                       ! car_array_base = default car data
    mov r2, r3                           ! r3 = copy (unused, register scheduling)
    bra     .L_subsystem_calls           ! proceed to subsystem dispatch
    mov.l r2, @r9                        ! car_struct_ptr = default car data [delay slot]
.L_bit11_mask:
    .2byte  0x0800                        /* traffic light change bit mask */
.L_race_points:
    .4byte  sym_0607ED88               /* race score/points counter */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer variable */
.L_game_state:
    .4byte  g_game_state               /* game phase state (0x10/0x12/0x15) */
.L_race_state_flag:
    .4byte  sym_0607ED8C               /* per-frame race state flag (16-bit) */
.L_car_array_base:
    .4byte  sym_0607E944               /* car array base pointer variable */
.L_traffic_light_state:
    .4byte  sym_06063D9A               /* traffic light state register */
.L_race_event_flag:
    .4byte  sym_0607EACC               /* race event flag (0xF on light change) */
.L_countdown_timer:
    .4byte  sym_0607EBCC               /* race countdown timer (decremented per frame) */
.L_menu_overlay_flag:
    .4byte  sym_0605AB18               /* menu overlay active flag (byte) */
.L_fn_menu_overlay:
    .4byte  menu_overlay_render        /* draw menu overlay */
.L_fn_state_notify:
    .4byte  sym_060033E6               /* state change notification handler */
.L_car_data_default:
    .4byte  sym_06078B68               /* default car data pointer */
.L_car_update_flag:
    .4byte  sym_06078635               /* per-car update trigger flag (byte) */
.L_swap_car_out:
    mov #0x0, r2                         ! r2 = 0
    mov.w r2, @r11                       ! race_state_flag = 0 (deactivate)
    mov.l   .L_car_array_start, r3       ! r3 = &car_array_start
    mov.l r3, @r14                       ! car_array_base = array start
    mov r3, r2                           ! r2 = array start (unused copy)
    mov.l r3, @r9                        ! car_struct_ptr = array start
    mov.l @r8, r3                        ! r3 = current race points
    add #-0x2, r3                        ! subtract 2 (car swap penalty)
    mov.l r3, @r8                        ! write back penalized points
.L_subsystem_calls:
    mov.l   .L_fn_frame_update, r3       ! r3 = &per_car_frame_update
    jsr @r3                              ! per-frame physics/state update
    nop                                  ! delay slot
    mov.l   .L_fn_camera_compute, r3     ! r3 = &render_camera_compute
    jsr @r3                              ! compute camera matrix for this car
    nop                                  ! delay slot
    mov.l   .L_fn_render_prep, r3        ! r3 = &render_prep
    jsr @r3                              ! prepare render state
    nop                                  ! delay slot
    mov.l   .L_fn_race_state, r3         ! r3 = &race_state_update
    jsr @r3                              ! update race state (laps, checkpoints)
    nop                                  ! delay slot
    mov.l   .L_race_end_flag, r0         ! r0 = &race_end_flag
    mov.l @r0, r0                        ! r0 = race_end_flag value
    tst r0, r0                           ! test if race has ended
    bt      .L_check_timeout             ! race not ended -> check timeout instead
    mov.l   .L_fn_race_end_handler, r3   ! r3 = &race_end_handler
    jsr @r3                              ! handle race end sequence
    nop                                  ! delay slot
    mov.l   .L_countdown_timer_2, r0     ! r0 = &countdown_timer (2nd pool ref)
    mov.l @r0, r0                        ! r0 = countdown value
    tst r0, r0                           ! test if countdown expired
    bf      .L_car_loop_next             ! countdown != 0 -> continue racing
    bra     .L_car_loop_next             ! countdown=0: fall through after setting state
    mov.l r13, @r10                      ! game_state = 0x10 (racing) [delay slot]
.L_check_timeout:
    mov.l   .L_race_timeout, r0          ! r0 = &race_timeout
    mov.l @r0, r0                        ! r0 = timeout value
    tst r0, r0                           ! test if timeout expired
    bf      .L_car_loop_next             ! timeout != 0 -> continue racing
    mov.l r13, @r10                      ! timeout=0: game_state = 0x10 (racing)
.L_car_loop_next:
    add #0x1, r12                        ! increment car loop index
.L_car_loop_cond:
    extu.b r12, r3                       ! r3 = zero-extended loop index
    mov.l   .L_car_count, r2             ! r2 = &car_count
    mov.b @r2, r2                        ! r2 = car count (byte)
    extu.b r2, r2                        ! zero-extend car count
    cmp/ge r2, r3                        ! T = (index >= car_count)?
    bf      .L_car_loop_body             ! more cars remaining -> loop back
    mov.l   .L_terrain_mode, r0          ! r0 = &terrain_mode flag
    mov.b @r0, r0                        ! read terrain rendering mode (byte)
    tst r0, r0                           ! test if terrain mode is off
    bt      .L_sprite_path               ! terrain off -> use sprite path
    mov.l   .L_fn_terrain_lookup, r3     ! r3 = &terrain_data_lookup
    jsr @r3                              ! call terrain_data_lookup()
    nop                                  ! delay slot
    bra     .L_scene_prep                ! skip sprite path
    nop                                  ! delay slot
.L_sprite_path:
    mov.l   .L_fn_sprite_xform, r3       ! r3 = &sprite_transform
    jsr @r3                              ! call sprite_transform()
    nop                                  ! delay slot
.L_scene_prep:
    mov.l   .L_fn_scene_prep, r3         ! r3 = &scene_data_prep
    jsr @r3                              ! prepare scene data structures
    nop                                  ! delay slot
    mov.l   .L_camera_mode, r0           ! r0 = &camera_mode
    mov.b @r0, r0                        ! read camera mode (byte)
    extu.b r0, r0                        ! zero-extend camera mode
    cmp/eq #0x1, r0                      ! test if full camera mode (1)
    bf      .L_simple_perspective        ! mode != 1 -> simple perspective path
    mov.l   .L_fn_camera_system, r3      ! r3 = &camera_system
    jsr @r3                              ! full camera system update
    nop                                  ! delay slot
    mov.l   .L_camera_param_a, r6        ! r6 = &camera_param_table_a (ptr-to-ptr)
    mov.l   .L_camera_param_b, r5        ! r5 = camera_param_b (arg1)
    mov.l   .L_camera_param_c, r4        ! r4 = camera_param_c (arg0)
    mov.l   .L_fn_camera_orient, r3      ! r3 = &camera_orient_calc
    jsr @r3                              ! camera_orient_calc(param_c, param_b, *param_a)
    mov.l @r6, r6                        ! r6 = deref param_a ptr [delay slot]
    bra     .L_after_camera              ! skip simple perspective path
    nop                                  ! delay slot
.L_simple_perspective:
    mov.l   .L_fn_perspective, r3        ! r3 = &perspective_project
    jsr @r3                              ! simple perspective projection
    nop                                  ! delay slot
.L_after_camera:
    mov.l   .L_fn_scene_master, r3       ! r3 = &scene_master
    jsr @r3                              ! render entire scene
    nop                                  ! delay slot
    mov.l   .L_debug_display_flag, r0    ! r0 = &debug_display_flag
    mov.b @r0, r0                        ! read debug HUD flag (byte)
    extu.b r0, r0                        ! zero-extend flag
    tst r0, r0                           ! test if debug display is off
    bt      .L_epilogue                  ! debug off -> skip to epilogue
    mov.l   .L_debug_display_data, r7    ! r7 = &debug_display_data (arg3)
    mov.l   .L_mask_nibble3, r6          ! r6 = 0xF000 mask (arg2)
    mov.w   .L_debug_vdp1_offset, r5     ! r5 = 0x0082 VDP1 cmd offset (arg1)
    mov.l   .L_fn_debug_draw, r3         ! r3 = &debug_draw
    jsr @r3                              ! draw debug HUD element
    mov #0x8, r4                         ! r4 = 8 (digit count, arg0) [delay slot]
.L_epilogue:
    add #0x4, r15                        ! free local stack slot
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r8                      ! restore r8
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    mov.l   .L_fn_frame_end, r3          ! r3 = &frame_end_commit
    jmp @r3                              ! tail-call frame_end_commit
    mov.l @r15+, r14                     ! restore r14 [delay slot]
.L_debug_vdp1_offset:
    .2byte  0x0082                        /* VDP1 cmd offset for debug display */
.L_car_array_start:
    .4byte  sym_06078900               /* car array start (first car struct) */
.L_fn_frame_update:
    .4byte  sym_060302C6               /* per-car frame update (physics/state) */
.L_fn_camera_compute:
    .4byte  render_camera_compute      /* camera matrix computation */
.L_fn_render_prep:
    .4byte  sym_0602F0E8               /* pre-render state preparation */
.L_fn_race_state:
    .4byte  race_state_update          /* race progress (laps, checkpoints) */
.L_race_end_flag:
    .4byte  sym_0607EAD8               /* race end trigger flag */
.L_fn_race_end_handler:
    .4byte  sym_0600C302               /* race end sequence handler */
.L_countdown_timer_2:
    .4byte  sym_0607EBCC               /* countdown timer (dup for reach) */
.L_race_timeout:
    .4byte  sym_0607EAD0               /* race timeout counter */
.L_car_count:
    .4byte  sym_06078634               /* total car count (byte) */
.L_terrain_mode:
    .4byte  sym_06083255               /* terrain rendering mode flag (byte) */
.L_fn_terrain_lookup:
    .4byte  terrain_data_lookup        /* terrain-based rendering */
.L_fn_sprite_xform:
    .4byte  sprite_transform           /* sprite-based rendering */
.L_fn_scene_prep:
    .4byte  sym_06012198               /* scene data preparation */
.L_camera_mode:
    .4byte  sym_06078654               /* camera mode (1=full, else=simple) */
.L_fn_camera_system:
    .4byte  camera_system              /* full camera system update */
.L_camera_param_a:
    .4byte  sym_06063E24               /* camera parameter table A (ptr) */
.L_camera_param_b:
    .4byte  sym_06063EEC               /* camera parameter B */
.L_camera_param_c:
    .4byte  sym_06063EF8               /* camera parameter C */
.L_fn_camera_orient:
    .4byte  camera_orient_calc         /* camera orientation computation */
.L_fn_perspective:
    .4byte  perspective_project        /* simple perspective projection */
.L_fn_scene_master:
    .4byte  scene_master               /* master scene renderer */
.L_debug_display_flag:
    .4byte  sym_06086030               /* debug HUD display flag (byte) */
.L_debug_display_data:
    .4byte  sym_0605A1C8               /* debug display data struct */
.L_mask_nibble3:
    .4byte  0x0000F000                  /* nibble 3 mask */
.L_fn_debug_draw:
    .4byte  sym_060283E0               /* debug HUD draw function */
.L_fn_frame_end:
    .4byte  frame_end_commit           /* frame end / VDP commit */
