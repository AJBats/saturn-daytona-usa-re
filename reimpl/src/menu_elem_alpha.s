/* menu_elem_alpha -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B0C0 - 0x0603B118
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Computes alpha/blend factor for a menu element.
 *
 * Input:
 *   r4 = ptr to menu element descriptor (double-indirect: *r4 = element data)
 *   r5 = blend parameter (numerator base)
 *
 * Output:
 *   r0 = 0 if element is fully opaque (both alpha bits set),
 *        otherwise quotient from udiv_32(max_alpha, blend_param + max_alpha - 1)
 *
 * The element data struct has:
 *   byte @(r0, base) = flags byte (r0 set by save_checksum_calc)
 *     bit 3 (0x08) = alpha-enable flag
 *     bit 2 (0x04) = alpha-ready flag
 *   long @(12, base) = max_alpha (divisor / range)
 *
 * If both alpha bits are set, returns 0 (fully opaque, skip blend).
 * Otherwise computes blend ratio via unsigned division.
 */

    .section .text.FUN_0603B0C0


    .global menu_elem_alpha
    .type menu_elem_alpha, @function
menu_elem_alpha:
    mov.l r14, @-r15                           ! save r14 (callee-saved)
    sts.l pr, @-r15                            ! save return address
    add #-0x8, r15                             ! allocate 8 bytes on stack
    mov.l r4, @r15                             ! [sp+0] = element descriptor ptr
    mov.l r5, @(4, r15)                        ! [sp+4] = blend parameter
    mov.l @r15, r14                            ! r14 = element descriptor ptr
    mov.l @r14, r14                            ! r14 = *descriptor (element data base)
    mov.b @(r0, r14), r14                      ! r14 = flags byte at data[r0]
    extu.b r14, r14                            ! zero-extend flags to 32 bits
    .byte   0xB4, 0x33    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0)
    mov #0x0, r4                               ! r4 = 0 (delay slot: status query arg)
    mov #0x8, r2                               ! r2 = 0x08 (alpha-enable bit mask)
    and r14, r2                                ! r2 = flags & 0x08
    tst r2, r2                                 ! alpha-enable bit clear?
    bt      .L_calc_blend                      ! yes -> element needs blending
    bra     .L_check_ready                     ! no -> check alpha-ready bit
    nop                                        ! delay slot
.L_check_ready:
    mov #0x4, r2                               ! r2 = 0x04 (alpha-ready bit mask)
    and r14, r2                                ! r2 = flags & 0x04
    tst r2, r2                                 ! alpha-ready bit clear?
    bt      .L_calc_blend                      ! yes -> element needs blending
    bra     .L_return_opaque                   ! no -> both bits set, fully opaque
    nop                                        ! delay slot
.L_return_opaque:
    mov #0x0, r0                               ! r0 = 0 (fully opaque, no blend needed)
    add #0x8, r15                              ! free stack frame
    lds.l @r15+, pr                            ! restore return address
    rts                                        ! return
    mov.l @r15+, r14                           ! restore r14 (delay slot)
.L_calc_blend:
    mov.l @r15, r4                             ! r4 = element descriptor ptr
    mov.l @(4, r15), r1                        ! r1 = blend parameter (numerator base)
    mov.l @r4, r4                              ! r4 = *descriptor (element data base)
    mov.l @(12, r4), r3                        ! r3 = max_alpha (element data[12])
    add r3, r1                                 ! r1 = blend_param + max_alpha
    mov r3, r0                                 ! r0 = max_alpha (divisor)
    mov.l   .L_pool_udiv32, r3                 ! r3 = &input_proc_complete (udiv_32)
    jsr @r3                                    ! call udiv_32(r0=divisor, r1=dividend)
    add #-0x1, r1                              ! r1 = blend_param + max_alpha - 1 (delay slot)
    add #0x8, r15                              ! free stack frame
    lds.l @r15+, pr                            ! restore return address
    rts                                        ! return (r0 = quotient from udiv)
    mov.l @r15+, r14                           ! restore r14 (delay slot)
    .2byte  0xFFFF                             ! alignment padding
.L_pool_udiv32:
    .4byte  input_proc_complete
