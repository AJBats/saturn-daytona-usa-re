/* save_header_parse -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BB86 - 0x0603BC12
 * Auto-generated by tools/generate_l3_tu.py
 *
 * save_header_parse -- Parse save header from global state into caller buffer
 *
 * Checks whether the save hardware is present by testing bit 0 of the
 * status flags at state_base[0xC4].  If absent, returns 0 immediately.
 * Otherwise, calls save_block_copy to validate the save block at
 * state_base + 0x043C.  On success, copies two 4-byte fields from the
 * save block into the caller's output buffer using memmove, then clears
 * the four status bytes at output buffer offsets 8-11 and returns 1.
 *
 * The save block address is computed as:
 *   state_base + 0x043C                (input to save_block_copy)
 *   state_base + 0x043C + 0x009C       (header region base, stored in r13)
 * Two 4-byte fields are copied from the header region:
 *   header[+6..+9]   -> output[+6..+9]    (first memmove, 4 bytes)
 *   header[+14..+17] -> output[+14..+17]   (second memmove, 4 bytes)
 * The descriptor pointer (r4/r14) is advanced by 0x0096 between copies.
 *
 * Args:
 *   r4 = pointer to caller's output buffer (16+ bytes)
 *
 * Returns:
 *   r0 = 1 on success (header parsed and copied)
 *        0 if save hardware absent or save_block_copy failed
 *
 * Calls:
 *   save_block_copy   (0x0603BAC6) -- validate/copy save block
 *   sym_060360FC       (memmove)   -- safe overlapping memory copy
 *
 * Pool references:
 *   sym_060A4D14   -- global game state base pointer (pointer-to-pointer)
 *   DAT_0603bbb4   -- 0x00C4: offset to save status flags
 *   DAT_0603bbb6   -- 0x043C: offset to save block within state struct
 *   DAT_0603bc50   -- 0x043C: same offset (cross-TU, used to compute header base)
 *   DAT_0603bc52   -- 0x009C: offset from save block to header region
 *   DAT_0603bc54   -- 0x0096: descriptor advance for second copy
 *   .L_pool_0603BC58 -- sym_060360FC (memmove, cross-TU pool in save_size_calc)
 */

    .section .text.FUN_0603BB86


    .global save_header_parse
    .type save_header_parse, @function
save_header_parse:
    mov.l r14, @-r15                        ! save r14 (callee-saved, will hold output buffer ptr)
    mov.l r13, @-r15                        ! save r13 (callee-saved, will hold state ptr / header base)
    sts.l pr, @-r15                         ! save return address
    .byte   0xDD, 0x0B    /* mov.l .L_pool_state_base, r13 */  ! r13 = &sym_060A4D14 (state ptr-ptr)
    mov.w   DAT_0603bbb4, r1               ! r1 = 0x00C4 (status flags offset)
    mov.l @r13, r0                          ! r0 = *state_ptr (dereference to get state base)
    mov.l @(r0, r1), r0                     ! r0 = state_base[0xC4] (save status flags word)
    tst #0x1, r0                            ! test bit 0: save hardware present?
    bf/s    .save_hw_present                ! if bit 0 set, save hardware exists -- continue
    mov r4, r14                             ! (delay) r14 = output buffer pointer (preserve arg)
    bra     .return                         ! bit 0 clear: no save hardware
    mov #0x0, r0                            ! (delay) return 0 (no save device)
.save_hw_present:
    mov.l @r13, r4                          ! r4 = state_base (dereference state ptr-ptr)
    mov.w   DAT_0603bbb6, r3               ! r3 = 0x043C (save block offset within state)
    add r3, r4                              ! r4 = state_base + 0x043C (save block address)
    .byte   0xBF, 0x8F    /* bsr 0x0603BAC6 (external) */  ! call save_block_copy(r4)
    nop                                     ! delay slot
    tst r0, r0                              ! save_block_copy result == 0?
    bf      .block_valid                    ! if nonzero, block validated -- proceed to copy
    bra     .return                         ! block invalid -- return failure
    mov #0x0, r0                            ! (delay) return 0

    .global DAT_0603bbb0
DAT_0603bbb0:
    mov.l r10, @(r0, r0)                   ! data: 0x00A6 (cross-TU mov.w constant)
    .word 0x0800 /* UNKNOWN */              ! data: 0x0800 (cross-TU constant)

    .global DAT_0603bbb4
DAT_0603bbb4:
    .2byte  0x00C4                          ! constant: offset to save status flags in state struct

    .global DAT_0603bbb6
DAT_0603bbb6:
    .2byte  0x043C                          ! constant: offset to save block in state struct
    .4byte  evt_boundary_check              ! pool: event boundary check function
.L_pool_state_base:
    .4byte  sym_060A4D14                    ! pool: global game state pointer-to-pointer
.block_valid:
    mov.l @r13, r3                          ! r3 = state_base (reload from ptr-ptr)
    mov #0x4, r6                            ! r6 = 4 (byte count for memmove)
    .byte   0x92, 0x45    /* mov.w .L_wpool_0603BC52, r2 */  ! r2 = 0x009C (header region offset)
    .byte   0x9D, 0x43    /* mov.w .L_wpool_0603BC50, r13 */ ! r13 = 0x043C (save block offset)
    add r3, r13                             ! r13 = state_base + 0x043C (save block base)
    add r2, r13                             ! r13 = state_base + 0x043C + 0x009C = header region base
    .byte   0xD3, 0x22    /* mov.l .L_pool_0603BC58, r3 */   ! r3 = memmove (sym_060360FC)
    mov r13, r5                             ! r5 = header region base (source)
    add #0x6, r5                            ! r5 = header[+6] (source for first copy)
    jsr @r3                                 ! call memmove(dst=r4, src=r5, len=r6=4)
    mov r14, r4                             ! (delay) r4 = output buffer[+0] (but copies to +6)
    mov #0x4, r6                            ! r6 = 4 (byte count for second memmove)
    mov r13, r5                             ! r5 = header region base
    mov r14, r4                             ! r4 = output buffer pointer
    .byte   0x92, 0x3A    /* mov.w .L_wpool_0603BC54, r2 */  ! r2 = 0x0096 (descriptor advance)
    mov.l @r14, r3                          ! r3 = output_buf[0] (current descriptor value)
    add #0xE, r5                            ! r5 = header[+14] (source for second copy)
    add r2, r3                              ! r3 = descriptor + 0x0096 (advance descriptor)
    mov.l r3, @r14                          ! output_buf[0] = advanced descriptor
    .byte   0xD3, 0x1C    /* mov.l .L_pool_0603BC58, r3 */   ! r3 = memmove (sym_060360FC)
    jsr @r3                                 ! call memmove(dst=r4+4, src=r5, len=r6=4)
    add #0x4, r4                            ! (delay) r4 = output_buf + 4 (destination for second copy)
    mov.l @(4, r14), r0                     ! r0 = output_buf[4] (second copied field)
    tst r0, r0                              ! is the copied field zero?
    bf      .field_valid                    ! if nonzero, field is valid -- finalize
    bra     .return                         ! field is zero -- return failure
    mov #0x0, r0                            ! (delay) return 0
.field_valid:
    mov #0x0, r4                            ! r4 = 0 (clear value)
    extu.b r4, r0                           ! r0 = 0 (zero-extended byte)
    mov.b r0, @(10, r14)                    ! output_buf[10] = 0 (clear status byte 2)
    extu.b r4, r0                           ! r0 = 0
    mov.b r0, @(11, r14)                    ! output_buf[11] = 0 (clear status byte 3)
    extu.b r4, r0                           ! r0 = 0
    mov.b r0, @(8, r14)                     ! output_buf[8] = 0 (clear status byte 0)
    extu.b r4, r0                           ! r0 = 0
    mov.b r0, @(9, r14)                     ! output_buf[9] = 0 (clear status byte 1)
    mov #0x1, r0                            ! r0 = 1 (success)
.return:
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! (delay) restore r14
