/* cd_dma_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06012C3C - 0x06012CF4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Sets up and executes a CD DMA transfer for loading a file from disc.
 *
 * Two-phase retry loop:
 *   Phase 1: Polls the CD status flag (sym_06084AEC) waiting for it to
 *            become zero (indicating the CD subsystem is ready). Once ready,
 *            calls cmd_status_check(filename) to initiate the read command.
 *            Retries up to 5 times; if the limit is reached, calls the BIOS
 *            service function (via sym_0600026C) to reset the CD subsystem.
 *
 *   Phase 2: Calls cmd_validate_chain(file_id, flags=0, dest, size=-1) to
 *            execute the actual DMA transfer and validate the result.
 *            Same retry logic with BIOS reset fallback on exhaustion.
 *
 * Arguments:
 *   r4 = CD file identifier (e.g. filename pointer)
 *   r5 = DMA destination address
 *
 * Register allocation:
 *   r8  = cmd_validate_chain (function pointer)
 *   r9  = retry counter (both phases)
 *   r10 = sym_06084AEC (CD status flag byte pointer)
 *   r11 = cmd_status_check (function pointer)
 *   r12 = last return value / status code
 *   r13 = 5 (retry limit)
 *   r14 = sym_0600026C (indirect pointer to BIOS service function)
 *   @(0,r15) = saved r4 (file ID), later reused as phase 2 retry counter
 *   @(4,r15) = saved r5 (destination address)
 *   @(8,r15) = initial sentinel value (-1)
 */

    .section .text.FUN_06012C3C


    .global cd_dma_setup
    .type cd_dma_setup, @function
cd_dma_setup:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r13, @-r15                    ! save r13 (callee-saved)
    mov.l r12, @-r15                    ! save r12 (callee-saved)
    mov.l r11, @-r15                    ! save r11 (callee-saved)
    mov.l r10, @-r15                    ! save r10 (callee-saved)
    mov.l r9, @-r15                     ! save r9  (callee-saved)
    mov.l r8, @-r15                     ! save r8  (callee-saved)
    sts.l pr, @-r15                     ! save return address
    add #-0xC, r15                      ! allocate 12 bytes of stack locals
    mov.l   .L_pool_cmd_validate_chain, r8  ! r8 = &cmd_validate_chain (DMA transfer function)
    mov.l   .L_pool_cd_status_flag, r10     ! r10 = &sym_06084AEC (CD status flag byte)
    mov.l   .L_pool_cmd_status_check, r11   ! r11 = &cmd_status_check (file read validator)
    mov #0x5, r13                       ! r13 = 5 (max retry count for both phases)
    mov.l   .L_pool_bios_service_ptr, r14   ! r14 = &sym_0600026C (indirect BIOS service ptr)
    mov.l r4, @r15                      ! local[0] = r4 (file identifier)
    mov.l r5, @(4, r15)                 ! local[4] = r5 (DMA destination address)
    mov #-0x1, r4                       ! r4 = -1 (sentinel value)
    mov r4, r12                         ! r12 = -1 (initial status = no result yet)
    mov.l r4, @(8, r15)                 ! local[8] = -1 (sentinel)
    bra     .L_phase1_check             ! jump into phase 1 loop at retry check
    mov #0x0, r9                        ! r9 = 0 (retry counter, delay slot)

    .global DAT_06012c66
DAT_06012c66:
    sts macl, r10
    .4byte  cdb_read_status
    .4byte  sym_060448D4
    .4byte  0x0000E000
    .4byte  sym_060283E0
    .4byte  sym_060612C4
    .4byte  sym_060612B4
    .4byte  memcpy_word_idx
    .4byte  ai_brake_zone_calc
    .4byte  sym_0605ACCA
.L_pool_cmd_validate_chain:
    .4byte  cmd_validate_chain          ! fn ptr: CD DMA transfer + validation
.L_pool_cd_status_flag:
    .4byte  sym_06084AEC                ! byte flag: 0 = CD ready, 1 = CD busy/error
.L_pool_cmd_status_check:
    .4byte  cmd_status_check            ! fn ptr: validate CD file read status
.L_pool_bios_service_ptr:
    .4byte  sym_0600026C                ! indirect ptr to BIOS service/reset function
.L_poll_cd_ready:
    .byte   0xBF, 0x9E    /* bsr 0x06012BDC (external) */  ! call cd_error_recover
    nop                                 ! (delay slot)
.L_phase1_check:
    mov.b @r10, r0                      ! r0 = CD status flag byte
    tst r0, r0                          ! is CD status == 0 (ready)?
    bf      .L_poll_cd_ready            ! if nonzero (busy/error), call cd_error_recover
.L_phase1_status_check:
    jsr @r11                            ! call cmd_status_check(file_id)
    mov.l @r15, r4                      ! (delay slot) r4 = file identifier from local[0]
    add #0x1, r9                        ! ++retry_counter
    cmp/ge r13, r9                      ! is retry_counter >= 5?
    bf/s    .L_phase1_retry_ok          ! if retries remaining, skip BIOS reset
    mov r0, r12                         ! r12 = cmd_status_check result (delay slot)
    mov.l @r14, r2                      ! r2 = *sym_0600026C (BIOS service function ptr)
    jsr @r2                             ! call BIOS service (reset CD subsystem)
    nop                                 ! (delay slot)
.L_phase1_retry_ok:
    cmp/pz r12                          ! is status result >= 0 (success)?
    bf      .L_phase1_status_check      ! if negative (still failing), retry phase 1
    mov #0x0, r2                        ! r2 = 0
    mov.l r2, @r15                      ! local[0] = 0 (reuse as phase 2 retry counter)
.L_phase2_transfer:
    mov #-0x1, r7                       ! r7 = -1 (size = entire file)
    mov #0x0, r5                        ! r5 = 0 (flags = none)
    mov.l @(4, r15), r6                 ! r6 = DMA destination address from local[4]
    jsr @r8                             ! call cmd_validate_chain(file_id, 0, dest, -1)
    mov r12, r4                         ! (delay slot) r4 = file_id (status handle from phase 1)
    mov r0, r9                          ! r9 = transfer result
    mov.l @r15, r3                      ! r3 = phase 2 retry counter from local[0]
    add #0x1, r3                        ! ++retry_counter
    cmp/ge r13, r3                      ! is retry_counter >= 5?
    bf/s    .L_phase2_retry_ok          ! if retries remaining, skip BIOS reset
    mov.l r3, @r15                      ! (delay slot) store updated counter back
    mov.l @r14, r3                      ! r3 = *sym_0600026C (BIOS service function ptr)
    jsr @r3                             ! call BIOS service (reset CD subsystem)
    nop                                 ! (delay slot)
.L_phase2_retry_ok:
    cmp/pz r9                           ! is transfer result >= 0 (success)?
    bf      .L_phase2_transfer          ! if negative (still failing), retry phase 2
    add #0xC, r15                       ! deallocate 12 bytes of stack locals
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
