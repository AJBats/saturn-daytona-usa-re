/* grid_position_camera -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601A0F0 - 0x0601A1BA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains two independent code objects sharing a constant pool:
 *
 * 1. grid_position_camera (FUN_0601A0F0)
 *    Adjusts the camera's grid slot index (starting position selector) based
 *    on D-pad Up/Down input, then tail-calls an external function.
 *
 *    The valid index range depends on the game mode:
 *      - bit 0 of held buttons NOT set → mode A: max = 0x06, reset val = 0
 *      - bit 0 of held buttons set     → mode B (time attack?): max = 0x19
 *    (r12 is set to 0 for mode A and stays 0; r5 holds the max.)
 *
 *    Input priority (newly pressed beats held):
 *      1. Newly pressed Up   (bit 15, 0x8000) → increment slot counter
 *      2. Newly pressed Down (bit 14, 0x4000) → decrement slot counter
 *      3. Held Up            (bit 15, 0x8000) → increment if slot < max
 *      4. Held Down          (bit 14, 0x4000) → decrement if slot > 0
 *    After adjustment: clamp to [0, 4], then clamp lower bound to 0.
 *    On any change the new slot value is stored to sym_0605D243 (byte).
 *    Tail-calls external function (BRA encoding, offset beyond TU range).
 *
 *    Key data:
 *      sym_06063D98  = input button state struct
 *                       +0 = held buttons (16-bit word)
 *                       +2 = newly pressed buttons (16-bit word)
 *      sym_0605AD04  = grid slot counter (32-bit, clamped to [0..4])
 *      sym_0605D243  = mode variant / grid slot output byte
 *      0x00008000    = bit 15 mask = Up button
 *      0x4000        = bit 14 mask = Down button
 *
 * 2. loc_0601A1A8
 *    Dispatch table stub: reads sym_0605D243 as a byte index, multiplies
 *    by 4 (shll2), adds to the base of sym_0605AD04 dispatch table, loads
 *    the function pointer, and jumps to it.
 */

    .section .text.FUN_0601A0F0


    .global grid_position_camera
    .type grid_position_camera, @function
grid_position_camera:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    mov.l r13, @-r15                        ! save r13 (callee-saved)
    mov.l r12, @-r15                        ! save r12 (callee-saved)
    mov.l   .L_pool_input_state, r13        ! r13 = &input_state (sym_06063D98)
    mov.l   .L_pool_slot_counter, r14       ! r14 = &grid_slot_counter (sym_0605AD04)
    mov.w @r13, r0                          ! r0 = held buttons (16-bit, offset +0)
    extu.w r0, r0                           ! r0 = zero-extended held buttons
    tst #0x1, r0                            ! test bit 0 of held buttons (mode flag)
    bt/s    .L_mode_b                       ! if bit 0 clear → mode B (max = 0x19)
    mov #0x0, r12                           ! (delay) r12 = 0 (reset/clear value)
    bra     .L_mode_selected                ! bit 0 set → mode A (max = 0x06)
    mov #0x6, r5                            ! (delay) r5 = 0x06 (mode A max)
.L_mode_b:
    mov #0x19, r5                           ! r5 = 0x19 (25 = mode B max slot index)
.L_mode_selected:
    mov.l   .L_up_btn_mask, r7             ! r7 = 0x00008000 (Up button mask, bit 15)
    mov.l   .L_pool_slot_byte, r4           ! r4 = &grid_slot_byte (sym_0605D243)
    mov.w @(2, r13), r0                     ! r0 = newly pressed buttons (offset +2)
    mov r0, r2                              ! r2 = newly pressed copy
    extu.w r2, r2                           ! r2 = zero-extended newly pressed
    and r7, r2                              ! r2 = newly_pressed & 0x8000 (Up pressed?)
    tst r2, r2                              ! is Up newly pressed?
    bt      .L_check_new_down              ! no → check newly pressed Down
    mov.l @r14, r3                          ! r3 = current grid_slot_counter
    add #0x1, r3                            ! r3 = slot + 1
    mov.l r3, @r14                          ! grid_slot_counter = slot + 1
    exts.b r12, r2                          ! r2 = sign-extend r12 (0 → 0)
    bra     .L_clamp                        ! go to clamp
    mov.b r2, @r4                           ! (delay) slot_byte = r12 (clear/reset byte)
.L_check_new_down:
    mov.w   .L_down_btn_mask, r6            ! r6 = 0x4000 (Down button mask, bit 14)
    mov.w @(2, r13), r0                     ! r0 = newly pressed buttons (re-read)
    mov r0, r2                              ! r2 = newly pressed copy
    extu.w r2, r2                           ! r2 = zero-extended newly pressed
    and r6, r2                              ! r2 = newly_pressed & 0x4000 (Down pressed?)
    tst r2, r2                              ! is Down newly pressed?
    bt      .L_check_held_up               ! no → check held Up button
    mov.l @r14, r3                          ! r3 = current grid_slot_counter
    add #-0x1, r3                           ! r3 = slot - 1
    mov.l r3, @r14                          ! grid_slot_counter = slot - 1
    exts.b r12, r2                          ! r2 = sign-extend r12 (0 → 0)
    bra     .L_clamp                        ! go to clamp
    mov.b r2, @r4                           ! (delay) slot_byte = r12 (clear/reset byte)
.L_check_held_up:
    mov.w @r13, r2                          ! r2 = held buttons (16-bit, offset +0)
    extu.w r2, r2                           ! r2 = zero-extended held buttons
    and r7, r2                              ! r2 = held & 0x8000 (Up held?)
    tst r2, r2                              ! is Up held?
    bt      .L_check_held_down             ! no → check held Down button
    mov.b @r4, r3                           ! r3 = current slot_byte
    extu.b r5, r5                           ! r5 = zero-extended max slot value
    cmp/eq r5, r3                           ! is slot_byte == max?
    bf      .L_clamp                        ! if not at max → skip increment
    mov.l @r14, r3                          ! r3 = current grid_slot_counter
    add #0x1, r3                            ! r3 = slot + 1
    mov.l r3, @r14                          ! grid_slot_counter = slot + 1
    exts.b r12, r2                          ! r2 = sign-extend r12 (0 → 0)
    bra     .L_clamp                        ! go to clamp
    mov.b r2, @r4                           ! (delay) slot_byte = r12 (clear/reset byte)
.L_check_held_down:
    mov.w @r13, r2                          ! r2 = held buttons (16-bit, offset +0)
    extu.w r2, r2                           ! r2 = zero-extended held buttons
    and r6, r2                              ! r2 = held & 0x4000 (Down held?)
    tst r2, r2                              ! is Down held?
    bt      .L_clamp                        ! no input → go to clamp
    extu.b r5, r5                           ! r5 = zero-extended max slot value
    mov.b @r4, r3                           ! r3 = current slot_byte
    cmp/eq r5, r3                           ! is slot_byte == max?
    bf      .L_clamp                        ! if not at max → skip decrement
    mov.l @r14, r3                          ! r3 = current grid_slot_counter
    add #-0x1, r3                           ! r3 = slot - 1
    mov.l r3, @r14                          ! grid_slot_counter = slot - 1
    exts.b r12, r2                          ! r2 = sign-extend r12 (0 → 0)
    mov.b r2, @r4                           ! slot_byte = r12 (clear/reset byte)
.L_clamp:
    mov #0x5, r2                            ! r2 = 5 (upper clamp threshold)
    mov.l @r14, r3                          ! r3 = current grid_slot_counter
    cmp/ge r2, r3                           ! is slot >= 5?
    bf      .L_check_lower_clamp            ! if slot < 5 → skip upper clamp
    mov #0x4, r2                            ! r2 = 4 (clamp to max = 4)
    mov.l r2, @r14                          ! grid_slot_counter = 4
.L_check_lower_clamp:
    mov.l @r14, r3                          ! r3 = current grid_slot_counter
    cmp/pz r3                               ! is slot >= 0?
    bt      .L_epilogue                     ! if non-negative → no lower clamp needed
    mov.l r12, @r14                         ! grid_slot_counter = 0 (clamp to zero)
.L_epilogue:
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    .byte   0xAF, 0x0E    /* bra 0x06019FB2 (external) */ ! tail-call external handler
    mov.l @r15+, r14                        ! (delay) restore r14
.L_down_btn_mask:
    .2byte  0x4000                          /* Down button bit mask (bit 14) */
.L_pool_input_state:
    .4byte  sym_06063D98                    /* &input_state (+0=held, +2=newly pressed) */
.L_pool_slot_counter:
    .4byte  sym_0605AD04                    /* &grid_slot_counter (32-bit) */
.L_up_btn_mask:
    .4byte  0x00008000                      /* Up button bit mask (bit 15, 32-bit for AND) */
.L_pool_slot_byte:
    .4byte  sym_0605D243                    /* &grid_slot_byte (byte output) */

    .global loc_0601A1A8
loc_0601A1A8:
    .byte   0xD3, 0x25    /* mov.l .L_pool_0601A240, r3 */  ! r3 = &dispatch_table_base (sym_0605AD04 area)
    mov.b @r3, r3                           ! r3 = dispatch_index byte (sym_0605D243 value)
    extu.b r3, r3                           ! r3 = zero-extended dispatch index
    shll2 r3                                ! r3 = index * 4 (byte → dword offset)
    .byte   0xD2, 0x24    /* mov.l .L_pool_0601A244, r2 */  ! r2 = dispatch_table base address
    add r2, r3                              ! r3 = &dispatch_table[index]
    mov.l @r3, r3                           ! r3 = function pointer from dispatch table
    jmp @r3                                 ! jump to dispatched function
    nop                                     ! (delay slot)
