/* hud_large_element -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E37C - 0x0601E488
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Called from hud_overlay_render to process up to 3 large HUD elements
 * (e.g. position display, lap counter, speed readout).
 *
 * Iterates over element indices 0..2. For each element:
 *   1. Looks up the element's display ID from the ID table (sym_06087086).
 *      If zero, the slot is empty — skip it.
 *   2. Writes the display ID into the HUD element struct at field +0x1C
 *      (word), then calls hud_text_handler to query the element's state.
 *   3. State dispatch (return from hud_text_handler):
 *        0 — proceed to bounds check (element active)
 *        1 — skip element entirely (inactive / hidden)
 *        2 — call hud_utility to check if the element's display callback
 *            is still valid; sets the "display active" flag at +0x1F
 *            based on the result.
 *   4. Bounds check: reads field +12 (element Y-position or scroll offset)
 *      and compares against the current course size + 0x20. If within
 *      bounds, sets "needs update" flag at +0x1E to 0 (cleared); if
 *      beyond bounds, sets it to 1.
 *
 * On exit, stores the count of valid (non-skipped) elements into the
 * output counter at .L_pool_0601E518 (out-of-TU, referenced via .byte
 * encoded mov.l).
 *
 * HUD element array (sym_06087094): 0x20 (32) bytes per element.
 *   +0x0C (long)  — Y-position / scroll progress
 *   +0x1C (word)  — display ID (set here from the ID table)
 *   +0x1E (byte)  — "needs update" flag (0=no, 1=yes)
 *   +0x1F (byte)  — "display active" flag (0=inactive, 0xFF=active)
 *
 * Arguments: none (uses global state)
 * Returns:   nothing (writes output count to memory)
 *
 * Calls:
 *   hud_text_handler  (0x0601E488) — query element display state
 *   hud_utility       (0x0601E6A4) — check display callback validity
 */

    .section .text.FUN_0601E37C


    .global hud_large_element
    .type hud_large_element, @function
hud_large_element:
    mov.l r14, @-r15               ! save r14
    mov.l r13, @-r15               ! save r13
    mov.l r12, @-r15               ! save r12
    mov.l r11, @-r15               ! save r11
    mov.l r10, @-r15               ! save r10
    mov.l r9, @-r15                ! save r9
    mov.l r8, @-r15                ! save r8
    sts.l pr, @-r15                ! save return address

/* === Register assignments ===
 * r8  = 0x00FF (display-active mask, also used as flag byte)
 * r9  = 3 (element count / loop limit)
 * r10 = 0 (zero constant, also "cleared" flag value)
 * r11 = 1 (set flag value)
 * r12 = input loop index (0..2, incremented every iteration)
 * r13 = output element counter (incremented only for non-skipped elements)
 * r14 = HUD element array base (sym_06087094, 0x20 bytes per element)
 */
    mov.w   DAT_0601e444, r8       ! r8 = 0x00FF (display-active mask constant)
    mov #0x3, r9                   ! r9 = 3 (number of large HUD element slots)
    mov #0x0, r10                  ! r10 = 0 (zero constant / "cleared" flag)
    mov #0x1, r11                  ! r11 = 1 ("set" flag value)
    mov.l   .L_pool_elem_array, r14 ! r14 = HUD element array base (sym_06087094)
    extu.w r10, r13                ! r13 = 0 (output element counter, zero-extended)
    bra     .L_loop_check          ! jump to loop condition test
    mov r13, r12                   ! r12 = 0 (input loop index, delay slot)

/* === Main loop body: process one large HUD element slot === */
.L_loop_body:
    extu.w r12, r2                 ! r2 = loop index (zero-extended to 32-bit)
    mov.l   .L_pool_id_table, r3   ! r3 = display ID table base (sym_06087086)
    shll2 r2                       ! r2 = index * 4 (stride into ID table)
    add r3, r2                     ! r2 = &id_table[index]
    mov.w @r2, r2                  ! r2 = id_table[index] (display ID, word)
    extu.w r2, r2                  ! zero-extend display ID
    tst r2, r2                     ! display ID == 0? (empty slot)
    bf      .L_slot_has_id         ! non-zero: slot has a valid display ID
    bra     .L_next_input          ! zero: skip this slot entirely
    nop                            ! (delay)

/* --- Slot has a display ID: write it into the element struct, query state --- */
.L_slot_has_id:
    extu.w r13, r2                 ! r2 = output element index (zero-extended)
    mov r12, r0                    ! r0 = input loop index (display ID from table)
    shll2 r2                       ! r2 = out_index * 4
    shll2 r2                       ! r2 = out_index * 16
    shll r2                        ! r2 = out_index * 32 (element stride = 0x20)
    add r14, r2                    ! r2 = &element[out_index]
    mov.w r0, @(28, r2)           ! element[out_index].field_1C = input index (display ID slot)
    .byte   0xB0, 0x63    /* bsr 0x0601E488 (hud_text_handler — query element state) */
    mov r13, r4                    ! r4 = output element index (arg for hud_text_handler, delay slot)
    bra     .L_state_dispatch      ! jump to state dispatch switch
    nop                            ! (delay)

/* === State 2 handler: check display callback via hud_utility === */
.L_state_2_check:
    extu.w r13, r4                 ! r4 = output element index (zero-extended)
    shll2 r4                       ! r4 = out_index * 4
    shll2 r4                       ! r4 = out_index * 16
    shll r4                        ! r4 = out_index * 32 (element stride)
    add r14, r4                    ! r4 = &element[out_index]
    mov.w @(28, r4), r0            ! r0 = element[out_index].field_1C (display ID)
    mov r0, r4                     ! r4 = display_id
    .byte   0xB1, 0x66    /* bsr 0x0601E6A4 (hud_utility — check display callback) */
    extu.w r4, r4                  ! zero-extend display_id (delay slot, arg for hud_utility)
    tst r0, r0                     ! hud_utility returned 0? (callback invalid)
    bt      .L_display_inactive    ! yes: mark element as inactive
    extu.w r13, r3                 ! r3 = output element index
    shll2 r3                       ! r3 = out_index * 4
    shll2 r3                       ! r3 = out_index * 16
    shll r3                        ! r3 = out_index * 32 (element stride)
    add r14, r3                    ! r3 = &element[out_index]
    extu.b r8, r2                  ! r2 = 0xFF (display-active flag, low byte of 0x00FF)
    mov #0x1F, r0                  ! r0 = 0x1F (offset of "display active" flag in element struct)
    mov.b r2, @(r0, r3)           ! element[out_index].display_active = 0xFF (active)
    bra     .L_bounds_check        ! proceed to bounds check
    nop                            ! (delay)

/* --- Display callback invalid: mark element as inactive --- */
.L_display_inactive:
    extu.w r13, r2                 ! r2 = output element index
    shll2 r2                       ! r2 = out_index * 4
    shll2 r2                       ! r2 = out_index * 16
    shll r2                        ! r2 = out_index * 32 (element stride)
    add r14, r2                    ! r2 = &element[out_index]
    extu.b r11, r3                 ! r3 = 1 (inactive-but-present flag)
    mov #0x1F, r0                  ! r0 = 0x1F (offset of "display active" flag)
    mov.b r3, @(r0, r2)           ! element[out_index].display_active = 1 (inactive)
    bra     .L_bounds_check        ! proceed to bounds check
    nop                            ! (delay)

/* === State dispatch: switch on hud_text_handler return value ===
 * r0 = state code from hud_text_handler:
 *   0 — element active, proceed to bounds check
 *   1 — element hidden/inactive, skip entirely
 *   2 — need to verify display callback via hud_utility
 */
.L_state_dispatch:
    cmp/eq #0x0, r0                ! state == 0? (active)
    bt      .L_bounds_check        ! yes: proceed to bounds check
    cmp/eq #0x1, r0                ! state == 1? (hidden)
    bt      .L_next_input          ! yes: skip this element
    cmp/eq #0x2, r0                ! state == 2? (check callback)
    bt      .L_state_2_check       ! yes: verify via hud_utility

/* === Bounds check: compare element Y-position against course size ===
 * If element Y-pos < course_size + 0x20: needs_update = 0 (within bounds)
 * If element Y-pos >= course_size + 0x20: needs_update = 1 (out of bounds)
 */
.L_bounds_check:
    extu.w r13, r4                 ! r4 = output element index
    mov.l   .L_pool_player_index, r3 ! r3 = &player_index byte (sym_060877D8)
    mov.l   .L_pool_course_size_table, r2 ! r2 = course size table base (sym_0604A5C0)
    shll2 r4                       ! r4 = out_index * 4
    mov.b @r3, r3                  ! r3 = current player/car index (byte)
    shll2 r4                       ! r4 = out_index * 16
    extu.b r3, r3                  ! zero-extend player index
    shll r4                        ! r4 = out_index * 32 (element stride)
    shll2 r3                       ! r3 = player_index * 4 (course size table stride)
    add r14, r4                    ! r4 = &element[out_index]
    add r2, r3                     ! r3 = &course_size_table[player_index]
    mov.l @(12, r4), r4            ! r4 = element[out_index].y_position (long at +0x0C)
    mov.l @r3, r3                  ! r3 = course_size_table[player_index]
    add #0x20, r3                  ! r3 = course_size + 0x20 (upper bound threshold)
    cmp/hs r3, r4                  ! y_position >= (course_size + 0x20)? (unsigned compare)
    bt      .L_out_of_bounds       ! yes: element is beyond course bounds

/* --- Within bounds: clear "needs update" flag --- */
    extu.w r13, r3                 ! r3 = output element index
    shll2 r3                       ! r3 = out_index * 4
    shll2 r3                       ! r3 = out_index * 16
    shll r3                        ! r3 = out_index * 32 (element stride)
    add r14, r3                    ! r3 = &element[out_index]
    extu.b r10, r2                 ! r2 = 0 (cleared flag)
    mov #0x1E, r0                  ! r0 = 0x1E (offset of "needs update" flag)
    mov.b r2, @(r0, r3)           ! element[out_index].needs_update = 0
    bra     .L_advance_output      ! proceed to advance output counter
    nop                            ! (delay)

    .global DAT_0601e444
DAT_0601e444:
    .2byte  0x00FF
    .2byte  0xFFFF
.L_pool_elem_array:
    .4byte  sym_06087094
.L_pool_id_table:
    .4byte  sym_06087086
.L_pool_player_index:
    .4byte  sym_060877D8
.L_pool_course_size_table:
    .4byte  sym_0604A5C0

/* --- Out of bounds: set "needs update" flag --- */
.L_out_of_bounds:
    extu.w r13, r2                 ! r2 = output element index
    shll2 r2                       ! r2 = out_index * 4
    shll2 r2                       ! r2 = out_index * 16
    shll r2                        ! r2 = out_index * 32 (element stride)
    add r14, r2                    ! r2 = &element[out_index]
    extu.b r11, r3                 ! r3 = 1 (set flag)
    mov #0x1E, r0                  ! r0 = 0x1E (offset of "needs update" flag)
    mov.b r3, @(r0, r2)           ! element[out_index].needs_update = 1

/* --- Advance output counter (valid element processed) --- */
.L_advance_output:
    add #0x1, r13                  ! r13++ (increment output element counter)

/* --- Advance input loop index --- */
.L_next_input:
    add #0x1, r12                  ! r12++ (advance to next input slot)

/* === Loop condition: check if all 3 slots processed === */
.L_loop_check:
    extu.w r12, r3                 ! r3 = input index (zero-extended)
    cmp/ge r9, r3                  ! index >= 3? (all slots processed)
    bf      .L_loop_body           ! no: process next slot

/* === Epilogue: store output count and return === */
    .byte   0xD3, 0x29    /* mov.l .L_pool_0601E518, r3 (out-of-TU: output element count address) */
    mov.w r13, @r3                 ! *output_count = r13 (number of valid elements)
    lds.l @r15+, pr                ! restore return address
    mov.l @r15+, r8                ! restore r8
    mov.l @r15+, r9                ! restore r9
    mov.l @r15+, r10               ! restore r10
    mov.l @r15+, r11               ! restore r11
    mov.l @r15+, r12               ! restore r12
    mov.l @r15+, r13               ! restore r13
    rts                            ! return
    mov.l @r15+, r14               ! restore r14 (delay slot)
