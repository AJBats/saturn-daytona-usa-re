/* display_cmd_vscroll -- Display command handlers for vertical scroll
 *
 * Handles display commands 2, 4-7 from the display dispatch table (sym_06032334).
 * Each sub-handler manipulates the display element's control word or buffer,
 * then branches back to the display dispatch return path at 0x0603230A.
 *
 * Commands:
 *   display_cmd_vscroll (cmd 2)  - dispatch disp_init_setup, return
 *   loc_060323F0        (cmd 4)  - write byte to display buffer at r14+0x2DE
 *   loc_06032404        (cmd 5)  - OR bits into display control word (r14+0x0E)
 *   loc_06032414        (cmd 6)  - AND-NOT bits from display control word (r14+0x0E)
 *   loc_06032424        (cmd 7)  - call with args r4=0, r5=r7 (cross-TU tail)
 *
 * Translation unit: 0x060323E4 - 0x0603242A
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_060323E4


/*----------------------------------------------------------------------
 * display_cmd_vscroll (cmd 2) — vertical scroll dispatch
 *
 * Calls disp_init_setup to push callee-saved regs and set up the
 * display element context in r14, then returns via the display
 * dispatch return path.
 *----------------------------------------------------------------------*/
    .global display_cmd_vscroll
    .type display_cmd_vscroll, @function
display_cmd_vscroll:
    sts.l pr, @-r15                         ! save return address to stack
    .byte   0xBE, 0xEB    /* bsr 0x060321C0 (external) */
    nop                                     ! delay slot
    lds.l @r15+, pr                         ! restore return address from stack
    .byte   0xAF, 0x8D    /* bra 0x0603230A (external) */
    nop                                     ! delay slot: return to display dispatch loop

/*----------------------------------------------------------------------
 * cmd 4: write byte to display buffer — extracts low byte and index
 *        from r7, writes byte at r14 + 0x2DE + index.
 *----------------------------------------------------------------------*/
    .global loc_060323F0
loc_060323F0:
    extu.b r7, r1                           ! r1 = low byte of r7 (value to write)
    swap.w r7, r2                           ! r2 = high word of r7 swapped to low
    extu.b r2, r2                           ! r2 = byte index (from bits 16-23 of r7)
    mov.l   _pool_disp_buf_offset, r0      ! r0 = 0x2DE (display buffer offset)
    add r14, r0                             ! r0 = r14 + 0x2DE (display buffer base)
    .byte   0xAF, 0x86    /* bra 0x0603230A (external) */
    mov.b r1, @(r0, r2)                    ! delay slot: write value byte at buf[index]
    .2byte  0x0000                          ! alignment padding
_pool_disp_buf_offset:
    .4byte  0x000002DE                      ! display buffer offset from element base

/*----------------------------------------------------------------------
 * cmd 5: OR bits into display control word — sets bits specified by
 *        r7 in the 16-bit control word at r14+0x0E.
 *----------------------------------------------------------------------*/
    .global loc_06032404
loc_06032404:
    mov.l   _pool_ctrl_word_off_a, r0      ! r0 = 0x0E (control word offset)
    mov.w @(r0, r14), r1                   ! r1 = current control word at r14+0x0E
    or r7, r1                               ! r1 |= r7 — set requested bits
    .byte   0xAF, 0x7E    /* bra 0x0603230A (external) */
    mov.w r1, @(r0, r14)                   ! delay slot: write back updated control word
    .2byte  0x0000                          ! alignment padding
_pool_ctrl_word_off_a:
    .4byte  0x0000000E                      ! control word offset from element base

/*----------------------------------------------------------------------
 * cmd 6: AND-NOT bits from display control word — clears bits specified
 *        by r7 in the 16-bit control word at r14+0x0E.
 *----------------------------------------------------------------------*/
    .global loc_06032414
loc_06032414:
    mov.l   _pool_ctrl_word_off_b, r0      ! r0 = 0x0E (control word offset)
    mov.w @(r0, r14), r1                   ! r1 = current control word at r14+0x0E
    not r7, r2                              ! r2 = ~r7 (invert bit mask)
    and r2, r1                              ! r1 &= ~r7 — clear requested bits
    .byte   0xAF, 0x75    /* bra 0x0603230A (external) */
    mov.w r1, @(r0, r14)                   ! delay slot: write back updated control word
_pool_ctrl_word_off_b:
    .4byte  0x0000000E                      ! control word offset from element base

/*----------------------------------------------------------------------
 * cmd 7: call with args — sets r4=0, r5=r7, loads function pointer
 *        from cross-TU pool (0x06032438 in display_cmd_position).
 *        TU boundary truncates here; execution continues in next TU.
 *----------------------------------------------------------------------*/
    .global loc_06032424
loc_06032424:
    mov #0x0, r4                            ! r4 = 0 (first argument)
    mov r7, r5                              ! r5 = r7 (second argument = command param)
    .byte   0xD0, 0x03    /* mov.l .L_pool_06032438, r0 */
