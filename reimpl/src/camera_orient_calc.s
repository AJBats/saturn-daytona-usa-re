/* camera_orient_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060053AC - 0x06005494
 * Auto-generated by tools/generate_l3_tu.py
 *
 * camera_orient_calc(r4=pos_xyz_ptr, r5=rot_angles_ptr, r6=scale):
 *   Builds the camera view matrix from a position/orientation pair and
 *   computes the final camera world-space position, storing it into the
 *   camera position state (sym_06063DF8).
 *
 *   This is the camera-side counterpart to obj_state_writer (FUN_06005494),
 *   which immediately follows this TU. Both functions share the same
 *   rotation-matrix + mat_vec_mac pattern; camera_orient_calc additionally
 *   computes an offset position via sincos_pair + fpmul and records the
 *   result into the rendering budget counter struct (sym_06089EDC[+44]).
 *
 * Algorithm:
 *   1. camera_push (sym_06026E0C) — save/init camera state; r12 = scale arg
 *   2. Store r12 into sym_06089EDC[+44] (rendering budget counter slot)
 *   3. Check camera direction flip (sym_06078663):
 *      if non-zero: mat_scale_columns(-1.0, 1.0, 1.0) — mirror Y axis
 *   4. Build view rotation matrix (all angles negated):
 *        mat_rot_x(-rot[0])  — general rotation component
 *        mat_rot_z(-rot[8])         — Z-axis rotation
 *        mat_rot_y(-rot[4])         — Y-axis rotation
 *   5. mat_vec_mac(-pos[0], -pos[1], -pos[2]) — translate into view space
 *   6. sincos_pair(rot[0], &sin0, &cos0) — trig for angles[0]
 *      sincos_pair(rot[4], &sin1, &cos1) — trig for angles[4]
 *   7. Compute and store world-space camera position (sym_06063DF8):
 *        cam_pos[0] = pos[0] + scale * cos0 * sin1
 *        cam_pos[1] = pos[1] - scale * sin0
 *        cam_pos[2] = pos[2] - scale * cos0 * cos1
 *
 * Persistent registers:
 *   r12 = scale factor (arg2, held across calls)
 *   r13 = rot_angles_ptr (arg1)
 *   r14 = pos_xyz_ptr (arg0)
 *   r11 = cam_pos_state ptr (sym_06063DF8, loaded late)
 *   r13 = fpmul function (reloaded after sincos phase)
 *
 * Stack frame: 0x10 bytes of local storage (sincos results)
 *   SP+0x00 = cos(rot[0])  (cos0)
 *   SP+0x04 = sin(rot[4])  (sin1)
 *   SP+0x08 = cos(rot[4])  (cos1)
 *   SP+0x0C = sin(rot[0])  (sin0)
 */

    .section .text.FUN_060053AC


    .global camera_orient_calc
    .type camera_orient_calc, @function
camera_orient_calc:
    mov.l r14, @-r15                  ! save r14 (callee-saved)
    mov r4, r14                       ! r14 = pos_xyz_ptr (arg0)
    mov.l r13, @-r15                  ! save r13 (callee-saved)
    mov r5, r13                       ! r13 = rot_angles_ptr (arg1)
    mov.l r12, @-r15                  ! save r12 (callee-saved)
    mov.l r11, @-r15                  ! save r11 (callee-saved)
    sts.l pr, @-r15                   ! save return address
    add #-0x10, r15                   ! reserve 16 bytes for sincos results
    mov.l   .L_fn_camera_push, r3    ! r3 = camera_push function (sym_06026E0C)
    jsr @r3                           ! camera_push() — save and init camera state
    mov r6, r12                       ! r12 = scale (arg2, delay slot)
    mov.l   .L_budget_counter, r4    ! r4 = &budget_counter ptr (sym_06089EDC)
    mov.l @r4, r4                     ! r4 = budget_counter struct base
    mov.l r12, @(44, r4)             ! budget_counter[+44] = scale — record in render budget
    mov.l   .L_cam_dir_flip, r0      ! r0 = &camera direction flip flag (sym_06078663)
    mov.b @r0, r0                     ! r0 = camera direction flip byte
    tst r0, r0                        ! is flip flag zero?
    bt      .L_skip_y_mirror          ! yes: skip Y-axis mirror
    mov.l   .L_fp_one, r6            ! r6 = 1.0 (16.16 fixed-point) — Z/Y scale
    mov.l   .L_fp_neg_one, r4        ! r4 = -1.0 (16.16 fixed-point) — X scale (flip)
    mov.l   .L_fn_mat_scale_cols, r3 ! r3 = mat_scale_columns function
    jsr @r3                           ! mat_scale_columns(-1.0, 1.0, 1.0) — mirror Y axis
    mov r6, r5                        ! r5 = 1.0 (Y scale, delay slot)
.L_skip_y_mirror:
    mov.l @r13, r4                    ! r4 = rot_angles[0] (general rotation component)
    mov.l   .L_fn_mat_rot_x, r3 ! r3 = mat_rot_x function
    jsr @r3                           ! mat_rot_x(-rot[0]) — apply negated general rotation
    neg r4, r4                        ! r4 = -rot[0] (delay slot)
    mov.l @(8, r13), r4              ! r4 = rot_angles[8] (Z rotation angle)
    mov.l   .L_fn_mat_rot_z, r3      ! r3 = mat_rot_z function
    jsr @r3                           ! mat_rot_z(-rot[8]) — apply negated Z rotation
    neg r4, r4                        ! r4 = -rot[8] (delay slot)
    mov.l @(4, r13), r4              ! r4 = rot_angles[4] (Y rotation angle)
    mov.l   .L_fn_mat_rot_y, r3      ! r3 = mat_rot_y function
    jsr @r3                           ! mat_rot_y(-rot[4]) — apply negated Y rotation
    neg r4, r4                        ! r4 = -rot[4] (delay slot)
    mov.l @(8, r14), r6              ! r6 = pos[8] (Z coordinate)
    mov.l @(4, r14), r5              ! r5 = pos[4] (Y coordinate)
    mov.l @r14, r4                    ! r4 = pos[0] (X coordinate)
    mov.l   .L_fn_mat_vec_mac, r3    ! r3 = mat_vec_multiply_accumulate (sym_06026E2E)
    neg r6, r6                        ! r6 = -pos_z
    neg r5, r5                        ! r5 = -pos_y
    jsr @r3                           ! mat_vec_mac(-pos_x, -pos_y, -pos_z) — translate view
    neg r4, r4                        ! r4 = -pos_x (delay slot)
    mov r15, r6                       ! r6 = SP (ptr to cos0 slot at SP+0)
    mov r15, r5                       ! r5 = SP
    mov.l   .L_fn_sincos_pair, r3    ! r3 = sincos_pair function
    add #0xC, r5                      ! r5 = SP+12 (ptr to sin0 slot)
    jsr @r3                           ! sincos_pair(rot[0], &sin0, &cos0)
    mov.l @r13, r4                    ! r4 = rot_angles[0] (delay slot: angle for sincos)
    mov r15, r6                       ! r6 = SP
    mov r15, r5                       ! r5 = SP
    mov.l   .L_fn_sincos_pair, r3    ! r3 = sincos_pair function
    add #0x8, r6                      ! r6 = SP+8 (ptr to cos1 slot)
    add #0x4, r5                      ! r5 = SP+4 (ptr to sin1 slot)
    jsr @r3                           ! sincos_pair(rot[4], &sin1, &cos1)
    mov.l @(4, r13), r4              ! r4 = rot_angles[4] (delay slot: angle for sincos)
    mov.l   .L_cam_pos_state, r11    ! r11 = &cam_pos_state (sym_06063DF8, XYZ output)
    mov.l   .L_fn_fpmul, r13         ! r13 = fpmul function (reuse r13 register)
    mov.l @(4, r15), r5              ! r5 = sin1 = sin(rot[4]) from SP+4
    jsr @r13                          ! fpmul(cos0, sin1) → r0 = cos0 * sin1
    mov.l @r15, r4                    ! r4 = cos0 = cos(rot[0]) from SP+0 (delay slot)
    mov r0, r5                        ! r5 = cos0 * sin1
    jsr @r13                          ! fpmul(scale, cos0*sin1) → r0 = scale * cos0 * sin1
    mov r12, r4                       ! r4 = scale (delay slot)
    mov.l @r14, r3                    ! r3 = pos[0] (X coordinate)
    add r3, r0                        ! r0 = pos_x + scale * cos0 * sin1
    mov.l r0, @r11                    ! cam_pos[0] = pos_x + scale*cos0*sin1 (X)
    mov.l @(12, r15), r5             ! r5 = sin0 = sin(rot[0]) from SP+12
    jsr @r13                          ! fpmul(scale, sin0) → r0 = scale * sin0
    mov r12, r4                       ! r4 = scale (delay slot)
    mov.l @(4, r14), r3              ! r3 = pos[4] (Y coordinate)
    sub r0, r3                        ! r3 = pos_y - scale * sin0
    mov.l r3, @(4, r11)              ! cam_pos[1] = pos_y - scale*sin0 (Y)
    mov.l @(8, r15), r5              ! r5 = cos1 = cos(rot[4]) from SP+8
    jsr @r13                          ! fpmul(cos0, cos1) → r0 = cos0 * cos1
    mov.l @r15, r4                    ! r4 = cos0 = cos(rot[0]) from SP+0 (delay slot)
    mov r0, r5                        ! r5 = cos0 * cos1
    jsr @r13                          ! fpmul(scale, cos0*cos1) → r0 = scale * cos0 * cos1
    mov r12, r4                       ! r4 = scale (delay slot)
    mov.l @(8, r14), r3              ! r3 = pos[8] (Z coordinate)
    sub r0, r3                        ! r3 = pos_z - scale * cos0 * cos1
    mov.l r3, @(8, r11)              ! cam_pos[2] = pos_z - scale*cos0*cos1 (Z)
    add #0x10, r15                    ! release 16-byte sincos stack frame
    lds.l @r15+, pr                   ! restore return address
    mov.l @r15+, r11                  ! restore r11
    mov.l @r15+, r12                  ! restore r12
    mov.l @r15+, r13                  ! restore r13
    rts                               ! return to caller
    mov.l @r15+, r14                  ! restore r14 (delay slot)
    .2byte  0xFFFF                    ! alignment padding before constant pool
.L_fn_camera_push:
    .4byte  sym_06026E0C              /* camera_push — save/init camera state */
.L_budget_counter:
    .4byte  sym_06089EDC              /* rendering budget counter struct ptr (write [+44] = scale) */
.L_cam_dir_flip:
    .4byte  sym_06078663              /* camera direction flip flag (byte; 0=normal, !0=flip Y) */
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_fp_neg_one:
    .4byte  0xFFFF0000                  /* -1.0 (16.16 fixed-point) */
.L_fn_mat_scale_cols:
    .4byte  mat_scale_columns           /* matrix column scale: mat_scale_columns(x, y, z) */
.L_fn_mat_rot_x:
    .4byte  mat_rot_x            /* general rotation matrix transform */
.L_fn_mat_rot_z:
    .4byte  mat_rot_z                   /* Z-axis rotation matrix */
.L_fn_mat_rot_y:
    .4byte  mat_rot_y                   /* Y-axis rotation matrix */
.L_fn_mat_vec_mac:
    .4byte  sym_06026E2E               /* mat_vec_multiply_accumulate — translate view */
.L_fn_sincos_pair:
    .4byte  sincos_pair                 /* sincos_pair(angle, &sin_out, &cos_out) */
.L_cam_pos_state:
    .4byte  sym_06063DF8               /* camera position/orientation state (XYZ output) */
.L_fn_fpmul:
    .4byte  fpmul                       /* 16.16 fixed-point multiply: fpmul(r4, r5) → r0 */
