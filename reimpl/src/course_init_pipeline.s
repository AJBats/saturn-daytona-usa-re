/* course_init_pipeline -- course selection input handler + resource init
 * Translation unit: 0x0601A940 - 0x0601AAE8
 *
 * Processes D-pad and button input on the course selection screen.
 * Reads gamepad edge-triggered and held button state from the input
 * structure at sym_06063D98, then increments or decrements the course
 * index (byte at sym_0605D24C). Clamps the index to [0, 0x31] and
 * resets it to 0 on any action-button press (bits 7:3 of button word).
 *
 * When Start/A is pressed (bits 10:9 = 0x0600 mask):
 *   1. If the course-active flag (sym_06085FF6) is set, tears down
 *      the current course by calling the two sound RAM upload stubs
 *      (sym_06012EC4 / sym_06012F00) and clears the flag.
 *   2. Based on course index, calls either race_variant_e (index < 0x24)
 *      or race_variant_f (index >= 0x24) to initialize the selected
 *      course variant.
 *   3. Sends two sound commands via sound_cmd_dispatch -- a fixed init
 *      command (0xAE0001FF) and a per-course command looked up from
 *      the table at sym_06049CFC[course_index].
 *
 * Finally (unconditionally every frame), calls the geometry render
 * dispatch function (sym_060283E0) four times to update VDP2 scroll
 * layers -- twice with the fixed layer name (sym_06049CDC) and twice
 * with per-course rendering parameters from sym_0605D35C[course_index].
 *
 * Called from: car_select_setup (tail-call via jmp)
 * Calls: sym_06012EC4, sym_06012F00, race_variant_e, race_variant_f,
 *        sound_cmd_dispatch, sym_060283E0
 *
 * Persistent registers:
 *   r11 = geometry render dispatch (sym_060283E0)
 *   r12 = &input structure (sym_06063D98)
 *   r13 = zero constant (used for clearing bytes)
 *   r14 = &course index byte (sym_0605D24C)
 *
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 */

    .section .text.FUN_0601A940


    .global course_init_pipeline
    .type course_init_pipeline, @function
course_init_pipeline:
    mov.l r14, @-r15                     ! save r14
    mov.l r13, @-r15                     ! save r13
    mov.l r12, @-r15                     ! save r12
    mov.l r11, @-r15                     ! save r11
    sts.l pr, @-r15                      ! save PR
    mov.l   .L_ptr_input_struct, r12     ! r12 -> &input struct (sym_06063D98)
    mov.l   .L_ptr_course_index, r14     ! r14 -> &course_index byte
    mov.l   .L_fp_half, r5              ! r5 = 0x8000 (D-pad right bit mask)
    mov.l   .L_ptr_course_confirm, r4   ! r4 -> &course_confirm byte
    mov.w @(2, r12), r0                  ! r0 = edge-triggered button word
    mov r0, r3                           ! r3 = copy of button word
    extu.w r3, r3                        ! zero-extend to 32-bit
    and r5, r3                           ! isolate bit 15 (D-pad right edge)
    tst r3, r3                           ! D-pad right pressed this frame?
    bt/s    .L_check_dpad_left           ! no -> check D-pad left
    mov #0x0, r13                        ! (delay) r13 = 0 (constant zero)
    mov.b @r14, r3                       ! r3 = course_index
    add #0x1, r3                         ! course_index++
    mov.b r3, @r14                       ! store updated index
    exts.b r13, r2                       ! r2 = 0 (sign-extended)
    bra     .L_clamp_index               ! go clamp the result
    mov.b r2, @r4                        ! (delay) course_confirm = 0
.L_check_dpad_left:                          ! --- check D-pad left edge ---
    mov.w   DAT_0601a9a4, r6            ! r6 = 0x4000 (D-pad left bit mask)
    mov.w @(2, r12), r0                  ! r0 = edge-triggered button word
    mov r0, r2                           ! r2 = copy of button word
    extu.w r2, r2                        ! zero-extend to 32-bit
    and r6, r2                           ! isolate bit 14 (D-pad left edge)
    tst r2, r2                           ! D-pad left pressed this frame?
    bt      .L_check_held_right          ! no -> check held buttons
    mov.b @r14, r3                       ! r3 = course_index
    add #-0x1, r3                        ! course_index--
    mov.b r3, @r14                       ! store updated index
    exts.b r13, r2                       ! r2 = 0
    bra     .L_clamp_index               ! go clamp the result
    mov.b r2, @r4                        ! (delay) course_confirm = 0
.L_check_held_right:                         ! --- check D-pad right held (auto-repeat) ---
    mov.w @r12, r2                       ! r2 = currently-held button word
    extu.w r2, r2                        ! zero-extend to 32-bit
    and r5, r2                           ! isolate bit 15 (D-pad right held)
    tst r2, r2                           ! D-pad right held?
    bt      .L_check_held_left           ! no -> check left held
    mov.b @r4, r0                        ! r0 = course_confirm (repeat counter)
    cmp/eq #0x14, r0                     ! counter == 0x14 (auto-repeat threshold)?
    bf      .L_clamp_index               ! not yet -> skip increment
    mov.b @r14, r2                       ! r2 = course_index
    add #0x1, r2                         ! course_index++ (auto-repeat)
    mov.b r2, @r14                       ! store updated index
    exts.b r13, r3                       ! r3 = 0
    mov.b r3, @r4                        ! course_confirm = 0 (reset repeat counter)
    bra     .L_clamp_index               ! go clamp the result
    nop                                  ! (delay)

    .global DAT_0601a9a4
DAT_0601a9a4:
    .2byte  0x4000
    .2byte  0xFFFF
.L_ptr_input_struct:
    .4byte  sym_06063D98
.L_ptr_course_index:
    .4byte  sym_0605D24C
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_ptr_course_confirm:
    .4byte  sym_0605D243
.L_check_held_left:                          ! --- check D-pad left held (auto-repeat) ---
    mov.w @r12, r2                       ! r2 = currently-held button word
    extu.w r2, r2                        ! zero-extend to 32-bit
    and r6, r2                           ! isolate bit 14 (D-pad left held)
    tst r2, r2                           ! D-pad left held?
    bt      .L_clamp_index               ! no -> go to clamping
    mov.b @r4, r0                        ! r0 = course_confirm (repeat counter)
    cmp/eq #0x14, r0                     ! counter == 0x14 (auto-repeat threshold)?
    bf      .L_clamp_index               ! not yet -> skip decrement
    mov.b @r14, r2                       ! r2 = course_index
    add #-0x1, r2                        ! course_index-- (auto-repeat)
    mov.b r2, @r14                       ! store updated index
    exts.b r13, r3                       ! r3 = 0
    mov.b r3, @r4                        ! course_confirm = 0 (reset repeat counter)
.L_clamp_index:                              ! --- clamp course_index to [0, 0x31] ---
    mov #0x32, r3                        ! r3 = 0x32 (upper bound, exclusive)
    mov.b @r14, r2                       ! r2 = course_index (signed)
    cmp/ge r3, r2                        ! index >= 0x32?
    bf      .L_check_negative            ! no -> check lower bound
    exts.b r13, r3                       ! r3 = 0
    mov.b r3, @r14                       ! course_index = 0 (wrap to start)
.L_check_negative:                           ! --- check lower bound ---
    mov.b @r14, r2                       ! r2 = course_index (signed)
    cmp/pz r2                            ! index >= 0?
    bt      .L_check_action_buttons      ! yes -> continue
    mov #0x31, r2                        ! r2 = 0x31 (max valid index)
    mov.b r2, @r14                       ! course_index = 0x31 (wrap to end)
.L_check_action_buttons:                     ! --- reset index on any action button ---
    mov.w @(2, r12), r0                  ! r0 = edge-triggered button word
    extu.w r0, r0                        ! zero-extend (needed for TST #imm,R0)
    tst #0xF8, r0                        ! any of bits 7:3 set (A/B/C/X/Y/Z)?
    bt      .L_check_start_pressed       ! no -> check Start/A
    exts.b r13, r3                       ! r3 = 0
    mov.b r3, @r14                       ! course_index = 0 (reset on action button)
.L_check_start_pressed:                      ! --- handle Start/A confirm ---
    mov.w @(2, r12), r0                  ! r0 = edge-triggered button word
    mov.w   DAT_0601aa3a, r3            ! r3 = 0x0600 (Start + A button mask)
    mov r0, r2                           ! r2 = copy of button word
    extu.w r2, r2                        ! zero-extend to 32-bit
    and r3, r2                           ! isolate Start/A bits
    tst r2, r2                           ! Start or A pressed?
    bt      .L_update_scroll_layers      ! no -> skip to scroll layer update
    mov.l   .L_ptr_course_active_flag, r0 ! r0 -> &course_active flag
    mov.b @r0, r0                        ! r0 = course_active flag
    extu.b r0, r0                        ! zero-extend
    tst r0, r0                           ! course already active?
    bt      .L_select_variant            ! no -> skip teardown
    mov.l   .L_fn_sound_ram_upload_a, r3 ! r3 -> sound RAM upload stub A
    jsr @r3                              ! call sound_ram_upload_a()
    nop                                  ! (delay)
    mov.l   .L_fn_sound_ram_upload_b, r3 ! r3 -> sound RAM upload stub B
    jsr @r3                              ! call sound_ram_upload_b()
    nop                                  ! (delay)
    extu.b r13, r2                       ! r2 = 0 (unsigned)
    mov.l   .L_ptr_course_active_flag, r3 ! r3 -> &course_active flag
    mov.b r2, @r3                        ! course_active = 0 (cleared)
.L_select_variant:                           ! --- select race variant by index ---
    mov #0x24, r3                        ! r3 = 0x24 (variant threshold)
    mov.l   .L_ptr_variant_init_flag, r11 ! r11 -> &variant_init flag
    mov.b @r14, r2                       ! r2 = course_index
    cmp/ge r3, r2                        ! index >= 0x24?
    bt      .L_index_ge_0x24             ! yes -> use variant F
    mov.b @r11, r3                       ! r3 = variant_init flag
    tst r3, r3                           ! variant already initialized?
    bt      .L_send_sound_cmds           ! yes (flag==0) -> skip init
    mov.l   .L_fn_race_variant_e, r3    ! r3 -> race_variant_e
    jsr @r3                              ! call race_variant_e()
    nop                                  ! (delay)
    exts.b r13, r2                       ! r2 = 0
    bra     .L_send_sound_cmds           ! go send sound commands
    mov.b r2, @r11                       ! (delay) variant_init = 0 (mark done)

    .global DAT_0601aa3a
DAT_0601aa3a:
    .2byte  0x0600
.L_ptr_course_active_flag:
    .4byte  sym_06085FF6
.L_fn_sound_ram_upload_a:
    .4byte  sym_06012EC4
.L_fn_sound_ram_upload_b:
    .4byte  sym_06012F00
.L_ptr_variant_init_flag:
    .4byte  sym_06085FF7
.L_fn_race_variant_e:
    .4byte  race_variant_e
.L_index_ge_0x24:                            ! --- course index >= 0x24: use variant F ---
    mov.b @r11, r0                       ! r0 = variant_init flag
    cmp/eq #0x1, r0                      ! already set to 1 (variant F active)?
    bt      .L_send_sound_cmds           ! yes -> skip init
    mov.l   .L_fn_race_variant_f, r3    ! r3 -> race_variant_f
    jsr @r3                              ! call race_variant_f()
    nop                                  ! (delay)
    mov #0x1, r2                         ! r2 = 1
    mov.b r2, @r11                       ! variant_init = 1 (mark variant F active)
.L_send_sound_cmds:                          ! --- send sound init + per-course commands ---
    mov.l   .L_snd_init_cmd, r5         ! r5 = 0xAE0001FF (sound init command)
    mov.l   .L_fn_sound_cmd_dispatch, r3 ! r3 -> sound_cmd_dispatch
    jsr @r3                              ! call sound_cmd_dispatch(0, 0xAE0001FF)
    mov #0x0, r4                         ! (delay) r4 = 0 (channel)
    mov.b @r14, r5                       ! r5 = course_index
    mov.l   .L_course_snd_cmd_table, r3 ! r3 -> per-course sound command table
    mov.l   .L_fn_sound_cmd_dispatch, r2 ! r2 -> sound_cmd_dispatch
    shll2 r5                             ! r5 = course_index * 4 (table stride)
    add r3, r5                           ! r5 -> table[course_index]
    mov.l @r5, r5                        ! r5 = per-course sound command
    jsr @r2                              ! call sound_cmd_dispatch(0, cmd)
    mov #0x0, r4                         ! (delay) r4 = 0 (channel)
.L_update_scroll_layers:                     ! --- update VDP2 scroll layers (4 calls) ---
    mov.l   .L_fn_geom_render_dispatch, r11 ! r11 -> geom_render_dispatch
    mov #0x0, r6                         ! r6 = 0 (no flags)
    mov.w   DAT_0601aac2, r5            ! r5 = 0x099C (scroll offset A)
    mov.l   .L_scroll_layer_name, r7    ! r7 -> layer name buffer
    jsr @r11                             ! call geom_render_dispatch(0xC, 0x099C, 0, name)
    mov #0xC, r4                         ! (delay) r4 = 0xC (layer count)
    mov.l   .L_scroll_layer_name, r7    ! r7 -> layer name buffer
    mov #0x0, r6                         ! r6 = 0 (no flags)
    mov.w   .L_scroll_offset_b, r5      ! r5 = 0x091C (scroll offset B)
    jsr @r11                             ! call geom_render_dispatch(0xC, 0x091C, 0, name)
    mov #0xC, r4                         ! (delay) r4 = 0xC (layer count)
    mov.b @r14, r7                       ! r7 = course_index
    mov.l   .L_course_render_params, r3 ! r3 -> per-course render param table
    mov.l   .L_mask_0xE000, r6          ! r6 = 0xE000 (priority bits mask)
    mov.w   .L_scroll_offset_b, r5      ! r5 = 0x091C (scroll offset B)
    shll r7                              ! r7 = course_index * 2
    shll2 r7                             ! r7 = course_index * 8 (table stride)
    add r3, r7                           ! r7 -> render_params[course_index]
    mov.l @r7, r7                        ! r7 = render_params[course_index][0]
    jsr @r11                             ! call geom_render_dispatch(0xC, 0x091C, 0xE000, param0)
    mov #0xC, r4                         ! (delay) r4 = 0xC (layer count)
    mov.b @r14, r7                       ! r7 = course_index
    mov.l   .L_course_render_params, r3 ! r3 -> per-course render param table
    mov.l   .L_mask_0xE000, r6          ! r6 = 0xE000 (priority bits mask)
    mov.w   DAT_0601aac2, r5            ! r5 = 0x099C (scroll offset A)
    shll r7                              ! r7 = course_index * 2
    shll2 r7                             ! r7 = course_index * 8 (table stride)
    add r3, r7                           ! r7 -> render_params[course_index]
    mov.l @(4, r7), r7                   ! r7 = render_params[course_index][1]
    jsr @r11                             ! call geom_render_dispatch(0xC, 0x099C, 0xE000, param1)
    mov #0xC, r4                         ! (delay) r4 = 0xC (layer count)
    lds.l @r15+, pr                      ! restore PR
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return
    mov.l @r15+, r14                     ! (delay) restore r14

    .global DAT_0601aac2
DAT_0601aac2:
    .2byte  0x099C
.L_scroll_offset_b:
    .2byte  0x091C
    .2byte  0xFFFF
.L_fn_race_variant_f:
    .4byte  race_variant_f
.L_snd_init_cmd:
    .4byte  0xAE0001FF
.L_fn_sound_cmd_dispatch:
    .4byte  sound_cmd_dispatch
.L_course_snd_cmd_table:
    .4byte  sym_06049CFC
.L_fn_geom_render_dispatch:
    .4byte  sym_060283E0
.L_scroll_layer_name:
    .4byte  sym_06049CDC
.L_course_render_params:
    .4byte  sym_0605D35C
.L_mask_0xE000:
    .4byte  0x0000E000                  /* bits 15:13 mask */
