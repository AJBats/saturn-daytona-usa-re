/* sys_boot_table_init -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B74C - 0x0603B7C0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Initializes the global command/event state table (sym_060A4D14).
 * Stores the entry count in the struct's first field, calls an external
 * setup function, clears six state fields (offsets 0x94..0xC4), then
 * loops over all entries at offset 0x0C3C (stride 0xF0) clearing the
 * status field at +0xEC in each entry.
 *
 * Arguments:
 *   r4 = entry count (stored at state_base[0])
 *
 * Struct layout used:
 *   +0x00  entry count
 *   +0x94  state field A (cleared)
 *   +0xA8  state field B (cleared)
 *   +0xAC  position field A (cleared)
 *   +0xB0  position field B (cleared)
 *   +0xB8  state field C (cleared)
 *   +0xC4  state field D (cleared)
 *   +0x0C3C  start of entry array, each entry 0xF0 bytes
 *     +0xEC within entry = status (cleared)
 */

    .section .text.FUN_0603B74C


    .global sys_boot_table_init
    .type sys_boot_table_init, @function
sys_boot_table_init:
    /* --- prologue: save r14, r13, pr --- */
    mov.l r14, @-r15                ! push r14 (callee-saved)
    mov.l r13, @-r15                ! push r13 (callee-saved)
    sts.l pr, @-r15                 ! push return address
    mov.l   .L_pool_state_ptr, r14  ! r14 = &state_base (sym_060A4D14)
    mov.l @r14, r3                  ! r3 = *state_base (deref to struct)
    mov.l r4, @r3                   ! struct[0x00] = r4 (entry count)
    .byte   0xBF, 0xEC    /* bsr 0x0603B734 (external) */ ! call external setup
    mov #0x0, r13                   ! (delay slot) r13 = 0 (zero constant)
    /* --- clear six state fields in the struct --- */
    mov.l @r14, r2                  ! r2 = struct base
    mov.w   DAT_0603b7a4, r0        ! r0 = 0x0094
    mov.l r13, @(r0, r2)            ! struct[0x94] = 0
    mov.l @r14, r3                  ! r3 = struct base
    add #0x14, r0                   ! r0 = 0xA8
    mov.l r13, @(r0, r3)            ! struct[0xA8] = 0
    mov.l @r14, r3                  ! r3 = struct base
    mov r3, r2                      ! r2 = struct base (copy)
    add #0x8, r0                    ! r0 = 0xB0
    mov.l r13, @(r0, r2)            ! struct[0xB0] = 0
    add #-0x4, r0                   ! r0 = 0xAC
    mov.l r13, @(r0, r3)            ! struct[0xAC] = 0
    mov.l @r14, r3                  ! r3 = struct base
    add #0xC, r0                    ! r0 = 0xB8
    mov.l r13, @(r0, r3)            ! struct[0xB8] = 0
    mov.l @r14, r3                  ! r3 = struct base
    add #0xC, r0                    ! r0 = 0xC4
    mov.l r13, @(r0, r3)            ! struct[0xC4] = 0
    /* --- loop: clear status field in each entry --- */
    mov.l @r14, r5                  ! r5 = struct base
    mov.w   DAT_0603b7a6, r3        ! r3 = 0x0C3C (entry array offset)
    add r3, r5                      ! r5 = &struct[0x0C3C] (first entry)
    bra     .L_loop_test            ! jump to loop condition
    mov r13, r4                     ! (delay slot) r4 = 0 (loop counter)
.L_loop_clear_entry:
    mov.w   DAT_0603b7a8, r0        ! r0 = 0x00EC (status field offset)
    mov.l r13, @(r0, r5)            ! entry[0xEC] = 0 (clear status)
    mov.w   DAT_0603b7aa, r3        ! r3 = 0x00F0 (entry stride)
    add r3, r5                      ! r5 += 0xF0 (advance to next entry)
    add #0x1, r4                    ! r4++ (increment counter)
.L_loop_test:
    mov.l @r14, r2                  ! r2 = struct base
    mov.l @r2, r3                   ! r3 = struct[0x00] (entry count)
    cmp/ge r3, r4                   ! counter >= entry_count?
    bf      .L_loop_clear_entry     ! if not, continue loop
    /* --- epilogue: restore pr, r13, r14 --- */
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    rts                             ! return to caller
    mov.l @r15+, r14                ! (delay slot) restore r14

    /* --- word-size constant pool (PC-relative mov.w targets) --- */
    .global DAT_0603b7a4
DAT_0603b7a4:
    .2byte  0x0094                  ! base field offset (state field A)

    .global DAT_0603b7a6
DAT_0603b7a6:
    .2byte  0x0C3C                  ! entry array start offset

    .global DAT_0603b7a8
DAT_0603b7a8:
    .2byte  0x00EC                  ! status field offset within entry

    .global DAT_0603b7aa
DAT_0603b7aa:
    .2byte  0x00F0                  ! entry stride (bytes per entry)
.L_pool_state_ptr:
    .4byte  sym_060A4D14            ! global command/event state base pointer
    .4byte  sys_boot_sequence       ! boot handler: event command batch processor
    .4byte  mem_test_verify         ! boot handler: memory test verification
    .4byte  sym_060406A6            ! boot handler: subsystem init A
    .4byte  sym_0604069A            ! boot handler: subsystem init B
