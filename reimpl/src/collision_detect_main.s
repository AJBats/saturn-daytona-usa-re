/* collision_detect_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CE66 - 0x0600CEBA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track position and checkpoint update for the current car.
 * Called once per car per frame from the car_frame_update pipeline.
 *
 * Algorithm:
 *   1. Save previous track position: car[+0x01F0] = car[+0x01EC]
 *   2. Test bit 3 of car[byte+3] (finish line proximity flag):
 *        clear → call track_pos_query (checkpoint advance via angle)
 *        set   → call race_heading_calc (heading interpolation)
 *   3. Look up segment table: car[+0x01EC] = seg_table[car[+0x0184] * 4] (16-bit)
 *
 * Inputs:
 *   sym_0607E940 = pointer to current car state struct
 *   sym_0607EB84 = track segment table base (via cross-TU pool)
 *
 * Car struct offsets used:
 *   +0x03   byte  — status flags (bit 3 = finish line proximity)
 *   +0x0184 long  — current segment index
 *   +0x01EC long  — track position (checkpoint parameter)
 *   +0x01F0 long  — previous frame track position
 */

    .section .text.FUN_0600CE66


    .global collision_detect_main
    .type collision_detect_main, @function
collision_detect_main:
    mov.l r14, @-r15                         ! save r14 (will hold car struct ptr)
    sts.l pr, @-r15                          ! save return address
    .byte   0xDE, 0x09    /* mov.l .L_pool_car_state_ptr, r14 */ ! r14 = &car_state_ptr
    mov.w   DAT_0600ce8e, r0                 ! r0 = 0x01EC (track position offset)
    mov.l @r14, r14                          ! r14 = car struct pointer
    mov.l @(r0, r14), r3                     ! r3 = car[+0x01EC] (current track position)
    add #0x4, r0                             ! r0 = 0x01F0 (prev track position offset)
    mov.l r3, @(r0, r14)                     ! car[+0x01F0] = r3 (save previous position)
    mov r14, r0                              ! r0 = car struct base address
    mov.b @(3, r0), r0                       ! r0 = car[byte+3] (status flags)
    tst #0x8, r0                             ! test bit 3 (finish line proximity flag)
    bf      .L_proximity_set                 ! bit 3 set → race heading path
    .byte   0xBF, 0x5F    /* bsr 0x0600CD40 (external) */ ! call track_pos_query (checkpoint advance)
    nop                                      ! delay slot
    bra     .L_update_from_segment           ! skip heading path
    nop                                      ! delay slot

    .global DAT_0600ce86
DAT_0600ce86:
    mov.b r14, @(r0, r1)                     ! (cross-TU data — not executed in this function)

    .global DAT_0600ce88
DAT_0600ce88:
    mov.b r8, @(r0, r1)                      ! (cross-TU data — not executed in this function)

    .global DAT_0600ce8a
DAT_0600ce8a:
    .word 0x01E0 /* UNKNOWN */               ! (cross-TU word pool constant)

    .global DAT_0600ce8c
DAT_0600ce8c:
    shll r0                                  ! (cross-TU data — not executed in this function)

    .global DAT_0600ce8e
DAT_0600ce8e:
    .2byte  0x01EC                           ! word constant: track position offset
.L_pool_car_state_ptr:
    .4byte  sym_0607E940                     ! pointer to current car state struct
    .4byte  sym_0607EA9C                     ! section count (cross-TU, unused in this function)
    .4byte  atan2                            ! atan2 function (cross-TU, unused in this function)
.L_proximity_set:
    .byte   0xBF, 0x98    /* bsr 0x0600CDD0 (external) */ ! call race_heading_calc
    nop                                      ! delay slot
.L_update_from_segment:
    .byte   0x90, 0x4B    /* mov.w .L_wpool_0600CF3A, r0 */ ! r0 = 0x0184 (segment index offset, cross-TU pool)
    .byte   0xD3, 0x28    /* mov.l .L_pool_0600CF44, r3 */  ! r3 = &seg_table_ptr (sym_0607EB84, cross-TU pool)
    mov.l @(r0, r14), r2                     ! r2 = car[+0x0184] (current segment index)
    mov.l @r3, r3                            ! r3 = track segment table base
    shll2 r2                                 ! r2 = segment_index * 4
    add #0x68, r0                            ! r0 = 0x0184 + 0x68 = 0x01EC (track position offset)
    add r3, r2                               ! r2 = &seg_table[segment_index] (byte offset)
    mov.w @r2, r2                            ! r2 = seg_table entry (16-bit heading/param)
    extu.w r2, r2                            ! zero-extend to 32-bit
    mov.l r2, @(r0, r14)                     ! car[+0x01EC] = segment parameter
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return
    mov.l @r15+, r14                         ! restore r14 (delay slot)
