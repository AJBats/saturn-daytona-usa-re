/* input_proc_extended -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06035F04 - 0x06035F44
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Copies 12 bytes of extended peripheral data (SMPC response)
 * into the global input buffer at sym_06063594.
 *
 * input_proc_extended:
 *   Bulk-copies 12 bytes via data_copy_fn (sym_06035168).
 *   r4 = source peripheral data, r2 = dest buffer, r0 = 0xC byte count.
 *
 * input_field_copy (sym_06035F16):
 *   Byte-level field scatter from source (r4) to dest struct (r5).
 *   Copies peripheral ID byte, 4 status bytes at offsets +4..+7,
 *   and a 24-bit masked long at offset +8.
 *   Called from input_proc_buttons via BSR with r5 = input buffer.
 */

    .section .text.FUN_06035F04


    .global input_proc_extended
    .type input_proc_extended, @function
input_proc_extended:
    sts.l pr, @-r15                     ! save return address
    mov r4, r1                          ! r1 = source peripheral data
    mov.l   .L_input_ext_buf, r2        ! r2 = destination: global extended input buffer
    mov.l   .L_fn_data_copy, r3         ! r3 = data copy function (memcpy-like)
    jsr @r3                             ! call data_copy(r0=0xC, r1=src, r2=dst)
    mov #0xC, r0                        ! r0 = 12 bytes to copy (delay slot)
    lds.l @r15+, pr                     ! restore return address
    rts
    nop

    .global sym_06035F16
sym_06035F16:
    mov.b @r4, r3                       ! r3 = peripheral ID byte
    mov.b r3, @r5                       ! dst[0] = peripheral ID
    mov.b @(1, r4), r0                  ! r0 = src[1] (data size / status byte)
    mov r0, r2                          ! r2 = save for caller (button state)
    mov.b r0, @(4, r5)                  ! dst[4] = data size byte
    mov.b @(2, r4), r0                  ! r0 = src[2] (extension byte 1)
    mov.b r0, @(5, r5)                  ! dst[5] = extension byte 1
    mov.b @(3, r4), r0                  ! r0 = src[3] (extension byte 2)
    mov.b r0, @(6, r5)                  ! dst[6] = extension byte 2
    mov.b @(4, r4), r0                  ! r0 = src[4] (extension byte 3)
    mov.b r0, @(7, r5)                  ! dst[7] = extension byte 3
    mov.l @(4, r4), r3                  ! r3 = src long at offset +4 (raw 32-bit value)
    mov.l   .L_mask_low24, r2           ! r2 = 0x00FFFFFF
    and r2, r3                          ! r3 = low 24 bits only (strip peripheral ID)
    rts
    mov.l r3, @(8, r5)                  ! dst[8] = masked 24-bit extension data
    .2byte  0xFFFF
.L_input_ext_buf:
    .4byte  sym_06063594                /* [HIGH] global extended input data buffer (12 bytes, BSS) */
.L_fn_data_copy:
    .4byte  sym_06035168                /* [HIGH] data copy function — memcpy-like (r0=count, r1=src, r2=dst) */
.L_mask_low24:
    .4byte  0x00FFFFFF                  /* [HIGH] low 24-bit mask — strips peripheral ID from extension long */
