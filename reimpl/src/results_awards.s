/* results_awards -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06016750 - 0x060167C8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Processes the next results award for a given car slot.
 * Copies a 16-byte award lookup table from ROM into a stack
 * buffer, then uses the slot's category counter (+0x40) to
 * index into it.  Stores the selected award value at +0x3C,
 * increments the sub-counter (+0x02) and category counter
 * (+0x40).  When all 4 categories are done, resets the
 * sub-counter to 2.
 *
 * Args: r4 = car slot index
 *
 * Calls (external):
 *   memcpy_long           sym_06035168  copy award table to stack
 */

    .section .text.FUN_06016750


    .global results_awards
    .type results_awards, @function
results_awards:
    sts.l pr, @-r15                         ! save return address
    add #-0x10, r15                         ! allocate 16 bytes on stack
    mov r15, r6                             ! r6 = stack buffer ptr (for later indexing)
    mov r15, r1                             ! r1 = dst for memcpy_long
    mov.l   .L_pool_award_table_src, r2     ! r2 = src (award lookup table in ROM)
    mov.l   .L_pool_memcpy_long, r3         ! r3 = memcpy_long
    jsr @r3                                 ! call memcpy_long(r0=16, r1=stack, r2=award_src)
    mov #0x10, r0                           ! r0 = 16 bytes to copy (delay slot)
    mov.l   .L_pool_slot_data_base, r7      ! r7 = slot data array base
    extu.b r4, r5                           ! r5 = slot_index (zero-extend byte)
    mov #0x40, r0                           ! r0 = 0x40 offset for category counter
    mov r5, r3                              ! r3 = slot_index (copy for stride calc)
    shll2 r5                                ! r5 = slot_index * 4
    shll2 r3                                ! r3 = slot_index * 4
    shll2 r3                                ! r3 = slot_index * 16
    shll2 r3                                ! r3 = slot_index * 64
    add r3, r5                              ! r5 = slot_index * 68 (struct stride)
    exts.w r5, r5                           ! sign-extend offset to 32-bit
    add r7, r5                              ! r5 = &slot_data[slot_index]
    mov.b @(r0, r5), r0                     ! r0 = struct[+0x40] (category counter)
    extu.b r0, r0                           ! zero-extend category counter
    shll2 r0                                ! r0 = category * 4 (index into 4-byte entries)
    mov.l @(r0, r6), r3                     ! r3 = award_table[category] from stack buffer
    mov.l r3, @(60, r5)                     ! struct[+0x3C] = selected award value
    mov.b @(2, r5), r0                      ! r0 = struct[+0x02] (sub-counter)
    mov r0, r2                              ! r2 = sub-counter
    add #0x1, r2                            ! r2 = sub-counter + 1
    mov r2, r0                              ! r0 = updated sub-counter
    mov.b r0, @(2, r5)                      ! struct[+0x02] = sub-counter + 1
    mov #0x4, r2                            ! r2 = 4 (max categories)
    mov #0x40, r0                           ! r0 = 0x40 offset for category counter
    mov.b @(r0, r5), r3                     ! r3 = struct[+0x40] (category counter)
    add #0x1, r3                            ! r3 = category + 1
    mov.b r3, @(r0, r5)                     ! struct[+0x40] = category + 1
    mov.b @(r0, r5), r3                     ! re-read struct[+0x40] (sign-clean via store)
    extu.b r3, r3                           ! zero-extend new category counter
    cmp/gt r2, r3                           ! category > 4?
    bf      .L_done                         ! if not, skip reset
    extu.b r4, r4                           ! r4 = slot_index (recompute struct ptr)
    mov r4, r2                              ! r2 = slot_index (copy for stride)
    shll2 r4                                ! r4 = slot_index * 4
    shll2 r2                                ! r2 = slot_index * 4
    shll2 r2                                ! r2 = slot_index * 16
    shll2 r2                                ! r2 = slot_index * 64
    add r2, r4                              ! r4 = slot_index * 68
    exts.w r4, r4                           ! sign-extend offset to 32-bit
    add r7, r4                              ! r4 = &slot_data[slot_index]
    mov #0x2, r3                            ! r3 = 2 (reset value)
    mov r3, r0                              ! r0 = 2
    mov.b r0, @(2, r4)                      ! struct[+0x02] = 2 (reset sub-counter)
.L_done:
    add #0x10, r15                          ! deallocate stack buffer
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return
    nop                                     ! delay slot
.L_pool_award_table_src:
    .4byte  sym_0605BB0C
.L_pool_memcpy_long:
    .4byte  sym_06035168
.L_pool_slot_data_base:
    .4byte  sym_06084FC8
