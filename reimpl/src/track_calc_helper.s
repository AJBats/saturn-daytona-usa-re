/* track_calc_helper -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06018278 - 0x06018320
 * Auto-generated by tools/generate_l3_tu.py
 *
 * track_calc_helper (0x06018278):
 *   Scroll/slot-table commit helper — runs once every 7 sub-steps.
 *
 *   Called from the track geometry pipeline to advance a 7-step sub-frame
 *   counter and, on completion, write the current projection parameter
 *   (sym_06089E3C) into the per-slot data table (sym_06063F64) at the
 *   entry indexed by the slot counter (sym_06069BB6).
 *
 *   Early-exit conditions (both must hold to proceed):
 *     - sym_0605BE1C (scroll_offset_a) != 0   — scroll state is active
 *     - sym_06063D9A (button_state) != 0       — input is active
 *
 *   Per-call (when bit-0 of button_state is set):
 *     sym_0605BE1E (scroll_step) is incremented.
 *     When scroll_step reaches 7:
 *       scroll_step reset to 0
 *       scroll_offset_a set to 1
 *       proj_param (sym_06089E3C) stored into slot_table[slot_idx * 8]
 *       slot_table[slot_idx * 8 + 6] set to 0x0460
 *
 *   When bit-0 of button_state is clear:
 *     scroll_step is reset to 0 (no-progress branch).
 *
 *   Register usage on entry: none (all loaded from pool)
 *   Register usage on exit:  none preserved (r4..r7 clobbered)
 *
 *   Calls: sym_06035280 (shift_left_n: r0 = r0 << r1) — used to
 *          transform the slot index into a byte offset (index * 8).
 *
 *   Pool symbols:
 *     sym_06063D9A  — button_state          (16-bit input bitfield)
 *     sym_0605BE1C  — scroll_offset_a       (16-bit, active-enable flag)
 *     sym_0605BE1E  — scroll_step           (16-bit, 7-step sub-counter)
 *     sym_06048120  — segment_type_table    (byte lookup, 8 entries)
 *     sym_06035280  — shift_left_n          (function: r0 <<= r1)
 *     sym_06063F64  — slot_table            (per-slot records, 8 bytes/entry)
 *     sym_06069BB6  — slot_index            (16-bit counter, indexes slot_table)
 *     sym_06089E3C  — proj_param            (32-bit projection parameter C)
 */

    .section .text.FUN_06018278


    .global track_calc_helper
    .type track_calc_helper, @function
track_calc_helper:
    /* ---- prologue ---- */
    sts.l pr, @-r15                         ! save return address
    mov.l   .L_ptr_button_state, r5         ! r5 = &button_state (sym_06063D9A)
    mov.l   .L_ptr_scroll_offset_a, r7      ! r7 = &scroll_offset_a (sym_0605BE1C)
    mov.w @r5, r5                           ! r5 = button_state (16-bit)
    mov.w @r7, r0                           ! r0 = scroll_offset_a (16-bit)
    extu.w r0, r0                           ! zero-extend scroll_offset_a
    tst r0, r0                              ! scroll_offset_a == 0?
    bf/s    .L_exit                         ! no → proceed (delay: zero-extend button_state)
    extu.w r5, r5                           ! (delay) r5 = button_state zero-extended
    tst r5, r5                              ! button_state == 0?
    bt      .L_exit                         ! yes → nothing to do, return

    /* ---- both conditions met: scroll active + input active ---- */
    mov #0x0, r6                            ! r6 = 0 (reset value for scroll_step)
    mov.l   .L_ptr_scroll_step, r4          ! r4 = &scroll_step (sym_0605BE1E)
    mov.l   .L_ptr_seg_type_table, r3       ! r3 = &segment_type_table (sym_06048120)
    mov.l   .L_fn_shift_left_n, r2         ! r2 = &shift_left_n (sym_06035280)
    mov.w @r4, r1                           ! r1 = scroll_step (16-bit)
    extu.w r1, r1                           ! zero-extend scroll_step
    add r3, r1                              ! r1 = segment_type_table + scroll_step
    mov.b @r1, r1                           ! r1 = segment_type_table[scroll_step] (byte)
    extu.b r1, r1                           ! zero-extend byte lookup result
    jsr @r2                                 ! shift_left_n(r0=lookup_byte, r1=shift_count)
    mov #0x1, r0                            ! (delay) r0 = 1 (mask for bit-0 of button_state)
    and r5, r0                              ! r0 = button_state & 1
    tst r0, r0                              ! bit-0 clear?
    bt      .L_reset_step                   ! yes → reset step, no progress

    /* ---- bit-0 set: increment scroll_step ---- */
    mov.w @r4, r3                           ! r3 = scroll_step (reload)
    add #0x1, r3                            ! r3 = scroll_step + 1
    mov.w r3, @r4                           ! scroll_step = scroll_step + 1
    mov.w @r4, r0                           ! r0 = updated scroll_step
    extu.w r0, r0                           ! zero-extend
    cmp/eq #0x7, r0                         ! scroll_step == 7?
    bf      .L_exit                         ! no → done for this call

    /* ---- scroll_step reached 7: commit projection data to slot table ---- */
    extu.w r6, r6                           ! r6 = 0 (zero-extend, already 0)
    mov #0x1, r2                            ! r2 = 1 (new value for scroll_offset_a)
    mov.w r6, @r4                           ! scroll_step = 0 (reset)
    mov.w r2, @r7                           ! scroll_offset_a = 1 (mark complete)
    mov.l   .L_ptr_slot_table, r5          ! r5 = slot_table base (sym_06063F64)
    mov.l   .L_ptr_slot_index, r4          ! r4 = &slot_index (sym_06069BB6)
    mov.l   .L_ptr_proj_param, r2          ! r2 = &proj_param (sym_06089E3C)
    mov.w @r4, r3                           ! r3 = slot_index (16-bit)
    mov.l @r2, r2                           ! r2 = proj_param value (32-bit)
    extu.w r3, r3                           ! zero-extend slot_index
    shll2 r3                                ! r3 = slot_index * 4
    shll r3                                 ! r3 = slot_index * 8 (stride = 8 bytes/entry)
    add r5, r3                              ! r3 = &slot_table[slot_index]
    mov.l r2, @r3                           ! slot_table[slot_index].ptr = proj_param
    mov.w @r4, r3                           ! r3 = slot_index (reload)
    extu.w r3, r3                           ! zero-extend slot_index
    shll2 r3                                ! r3 = slot_index * 4
    shll r3                                 ! r3 = slot_index * 8
    add r5, r3                              ! r3 = &slot_table[slot_index]
    mov.w   .L_wpool_slot_flag, r2          ! r2 = 0x0460 (slot flag value)
    mov r2, r0                              ! r0 = 0x0460
    mov.w r0, @(6, r3)                      ! slot_table[slot_index].flag_w6 = 0x0460
    bra     .L_exit                         ! → epilogue
    nop

    /* ---- bit-0 clear: reset step counter without progress ---- */
.L_reset_step:
    extu.w r6, r6                           ! r6 = 0 (zero-extend)
    mov.w r6, @r4                           ! scroll_step = 0

    /* ---- epilogue ---- */
.L_exit:
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    nop

    /* ---- data / constant pool ---- */

    .global DAT_060182f2
DAT_060182f2:
    mov.b r3, @(r0, r5)                     ! (raw data — NOT executed code)
.L_wpool_slot_flag:
    .2byte  0x0460                          ! slot flag written to slot_table[n].flag_w6
    .2byte  0xFFFF                          ! padding
    .4byte  sym_0607EBC4                    ! game_state_flags (32-bit bitmask)
    .4byte  0x00800000                      ! bit 23 mask (game_state_flags check)
.L_ptr_button_state:
    .4byte  sym_06063D9A                    ! &button_state (16-bit input bitfield)
.L_ptr_scroll_offset_a:
    .4byte  sym_0605BE1C                    ! &scroll_offset_a (16-bit enable flag)
.L_ptr_scroll_step:
    .4byte  sym_0605BE1E                    ! &scroll_step (16-bit, 0..6 counter)
.L_ptr_seg_type_table:
    .4byte  sym_06048120                    ! &segment_type_table (8-byte lookup)
.L_fn_shift_left_n:
    .4byte  sym_06035280                    ! shift_left_n (r0 = r0 << r1)
.L_ptr_slot_table:
    .4byte  sym_06063F64                    ! slot_table base (8 bytes/entry)
.L_ptr_slot_index:
    .4byte  sym_06069BB6                    ! &slot_index (16-bit, indexes slot_table)
.L_ptr_proj_param:
    .4byte  sym_06089E3C                    ! &proj_param C (32-bit projection parameter)
