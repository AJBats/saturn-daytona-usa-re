/* text_color_set -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06016C6A - 0x06016CDC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * text_color_set:
 *   Sets text color with a countdown timer. Decrements the color
 *   countdown by 6 each call. When it expires (<=0), resets the
 *   color state and tail-calls clear_vdp2_registers with the
 *   original color argument.
 *
 * loc_06016CA4:
 *   Color dispatch — indexes into a 68-byte slot struct array,
 *   reads the handler index at byte offset +2, then jumps to the
 *   corresponding entry in a function pointer table.
 */

    .section .text.FUN_06016C6A


    .global text_color_set
    .type text_color_set, @function
text_color_set:
    mov.l r14, @-r15                        ! save r14
    sts.l pr, @-r15                         ! save return address
    add #-0x4, r15                          ! allocate 4 bytes on stack
    mov.b r4, @r15                          ! store color arg on stack
    .byte   0xDE, 0x0B    /* mov.l .L_pool_color_countdown, r14 */  ! r14 = &color_countdown byte
    .byte   0xB5, 0x5B    /* bsr 0x0601772E (external) */           ! call track_seg_util
    mov.b @r14, r4                          ! (delay) r4 = current countdown value
    mov.b @r14, r2                          ! r2 = current countdown value
    add #-0x6, r2                           ! r2 -= 6 (decrement countdown)
    mov.b r2, @r14                          ! store updated countdown
    mov.b @r14, r3                          ! r3 = updated countdown (sign-extended)
    cmp/pl r3                               ! countdown > 0?
    bt      .L_still_counting               ! if so, skip reset — just return
    .byte   0xB5, 0x53    /* bsr 0x0601772E (external) */           ! call track_seg_util (reset)
    mov #0x0, r4                            ! (delay) r4 = 0 (reset value)
    mov.b @r15, r4                          ! reload original color arg from stack
    extu.b r4, r4                           ! zero-extend to 32-bit
    add #0x4, r15                           ! deallocate stack frame
    lds.l @r15+, pr                         ! restore return address
    .byte   0xA3, 0x28    /* bra 0x060172E4 (external) */           ! tail-call clear_vdp2_registers
    mov.l @r15+, r14                        ! (delay) restore r14
.L_still_counting:
    add #0x4, r15                           ! deallocate stack frame
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return (countdown still active)
    mov.l @r15+, r14                        ! (delay) restore r14
    .4byte  sym_06084FC8                    ! slot data struct array base (unused pool entry)
.L_pool_color_countdown:
    .4byte  sym_06085F88                    ! color countdown byte

    .global loc_06016CA4
loc_06016CA4:
    add #-0x4, r15                          ! allocate 4 bytes on stack
    mov.b r4, @r15                          ! store color index arg
    mov.b @r15, r3                          ! r3 = color index (sign-extended)
    extu.b r3, r3                           ! r3 = color index (zero-extended)
    mov r3, r2                              ! r2 = color index (copy)
    shll2 r3                                ! r3 = index * 4
    shll2 r2                                ! r2 = index * 4
    shll2 r2                                ! r2 = index * 16
    shll2 r2                                ! r2 = index * 64
    add r2, r3                              ! r3 = index * 68 (struct size = 0x44)
    exts.w r3, r3                           ! sign-extend struct offset to 32-bit
    .byte   0xD1, 0x06    /* mov.l .L_pool_slot_array_base, r1 */   ! r1 = slot struct array base
    add r1, r3                              ! r3 = &slot_array[index]
    mov.b @(0x2, r3), r0                    ! r0 = handler index (byte at struct offset +2)
    mov r0, r3                              ! r3 = handler index
    extu.b r3, r3                           ! zero-extend handler index
    shll2 r3                                ! r3 = handler_index * 4 (pointer table offset)
    .byte   0xD2, 0x04    /* mov.l .L_pool_handler_table, r2 */     ! r2 = handler function table base
    add r2, r3                              ! r3 = &handler_table[handler_index]
    mov.l @r3, r3                           ! r3 = handler function address
    mov.b @r15, r4                          ! reload color index arg
    jmp @r3                                 ! jump to handler
    add #0x4, r15                           ! (delay) deallocate stack frame
    .2byte  0xFFFF                          ! padding
.L_pool_slot_array_base:
    .4byte  sym_06084FC8                    ! slot data struct array (68-byte entries)
.L_pool_handler_table:
    .4byte  sym_0605BB6C                    ! handler function pointer table
