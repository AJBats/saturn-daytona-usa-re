/* event_queue_overflow -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040F1C - 0x06040F82
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Event queue overflow handler.
 * Called via fall-through from evt_reg_save (which saves r14/r13
 * and copies r4 -> r14, so r14 = event channel index).
 *
 * Validates channel index is in range [0, 0x18), checks the slot
 * is active (byte == 1), registers an event checkpoint via
 * evt_checkpoint_validate, stores a pending flag (0x8000) into
 * the state structure at offset +0x3C, then polls
 * large_prologue_save in a loop until the queue drains (returns 3)
 * or the checkpoint fires (returns 1).
 *
 * On success, clears the pending flag and slot byte, returns 0.
 * Error codes: -6 = index out of range, -7 = slot not active,
 *              -12 = queue full (large_prologue_save returned 3).
 *
 * Inputs:
 *   r14 -- event channel index (0..23), set by evt_reg_save
 *
 * Outputs:
 *   r0  -- 0 on success, negative error code on failure
 *
 * Uses:
 *   r13        -- pointer to sym_060A5400 (game/AI state base pointer)
 *   sym_060A5400 -- indirect pointer to event state structure
 */

    .section .text.FUN_06040F1C


    .global event_queue_overflow
    .type event_queue_overflow, @function
event_queue_overflow:
    sts.l pr, @-r15                         ! save return address
    mov.l   .L_pool_state_base_ptr, r13     ! r13 = &sym_060A5400 (state base pointer)
    cmp/pz r14                              ! channel index >= 0?
    bf      .L_index_out_of_range           ! no -> return error -6
    mov #0x18, r2                           ! r2 = 24 (max channel count)
    cmp/ge r2, r14                          ! channel index >= 24?
    bf      .L_check_slot_active            ! no -> index is valid, check slot
.L_index_out_of_range:
    bra     .L_return                       ! index out of range
    mov #-0x6, r0                           ! r0 = -6 (ERR_INDEX_OUT_OF_RANGE)
.L_check_slot_active:
    mov.l @r13, r0                          ! r0 = *state_base (event state struct)
    mov.b @(r0, r14), r0                    ! r0 = state[channel_index] (slot status byte)
    cmp/eq #0x1, r0                         ! slot active (== 1)?
    bt      .L_register_checkpoint          ! yes -> proceed to register checkpoint
    bra     .L_return                       ! slot not active
    mov #-0x7, r0                           ! r0 = -7 (ERR_SLOT_NOT_ACTIVE)
    .2byte  0xFFFF                          ! padding / alignment
.L_pool_state_base_ptr:
    .4byte  sym_060A5400                    ! game/AI state base pointer
.L_register_checkpoint:
    .byte   0xD6, 0x19    /* mov.l .L_pool_06040FA8, r6 */  ! r6 = 0x0000FFFF (event mask)
    mov #0x0, r5                            ! r5 = 0 (no flags)
    .byte   0xB1, 0xB5    /* bsr 0x060412B2 (external) */   ! call evt_checkpoint_validate(r4=index, r5=0, r6=mask)
    mov r14, r4                             ! r4 = channel index (delay slot)
    .byte   0xD4, 0x18    /* mov.l .L_pool_06040FAC, r4 */  ! r4 = 0x00008000 (pending flag)
    mov.l @r13, r2                          ! r2 = *state_base
    mov.l r4, @(60, r2)                     ! state[+0x3C] = 0x8000 (set pending flag)
.L_poll_loop:
    .byte   0xB3, 0xA3    /* bsr 0x06041698 (external) */   ! call large_prologue_save()
    nop                                     ! delay slot
    cmp/eq #0x3, r0                         ! returned 3 (queue full)?
    bf/s    .L_check_complete               ! no -> check if checkpoint fired
    mov r0, r4                              ! r4 = return value (delay slot)
    bra     .L_return                       ! queue full -> return error
    mov #-0xC, r0                           ! r0 = -12 (ERR_QUEUE_FULL)
.L_check_complete:
    .byte   0xB1, 0xD8    /* bsr 0x06041310 (external) */   ! call evt_checkpoint_check(r4=index)
    mov r14, r4                             ! r4 = channel index (delay slot)
    cmp/eq #0x1, r0                         ! checkpoint fired (== 1)?
    bf      .L_not_yet_fired                ! no -> keep polling
    bra     .L_clear_and_return             ! yes -> clear state and return success
    nop                                     ! delay slot
.L_not_yet_fired:
    bra     .L_poll_loop                    ! loop back to poll again
    nop                                     ! delay slot
.L_clear_and_return:
    mov #0x0, r4                            ! r4 = 0
    mov r4, r5                              ! r5 = 0
    mov.l @r13, r2                          ! r2 = *state_base
    mov.l r4, @(60, r2)                     ! state[+0x3C] = 0 (clear pending flag)
    mov.l @r13, r0                          ! r0 = *state_base
    mov.b r5, @(r0, r14)                    ! state[channel_index] = 0 (deactivate slot)
    mov r5, r0                              ! r0 = 0 (success)
.L_return:
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return
    mov.l @r15+, r14                        ! restore r14 (delay slot)
