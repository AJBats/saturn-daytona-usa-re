/* geom_vertex_compute -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601EBDA - 0x0601EFC4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Geometry vertex unpack — inverse of geom_batch_transform.
 * Reads byte-by-byte from a packed source buffer (r4) and distributes
 * the data back into the individual geometry arrays: vertex matrix rows,
 * scale tables, model descriptors, coordinate extents, display flags,
 * and transform scratchpad. All fixed-point, no function calls.
 *
 * r4 = source pointer (walks through packed input buffer)
 * r5 = 0x00F0 (batch stride / vertex count per block)
 */

    .section .text.FUN_0601EBDA


    .global geom_vertex_compute
    .type geom_vertex_compute, @function
geom_vertex_compute:
    mov.l r14, @-r15             ! save callee-saved regs
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.w   .L_const_batch_stride, r5 ! r5 = 0x00F0 (batch stride)
    .byte   0xD0, 0x09    /* mov.l .L_ptr_geom_busy_flag, r0 */
    mov.b @r0, r0                ! read busy flag byte
    extu.b r0, r0
    tst r0, r0                   ! flag == 0?
    bt      .L_begin_unpack      ! yes: proceed with unpack
    bra     .L_epilogue          ! no: skip (geometry busy)
    nop
.L_const_batch_stride:
    .2byte  0x00F0               ! 240 = batch stride per row block
    .2byte  0xFFFF               ! (out-of-TU pool refs follow)
    .4byte  sym_0604A5C0
    .4byte  sym_060877D8
    .4byte  sym_0605E098
    .4byte  sym_0604A5AC
    .4byte  sym_0605E09C
.L_ptr_geom_busy_flag:
    .4byte  sym_06087080         ! -> geom busy flag byte
    ! ---- Phase 1: Unpack vertex matrix row data (9 pairs x stride) ----
.L_begin_unpack:
    .byte   0xD4, 0xB5    /* mov.l .L_ptr_input_buf, r4 */
    mov.l @r4, r4                ! dereference: r4 = actual buffer addr
    add #0x10, r4               ! skip 16-byte header
    .byte   0xD6, 0xB5    /* mov.l .L_ptr_vtx_row_table, r6 */
    mov r6, r7                  ! r7 = current table entry ptr
    mov r6, r11
    add #0x48, r11              ! r11 = table end (9 entries * 8 bytes)
.L_row_table_outer:                  ! for each row pair in table
    mov.l @r7, r14              ! r14 = dest data base for this row
    mov r14, r6                 ! r6 = current dest pos
    mov r14, r12
    add r5, r12                 ! r12 = end of this row block (base + stride)
.L_row_table_inner:                  ! unpack 12 bytes (3x4) per vertex entry
    mov r6, r0                  ! r0 = entry base
    mov r6, r14
    mov.b @r4+, r1              ! unpack bytes [0..3] from src -> dest
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    mov.b r2, @r14
    mov r0, r14
    add #0x4, r14               ! advance to bytes [4..7]
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    mov.b r2, @r14
    mov r0, r14
    add #0x8, r14               ! advance to bytes [8..11]
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    add #0xC, r6                ! advance dest by 12
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    cmp/hs r12, r6              ! reached end of row block?
    bf/s    .L_row_table_inner   ! no: next entry
    mov.b r2, @r14              ! (delay slot) write last byte
    add #0x8, r7                ! advance to next table pair
    cmp/hs r11, r7              ! done all 9 pairs?
    bf      .L_row_table_outer   ! no: next row
    ! ---- Phase 2: Unpack model descriptors (6 entries, 8 bytes each) ----
    .byte   0xD6, 0x9B    /* mov.l .L_ptr_model_desc_table, r6 */
    mov r6, r7
    add #0x18, r7               ! r7 = table end (6 ptrs * 4 bytes)
.L_unpack_model_desc:                ! deref each ptr, unpack 8 bytes into it
    mov.l @r6, r0               ! r0 = deref'd ptr -> descriptor data
    mov.b @r4+, r1
    mov r0, r14
    add #0x4, r6                ! advance table ptr
    mov.b r1, @r14              ! unpack bytes [0..3]
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    mov.b r2, @r14
    mov r0, r14
    mov.b @r4+, r1
    add #0x4, r14               ! advance to bytes [4..7]
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    cmp/hs r7, r6               ! done all 6 descriptors?
    bf/s    .L_unpack_model_desc ! no: next descriptor
    mov.b r2, @r14              ! (delay slot) write last byte
    ! ---- Phase 3: Unpack vertex scale table A (8 entries, 8 bytes each) ----
    .byte   0xD6, 0x8C    /* mov.l .L_ptr_vtx_scale_a, r6 */
    mov r6, r7
    add #0x20, r7               ! r7 = end (8 entries * 4 bytes)
.L_unpack_scale_a:                   ! unpack 8 bytes per entry (2x4 byte halves)
    mov r6, r14
    mov.b @r4+, r1
    add #0x4, r6
    mov.b r1, @r14              ! unpack bytes [0..3]
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    mov.b r2, @r14
    mov r6, r14
    mov.b @r4+, r1
    add #0x4, r6                ! advance to next 4-byte half
    mov.b r1, @r14              ! unpack bytes [4..7]
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    cmp/hs r7, r6               ! done all 8 entries?
    bf/s    .L_unpack_scale_a    ! no: next scale entry
    mov.b r2, @r14              ! (delay slot) write last byte
    ! ---- Phase 4: Unpack vertex scale table B (8 entries, 8 bytes each) ----
    .byte   0xD6, 0x7E    /* mov.l .L_ptr_vtx_scale_b, r6 */
    mov r6, r7
    add #0x20, r7               ! r7 = end
.L_unpack_scale_b:                   ! unpack 8 bytes per entry
    mov r6, r14
    mov.b @r4+, r1
    add #0x4, r6
    mov.b r1, @r14              ! unpack bytes [0..3]
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    mov.b r2, @r14
    mov r6, r14
    mov.b @r4+, r1
    add #0x4, r6                ! advance to next 4-byte half
    mov.b r1, @r14              ! unpack bytes [4..7]
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r1
    mov.b r1, @r14
    add #0x1, r14
    mov.b @r4+, r2
    cmp/hs r7, r6               ! done all 8?
    bf/s    .L_unpack_scale_b    ! no: next
    mov.b r2, @r14              ! (delay slot) write last byte
    ! ---- Phase 5: Unpack coordinate extents (3 entries, 12 bytes each) ----
    .byte   0xD6, 0x6F    /* mov.l .L_ptr_coord_extents, r6 */
    mov r6, r7                  ! r7 = current pos
    mov r6, r14
    add #0x24, r14              ! r14 = end (3 * 12 = 36 = 0x24)
.L_unpack_extents:                   ! unpack 12 bytes per extent entry
    mov r7, r6
    mov.b @r4+, r1              ! unpack 12 bytes sequentially
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    add #0xC, r7                ! advance by 12
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    cmp/hs r14, r7              ! done all 3 extents?
    bf/s    .L_unpack_extents    ! no: next extent
    mov.b r2, @r6               ! (delay slot) write last byte
    ! ---- Phase 6: Unpack course data (3 x 4-byte entries) ----
    .byte   0xD6, 0x5B    /* mov.l .L_ptr_course_data_a, r6 */
    mov.b @r4+, r1              ! unpack course param A (4 bytes)
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x56    /* mov.l .L_ptr_course_data_b, r6 */
    mov.b @r4+, r1              ! unpack course param B (4 bytes)
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x51    /* mov.l .L_ptr_course_data_c, r6 */
    mov.b @r4+, r1              ! unpack course param C (4 bytes)
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    ! ---- Phase 7: Unpack single-byte flags (4 bytes total) ----
    mov.b @r4+, r2
    .byte   0xD3, 0x4B    /* mov.l .L_ptr_anim_flag_a, r3 */
    mov.b r2, @r3               ! unpack animation state flag A
    mov.b @r4+, r3
    .byte   0xD2, 0x4B    /* mov.l .L_ptr_anim_flag_b, r2 */
    mov.b r3, @r2               ! unpack animation state flag B
    mov.b @r4+, r2
    .byte   0xD3, 0x4A    /* mov.l .L_ptr_disp_flag_a, r3 */
    mov.b r2, @r3               ! unpack display mode flag A
    mov.b @r4+, r3
    .byte   0xD2, 0x4A    /* mov.l .L_ptr_disp_flag_b, r2 */
    mov.b r3, @r2               ! unpack display mode flag B
    ! ---- Phase 8: Unpack transform scratchpad params (2-byte pairs) ----
    .byte   0xD6, 0x4A    /* mov.l .L_ptr_xform_param_00, r6 */
    mov.b @r4+, r1              ! unpack xform param pair [0x00] (2 bytes)
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x48    /* mov.l .L_ptr_xform_param_02, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x46    /* mov.l .L_ptr_xform_param_04, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x44    /* mov.l .L_ptr_xform_param_06, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x42    /* mov.l .L_ptr_xform_param_08, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x40    /* mov.l .L_ptr_xform_param_0A, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x3E    /* mov.l .L_ptr_xform_param_0C, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x3C    /* mov.l .L_ptr_xform_param_0E, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x3A    /* mov.l .L_ptr_xform_param_10, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x35    /* mov.l .L_ptr_xform_param_14, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x30    /* mov.l .L_ptr_xform_param_18, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x2B    /* mov.l .L_ptr_xform_param_1C, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x29    /* mov.l .L_ptr_xform_param_1E, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x27    /* mov.l .L_ptr_xform_param_20, r6 */
    mov r6, r3
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r3
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x24    /* mov.l .L_ptr_xform_param_22, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x22    /* mov.l .L_ptr_xform_param_24, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x20    /* mov.l .L_ptr_xform_param_26, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    bra     .L_single_field_cont ! jump past pool to continue
    nop
    ! ==== constant pool 1 ====
.L_ptr_input_buf:
    .4byte  sym_0605E098         ! -> geom input buf ptr (deref'd)
.L_ptr_vtx_row_table:
    .4byte  sym_0605DD6C         ! -> vertex matrix row ptr table (9 pairs)
.L_ptr_model_desc_table:
    .4byte  sym_0605DE24         ! -> model descriptor ptr table (6 entries)
.L_ptr_vtx_scale_a:
    .4byte  sym_0605DDB4         ! -> vertex scale table A (8 x 4 bytes)
.L_ptr_vtx_scale_b:
    .4byte  sym_0605DDD4         ! -> vertex scale table B (8 x 4 bytes)
.L_ptr_coord_extents:
    .4byte  sym_0605DE40         ! -> coordinate extent table (3 x 12 bytes)
.L_ptr_course_data_a:
    .4byte  sym_0605AD00         ! -> course data param A (4 bytes)
.L_ptr_course_data_b:
    .4byte  sym_0605AD04         ! -> course data param B (4 bytes)
.L_ptr_course_data_c:
    .4byte  sym_0605AD0C         ! -> course data param C (4 bytes)
.L_ptr_anim_flag_a:
    .4byte  sym_0605AB16         ! -> animation state flag A (1 byte)
.L_ptr_anim_flag_b:
    .4byte  sym_0605AB17         ! -> animation state flag B (1 byte)
.L_ptr_disp_flag_a:
    .4byte  sym_0605D240         ! -> display mode flag A (1 byte)
.L_ptr_disp_flag_b:
    .4byte  sym_0605D241         ! -> display mode flag B (1 byte)
.L_ptr_xform_param_00:              ! transform scratchpad — 2-byte runtime values
    .4byte  sym_06060D44         ! param pair [0x00]
.L_ptr_xform_param_02:
    .4byte  sym_06060D46         ! param pair [0x02]
.L_ptr_xform_param_04:
    .4byte  sym_06060D40         ! param pair [0x04]
.L_ptr_xform_param_06:
    .4byte  sym_06060D42         ! param pair [0x06]
.L_ptr_xform_param_08:
    .4byte  sym_06060D48         ! param pair [0x08]
.L_ptr_xform_param_0A:
    .4byte  sym_06060D4A         ! param pair [0x0A]
.L_ptr_xform_param_0C:
    .4byte  sym_06060D4C         ! param pair [0x0C]
.L_ptr_xform_param_0E:
    .4byte  sym_06060D4E         ! param pair [0x0E]
.L_ptr_xform_param_10:
    .4byte  sym_06060D54         ! param pair [0x10] (4 bytes)
.L_ptr_xform_param_14:
    .4byte  sym_06060D58         ! param pair [0x14] (4 bytes)
.L_ptr_xform_param_18:
    .4byte  sym_06060D50         ! param pair [0x18] (4 bytes)
.L_ptr_xform_param_1C:
    .4byte  sym_06060D60         ! param pair [0x1C]
.L_ptr_xform_param_1E:
    .4byte  sym_06060D62         ! param pair [0x1E]
.L_ptr_xform_param_20:
    .4byte  sym_06060D5C         ! param pair [0x20]
.L_ptr_xform_param_22:
    .4byte  sym_06060D5E         ! param pair [0x22]
.L_ptr_xform_param_24:
    .4byte  sym_06060D64         ! param pair [0x24]
.L_ptr_xform_param_26:
    .4byte  sym_06060D66         ! param pair [0x26]
    ! ---- Phase 9: Unpack remaining transform params (past pool gap) ----
.L_single_field_cont:
    .byte   0xD6, 0x1F    /* mov.l .L_ptr_xform_param_28, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x1D    /* mov.l .L_ptr_xform_param_2A, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x1B    /* mov.l .L_ptr_xform_param_2C, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x16    /* mov.l .L_ptr_xform_param_30, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r2
    mov.b r2, @r6
    .byte   0xD6, 0x11    /* mov.l .L_ptr_xform_param_34, r6 */
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4+, r1
    mov.b r1, @r6
    add #0x1, r6
    mov.b @r4, r3
    mov.b r3, @r6               ! final byte written
.L_epilogue:                         ! restore callee-saved regs and return
    mov.l @r15+, r11
    mov.l @r15+, r12
    rts
    mov.l @r15+, r14             ! (delay slot)
