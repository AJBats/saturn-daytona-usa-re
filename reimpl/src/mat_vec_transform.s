/* mat_vec_transform -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06026FFC - 0x06027124
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Matrix-vector transform functions for Stack A (camera/world transform pipeline).
 *
 * Stack A is the camera/world transform pipeline. It uses:
 *   sym_06089EDC = matrix stack A pointer (current top)
 *   sym_06089EE0 = matrix stack A alternate base
 *   sym_0608A4E0 = vector scratch buffer A0
 *   sym_0608A4F0 = vector scratch buffer A1
 *   sym_0608A520 = vector output buffer A (transform result)
 *
 * Matrix format: 48 bytes per entry (0x30)
 *   [0x00] 3x3 rotation (9 x int32 = 36 bytes, row-major, 16.16 fixed-point)
 *   [0x24] translation vector (3 x int32 = 12 bytes, 16.16 fixed-point)
 *
 * Contains:
 *   mat_vec_transform      - M * vec + T (rotation + translation)
 *   mat_vec_notrans        - M * vec     (rotation only, raw bytes)
 *   sym_06027080           - matrix stack push (duplicate top, advance by 0x30)
 *   mat_stack_pop          - matrix stack pop (rewind by 0x30, raw bytes)
 *   sym_060270C6           - set identity matrix at explicit base address
 *   sym_060270D0           - set identity matrix at current stack top
 *   sym_060270F2           - transform vec3 inplace into translation vector
 */

    .section .text.FUN_06026FFC


/* mat_vec_transform -- Matrix * vector + translation (Stack A)
 *
 * Computes: result = M * vec + T
 * where M is the 3x3 rotation at top of Stack A,
 * T is the translation at offset +0x24, and vec is the input.
 *
 * Input:  r4 = pointer to input vec3 (12 bytes: X, Y, Z)
 *         r5 = pointer to output vec3 (12 bytes)
 * Output: *r5 = M * vec + T (also stored to sym_0608A520 output buffer)
 *
 * Algorithm:
 *   For each output row i (0..2):
 *     clrmac
 *     acc += M[i][0] * vec[0]
 *     acc += M[i][1] * vec[1]
 *     load T[i] from translation vector
 *     acc += M[i][2] * vec[2]
 *     result[i] = (acc >> 16) + T[i]   (xtrct extracts middle 32 bits)
 *   Copy 3 results from output buffer to caller's output pointer
 */
    .global mat_vec_transform
    .type mat_vec_transform, @function
mat_vec_transform:
    mov.l r14, @-r15                       ! save r14 (callee-saved, used as output ptr)
    mov.l   .L_pool_mat_a_stack_ptr, r0    ! r0 = &matrix_stack_a_ptr (sym_06089EDC)
    mov #0x24, r7                          ! r7 = 0x24 (offset to translation vector)
    mov.l @r0, r6                          ! r6 = *mat_stack_a_ptr = matrix base address
    mov.l   .L_pool_output_buf_a, r14      ! r14 = sym_0608A520 (output buffer A)
    add r6, r7                             ! r7 = matrix_base + 0x24 = translation vector ptr
    mov #0x3, r3                           ! r3 = 3 (loop counter: 3 rows)
.L_transform_row_loop:
    clrmac                                 ! clear MAC accumulator for this row
    mac.l @r4+, @r6+                       ! acc += vec[j] * M[i][0]; advance both ptrs
    mac.l @r4+, @r6+                       ! acc += vec[j] * M[i][1]; advance both ptrs
    mov.l @r7+, r2                         ! r2 = T[i] (translation component); advance
    mac.l @r4+, @r6+                       ! acc += vec[j] * M[i][2]; advance both ptrs
    dt r3                                  ! r3--; set T flag if r3 == 0
    add #-0xC, r4                          ! rewind input vec ptr back to start (-12 bytes)
    sts mach, r0                           ! r0 = high 32 bits of MAC result
    sts macl, r1                           ! r1 = low 32 bits of MAC result
    xtrct r0, r1                           ! r1 = (mach<<16)|(macl>>16) = dot product >> 16
    add r2, r1                             ! r1 = (M_row . vec) + T[i]
    mov.l r1, @r14                         ! store result to output buffer A
    bf/s    .L_transform_row_loop          ! loop if rows remain (branch in delay slot)
    add #0x4, r14                          ! advance output ptr by 4 bytes (delay slot)
    add #-0xC, r14                         ! rewind output ptr back to start of results (-12)
    mov.l @r14+, r0                        ! r0 = result[0] (X component)
    mov.l @r14+, r1                        ! r1 = result[1] (Y component)
    mov.l @r14+, r2                        ! r2 = result[2] (Z component)
    mov.l r0, @r5                          ! output->X = result[0]
    mov.l r1, @(4, r5)                     ! output->Y = result[1]
    mov.l r2, @(8, r5)                     ! output->Z = result[2]
    rts                                    ! return
    mov.l @r15+, r14                       ! restore r14 (delay slot)

/* mat_vec_notrans -- Matrix * vector WITHOUT translation (Stack A)
 * Address: 0x06027034
 *
 * Same algorithm as mat_vec_transform but skips the translation
 * addition step. Computes: result = M * vec
 *
 * Encoded as raw .4byte because it shares pool labels with the
 * preceding function and BSR/BRA encoding must be preserved.
 *
 * Input:  r4 = pointer to input vec3
 *         r5 = pointer to output vec3
 * Output: *r5 = M * vec (rotation only, no translation)
 *
 * Instruction sequence (decoded):
 *   mov.l .L_pool_mat_a_stack_ptr, r0     ! r0 = &matrix_stack_a_ptr
 *   mov.l .L_pool_output_buf_a, r6        ! r6 = output buffer A
 *   mov.l @r0, r2                         ! r2 = matrix base address
 *   mov #0x3, r3                          ! r3 = 3 (row counter)
 *   .L_notrans_row_loop:
 *     clrmac                              ! clear accumulator
 *     mac.l @r4+, @r2+                    ! acc += vec[j] * M[i][0]
 *     mac.l @r4+, @r2+                    ! acc += vec[j] * M[i][1]
 *     mac.l @r4+, @r2+                    ! acc += vec[j] * M[i][2]
 *     dt r3                               ! r3--
 *     add #-0xC, r4                       ! rewind input vec ptr
 *     sts mach, r0                        ! high 32 bits
 *     sts macl, r1                        ! low 32 bits
 *     xtrct r0, r1                        ! dot product >> 16
 *     mov.l r1, @r6                       ! store to output buffer
 *     bf/s .L_notrans_row_loop            ! loop if rows remain
 *     add #0x4, r6                        ! advance output ptr (delay slot)
 *   add #-0xC, r6                         ! rewind output ptr
 *   mov.l @r6+, r0                        ! result[0]
 *   mov.l @(4, r6), r1                    ! result[1]
 *   mov.l @(8, r6), r2                    ! result[2]
 *   mov.l r0, @r5                         ! output->X
 *   mov.l r1, @(4, r5)                    ! output->Y
 *   rts                                   ! return
 *   mov.l r2, @(8, r5)                    ! output->Z (delay slot)
 */
    .4byte  0xD00BD60F
    .4byte  0x6202E303
    .4byte  0x0028024F
    .4byte  0x024F024F
    .4byte  0x431074F4
    .4byte  0x000A011A
    .4byte  0x210D2612
    .4byte  0x8FF47604
    .4byte  0x76F46062
    .4byte  0x51615262
    .4byte  0x25021511
    .4byte  0x000B1522
.L_pool_mat_a_stack_ptr:
    .4byte  sym_06089EDC                   /* matrix stack A pointer (current top) */
    .4byte  sym_06089EE0                   /* matrix stack A alternate base */
    .4byte  sym_0608A4E0                   /* vector scratch buffer A0 (12 bytes) */
    .4byte  sym_0608A4F0                   /* vector scratch buffer A1 (12 bytes) */
.L_pool_output_buf_a:
    .4byte  sym_0608A520                   /* vector output buffer A (transform result) */
    .4byte  0x00010000                     /* 1.0 in 16.16 fixed-point */

/* sym_06027080 -- Matrix stack push (Stack A)
 * Address: 0x06027080
 *
 * Duplicates the current 48-byte (0x30) matrix entry at the top of
 * Stack A, then advances the stack pointer by 0x30 so the copy becomes
 * the new top. This preserves the parent transform for later restoration.
 *
 * Input:  none (reads matrix stack A pointer from sym_06089EDC via far pool)
 * Output: stack pointer advanced by 0x30; top entry duplicated
 *
 * Algorithm:
 *   r3 = &mat_stack_a_ptr       (via .L_pool_0602732C in distant TU)
 *   r0 = *r3 = old_top
 *   r1 = old_top + 0x30 = new_top
 *   *r3 = new_top               (advance stack pointer)
 *   copy 12 longwords (48 bytes) from old_top to new_top
 */
    .global sym_06027080
sym_06027080:
    .byte   0xD3, 0xAA    /* mov.l .L_pool_0602732C, r3 -- r3 = &mat_stack_a_ptr */
    mov.l @r3, r0                          ! r0 = old stack top (current matrix base)
    mov #0x30, r1                          ! r1 = 0x30 (matrix entry size in bytes)
    add r0, r1                             ! r1 = old_top + 0x30 = new stack top
    mov.l r1, @r3                          ! store new top back to stack pointer
    mov.l @(0, r0), r2                     ! r2 = src[0] (M[0][0])
    mov.l @(4, r0), r3                     ! r3 = src[1] (M[0][1])
    mov.l r2, @(0, r1)                     ! dst[0] = src[0]
    mov.l r3, @(4, r1)                     ! dst[1] = src[1]
    mov.l @(8, r0), r2                     ! r2 = src[2] (M[0][2])
    mov.l @(12, r0), r3                    ! r3 = src[3] (M[1][0])
    mov.l r2, @(8, r1)                     ! dst[2] = src[2]
    mov.l r3, @(12, r1)                    ! dst[3] = src[3]
    mov.l @(16, r0), r2                    ! r2 = src[4] (M[1][1])
    mov.l @(20, r0), r3                    ! r3 = src[5] (M[1][2])
    mov.l r2, @(16, r1)                    ! dst[4] = src[4]
    mov.l r3, @(20, r1)                    ! dst[5] = src[5]
    mov.l @(24, r0), r2                    ! r2 = src[6] (M[2][0])
    mov.l @(28, r0), r3                    ! r3 = src[7] (M[2][1])
    mov.l r2, @(24, r1)                    ! dst[6] = src[6]
    mov.l r3, @(28, r1)                    ! dst[7] = src[7]
    mov.l @(32, r0), r2                    ! r2 = src[8] (M[2][2])
    mov.l @(36, r0), r3                    ! r3 = src[9] (T[0] = translate X)
    mov.l r2, @(32, r1)                    ! dst[8] = src[8]
    mov.l r3, @(36, r1)                    ! dst[9] = src[9]
    mov.l @(40, r0), r2                    ! r2 = src[10] (T[1] = translate Y)
    mov.l @(44, r0), r3                    ! r3 = src[11] (T[2] = translate Z)
    mov.l r2, @(40, r1)                    ! dst[10] = src[10]
    rts                                    ! return
    mov.l r3, @(44, r1)                    ! dst[11] = src[11] (delay slot)

/* mat_stack_pop -- Matrix stack pop (Stack A)
 * Address: 0x060270B6
 *
 * Rewinds the matrix stack A pointer by 0x30 (one entry), effectively
 * discarding the current top and restoring the previous transform.
 *
 * Encoded as raw bytes because the mov.l references a far pool entry
 * (.L_pool_0602732C in a distant TU).
 *
 * Input:  none
 * Output: stack pointer decremented by 0x30
 *
 * Instruction sequence (decoded):
 *   mov.l .L_pool_0602732C, r1   ! r1 = &mat_stack_a_ptr
 *   mov.l @r1, r0                ! r0 = current stack top
 *   add #-0x30, r0               ! r0 = top - 0x30 (rewind one entry)
 *   rts                          ! return
 *   mov.l r0, @r1                ! *mat_stack_a_ptr = new top (delay slot)
 */
    .4byte  0xD19B6012
    .4byte  0x70D0000B
    .2byte  0x2102

/* sym_060270C6 -- Set identity matrix at explicit base (Stack A)
 * Address: 0x060270C6
 *
 * Resets the matrix stack A pointer to a specified initial base address,
 * then writes a 3x3 identity matrix + zero translation at that location.
 *
 * Uses far pool entries:
 *   .L_pool_06027330 = initial base address for matrix stack A
 *   .L_pool_0602732C = &mat_stack_a_ptr
 *   .L_pool_06027340 = 0x00010000 (1.0 in 16.16 fixed-point)
 *
 * Input:  none
 * Output: mat_stack_a_ptr = initial base; identity matrix written there
 *
 * Algorithm:
 *   r0 = initial_base_addr   (from .L_pool_06027330)
 *   r1 = &mat_stack_a_ptr    (from .L_pool_0602732C)
 *   *r1 = r0                 (reset stack pointer to initial base)
 *   falls through to .L_write_identity to write identity matrix at r0
 */
    .global sym_060270C6
sym_060270C6:
    .byte   0xD0, 0x9A    /* mov.l .L_pool_06027330, r0 -- r0 = initial matrix base address */
    .byte   0xD1, 0x98    /* mov.l .L_pool_0602732C, r1 -- r1 = &mat_stack_a_ptr */
    mov #0x0, r2                           ! r2 = 0 (zero for off-diagonal and translation)
    bra     .L_write_identity              ! jump to identity write routine
    mov.l r0, @r1                          ! *mat_stack_a_ptr = initial base (delay slot)

/* sym_060270D0 -- Set identity matrix at current stack top (Stack A)
 * Address: 0x060270D0
 *
 * Writes a 3x3 identity matrix + zero translation at the current
 * matrix stack A top without changing the stack pointer.
 *
 * Uses far pool entries:
 *   .L_pool_0602732C = &mat_stack_a_ptr
 *   .L_pool_06027340 = 0x00010000 (1.0 in 16.16 fixed-point)
 *
 * Input:  none
 * Output: identity matrix written at current stack top
 *
 * Identity matrix layout (48 bytes):
 *   [ 1.0  0    0   ]   offsets [0x00, 0x04, 0x08]
 *   [ 0    1.0  0   ]   offsets [0x0C, 0x10, 0x14]
 *   [ 0    0    1.0 ]   offsets [0x18, 0x1C, 0x20]
 *   T = [ 0, 0, 0 ]     offsets [0x24, 0x28, 0x2C]
 */
    .global sym_060270D0
sym_060270D0:
    .byte   0xD0, 0x96    /* mov.l .L_pool_0602732C, r0 -- r0 = &mat_stack_a_ptr */
    mov #0x0, r2                           ! r2 = 0 (zero for off-diagonal and translation)
    mov.l @r0, r0                          ! r0 = current stack top (matrix base address)
.L_write_identity:
    .byte   0xD1, 0x9A    /* mov.l .L_pool_06027340, r1 -- r1 = 0x00010000 (1.0 fixed-point) */
    mov.l r2, @(4, r0)                     ! M[0][1] = 0
    mov.l r1, @(0, r0)                     ! M[0][0] = 1.0
    mov.l r2, @(8, r0)                     ! M[0][2] = 0
    mov.l r2, @(12, r0)                    ! M[1][0] = 0
    mov.l r1, @(16, r0)                    ! M[1][1] = 1.0
    mov.l r2, @(20, r0)                    ! M[1][2] = 0
    mov.l r2, @(24, r0)                    ! M[2][0] = 0
    mov.l r2, @(28, r0)                    ! M[2][1] = 0
    mov.l r1, @(32, r0)                    ! M[2][2] = 1.0
    mov.l r2, @(36, r0)                    ! T[0] = 0 (translate X)
    mov.l r2, @(40, r0)                    ! T[1] = 0 (translate Y)
    rts                                    ! return
    mov.l r2, @(44, r0)                    ! T[2] = 0 (translate Z, delay slot)

/* sym_060270F2 -- Transform vec3 inplace into translation vector (Stack A)
 * Address: 0x060270F2
 *
 * Transforms a 3-component vector by the current Stack A matrix's
 * 3x3 rotation and accumulates the result directly into the matrix's
 * translation vector (offset +0x24). This effectively applies a
 * position offset in the rotated coordinate frame.
 *
 * Uses far pool entries:
 *   .L_pool_06027334 = vector scratch buffer (sym_0608A4E0)
 *   .L_pool_0602732C = &mat_stack_a_ptr (sym_06089EDC)
 *
 * Input:  r4 = X component (16.16 fixed-point)
 *         r5 = Y component (16.16 fixed-point)
 *         r6 = Z component (16.16 fixed-point)
 * Output: translation vector at stack top += M * (X, Y, Z)
 *
 * Algorithm:
 *   1. Store (r4, r5, r6) to scratch buffer
 *   2. For each row i (0..2):
 *        dot = M[i][0]*X + M[i][1]*Y + M[i][2]*Z  (via MAC)
 *        T[i] += dot >> 16
 */
    .global sym_060270F2
sym_060270F2:
    .byte   0xD0, 0x90    /* mov.l .L_pool_06027334, r0 -- r0 = scratch buffer (sym_0608A4E0) */
    .byte   0xD1, 0x8D    /* mov.l .L_pool_0602732C, r1 -- r1 = &mat_stack_a_ptr */
    mov.l r4, @(0, r0)                     ! scratch[0] = X (input component)
    mov.l r5, @(4, r0)                     ! scratch[1] = Y (input component)
    mov.l r6, @(8, r0)                     ! scratch[2] = Z (input component)
    mov.l @r1, r4                          ! r4 = current matrix base (stack top)
    mov #0x3, r3                           ! r3 = 3 (row loop counter)
    mov r4, r5                             ! r5 = matrix base (copy for translation ptr)
    add #0x24, r5                          ! r5 = &T[0] (translation vector at offset +0x24)
.L_accum_row_loop:
    clrmac                                 ! clear MAC accumulator for this row
    mac.l @r4+, @r0+                       ! acc += M[i][0] * scratch[0]; advance ptrs
    mac.l @r4+, @r0+                       ! acc += M[i][1] * scratch[1]; advance ptrs
    mac.l @r4+, @r0+                       ! acc += M[i][2] * scratch[2]; advance ptrs
    mov.l @r5, r6                          ! r6 = T[i] (current translation component)
    add #-0xC, r0                          ! rewind scratch ptr back to start (-12 bytes)
    dt r3                                  ! r3--; set T flag if r3 == 0
    sts mach, r1                           ! r1 = high 32 bits of MAC result
    sts macl, r2                           ! r2 = low 32 bits of MAC result
    xtrct r1, r2                           ! r2 = (mach<<16)|(macl>>16) = dot product >> 16
    add r6, r2                             ! r2 = T[i] + (M_row . vec) -- accumulate
    mov.l r2, @r5                          ! T[i] = accumulated result
    bf/s    .L_accum_row_loop              ! loop if rows remain
    add #0x4, r5                           ! advance translation ptr by 4 bytes (delay slot)
    rts                                    ! return
    nop                                    ! (delay slot)
