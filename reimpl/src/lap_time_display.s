/* lap_time_display -- Lap time HUD renderer
 * Translation unit: 0x06013C58 - 0x06013E12
 *
 * Renders the lap time display on the racing HUD. This function:
 *   1. Configures display layers and loads display lists for time digit sprites
 *   2. Renders three digit groups from the car object table:
 *      - Minutes digit (offset 0xF0 in dlist table)
 *      - Seconds tens digit (offset 0x228, with 0x7000 VRAM offset)
 *      - Seconds ones / hundredths (offset 0x230, with 0x7000 VRAM offset)
 *   3. Renders a colon separator (offset 0x238 or 0x588 depending on 2p mode)
 *   4. Converts the race frame counter to a time value via anim_frame_transform,
 *      clamped to max 599,999 frames (~10 minutes at 60fps)
 *   5. Renders the converted time digits
 *   6. If pause/replay flag is set, renders the current lap index as a display
 *      list command, with min/max clamping to 3 laps
 *   7. If pause/replay flag is clear, tail-calls geom_render_dispatch to draw
 *      "FASTEST LAP" text overlay
 *
 * Calling convention:
 *   No explicit arguments — reads global state from car object table,
 *   car data array, frame counter, and 2p/pause flags.
 *
 * Symbols:
 *   sym_06028400 = display_list_loader (r4=mode, r5=dlist_base, r6=index, r7=tex)
 *   sym_06063750 = car_object_table (per-car display list entry array)
 *   sym_06078900 = car_data_base (car data array, stride 0x268)
 *   sym_0602853E = display_layer_config (r4=layer_id)
 *   sym_06028560 = render_state_commit (flush/init display channels)
 *   sym_06085FF4 = two_player_flag (byte, 0=1P, nonzero=2P)
 *   sym_060284AE = display_element_renderer (r4=mode, r5=dlist_base, r6=slot, r7=tex)
 *   sym_060786A4 = frame_counter (32-bit, current race frame)
 *   0x000927BF   = 599,999 (max frame index = ~10 min at 60fps)
 *   sym_06085FF8 = pause_replay_flag (byte)
 *   sym_06086012 = current_lap_index (byte, from replay cam system)
 *   sym_06028430 = display_list_cmd_writer (r4=mode, r5=slot, r6=value, r7=data)
 *   sym_06044A58 = "FASTEST LAP" string (ROM data)
 *   sym_060283E0 = geom_render_dispatch (text/geometry renderer)
 *   anim_frame_transform = converts frame count to displayable time components
 *   display_channel_b = display channel setup/teardown wrapper
 *
 * Auto-generated by tools/generate_l3_tu.py, then manually annotated.
 */

    .section .text.FUN_06013C58


    .global lap_time_display
    .type lap_time_display, @function
lap_time_display:
    mov.l r14, @-r15            ! save r14 (car_object_table ptr)
    mov.l r13, @-r15            ! save r13 (display_list_loader fn)
    mov.l r12, @-r15            ! save r12 (display_layer_config fn / reused)
    mov.l r11, @-r15            ! save r11 (scratch / lap clamp limit)
    sts.l pr, @-r15             ! save return address
    add #-0x8, r15              ! allocate 8 bytes of local stack frame
    mov.l   .L_pool_dlist_loader, r13        ! r13 = &display_list_loader (sym_06028400)
    mov.l   .L_pool_car_obj_table, r14       ! r14 = &car_object_table (sym_06063750)
    mov.l   .L_pool_car_data_base, r3        ! r3 = &car_data_base (sym_06078900)
    mov.l r3, @(4, r15)         ! sp[4] = car_data_base ptr (saved for later)
    mov.l   .L_pool_layer_config, r12        ! r12 = &display_layer_config (sym_0602853E)
    jsr @r12                    ! call display_layer_config(r4=0x4)
    mov #0x4, r4                ! (delay) r4 = 0x4 (layer ID for lap time)
    jsr @r12                    ! call display_layer_config(r4=0xC)
    mov #0xC, r4                ! (delay) r4 = 0xC (layer ID for time separator)
    mov.l   .L_pool_render_commit, r3        ! r3 = &render_state_commit (sym_06028560)
    jsr @r3                     ! call render_state_commit() — flush display state
    nop                         ! delay slot
    mov.w   .L_dat_minutes_offset, r7        ! r7 = 0x00F0 (minutes dlist entry offset in table)
    mov #0x0, r6                ! r6 = 0 (index/slot = 0 for minutes digit)
    add r14, r7                 ! r7 = &car_obj_table[0xF0] (minutes entry base)
    mov.l r7, @r15              ! sp[0] = minutes entry base ptr (temp save)
    mov.l @(4, r7), r7          ! r7 = car_obj_table[0xF0 + 4] (minutes texture param)
    mov.l @r15, r5              ! r5 = minutes entry base ptr
    mov.l @r5, r5               ! r5 = car_obj_table[0xF0 + 0] (minutes dlist base)
    jsr @r13                    ! call display_list_loader(r4=8, r5=dlist, r6=0, r7=tex)
    mov #0x8, r4                ! (delay) r4 = 0x8 (VDP command mode)
    jsr @r12                    ! call display_layer_config(r4=0x4)
    mov #0x4, r4                ! (delay) r4 = 0x4 (reconfigure layer for seconds)
    mov #0x18, r6               ! r6 = 0x18 (slot offset for seconds tens digit)
    mov.w   .L_dat_vram_offset, r12          ! r12 = 0x7000 (VRAM destination offset)
    mov.w   .L_dat_sec_tens_offset, r7       ! r7 = 0x0228 (seconds tens dlist entry offset)
    add r14, r7                 ! r7 = &car_obj_table[0x228] (seconds tens entry base)
    mov.l r7, @r15              ! sp[0] = seconds tens entry base ptr
    mov.l @(4, r7), r7          ! r7 = car_obj_table[0x228 + 4] (seconds tens tex param)
    mov.l @r15, r5              ! r5 = seconds tens entry base ptr
    add r12, r7                 ! r7 += 0x7000 (add VRAM offset to texture param)
    mov.l @r5, r5               ! r5 = car_obj_table[0x228 + 0] (seconds tens dlist base)
    jsr @r13                    ! call display_list_loader(r4=4, r5=dlist, r6=0x18, r7=tex+VRAM)
    mov #0x4, r4                ! (delay) r4 = 0x4 (mode for seconds layer)
    mov.w   .L_dat_sec_ones_offset, r7       ! r7 = 0x0230 (seconds ones dlist entry offset)
    add r14, r7                 ! r7 = &car_obj_table[0x230] (seconds ones entry base)
    mov.l r7, @r15              ! sp[0] = seconds ones entry base ptr
    mov.l @(4, r7), r7          ! r7 = car_obj_table[0x230 + 4] (seconds ones tex param)
    mov.w   .L_wpool_hundredths_slot, r6     ! r6 = 0x0CB0 (hundredths display slot)
    mov.l @r15, r5              ! r5 = seconds ones entry base ptr
    add r12, r7                 ! r7 += 0x7000 (add VRAM offset to texture param)
    mov.l @r5, r5               ! r5 = car_obj_table[0x230 + 0] (seconds ones dlist base)
    jsr @r13                    ! call display_list_loader(r4=4, r5=dlist, r6=0xCB0, r7=tex+VRAM)
    mov #0x4, r4                ! (delay) r4 = 0x4 (mode for hundredths layer)
    mov.l   .L_pool_2p_flag, r0              ! r0 = &two_player_flag (sym_06085FF4)
    mov.b @r0, r0               ! r0 = two_player_flag value (byte)
    tst r0, r0                  ! test if single-player mode
    bf      .L_use_2p_separator              ! if 2P mode: use 2P separator offset
    mov.w   .L_wpool_1p_sep_offset, r7      ! r7 = 0x0238 (1P colon separator dlist offset)
    bra     .L_render_separator              ! continue to render separator
    nop                         ! delay slot

    .global DAT_06013cca
.L_dat_minutes_offset:
DAT_06013cca:
    .2byte  0x00F0                           /* minutes dlist entry offset in car obj table */

    .global DAT_06013ccc
.L_dat_vram_offset:
DAT_06013ccc:
    .2byte  0x7000                           /* VRAM destination offset for digit textures */

    .global DAT_06013cce
.L_dat_sec_tens_offset:
DAT_06013cce:
    .2byte  0x0228                           /* seconds tens dlist entry offset */

    .global DAT_06013cd0
.L_dat_sec_ones_offset:
DAT_06013cd0:
    .2byte  0x0230                           /* seconds ones dlist entry offset */
.L_wpool_hundredths_slot:
    .2byte  0x0CB0                           /* hundredths display slot value */
.L_wpool_1p_sep_offset:
    .2byte  0x0238                           /* 1P colon separator dlist offset */
    .2byte  0xFFFF                           /* alignment padding */
.L_pool_dlist_loader:
    .4byte  sym_06028400                     /* display_list_loader function */
.L_pool_car_obj_table:
    .4byte  sym_06063750                     /* car object table base (display list entries) */
.L_pool_car_data_base:
    .4byte  sym_06078900                     /* car data array base (stride 0x268) */
.L_pool_layer_config:
    .4byte  sym_0602853E                     /* display_layer_config function */
.L_pool_render_commit:
    .4byte  sym_06028560                     /* render_state_commit function */
.L_pool_2p_flag:
    .4byte  sym_06085FF4                     /* two_player_flag (byte, 0=1P) */
.L_use_2p_separator:
    mov.w   .L_dat_2p_sep_offset, r7        ! r7 = 0x0588 (2P colon separator dlist offset)
.L_render_separator:
    add r14, r7                 ! r7 = &car_obj_table[sep_offset] (separator entry base)
    mov.l r7, @r15              ! sp[0] = separator entry base ptr
    mov.l @(4, r7), r7          ! r7 = separator entry tex param
    mov.w   .L_dat_sep_slot, r6             ! r6 = 0x0C84 (separator display slot)
    mov.l @r15, r5              ! r5 = separator entry base ptr
    add r12, r7                 ! r7 += 0x7000 (add VRAM offset to separator tex)
    mov.l @r5, r5               ! r5 = separator dlist base
    jsr @r13                    ! call display_list_loader(r4=4, r5=dlist, r6=0xC84, r7=tex+VRAM)
    mov #0x4, r4                ! (delay) r4 = 0x4 (mode for separator layer)
    mov.l   .L_pool_display_chan_b, r12      ! r12 = &display_channel_b function
    mov #0x0, r6                ! r6 = 0 (channel param)
    mov r6, r5                  ! r5 = 0 (channel param)
    jsr @r12                    ! call display_channel_b(r4=8, r5=0, r6=0)
    mov #0x8, r4                ! (delay) r4 = 0x8 (channel mode)
    mov #0x0, r6                ! r6 = 0
    mov r6, r5                  ! r5 = 0
    jsr @r12                    ! call display_channel_b(r4=0x10, r5=0, r6=0)
    mov #0x10, r4               ! (delay) r4 = 0x10 (another channel)
    mov #0x0, r6                ! r6 = 0
    mov r6, r5                  ! r5 = 0
    jsr @r12                    ! call display_channel_b(r4=0x20, r5=0, r6=0)
    mov #0x20, r4               ! (delay) r4 = 0x20 (another channel)
    mov.l   .L_pool_frame_transform, r12    ! r12 = &anim_frame_transform function
    mov.l @(4, r15), r4         ! r4 = car_data_base (from sp[4])
    mov.w   .L_dat_frame_field_offset, r0   ! r0 = 0x0240 (frame counter field offset in car struct)
    jsr @r12                    ! call anim_frame_transform(r4 = car[frame_field])
    mov.l @(r0, r4), r4         ! (delay) r4 = car_data_base[0x0240] (current frame value)
    mov r0, r7                  ! r7 = transform result (time component A: e.g. minutes)
    mov.w   .L_dat_digit_slot_a, r6          ! r6 = 0x009C (display slot for first digit group)
    mov.w   .L_dat_digit_slot_b, r5          ! r5 = 0x0CC4 (display slot for second digit group)
    mov.l   .L_pool_elem_renderer, r3       ! r3 = &display_element_renderer (sym_060284AE)
    jsr @r3                     ! call display_element_renderer(r4=0xC, r5=0xCC4, r6=0x9C, r7=minutes)
    mov #0xC, r4                ! (delay) r4 = 0xC (mode for time display)
    mov.l   .L_pool_frame_counter, r2       ! r2 = &frame_counter (sym_060786A4)
    mov.l   .L_pool_max_frame, r3           ! r3 = 599,999 (max frame index)
    mov.l @r2, r2               ! r2 = current frame counter value
    cmp/hi r3, r2               ! if (frame_counter > 599,999)
    bf      .L_frame_in_range               ! branch if frame_counter <= max
    mov.l   .L_pool_max_frame, r4           ! r4 = 599,999 (clamp to max)
    bra     .L_convert_time                 ! continue with clamped value
    nop                         ! delay slot
.L_frame_in_range:
    mov.l   .L_pool_frame_counter, r4       ! r4 = &frame_counter
    mov.l @r4, r4               ! r4 = actual frame counter value
.L_convert_time:
    jsr @r12                    ! call anim_frame_transform(r4=frame_count)
    nop                         ! delay slot
    mov r0, r7                  ! r7 = transform result (time component B: seconds)
    mov.w   .L_dat_digit_slot_a, r6          ! r6 = 0x009C (display slot for digit group)
    mov.w   .L_wpool_digit_slot_c, r5       ! r5 = 0x0C98 (display slot for third digit group)
    mov.l   .L_pool_elem_renderer, r3       ! r3 = &display_element_renderer
    jsr @r3                     ! call display_element_renderer(r4=0xC, r5=0xC98, r6=0x9C, r7=seconds)
    mov #0xC, r4                ! (delay) r4 = 0xC (mode for time display)
    mov.l   .L_pool_pause_flag, r0           ! r0 = &pause_replay_flag (sym_06085FF8)
    mov.b @r0, r0               ! r0 = pause_replay_flag value (byte)
    extu.b r0, r0               ! zero-extend byte to word
    tst r0, r0                  ! test if pause/replay mode is active
    bt      .L_show_fastest_lap             ! if not paused: show "FASTEST LAP" text
    mov.l   .L_pool_lap_index, r7           ! r7 = &current_lap_index (sym_06086012)
    mov #0x30, r6               ! r6 = 0x30 (display slot for lap number)
    mov.w   .L_dat_lap_slot, r5             ! r5 = 0x0104 (lap number display slot)
    mov.l   .L_pool_dlist_cmd_writer, r3    ! r3 = &display_list_cmd_writer (sym_06028430)
    mov.b @r7, r7               ! r7 = current_lap_index value (byte)
    extu.b r7, r7               ! zero-extend lap index byte
    add #0x1, r7                ! r7 = lap_index + 1 (1-based lap number for display)
    jsr @r3                     ! call display_list_cmd_writer(r4=0xC, r5=0x104, r6=0x30, r7=lap+1)
    mov #0xC, r4                ! (delay) r4 = 0xC (mode for lap display)
    mov #0x3, r11               ! r11 = 3 (maximum lap count for clamping)
    mov.l   .L_pool_lap_index, r12           ! r12 = &current_lap_index
    mov.b @r12, r12             ! r12 = current_lap_index value
    extu.b r12, r12             ! zero-extend lap index byte
    cmp/ge r11, r12             ! if (lap_index >= 3)
    bt      .L_clamp_to_max_lap             ! branch if at or above max laps
    bra     .L_use_actual_lap               ! else use actual lap index
    mov r12, r7                 ! (delay) r7 = actual lap index
.L_clamp_to_max_lap:
    mov r11, r7                 ! r7 = 3 (clamped to max lap)
.L_use_actual_lap:
    add #0x48, r7               ! r7 += 0x48 (base offset into dlist table for lap entries)
    mov.w   .L_dat_lap_elem_slot, r6         ! r6 = 0x010C (lap element display slot)
    shll2 r7                    ! r7 <<= 2 (multiply by 4)
    shll r7                     ! r7 <<= 1 (multiply by 2, total *= 8 for 8-byte entry stride)
    add r14, r7                 ! r7 = &car_obj_table[lap_entry] (dlist entry for lap)
    cmp/ge r11, r12             ! if (lap_index >= 3) — recheck for second param
    bt/s    .L_clamp_second_param           ! branch with delay to clamp second param
    mov.l @(4, r7), r7          ! (delay) r7 = car_obj_table[lap_entry + 4] (texture param)
    bra     .L_use_actual_second            ! else use actual lap index for second param
    mov r12, r5                 ! (delay) r5 = actual lap index
.L_clamp_second_param:
    mov r11, r5                 ! r5 = 3 (clamped to max lap for second param)
.L_use_actual_second:
    add #0x48, r5               ! r5 += 0x48 (base offset for dlist lookup)
    shll2 r5                    ! r5 <<= 2 (multiply by 4)
    shll r5                     ! r5 <<= 1 (multiply by 2, total *= 8)
    add r14, r5                 ! r5 = &car_obj_table[lap_entry_2] (second dlist entry)
    mov.l @r5, r5               ! r5 = car_obj_table[lap_entry_2 + 0] (dlist base)
    jsr @r13                    ! call display_list_loader(r4=0xC, r5=dlist, r6=0x10C, r7=tex)
    mov #0xC, r4                ! (delay) r4 = 0xC (mode for lap element)
    bra     .L_epilogue                     ! skip "FASTEST LAP" path, go to epilogue
    nop                         ! delay slot
.L_show_fastest_lap:
    mov.l   .L_pool_fastest_lap_str, r7     ! r7 = &"FASTEST LAP" string (sym_06044A58)
    mov.l   .L_pool_nibble3_mask, r6        ! r6 = 0x0000F000 (nibble 3 mask for palette/color)
    mov.w   .L_dat_fastest_lap_slot, r5     ! r5 = 0x0102 (display slot for "FASTEST LAP" text)
    mov #0xC, r4                ! r4 = 0xC (mode for text display)
    add #0x8, r15               ! deallocate local stack frame
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r11            ! restore r11
    mov.l @r15+, r12            ! restore r12
    mov.l @r15+, r13            ! restore r13
    mov.l   .L_pool_geom_dispatch, r3       ! r3 = &geom_render_dispatch (sym_060283E0)
    jmp @r3                     ! tail-call geom_render_dispatch(r4=0xC, r5=0x102, r6=0xF000, r7=str)
    mov.l @r15+, r14            ! (delay) restore r14

    .global DAT_06013dc6
.L_dat_2p_sep_offset:
DAT_06013dc6:
    .2byte  0x0588                           /* 2P colon separator dlist offset in car obj table */

    .global DAT_06013dc8
.L_dat_sep_slot:
DAT_06013dc8:
    .2byte  0x0C84                           /* separator display slot */

    .global DAT_06013dca
.L_dat_frame_field_offset:
DAT_06013dca:
    .2byte  0x0240                           /* car struct offset: current frame field */

    .global DAT_06013dcc
.L_dat_digit_slot_a:
DAT_06013dcc:
    .2byte  0x009C                           /* time digit display slot A */

    .global DAT_06013dce
.L_dat_digit_slot_b:
DAT_06013dce:
    .2byte  0x0CC4                           /* time digit display slot B */
.L_wpool_digit_slot_c:
    .2byte  0x0C98                           /* time digit display slot C */

    .global DAT_06013dd2
.L_dat_lap_slot:
DAT_06013dd2:
    .2byte  0x0104                           /* lap number display slot */

    .global DAT_06013dd4
.L_dat_lap_elem_slot:
DAT_06013dd4:
    .2byte  0x010C                           /* lap element display slot */

    .global DAT_06013dd6
.L_dat_fastest_lap_slot:
DAT_06013dd6:
    .2byte  0x0102                           /* "FASTEST LAP" text display slot */
.L_pool_display_chan_b:
    .4byte  display_channel_b                /* display channel setup wrapper */
.L_pool_frame_transform:
    .4byte  anim_frame_transform             /* frame-to-time conversion function */
.L_pool_elem_renderer:
    .4byte  sym_060284AE                     /* display_element_renderer function */
.L_pool_frame_counter:
    .4byte  sym_060786A4                     /* frame_counter (32-bit race frame) */
.L_pool_max_frame:
    .4byte  0x000927BF                       /* 599,999 = max frame index (~10 min at 60fps) */
.L_pool_pause_flag:
    .4byte  sym_06085FF8                     /* pause_replay_flag (byte) */
.L_pool_lap_index:
    .4byte  sym_06086012                     /* current_lap_index (byte, 0-based) */
.L_pool_dlist_cmd_writer:
    .4byte  sym_06028430                     /* display_list_cmd_writer function */
.L_pool_fastest_lap_str:
    .4byte  sym_06044A58                     /* "FASTEST LAP" string (ROM data) */
.L_pool_nibble3_mask:
    .4byte  0x0000F000                       /* nibble 3 mask (palette/color selector) */
.L_pool_geom_dispatch:
    .4byte  sym_060283E0                     /* geom_render_dispatch (text renderer) */
.L_epilogue:
    add #0x8, r15               ! deallocate local stack frame
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r11            ! restore r11
    mov.l @r15+, r12            ! restore r12
    mov.l @r15+, r13            ! restore r13
    rts                         ! return to caller
    mov.l @r15+, r14            ! (delay) restore r14
