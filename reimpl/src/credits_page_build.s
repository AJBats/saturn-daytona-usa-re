/* credits_page_build -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603F354 - 0x0603F3F6
 * Auto-generated by tools/generate_l3_tu.py
 *
 * credits_page_build(r4=credits_data, r11=entry_count, r12=max_visible,
 *                    r13=start_index, r14=output_buf):
 *   Builds a credits page by iterating through credit entries from a
 *   ring-buffered data stream. For each entry, reads the next record via
 *   vblank_dma_chain (0x0603F582), checks if the entry byte is non-zero
 *   (indicating valid data). When the current index exceeds max_visible,
 *   attempts a memcmp/match via the pool function at 0x0603F430; if no
 *   match, falls through to copy the entry using the external copy routine
 *   (0x0603F84C) and then display_buffer_init. Advances the output buffer
 *   pointer by 0x18 per entry. On exit, marks the last entry with bit 7
 *   set at offset 11 (end-of-page flag) and returns the entry count in r0.
 *
 * ring_desc_init (local subroutine at end of TU):
 *   Initializes a ring buffer descriptor struct for menu_element_render.
 *   Populates source pointer, ring buffer base address + offset, cursor = -1
 *   (triggers refill on first read), zero for reserved field, and copies
 *   the record-count field from the credits data struct.
 *   r4 = descriptor struct, r5 = credits data struct
 */

    .section .text.FUN_0603F354


    .global credits_page_build
    .type credits_page_build, @function
credits_page_build:
    sts.l pr, @-r15                         ! save return address
    add #-0x38, r15                         ! allocate 0x38 (56) bytes of stack frame
    mov.l   .L_pool_buf_init, r10           ! r10 = &display_buffer_init (kept across loop)
    mov.l r4, @r15                          ! save credits_data pointer on stack [sp+0]
    mov r15, r4                             ! r4 = stack frame base (for descriptor)
    bsr     ring_desc_init                  ! init ring buffer descriptor at sp+0x24
    add #0x24, r4                           ! r4 = &stack_descriptor (delay slot)
    bra     .L_loop_test                    ! jump to loop entry test
    mov #0x0, r13                           ! r13 = 0 (current entry index, delay slot)
.L_loop_body:
    mov r15, r5                             ! r5 = stack frame base
    mov r15, r4                             ! r4 = stack frame base
    add #0x4, r5                            ! r5 = &local_buf[0x4] (entry read buffer)
    .byte   0xB1, 0x09    /* bsr 0x0603F582 (external) */ ! call vblank_dma_chain — read next entry record
    add #0x24, r4                           ! r4 = &stack_descriptor (delay slot)
    mov r15, r2                             ! r2 = stack frame base
    add #0x4, r2                            ! r2 = &local_buf[0x4] (entry read buffer)
    mov.b @r2, r3                           ! r3 = first byte of entry record
    extu.b r3, r3                           ! zero-extend to 32 bits
    tst r3, r3                              ! is entry byte zero (end of data)?
    bf      .L_entry_valid                  ! non-zero — entry has data, process it
    bra     .L_loop_done                    ! zero — no more entries, exit loop
    nop                                     ! delay slot
.L_pool_buf_init:
    .4byte  display_buffer_init             ! pool: address of display_buffer_init function
.L_entry_valid:
    cmp/gt r12, r13                         ! current_index > max_visible?
    bf      .L_copy_entry                   ! no — entry is within visible range, copy directly
    mov #0xC, r6                            ! r6 = 0xC (12 bytes — compare length)
    mov r15, r5                             ! r5 = stack frame base
    mov r14, r4                             ! r4 = output buffer pointer
    .byte   0xD3, 0x28    /* mov.l .L_pool_0603F430, r3 */ ! r3 = &memcmp-like function (cross-TU pool)
    add #0x4, r5                            ! r5 = &local_buf[0x4] + 0x10 (entry data offset)
    add #0x10, r5                           ! (continued: r5 = &local_buf[0x14])
    jsr @r3                                 ! call compare function(output_buf-0xC, entry+0x10, 12)
    add #-0xC, r4                           ! r4 = output_buf - 0xC (prev entry, delay slot)
    tst r0, r0                              ! compare result == 0 (match)?
    bf      .L_copy_entry                   ! non-zero — no match, copy the entry
    bra     .L_advance_entry                ! match found — skip this entry (already present)
    nop                                     ! delay slot
.L_copy_entry:
    mov r15, r5                             ! r5 = stack frame base
    add #0x4, r5                            ! r5 = &local_buf[0x4] (entry read buffer)
    .byte   0xB2, 0x52    /* bsr 0x0603F84C (external) */ ! call entry copy routine (cross-TU)
    mov r14, r4                             ! r4 = output buffer pointer (delay slot)
    mov #0xC, r6                            ! r6 = 0xC (12 bytes to copy)
    mov r15, r5                             ! r5 = stack frame base
    mov r14, r4                             ! r4 = output buffer pointer
    add #0x4, r5                            ! r5 = &local_buf[0x4] + 0x10 (name/text data)
    add #0x10, r5                           ! (continued: r5 = &local_buf[0x14])
    jsr @r10                                ! call display_buffer_init(out+0xC, entry+0x10, 12)
    add #0xC, r4                            ! r4 = output_buf + 0xC (text field offset, delay slot)
.L_advance_entry:
    add #0x18, r14                          ! advance output buffer by 0x18 (24 bytes per entry)
    add #0x1, r13                           ! r13++ (increment entry index)
    add #-0x1, r11                          ! r11-- (decrement remaining entry count)
.L_loop_test:
    cmp/pl r11                              ! r11 > 0 (more entries to process)?
    bt      .L_loop_body                    ! yes — process next entry
.L_loop_done:
    add #-0x18, r14                         ! step back to last written entry
    mov.b @(11, r14), r0                    ! r0 = entry flags byte at offset 11
    or #0x80, r0                            ! set bit 7 (end-of-page marker)
    mov.b r0, @(11, r14)                    ! write back flags with end-of-page bit set
    mov r13, r0                             ! r0 = entry count (return value)
    add #0x38, r15                          ! deallocate stack frame
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return (r0 = number of entries processed)
    mov.l @r15+, r14                        ! restore r14 (delay slot)

/* ring_desc_init -- local subroutine
 *   Initializes a ring buffer descriptor struct used by menu_element_render.
 *   r4 = descriptor struct to fill (6 fields at offsets 0..16)
 *   r5 = credits data source struct:
 *     @(0, r5)  = source data pointer
 *     @(16, r5) = entry record count
 *   Descriptor layout after init:
 *     @(0, r4)  = r5 (credits data struct pointer)
 *     @(4, r4)  = ring buffer base address (game_state_base + offset)
 *     @(8, r4)  = -1 (cursor = invalid, forces refill on first read)
 *     @(12, r4) = 0 (reserved / unused)
 *     @(16, r4) = entry record count (copied from credits data)
 */
ring_desc_init:
    mov.l r5, @r4                           ! desc->data_ptr = credits data struct pointer
    .byte   0xD3, 0x15    /* mov.l .L_pool_0603F434, r3 */ ! r3 = &game_state_base (cross-TU pool)
    .byte   0x92, 0x24    /* mov.w .L_wpool_0603F42A, r2 */ ! r2 = ring buffer offset constant
    mov.l @r3, r3                           ! r3 = game_state_base (dereference pointer)
    add r3, r2                              ! r2 = game_state_base + offset (ring buffer addr)
    mov.l r2, @(4, r4)                      ! desc->ring_buf_base = computed ring buffer addr
    mov #-0x1, r3                           ! r3 = -1 (invalid cursor — forces refill)
    mov.l r3, @(8, r4)                      ! desc->cursor = -1
    mov.l @r5, r2                           ! r2 = credits_data->source_ptr
    mov.l @(16, r2), r3                     ! r3 = source->record_count (entry count field)
    mov #0x0, r2                            ! r2 = 0 (reserved field)
    mov.l r3, @(16, r4)                     ! desc->record_count = entry count
    rts                                     ! return to caller
    mov.l r2, @(12, r4)                     ! desc->reserved = 0 (delay slot)
