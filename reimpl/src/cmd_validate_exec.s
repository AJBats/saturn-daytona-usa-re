/* cmd_validate_exec -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603AC1C - 0x0603ACEA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Validates command parameters and dispatches command execution.
 *
 * Args:
 *   r4 = command ID (must be 1..24)
 *   r5 = command buffer address (must be 4-byte aligned)
 *   r6 = params struct pointer (NULL = no params)
 *
 * Params struct layout (when non-NULL):
 *   +0x00: mode field  (must be 0 or 1)
 *   +0x04: count field  (must be >= 2)
 *   +0x08: flag field   (must be 0)
 *
 * Validates inputs, stores buffer in global command state (sym_060A4D14),
 * initializes the boot table via sys_boot_table_init, checks error state
 * via error_code_stub, verifies a status bit in the buffer, then
 * dispatches to either hud_toggle_ctrl (no params) or save_size_calc
 * (with params) for the actual operation. Finalizes via cmd_dispatch_helper
 * and save_checksum_calc.
 *
 * Returns: result code in r0 (0 = success, negative = error)
 *   -0x01 = save_size_calc failed (params path)
 *   -0x02 = status bit not set in buffer
 *   -0x04 = invalid params struct
 *   -0x05 = command ID out of range
 *   -0x07 = hud_toggle_ctrl failed (no-params path)
 *   -0x15 = buffer address not 4-byte aligned
 */

    .section .text.FUN_0603AC1C


    .global cmd_validate_exec
    .type cmd_validate_exec, @function
cmd_validate_exec:
    mov.l r14, @-r15                ! save r14 on stack
    mov #0x1, r3                    ! r3 = 1 (minimum command ID)
    mov.l r13, @-r15                ! save r13 on stack
    sts.l pr, @-r15                 ! save return address on stack
    cmp/ge r3, r4                   ! T = (cmd_id >= 1)?
    bf/s    .L_cmd_id_out_of_range  ! if cmd_id < 1, branch to error
    mov r6, r14                     ! r14 = params struct pointer (delay slot)
    mov #0x18, r3                   ! r3 = 24 (maximum command ID)
    cmp/gt r3, r4                   ! T = (cmd_id > 24)?
    bf      .L_validate_alignment   ! if cmd_id <= 24, proceed to alignment check
.L_cmd_id_out_of_range:
    bra     .L_return               ! jump to function epilogue
    mov #-0x5, r0                   ! return -5: command ID out of range (delay slot)
.L_validate_alignment:
    mov #0x3, r3                    ! r3 = 0x3 (alignment mask)
    and r5, r3                      ! r3 = buffer_addr & 0x3
    tst r3, r3                      ! T = (lower 2 bits == 0)?
    bt      .L_check_params         ! if 4-byte aligned, proceed
    bra     .L_return               ! jump to function epilogue
    mov #-0x15, r0                  ! return -0x15: buffer not 4-byte aligned (delay slot)
.L_check_params:
    tst r14, r14                    ! T = (params == NULL)?
    bt      .L_store_buffer         ! if no params, skip validation
    mov.l @r14, r6                  ! r6 = params->mode
    tst r6, r6                      ! T = (mode == 0)?
    bt      .L_check_count          ! if mode == 0, check count
    mov r6, r0                      ! r0 = mode
    cmp/eq #0x1, r0                 ! T = (mode == 1)?
    bf      .L_invalid_params       ! if mode != 0 and != 1, invalid
.L_check_count:
    mov.l @(4, r14), r2             ! r2 = params->count
    mov #0x2, r3                    ! r3 = 2 (minimum count)
    cmp/ge r3, r2                   ! T = (count >= 2)?
    bf      .L_invalid_params       ! if count < 2, invalid
    mov.l @(8, r14), r0             ! r0 = params->flag
    tst r0, r0                      ! T = (flag == 0)?
    bf      .L_store_buffer         ! if flag != 0, skip to store (proceed)
.L_invalid_params:
    bra     .L_return               ! jump to function epilogue
    mov #-0x4, r0                   ! return -4: invalid params struct (delay slot)
.L_store_buffer:
    mov.l   .L_pool_cmd_state_ptr, r3 ! r3 = &sym_060A4D14 (global command state ptr)
    mov.l r5, @r3                   ! store buffer address in global command state
    .byte   0xB5, 0x71    /* bsr 0x0603B74C (external) */  ! call sys_boot_table_init(r4=cmd_id)
    nop                             ! delay slot
    tst r14, r14                    ! T = (params == NULL)?
    bf      .L_has_params           ! if params != NULL, branch
    bra     .L_call_error_check     ! jump to error check
    mov #0x1, r4                    ! r4 = 1 (no-params flag) (delay slot)
.L_has_params:
    mov #0x0, r4                    ! r4 = 0 (has-params flag)
.L_call_error_check:
    mov.l   .L_pool_error_code_stub, r3 ! r3 = &error_code_stub
    jsr @r3                         ! call error_code_stub(r4=flag)
    nop                             ! delay slot
    mov r0, r4                      ! r4 = error_code_stub result
    tst r4, r4                      ! T = (result == 0)?
    bt      .L_check_status_bit     ! if no error, check status bit
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    .byte   0xA6, 0x5A    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=error)
    mov.l @r15+, r14                ! restore r14 (delay slot)
.L_check_status_bit:
    mov.l   .L_pool_cmd_state_ptr, r0 ! r0 = &sym_060A4D14
    mov.w   DAT_0603ac9e, r1        ! r1 = 0x00C4 (status field offset)
    mov.l @r0, r0                   ! r0 = command state base address
    mov.l @(r0, r1), r0             ! r0 = state[0xC4] (status flags)
    tst #0x1, r0                    ! T = (bit 0 clear)?
    bf      .L_dispatch_command     ! if bit 0 set, proceed to dispatch
    mov #-0x2, r4                   ! r4 = -2 (status bit not set)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    .byte   0xA6, 0x4F    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-2)
    mov.l @r15+, r14                ! restore r14 (delay slot)

    .global DAT_0603ac9e
DAT_0603ac9e:
    .2byte  0x00C4
.L_pool_cmd_state_ptr:
    .4byte  sym_060A4D14
.L_pool_error_code_stub:
    .4byte  error_code_stub
.L_dispatch_command:
    tst r14, r14                    ! T = (params == NULL)?
    bf      .L_dispatch_with_params ! if params != NULL, use params path
    .byte   0xD3, 0x20    /* mov.l .L_pool_0603AD30, r3 */ ! r3 = &hud_toggle_ctrl (cross-TU pool)
    jsr @r3                         ! call hud_toggle_ctrl()
    nop                             ! delay slot
    mov r0, r13                     ! r13 = result from hud_toggle_ctrl
    cmp/pz r13                      ! T = (result >= 0)?
    bt      .L_finalize             ! if non-negative, proceed to finalize
    mov #-0x7, r4                   ! r4 = -7 (hud_toggle_ctrl failed)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    .byte   0xA6, 0x3D    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-7)
    mov.l @r15+, r14                ! restore r14 (delay slot)
.L_dispatch_with_params:
    .byte   0xD3, 0x1C    /* mov.l .L_pool_0603AD34, r3 */ ! r3 = &save_size_calc (cross-TU pool)
    jsr @r3                         ! call save_size_calc(r4=params)
    mov r14, r4                     ! r4 = params struct pointer (delay slot)
    mov r0, r13                     ! r13 = result from save_size_calc
    cmp/pl r13                      ! T = (result > 0)?
    bt      .L_finalize             ! if positive, proceed to finalize
    mov #-0x1, r4                   ! r4 = -1 (save_size_calc failed)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    .byte   0xA6, 0x32    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-1)
    mov.l @r15+, r14                ! restore r14 (delay slot)
.L_finalize:
    .byte   0xB0, 0x68    /* bsr 0x0603ADAC (external) */  ! call cmd_dispatch_helper(r4=params)
    mov r14, r4                     ! r4 = params struct pointer (delay slot)
    .byte   0xB6, 0x2E    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0)
    mov #0x0, r4                    ! r4 = 0 (success cleanup) (delay slot)
    mov r13, r0                     ! r0 = operation result (return value)
.L_return:
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    rts                             ! return to caller
    mov.l @r15+, r14                ! restore r14 (delay slot)
