/* event_callback_dispatch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040B90 - 0x06040C10
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Dispatch an event callback after validation.
 *
 * Continuation of event_timer_sched (falls through after event command
 * validation). Calls evt_field_extract to extract timing fields from
 * the event data, optionally adjusts a counter by elapsed time when
 * total consumed size meets the capacity threshold, then allocates an
 * event record and fills it with the callback, remaining time, enqueued
 * size, and an active flag.
 *
 * Entry state (from caller's stack frame, 0x18 bytes of locals):
 *   r13 = event struct pointer
 *     +0x00  event data pointer
 *     +0x08  base position / consumed size
 *     +0x10  span / additional size
 *   r14 = callback parameter (0 from event_timer_sched)
 *   sp+0x00 = enqueued size (from cmd_enqueue)
 *   sp+0x04 = remaining time slot (written by evt_field_extract)
 *   sp+0x08 = duration (written by evt_field_extract)
 *   sp+0x0C = capacity (written by evt_field_extract)
 *   sp+0x10 = size_limit (saved from caller)
 *
 * Returns:
 *   r0 = event record base pointer (sym_0606367C)
 *
 * Calls: sym_06040220 (evt_field_extract), sym_06035C48 (evt_record_alloc)
 *
 * Event record layout at sym_0606367C:
 *   +0x00 = allocated sub-record pointer (from evt_record_alloc)
 *   +0x04 = callback parameter (r14)
 *   +0x08 = remaining time
 *   +0x0C = enqueued size
 *   +0x10 = active flag (byte, 1 = active)
 */

    .section .text.FUN_06040B90


    .global event_callback_dispatch
    .type event_callback_dispatch, @function
/* ---------------------------------------------------------------
 * event_callback_dispatch
 *   Extract timing fields, adjust counter, allocate event record.
 * --------------------------------------------------------------- */
event_callback_dispatch:
    mov.l r14, @-r15                  ! save r14 (callee-saved)
    mov r15, r2                       ! r2 = sp (for capacity output ptr)
    add #0x10, r2                     ! r2 = sp+0x10 (capacity output slot)
    mov.l r2, @-r15                   ! push capacity output ptr
    mov r15, r3                       ! r3 = sp (for remaining time output ptr)
    add #0x1C, r3                     ! r3 = sp+0x1C (remaining time output slot)
    mov.l r3, @-r15                   ! push remaining time output ptr
    mov r15, r7                       ! r7 = sp (base for duration output ptr)
    mov.l   .L_pool_evt_field_extract, r3 ! r3 = &evt_field_extract (sym_06040220)
    add #0x1C, r7                     ! r7 = sp+0x1C (duration output slot)
    jsr @r3                           ! call evt_field_extract(event_data, ...)
    mov.l @r13, r4                    ! r4 = event_struct[+0x00] = event data ptr (delay slot)
    add #0x10, r15                    ! pop field extract stack args (4 words)
    mov r13, r4                       ! r4 = event struct pointer
    mov.l @(16, r15), r3              ! r3 = locals[16] = capacity (field extract output)
    mov.l @(8, r4), r5                ! r5 = event_struct[+0x08] = base consumed size
    mov.l @(16, r4), r2               ! r2 = event_struct[+0x10] = span
    add r2, r5                        ! r5 = base + span
    mov.l @r15, r2                    ! r2 = locals[0] = enqueued size
    add r2, r5                        ! r5 = base + span + enqueued = total consumed
    cmp/ge r3, r5                     ! is total_consumed >= capacity?
    bf      .L_fill_record            ! if not, skip counter adjustment
    mov.l @(8, r15), r0               ! r0 = locals[8] = remaining time
    tst r0, r0                        ! is remaining time zero?
    bt      .L_fill_record            ! if zero, skip adjustment
    mov.l @r15, r3                    ! r3 = locals[0] = enqueued size
    cmp/pl r3                         ! is enqueued size > 0?
    bf      .L_fill_record            ! if not positive, skip adjustment
    mov.l @(12, r15), r2              ! r2 = locals[12] = duration
    mov.l @(8, r15), r3               ! r3 = locals[8] = remaining time
    sub r3, r2                        ! r2 = duration - remaining = elapsed time
    mov.l @(4, r15), r1               ! r1 = locals[4] = counter value
    sub r2, r1                        ! r1 = counter - elapsed (adjust downward)
    mov.l r1, @(4, r15)               ! locals[4] = adjusted counter
.L_fill_record:
    mov.l   .L_pool_evt_record_base, r13 ! r13 = &event record struct (sym_0606367C)
    mov.l   .L_pool_evt_record_alloc, r3 ! r3 = &evt_record_alloc (sym_06035C48)
    jsr @r3                           ! call evt_record_alloc() â†’ r0 = sub-record ptr
    nop                               ! delay slot
    mov.l r0, @r13                    ! record[+0x00] = sub-record ptr
    mov.l r14, @(4, r13)              ! record[+0x04] = callback parameter
    mov.l @(4, r15), r2               ! r2 = locals[4] = remaining time (or adjusted counter)
    mov.l r2, @(8, r13)               ! record[+0x08] = remaining time
    mov.l @r15, r3                    ! r3 = locals[0] = enqueued size
    mov.l r3, @(12, r13)              ! record[+0x0C] = enqueued size
    mov r13, r3                       ! r3 = event record base ptr
    mov #0x1, r2                      ! r2 = 0x1 (active flag)
    mov #0x10, r0                     ! r0 = 0x10 (offset to active flag byte)
    mov.b r2, @(r0, r3)              ! record[+0x10] = 1 (mark event active)
    mov r3, r0                        ! r0 = event record base ptr (return value)
    add #0x18, r15                    ! deallocate 24 bytes of locals
    lds.l @r15+, pr                   ! restore return address
    mov.l @r15+, r13                  ! restore r13
    rts                               ! return to caller
    mov.l @r15+, r14                  ! restore r14 (delay slot)
    .4byte  cmd_enqueue
    .4byte  state_field_read
.L_pool_evt_field_extract:
    .4byte  sym_06040220
.L_pool_evt_record_base:
    .4byte  sym_0606367C
.L_pool_evt_record_alloc:
    .4byte  sym_06035C48
