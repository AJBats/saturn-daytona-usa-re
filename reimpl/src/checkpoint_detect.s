/* checkpoint_detect -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600D780 - 0x0600D8A4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Checkpoint crossing detection -- monitors track position changes to detect
 * when a car crosses section boundaries (lap segments). Handles both forward
 * and backward crossings with different thresholds.
 *
 * Main function: checkpoint_detect(r4 = update_flag)
 *   Computes delta = car[+0x1EC] - car[+0x1F0] (track positions)
 *   Three cases:
 *     |delta| <= 1: Small movement -> incremental position validation
 *     delta > 1:    Forward jump -> decrement counter, check section midpoint
 *     delta < -1:   Backward jump -> increment counter, check section boundary
 *   On boundary crossing: resets validated position, updates section store,
 *   calls external handlers, writes crossing direction (0=backward, 1=forward).
 *
 * Sub-function: position_validate (0x0600D84C)
 *   Validates car position against last validated position.
 *   If delta in (0, 16): normal forward movement -> update validated pos.
 *   If at section midpoint or midpoint+2: update and store crossing counter.
 *
 * Car struct offsets used:
 *   +0x1E8 = validated track position
 *   +0x1EC = current track position
 *   +0x1F0 = reference track position (previous/checkpoint base)
 *   +0x228 = crossing counter
 */

    .section .text.FUN_0600D780


    .global checkpoint_detect
    .type checkpoint_detect, @function

/* checkpoint_detect -- Detects when a car crosses a section boundary.
 *   r4 = update_flag (nonzero suppresses boundary crossing logic)
 * Computes movement delta between current and reference track positions.
 * For large forward/backward jumps, checks section midpoint/boundary
 * and triggers crossing handlers. For small movement, delegates to
 * position_validate for incremental validation.
 */
checkpoint_detect:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov r4, r14                         ! r14 = update_flag parameter
    mov.l r13, @-r15                    ! save r13 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_car_struct_ptr, r4       ! r4 = &car_struct_ptr
    mov.w   DAT_0600d82a, r0            ! r0 = 0x01EC (current track position offset)
    mov.l @r4, r4                       ! r4 = car struct base address
    mov.l @(r0, r4), r5                 ! r5 = car[+0x1EC] (current track position)
    add #0x4, r0                        ! r0 = 0x01F0 (reference position offset)
    mov.l @(r0, r4), r3                 ! r3 = car[+0x1F0] (reference track position)
    sub r3, r5                          ! r5 = delta = current - reference
    tst r5, r5                          ! test if delta == 0
    bt      .L_epilogue                 ! delta == 0 -> no movement, exit
    mov.l   .L_section_store, r7        ! r7 = &section_store (written on crossing)
    mov #-0x1, r3                       ! r3 = -1 (lower bound for small movement)
    mov.l   .L_section_count, r6        ! r6 = &section_count for current track
    cmp/ge r3, r5                       ! T = (delta >= -1)?
    bt/s    .L_small_or_forward         ! delta >= -1 -> small or forward movement
    mov #0x0, r13                       ! r13 = 0 (delay slot: direction = backward)
    ! --- backward jump path: delta < -1 ---
    mov.w   .L_off_crossing_counter, r0 ! r0 = 0x0228 (crossing counter offset)
    mov.l @(r0, r4), r3                 ! r3 = car[+0x228] (crossing counter)
    add #0x1, r3                        ! increment counter (backward crossing)
    mov.l r3, @(r0, r4)                 ! store updated crossing counter
    add #-0x40, r0                      ! r0 = 0x0228 - 0x40 = 0x01E8 (validated pos offset)
    mov.l @r6, r2                       ! r2 = section_count
    mov.l @(r0, r4), r3                 ! r3 = car[+0x1E8] (validated track position)
    cmp/eq r2, r3                       ! validated pos == section_count?
    bf      .L_epilogue                 ! not at section boundary -> exit
    tst r14, r14                        ! test update_flag
    bf      .L_epilogue                 ! update_flag != 0 -> suppress crossing, exit
    mov.w   DAT_0600d82e, r0            ! r0 = 0x01E8 (validated position offset)
    mov.l r13, @(r0, r4)               ! car[+0x1E8] = 0 (reset validated position)
    mov.l   .L_section_value, r3        ! r3 = &section_value
    mov.l @r3, r3                       ! r3 = current section identifier
    mov.l r3, @r7                       ! section_store = section identifier
    .byte   0xB0, 0xF9    /* bsr 0x0600D9BC (external) -- section update handler */
    mov #0x0, r4                        ! r4 = 0 (delay slot: handler argument)
    .byte   0xB0, 0xAF    /* bsr 0x0600D92C (external) -- crossing event handler */
    nop                                 ! delay slot
    extu.b r13, r13                     ! r13 = 0 (zero-extend, ensures clean value)
    mov.l   .L_crossing_direction, r3   ! r3 = &crossing_direction flag
    mov.b r13, @r3                      ! crossing_direction = 0 (backward crossing)
    bra     .L_epilogue                 ! jump to epilogue
    nop                                 ! delay slot

.L_small_or_forward:
    ! --- small or forward movement: delta >= -1 ---
    mov #0x1, r2                        ! r2 = 1 (upper bound for small movement)
    cmp/gt r2, r5                       ! T = (delta > 1)?
    bf      .L_small_movement           ! delta <= 1 -> small movement path
    ! --- forward jump path: delta > 1 ---
    mov.w   .L_off_crossing_counter, r0 ! r0 = 0x0228 (crossing counter offset)
    mov.l @(r0, r4), r2                 ! r2 = car[+0x228] (crossing counter)
    add #-0x1, r2                       ! decrement counter (forward crossing)
    mov.l r2, @(r0, r4)                 ! store updated crossing counter
    mov.l @r6, r3                       ! r3 = section_count
    mov #0x0, r2                        ! r2 = 0
    add #-0x40, r0                      ! r0 = 0x01E8 (validated position offset)
    cmp/gt r3, r2                       ! T = (0 > section_count)? i.e. section_count < 0
    mov.l @(r0, r4), r1                 ! r1 = car[+0x1E8] (validated track position)
    addc r2, r3                         ! r3 = section_count + T (round toward zero for negative)
    shar r3                             ! r3 = section_count / 2 (arithmetic shift = midpoint)
    cmp/ge r3, r1                       ! T = (validated pos >= midpoint)?
    bf      .L_epilogue                 ! not past midpoint -> exit
    tst r14, r14                        ! test update_flag
    bf      .L_epilogue                 ! update_flag != 0 -> suppress crossing, exit
    mov.w   DAT_0600d82e, r0            ! r0 = 0x01E8 (validated position offset)
    mov.l r13, @(r0, r4)               ! car[+0x1E8] = 0 (reset validated position)
    mov.l   .L_section_value, r3        ! r3 = &section_value
    mov.l @r3, r3                       ! r3 = current section identifier
    mov.l r3, @r7                       ! section_store = section identifier
    .byte   0xB0, 0xD9    /* bsr 0x0600D9BC (external) -- section update handler */
    mov #0x0, r4                        ! r4 = 0 (delay slot: handler argument)
    .byte   0xB0, 0x8F    /* bsr 0x0600D92C (external) -- crossing event handler */
    nop                                 ! delay slot
    mov #0x1, r2                        ! r2 = 1 (forward direction)
    mov.l   .L_crossing_direction, r3   ! r3 = &crossing_direction flag
    mov.b r2, @r3                       ! crossing_direction = 1 (forward crossing)
    bra     .L_epilogue                 ! jump to epilogue
    nop                                 ! delay slot

.L_small_movement:
    ! --- small movement: |delta| <= 1 ---
    tst r14, r14                        ! test update_flag
    bf      .L_epilogue                 ! update_flag != 0 -> skip validation, exit
    bsr     .L_position_validate        ! call position_validate sub-function
    nop                                 ! delay slot
    mov r14, r4                         ! r4 = update_flag (argument for tail-call)
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    .byte   0xA0, 0x3D    /* bra 0x0600D8A4 (external) -- tail-call checkpoint handler */
    mov.l @r15+, r14                    ! restore r14 (delay slot)

    .global DAT_0600d82a
DAT_0600d82a:
    .2byte  0x01EC                        /* car offset: current track position */
.L_off_crossing_counter:
    .2byte  0x0228                        /* car offset: crossing counter */

    .global DAT_0600d82e
DAT_0600d82e:
    .2byte  0x01E8                        /* car offset: validated track position */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_section_store:
    .4byte  sym_06063F1C               /* section boundary store (written on crossing) */
.L_section_count:
    .4byte  sym_0607EA9C               /* total section count for current track */
.L_section_value:
    .4byte  sym_06063F18               /* section identifier value */
.L_crossing_direction:
    .4byte  sym_0605DE3C               /* crossing direction flag (0=backward, 1=forward) */

.L_epilogue:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)

/* position_validate -- Validates car position against last validated position.
 * Called from checkpoint_detect when movement delta is small (|delta| <= 1).
 *
 * If (current - validated) is in range (0, 16): normal forward movement,
 *   updates validated position to current.
 * If current position is at section midpoint or midpoint+2: updates validated
 *   position and stores crossing counter to section boundary variable.
 */
.L_position_validate:
    mov.l   .L_car_struct_ptr_2, r4     ! r4 = &car_struct_ptr (duplicate for PC reach)
    mov.w   DAT_0600d894, r0            ! r0 = 0x01EC (current track position offset)
    mov.l @r4, r4                       ! r4 = car struct base address
    mov.l @(r0, r4), r5                 ! r5 = car[+0x1EC] (current track position)
    add #-0x4, r0                       ! r0 = 0x01E8 (validated position offset)
    mov r5, r6                          ! r6 = current position (copy for delta calc)
    mov.l @(r0, r4), r3                 ! r3 = car[+0x1E8] (last validated position)
    sub r3, r6                          ! r6 = delta = current - validated
    cmp/pl r6                           ! T = (delta > 0)?
    bf      .L_midpoint_check           ! delta <= 0 -> not normal forward, check midpoint
    mov #0x10, r2                       ! r2 = 16 (max normal forward increment)
    cmp/ge r2, r6                       ! T = (delta >= 16)?
    bt      .L_midpoint_check           ! delta too large -> abnormal, check midpoint
    mov.w   .L_off_validated_pos, r0    ! r0 = 0x01E8 (validated position offset)
    bra     .L_validate_return          ! jump to return
    mov.l r5, @(r0, r4)                 ! car[+0x1E8] = current pos (delay slot: update validated)

.L_midpoint_check:
    ! --- check if current position is at or near section midpoint ---
    mov.l   .L_section_count_2, r6      ! r6 = &section_count (duplicate for PC reach)
    mov #0x0, r2                        ! r2 = 0
    mov.l @r6, r6                       ! r6 = section_count
    cmp/gt r6, r2                       ! T = (0 > section_count)? i.e. section_count < 0
    addc r2, r6                         ! r6 += T (round toward zero for negative counts)
    shar r6                             ! r6 = section_count / 2 (arithmetic shift = midpoint)
    cmp/eq r6, r5                       ! T = (current pos == midpoint)?
    bt      .L_at_midpoint              ! exact midpoint -> update boundary
    mov r6, r2                          ! r2 = midpoint
    add #0x2, r2                        ! r2 = midpoint + 2
    cmp/eq r2, r5                       ! T = (current pos == midpoint + 2)?
    bf      .L_validate_return          ! neither midpoint nor midpoint+2 -> return

.L_at_midpoint:
    ! --- at section midpoint: update validated pos and store crossing counter ---
    mov.w   .L_off_validated_pos, r0    ! r0 = 0x01E8 (validated position offset)
    mov.l r5, @(r0, r4)                 ! car[+0x1E8] = current position
    add #0x40, r0                       ! r0 = 0x0228 (crossing counter offset)
    mov.l @(r0, r4), r3                 ! r3 = car[+0x228] (crossing counter)
    mov.l   .L_section_boundary, r2     ! r2 = &section_boundary variable
    mov.l r3, @r2                       ! section_boundary = crossing counter

.L_validate_return:
    rts                                 ! return to caller
    nop                                 ! delay slot

    .global DAT_0600d894
DAT_0600d894:
    .2byte  0x01EC                        /* car offset: current track position */
.L_off_validated_pos:
    .2byte  0x01E8                        /* car offset: validated track position */
.L_car_struct_ptr_2:
    .4byte  sym_0607E940               /* car struct pointer (dup for reach) */
.L_section_count_2:
    .4byte  sym_0607EA9C               /* section count (dup for reach) */
.L_section_boundary:
    .4byte  sym_06063F20               /* section boundary crossing counter store */
