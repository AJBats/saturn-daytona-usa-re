/* checkpoint_detect -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600D780 - 0x0600D8A4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Checkpoint crossing detection — monitors track position changes to detect
 * when a car crosses section boundaries (lap segments). Handles both forward
 * and backward crossings with different thresholds.
 *
 * Main function: checkpoint_detect(r4 = update_flag)
 *   Computes delta = car[+0x1EC] - car[+0x1F0] (track positions)
 *   Three cases:
 *     |delta| <= 1: Small movement → incremental position validation
 *     delta > 1:    Forward jump → decrement counter, check section midpoint
 *     delta < -1:   Backward jump → increment counter, check section boundary
 *   On boundary crossing: resets validated position, updates section store,
 *   calls external handlers, writes crossing direction (0=backward, 1=forward).
 *
 * Sub-function: position_validate (0x0600D84C)
 *   Validates car position against last validated position.
 *   If delta in (0, 16): normal forward movement → update validated pos.
 *   If at section midpoint or midpoint+2: update and store crossing counter.
 *
 * Car struct offsets used:
 *   +0x1E8 = validated track position
 *   +0x1EC = current track position
 *   +0x1F0 = reference track position (previous/checkpoint base)
 *   +0x228 = crossing counter
 */

    .section .text.FUN_0600D780


    .global checkpoint_detect
    .type checkpoint_detect, @function
checkpoint_detect:
    mov.l r14, @-r15
    mov r4, r14                      /* r14 = update_flag parameter */
    mov.l r13, @-r15
    sts.l pr, @-r15
    mov.l   .L_car_struct_ptr, r4
    mov.w   DAT_0600d82a, r0        /* r0 = 0x01EC (track position offset) */
    mov.l @r4, r4                    /* r4 = car struct */
    mov.l @(r0, r4), r5             /* r5 = car[+0x1EC] (current track pos) */
    add #0x4, r0                     /* r0 = 0x01F0 */
    mov.l @(r0, r4), r3             /* r3 = car[+0x1F0] (reference track pos) */
    sub r3, r5                       /* r5 = delta = current - reference */
    tst r5, r5
    bt      .L_0600D844              /* delta == 0 → no movement, exit */
    mov.l   .L_section_store, r7
    mov #-0x1, r3
    mov.l   .L_section_count, r6
    cmp/ge r3, r5                    /* delta >= -1? */
    bt/s    .L_0600D7D8              /* → small/forward movement path */
    mov #0x0, r13                    /* r13 = 0 */
    mov.w   .L_off_crossing_counter, r0 /* --- backward jump: delta < -1 --- */
    mov.l @(r0, r4), r3             /* r3 = car[+0x228] (crossing counter) */
    add #0x1, r3                     /* increment backward counter */
    mov.l r3, @(r0, r4)             /* store updated counter */
    add #-0x40, r0                   /* r0 = 0x0228 - 0x40 = 0x01E8 */
    mov.l @r6, r2                    /* r2 = section_count */
    mov.l @(r0, r4), r3             /* r3 = car[+0x1E8] (validated pos) */
    cmp/eq r2, r3                    /* validated pos == section_count? */
    bf      .L_0600D844              /* not at boundary → exit */
    tst r14, r14
    bf      .L_0600D844              /* update_flag != 0 → exit */
    mov.w   DAT_0600d82e, r0        /* r0 = 0x01E8 */
    mov.l r13, @(r0, r4)            /* car[+0x1E8] = 0 (reset validated pos) */
    mov.l   .L_section_value, r3
    mov.l @r3, r3                    /* r3 = section value */
    mov.l r3, @r7                    /* section_store = section_value */
    .byte   0xB0, 0xF9    /* bsr 0x0600D9BC (external) — section update handler */
    mov #0x0, r4
    .byte   0xB0, 0xAF    /* bsr 0x0600D92C (external) — crossing event handler */
    nop
    extu.b r13, r13                  /* r13 = 0 */
    mov.l   .L_crossing_direction, r3
    mov.b r13, @r3                   /* crossing_direction = 0 (backward) */
    bra     .L_0600D844
    nop
.L_0600D7D8:                              /* --- small or forward movement --- */
    mov #0x1, r2
    cmp/gt r2, r5                    /* delta > 1? */
    bf      .L_0600D818              /* delta <= 1 → small movement path */
    mov.w   .L_off_crossing_counter, r0 /* --- forward jump: delta > 1 --- */
    mov.l @(r0, r4), r2             /* r2 = car[+0x228] (crossing counter) */
    add #-0x1, r2                    /* decrement forward counter */
    mov.l r2, @(r0, r4)             /* store updated counter */
    mov.l @r6, r3                    /* r3 = section_count */
    mov #0x0, r2
    add #-0x40, r0                   /* r0 = 0x01E8 */
    cmp/gt r3, r2                    /* 0 > section_count? (T = negative flag) */
    mov.l @(r0, r4), r1             /* r1 = car[+0x1E8] (validated pos) */
    addc r2, r3                      /* r3 = section_count + T (round toward zero) */
    shar r3                          /* r3 = section_count / 2 (midpoint) */
    cmp/ge r3, r1                    /* validated pos >= midpoint? */
    bf      .L_0600D844              /* not past midpoint → exit */
    tst r14, r14
    bf      .L_0600D844              /* update_flag != 0 → exit */
    mov.w   DAT_0600d82e, r0        /* r0 = 0x01E8 */
    mov.l r13, @(r0, r4)            /* car[+0x1E8] = 0 (reset validated pos) */
    mov.l   .L_section_value, r3
    mov.l @r3, r3
    mov.l r3, @r7                    /* section_store = section_value */
    .byte   0xB0, 0xD9    /* bsr 0x0600D9BC (external) — section update handler */
    mov #0x0, r4
    .byte   0xB0, 0x8F    /* bsr 0x0600D92C (external) — crossing event handler */
    nop
    mov #0x1, r2
    mov.l   .L_crossing_direction, r3
    mov.b r2, @r3                    /* crossing_direction = 1 (forward) */
    bra     .L_0600D844
    nop
.L_0600D818:                              /* --- small movement: |delta| <= 1 --- */
    tst r14, r14
    bf      .L_0600D844              /* update_flag != 0 → exit */
    bsr     .L_0600D84C              /* position_validate() */
    nop
    mov r14, r4
    lds.l @r15+, pr
    mov.l @r15+, r13
    .byte   0xA0, 0x3D    /* bra 0x0600D8A4 (external) — tail-call checkpoint handler */
    mov.l @r15+, r14

    .global DAT_0600d82a
DAT_0600d82a:
    .2byte  0x01EC                        /* car offset: current track position */
.L_off_crossing_counter:
    .2byte  0x0228                        /* car offset: crossing counter */

    .global DAT_0600d82e
DAT_0600d82e:
    .2byte  0x01E8                        /* car offset: validated track position */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_section_store:
    .4byte  sym_06063F1C               /* section boundary store (written on crossing) */
.L_section_count:
    .4byte  sym_0607EA9C               /* total section count for current track */
.L_section_value:
    .4byte  sym_06063F18               /* section identifier value */
.L_crossing_direction:
    .4byte  sym_0605DE3C               /* crossing direction flag (0=backward, 1=forward) */
.L_0600D844:
    lds.l @r15+, pr
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_0600D84C:                              /* === position_validate sub-function === */
    mov.l   .L_car_struct_ptr_2, r4
    mov.w   DAT_0600d894, r0        /* r0 = 0x01EC */
    mov.l @r4, r4                    /* r4 = car struct */
    mov.l @(r0, r4), r5             /* r5 = car[+0x1EC] (current track pos) */
    add #-0x4, r0                    /* r0 = 0x01E8 */
    mov r5, r6
    mov.l @(r0, r4), r3             /* r3 = car[+0x1E8] (validated pos) */
    sub r3, r6                       /* r6 = current - validated */
    cmp/pl r6                        /* delta > 0? */
    bf      .L_0600D86C              /* not positive → check midpoint */
    mov #0x10, r2                    /* 16 = max normal increment */
    cmp/ge r2, r6                    /* delta >= 16? */
    bt      .L_0600D86C              /* too large → check midpoint */
    mov.w   .L_off_validated_pos, r0 /* r0 = 0x01E8 */
    bra     .L_0600D890
    mov.l r5, @(r0, r4)             /* car[+0x1E8] = current pos (update) */
.L_0600D86C:                              /* --- midpoint check --- */
    mov.l   .L_section_count_2, r6
    mov #0x0, r2
    mov.l @r6, r6                    /* r6 = section_count */
    cmp/gt r6, r2                    /* 0 > section_count? (T = negative) */
    addc r2, r6                      /* r6 += T (round toward zero) */
    shar r6                          /* r6 = section_count / 2 (midpoint) */
    cmp/eq r6, r5                    /* current pos == midpoint? */
    bt      .L_0600D884              /* → update validated + store boundary */
    mov r6, r2
    add #0x2, r2
    cmp/eq r2, r5                    /* current pos == midpoint + 2? */
    bf      .L_0600D890              /* neither → just return */
.L_0600D884:                              /* --- at midpoint: update boundary --- */
    mov.w   .L_off_validated_pos, r0 /* r0 = 0x01E8 */
    mov.l r5, @(r0, r4)             /* car[+0x1E8] = current pos */
    add #0x40, r0                    /* r0 = 0x0228 */
    mov.l @(r0, r4), r3             /* r3 = car[+0x228] (crossing counter) */
    mov.l   .L_section_boundary, r2
    mov.l r3, @r2                    /* section_boundary = crossing counter */
.L_0600D890:
    rts
    nop

    .global DAT_0600d894
DAT_0600d894:
    .2byte  0x01EC                        /* car offset: current track position */
.L_off_validated_pos:
    .2byte  0x01E8                        /* car offset: validated track position */
.L_car_struct_ptr_2:
    .4byte  sym_0607E940               /* car struct pointer (dup for reach) */
.L_section_count_2:
    .4byte  sym_0607EA9C               /* section count (dup for reach) */
.L_section_boundary:
    .4byte  sym_06063F20               /* section boundary crossing counter store */
