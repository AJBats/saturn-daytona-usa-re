/* vdp2_loop_ctrl -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060172BC - 0x06017372
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP2 Slot & Scroll Table Initializer
 * =====================================
 * Iterates over all 18 VDP2 slots (0..17) and zeroes both:
 *   1. The 68-byte slot struct (sym_06084FC8, stride 68)
 *   2. The 24-byte scroll parameter entry (sym_06085490, stride 24)
 *
 * Called during display mode initialization to reset VDP2 state
 * before configuring new scroll planes and priority layers.
 *
 * Functions:
 *   vdp2_loop_ctrl      — outer loop, calls clear_slot_struct + init_scroll_entry per slot
 *   sym_060172E4         — zeroes all fields of one 68-byte slot struct
 *   init_scroll_entry    — zeroes all fields of one 24-byte scroll parameter entry
 */

    .section .text.FUN_060172BC


    .global vdp2_loop_ctrl
    .type vdp2_loop_ctrl, @function
vdp2_loop_ctrl:
    mov.l r14, @-r15                        ! save r14 (loop counter)
    mov.l r13, @-r15                        ! save r13 (current index)
    mov.l r12, @-r15                        ! save r12 (loop limit)
    sts.l pr, @-r15                         ! save return address
    mov #0x12, r12                          ! r12 = 18 (total VDP2 slots)
    mov #0x0, r14                           ! r14 = 0 (loop counter)
.L_slot_loop:
    extu.b r14, r13                         ! r13 = counter & 0xFF (current slot index)
    bsr     sym_060172E4                    ! call clear_slot_struct(slot_index)
    mov r13, r4                             ! delay: r4 = slot index (arg)
    bsr     .L_init_scroll_entry            ! call init_scroll_entry(slot_index)
    mov r13, r4                             ! delay: r4 = slot index (arg)
    add #0x1, r14                           ! counter++
    extu.b r14, r2                          ! r2 = counter & 0xFF
    cmp/ge r12, r2                          ! counter >= 18?
    bf      .L_slot_loop                    ! if not, continue loop
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return
    mov.l @r15+, r14                        ! delay: restore r14

    .global sym_060172E4
sym_060172E4:
    extu.b r4, r4                           ! r4 = slot_index & 0xFF
    mov r4, r3                              ! r3 = slot_index (copy for stride calc)
    shll2 r4                                ! r4 = slot_index * 4
    shll2 r3                                ! r3 = slot_index * 4
    shll2 r3                                ! r3 = slot_index * 16
    shll2 r3                                ! r3 = slot_index * 64
    add r3, r4                              ! r4 = slot_index * 68 (stride = 4 + 64)
    exts.w r4, r4                           ! sign-extend offset to word
    mov.l   .L_pool_slot_base, r2           ! r2 = slot struct array base (sym_06084FC8)
    add r2, r4                              ! r4 = &slot_struct[slot_index]
    mov #0x0, r5                            ! r5 = 0 (zero value)
    extu.b r5, r0                           ! r0 = 0x00
    mov.b r0, @(2, r4)                      ! slot[+2] = 0 (byte)
    mov.b r0, @(1, r4)                      ! slot[+1] = 0 (byte)
    mov.b r0, @r4                           ! slot[+0] = 0 (byte)
    mov.l r5, @(12, r4)                     ! slot[+12] = 0 (long)
    mov r5, r3                              ! r3 = 0
    mov.l r5, @(8, r4)                      ! slot[+8] = 0 (long)
    mov r3, r2                              ! r2 = 0
    mov.l r3, @(4, r4)                      ! slot[+4] = 0 (long)
    mov.l r2, @(24, r4)                     ! slot[+24] = 0 (long)
    mov.l r2, @(20, r4)                     ! slot[+20] = 0 (long)
    mov.l r2, @(16, r4)                     ! slot[+16] = 0 (long)
    mov.l r2, @(36, r4)                     ! slot[+36] = 0 (long)
    mov.l r2, @(32, r4)                     ! slot[+32] = 0 (long)
    mov.l r2, @(28, r4)                     ! slot[+28] = 0 (long)
    mov.l r2, @(48, r4)                     ! slot[+48] = 0 (long)
    mov.l r2, @(44, r4)                     ! slot[+44] = 0 (long)
    mov.l r2, @(40, r4)                     ! slot[+40] = 0 (long)
    mov.l r2, @(56, r4)                     ! slot[+56] = 0 (long)
    mov.l r2, @(52, r4)                     ! slot[+52] = 0 (long)
    mov #0x41, r0                           ! r0 = 0x41 (offset 65)
    mov.b r2, @(r0, r4)                     ! slot[+65] = 0 (byte)
    mov #0x40, r0                           ! r0 = 0x40 (offset 64)
    rts                                     ! return
    mov.b r2, @(r0, r4)                     ! delay: slot[+64] = 0 (byte)
.L_pool_slot_base:
    .4byte  sym_06084FC8
.L_init_scroll_entry:
    mov #0x8, r7                            ! r7 = 8 (word loop count)
    mov #0x0, r5                            ! r5 = 0 (zero value)
    extu.b r4, r6                           ! r6 = slot_index & 0xFF
    mov r6, r3                              ! r3 = slot_index (copy for stride calc)
    shll2 r6                                ! r6 = slot_index * 4
    shll r6                                  ! r6 = slot_index * 8
    shll2 r3                                ! r3 = slot_index * 4
    shll2 r3                                ! r3 = slot_index * 16
    add r3, r6                              ! r6 = slot_index * 24 (stride = 8 + 16)
    exts.w r6, r6                           ! sign-extend offset to word
    .byte   0xD2, 0x17    /* mov.l .L_pool_060173A4, r2 */  ! r2 = scroll data base (sym_06085490, cross-TU pool)
    add r2, r6                              ! r6 = &scroll_entry[slot_index]
    extu.b r5, r3                           ! r3 = 0x00
    mov r3, r0                              ! r0 = 0x00
    mov.b r0, @(4, r6)                      ! scroll[+4] = 0 (byte)
    mov.w r0, @(6, r6)                      ! scroll[+6] = 0 (word)
    extu.b r3, r3                           ! r3 = 0x00 (redundant, keeps pipeline)
    mov r3, r0                              ! r0 = 0x00
    mov.b r0, @(5, r6)                      ! scroll[+5] = 0 (byte)
    extu.b r5, r4                           ! r4 = 0 (word loop counter)
.L_word_clear_loop:
    extu.b r4, r3                           ! r3 = counter & 0xFF
    mov r6, r2                              ! r2 = scroll entry base
    exts.w r5, r1                           ! r1 = 0x0000 (zero word)
    shll r3                                  ! r3 = counter * 2 (word offset)
    add #0x1, r4                            ! counter++
    add #0x8, r2                            ! r2 = &scroll[+8] (word array start)
    add r2, r3                              ! r3 = &scroll[+8 + counter*2]
    mov.w r1, @r3                           ! scroll[+8 + counter*2] = 0 (word)
    extu.b r4, r3                           ! r3 = counter & 0xFF
    cmp/ge r7, r3                           ! counter >= 8?
    bf      .L_word_clear_loop              ! if not, continue loop
    rts                                     ! return
    nop                                     ! delay: nop
