/* VERIFIED: called every frame in all game states (menu, circuit, car, race)
 * Method: call-trace differential — appears in baselines for all 4 investigated states
 *   Menu: 10x/10frames, Circuit: 10x/10frames, Car: 10x/10frames, Race: confirmed active
 * Date: 2026-02-28
 */
/* per_frame_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600A392 - 0x0600A474
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Per-frame setup called from the main game loop every iteration BEFORE
 * state dispatch. NOT the VBlank handler — this runs on the main thread.
 *
 * Responsibilities:
 *   1. Poll CD block status via cdb_read_status (double-read of CD regs).
 *      Result masked to bottom 4 bits gives CD drive state:
 *        0=Busy, 1=Pause, 2=Standby, 3=Play, 4=Seek,
 *        5=Scan, 6=Open(tray), 7=NoDisc, 8+=Error
 *   2. If CD status == 6 (tray open): call BIOS reset via indirect pointer.
 *   3. Frame sync state machine at sym_0607864A:
 *        State 0: call ai_section_transition to fill CD response buffer,
 *                 read frame sync byte, store if < 100.
 *        State 1: if CD status == 1 (pause), call cd_status_reader,
 *                 advance to state 2.
 *   4. Check button status word at g_pad_state for reset condition:
 *        If new-press bits 0x0800 set AND held bits 0x0700 all set:
 *          -> Call state_timeext_setup (SCU interrupt reconfigure)
 *          -> If game state >= 6: call secret input handler, then
 *             if state == 0x17: call obj_state_pack (capture state),
 *             reset game state to 0.
 *          -> If game state < 6: call BIOS reset via indirect pointer.
 */

    .section .text.FUN_0600A392


    .global per_frame_update
    .type per_frame_update, @function
per_frame_update:
    mov.l r14, @-r15                    ! save r14 on stack
    mov.l r13, @-r15                    ! save r13 on stack
    mov.l r12, @-r15                    ! save r12 on stack
    sts.l pr, @-r15                     ! save return address on stack
    add #-0xC, r15                      ! allocate 12-byte local buffer on stack
    .byte   0xDD, 0x10    /* mov.l .L_pool_game_state_ptr, r13 -- r13 = &game_state (sym_0605AD10) */
    .byte   0xD3, 0x11    /* mov.l .L_pool_fn_cdb_read_status, r3 -- r3 = cdb_read_status */
    jsr @r3                             ! call cdb_read_status — poll CD block status
    nop                                 ! (delay slot)
    mov #0xF, r14                       ! r14 = 0x0F (mask for bottom 4 bits)
    and r0, r14                         ! r14 = cd_status & 0x0F (drive state nibble)
    mov r14, r0                         ! r0 = cd_status nibble
    cmp/eq #0x6, r0                     ! is cd_status == 6 (tray open)?
    bf      .L_tray_ok                  ! if not tray open, skip BIOS reset
    .byte   0xD3, 0x0E    /* mov.l .L_pool_bios_reset_indirect, r3 -- r3 = &bios_reset_ptr (sym_0600026C) */
    mov.l @r3, r3                       ! r3 = *(bios_reset_ptr) — dereference indirect
    jsr @r3                             ! call BIOS reset (tray open handler)
    nop                                 ! (delay slot)
.L_tray_ok:
    .byte   0xDC, 0x0D    /* mov.l .L_pool_frame_sync_state_ptr, r12 -- r12 = &frame_sync_state (sym_0607864A) */
    mov.b @r12, r0                      ! r0 = frame_sync_state byte
    tst r0, r0                          ! is frame_sync_state == 0?
    bf      .L_sync_not_zero            ! if nonzero, branch to state 1+ handling
    .byte   0xD3, 0x0C    /* mov.l .L_pool_fn_ai_section_transition, r3 -- r3 = ai_section_transition */
    jsr @r3                             ! call ai_section_transition (fill CD response buffer)
    mov r15, r4                         ! (delay slot) r4 = stack buffer ptr
    mov r15, r4                         ! r4 = stack buffer ptr (reload for byte read)
    mov #0x64, r2                       ! r2 = 100 (max retry threshold)
    mov.b @(6, r4), r0                  ! r0 = buffer[6] — frame sync byte from CD response
    mov r0, r4                          ! r4 = frame sync byte (signed)
    extu.b r4, r3                       ! r3 = frame sync byte (unsigned)
    cmp/ge r2, r3                       ! is sync_byte >= 100?
    bt      .L_check_buttons            ! if >= 100, skip storing (too many retries)
    .byte   0xD3, 0x08    /* mov.l .L_pool_sync_byte_store, r3 -- r3 = &sync_byte_dest (sym_06078649) */
    mov.b r4, @r3                       ! store frame sync byte to sym_06078649
    bra     .L_check_buttons            ! jump to button status check
    nop                                 ! (delay slot)
    .2byte  0xFFFF                      ! alignment padding
    .4byte  sym_06078644                ! pool: course type byte address
.L_pool_game_state_ptr:
    .4byte  sym_0605AD10                ! pool: &game_state variable
.L_pool_fn_cdb_read_status:
    .4byte  cdb_read_status             ! pool: CD block status reader function
.L_pool_bios_reset_indirect:
    .4byte  sym_0600026C                ! pool: &BIOS service function (indirect pointer)
.L_pool_frame_sync_state_ptr:
    .4byte  sym_0607864A                ! pool: &frame_sync_state byte
.L_pool_fn_ai_section_transition:
    .4byte  ai_section_transition       ! pool: CD response buffer fill function
.L_pool_sync_byte_store:
    .4byte  sym_06078649                ! pool: &frame sync byte storage
.L_sync_not_zero:
    mov.b @r12, r0                      ! r0 = frame_sync_state byte (re-read)
    cmp/eq #0x1, r0                     ! is frame_sync_state == 1 (paused)?
    bf      .L_check_buttons            ! if not state 1, skip to button check
    mov r14, r0                         ! r0 = cd_status nibble
    cmp/eq #0x1, r0                     ! is cd_status == 1 (CD paused)?
    bf      .L_check_buttons            ! if CD not paused, skip
    .byte   0xD3, 0x17    /* mov.l .L_pool_fn_cd_status_reader, r3 -- r3 = cd_status_reader */
    jsr @r3                             ! call cd_status_reader (handle CD pause state)
    nop                                 ! (delay slot)
    mov #0x2, r2                        ! r2 = 2 (advance to state 2)
    mov.b r2, @r12                      ! frame_sync_state = 2
.L_check_buttons:
    .byte   0xD5, 0x16    /* mov.l .L_pool_button_status_ptr, r5 -- r5 = &button_status (g_pad_state) */
    mov.w   DAT_0600a460, r2            ! r2 = 0x0800 (new-press test mask)
    mov.w @(2, r5), r0                  ! r0 = button_status[+2] (new button presses)
    mov r0, r3                          ! r3 = new presses (signed)
    extu.w r3, r3                       ! r3 = new presses (unsigned 16-bit)
    and r2, r3                          ! r3 = new_presses & 0x0800
    tst r3, r3                          ! is the 0x0800 bit clear?
    bt      .L_epilogue                 ! if clear, skip reset logic
    mov.w   .L_wpool_held_mask, r4      ! r4 = 0x0700 (held button mask)
    mov.w @r5, r3                       ! r3 = button_status[+0] (held buttons)
    extu.w r3, r3                       ! r3 = held buttons (unsigned 16-bit)
    and r4, r3                          ! r3 = held & 0x0700
    cmp/eq r4, r3                       ! are all 0x0700 bits held?
    bf      .L_epilogue                 ! if not all held, skip reset logic
    .byte   0xBD, 0xE7    /* bsr 0x06009FFC (external) -- call state_timeext_setup (SCU interrupt reconfigure) */
    nop                                 ! (delay slot)
    mov #0x6, r3                        ! r3 = 6 (state threshold)
    mov.l @r13, r2                      ! r2 = game_state
    cmp/hs r3, r2                       ! is game_state >= 6?
    bf      .L_state_lt_6               ! if < 6, call BIOS reset
    .byte   0xBE, 0xBF    /* bsr 0x0600A1B8 (external) -- call secret input handler */
    nop                                 ! (delay slot)
    mov.l @r13, r0                      ! r0 = game_state (re-read after handler)
    cmp/eq #0x17, r0                    ! is game_state == 0x17 (state 23)?
    bf      .L_reset_state              ! if not state 23, skip obj_state_pack
    .byte   0xD3, 0x0A    /* mov.l .L_pool_fn_obj_state_pack, r3 -- r3 = obj_state_pack */
    jsr @r3                             ! call obj_state_pack (capture game state data)
    nop                                 ! (delay slot)
.L_reset_state:
    mov #0x0, r2                        ! r2 = 0
    bra     .L_epilogue                 ! jump to function epilogue
    mov.l r2, @r13                      ! (delay slot) game_state = 0 (reset to initial)
.L_state_lt_6:
    .byte   0xD2, 0x08    /* mov.l .L_pool_bios_reset_indirect_2, r2 -- r2 = &bios_reset_ptr (sym_0600026C) */
    mov.l @r2, r2                       ! r2 = *(bios_reset_ptr) — dereference indirect
    jsr @r2                             ! call BIOS reset (game state < 6 path)
    nop                                 ! (delay slot)
.L_epilogue:
    add #0xC, r15                       ! deallocate 12-byte local buffer
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller (main loop)
    mov.l @r15+, r14                    ! (delay slot) restore r14

    .global DAT_0600a460
DAT_0600a460:
    .2byte  0x0800                      ! button new-press test mask (bit 11)
.L_wpool_held_mask:
    .2byte  0x0700                      ! button held test mask (bits 8-10)
.L_pool_fn_cd_status_reader:
    .4byte  cd_status_reader            ! pool: CD status reader function (FUN_06012B58)
.L_pool_button_status_ptr:
    .4byte  g_pad_state                ! pool: &button_status (held=+0, new_press=+2)
.L_pool_fn_obj_state_pack:
    .4byte  obj_state_pack              ! pool: state capture function (FUN_06020BCE)
.L_pool_bios_reset_indirect_2:
    .4byte  sym_0600026C                ! pool: &BIOS service function (indirect pointer)
