/* save_integrity_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BDAC - 0x0603BE9C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Validates a save block's integrity.  Calls scene_buffer_update to
 * process the block's scene data buffer (field +8), then calls
 * interp_linear_remainder (sym_0603EFD4) on the block's timing field (+4).
 *
 * If scene_buffer_update returns 5 (corrupt) or interp_linear_remainder
 * returns 0 (invalid), the block is considered bad: race_timer_sync is
 * called with -1 to invalidate the timer, the global active-block pointer
 * at sym_060A4D14+0xB4 is cleared (if it matches this block), and the
 * function returns 5.
 *
 * If both checks pass, the block pointer is stored into the global
 * active-block slot, byte +0x12 is set to 1 (marking "validated"),
 * and the original scene_buffer_update result is returned.
 *
 * Args:
 *   r4 = save block pointer
 *
 * Returns:
 *   r0 = result code (5 = invalid/corrupt, else scene_buffer_update result)
 *
 * Calls:
 *   scene_buffer_update   — process block's scene data
 *   sym_0603EFD4          — interp_linear_remainder (validate timing field)
 *   race_timer_sync       — invalidate timer on failure
 */

    .section .text.FUN_0603BDAC


    .global save_integrity_check
    .type save_integrity_check, @function
save_integrity_check:
    mov.l r14, @-r15                    ! save r14
    mov r4, r14                         ! r14 = block_ptr
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes on stack (result buffer)
    mov r15, r5                         ! r5 = &result_buf (stack temp)
    mov.l   .L_pool_scene_buffer_update, r3 ! r3 = &scene_buffer_update
    jsr @r3                             ! call scene_buffer_update(r4, r5)
    mov.l @(8, r14), r4                 ! [delay] r4 = block_ptr->field_8 (scene data)
    mov.l   .L_pool_global_state, r12   ! r12 = &sym_060A4D14 (global state pointer)
    cmp/eq #0x5, r0                     ! result == 5? (corrupt)
    bt/s    .invalid_block              ! if corrupt, go to invalid path
    mov r0, r13                         ! [delay] r13 = result code
    mov.l   .L_pool_interp_linear, r3   ! r3 = &interp_linear_remainder
    jsr @r3                             ! call interp_linear_remainder(r4)
    mov.l @(4, r14), r4                 ! [delay] r4 = block_ptr->field_4 (timing data)
    tst r0, r0                          ! result == 0? (validation failed)
    bf      .block_valid                ! if nonzero, block is valid
.invalid_block:
    mov #-0x1, r5                       ! r5 = -1 (invalidate flag)
    mov.l   .L_pool_race_timer_sync, r3 ! r3 = &race_timer_sync
    jsr @r3                             ! call race_timer_sync(r4, r5=-1) — invalidate timer
    mov.l @(8, r14), r4                 ! [delay] r4 = block_ptr->field_8
    mov.l @r12, r2                      ! r2 = *global_state (base pointer)
    mov.w   .L_wpool_active_block_offset, r0       ! r0 = 0xB4 (active-block slot offset)
    mov.l @(r0, r2), r3                 ! r3 = global_state[0xB4] (current active block)
    cmp/eq r14, r3                      ! active block == this block?
    bf      .clear_done                 ! if not, skip clearing
    mov.l @r12, r2                      ! r2 = *global_state (reload base)
    mov #0x0, r3                        ! r3 = 0 (null)
    mov.w   .L_wpool_active_block_offset, r0       ! r0 = 0xB4
    mov.l r3, @(r0, r2)                 ! global_state[0xB4] = NULL — clear active block
.clear_done:
    bra     .epilogue                   ! jump to return
    mov #0x5, r13                       ! [delay] r13 = 5 (corrupt result code)
.block_valid:
    tst r13, r13                        ! scene_buffer_update result == 0?
    bt      .epilogue                   ! if zero, skip registration (no-op path)
    mov.l @r12, r3                      ! r3 = *global_state (base pointer)
    mov.w   .L_wpool_active_block_offset, r0       ! r0 = 0xB4
    mov.l r14, @(r0, r3)               ! global_state[0xB4] = block_ptr — register as active
    mov #0x1, r3                        ! r3 = 1 ("validated" state)
    mov #0x12, r0                       ! r0 = 0x12 (state byte offset)
    mov.b r3, @(r0, r14)               ! block_ptr->state_byte = 1 (mark validated)
.epilogue:
    mov r13, r0                         ! r0 = result code (return value)
    add #0x4, r15                       ! free stack temp
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! [delay] restore r14
    .2byte  0x00A8                      /* alignment padding (unreachable) */
.L_wpool_active_block_offset:
    .2byte  0x00B4                      /* [HIGH] offset to active-block slot in global state */
    .2byte  0xFFFF                      /* alignment padding */
.L_pool_scene_buffer_update:
    .4byte  scene_buffer_update         /* process save block scene data */
.L_pool_global_state:
    .4byte  sym_060A4D14                /* global game state base pointer */
.L_pool_interp_linear:
    .4byte  sym_0603EFD4                /* interp_linear_remainder — validate timing */
.L_pool_race_timer_sync:
    .4byte  race_timer_sync             /* invalidate/sync race timer */
    .4byte  0x2F864F22
    .4byte  0x4F127FF0
    .4byte  0x2F5265F3
    .4byte  0xBC3A7504
    .4byte  0x64F37404
    .4byte  0x84486403
    .4byte  0x644C2448
    .4byte  0x8B0560F3
    .4byte  0x70046002
    .4byte  0x63F2A012
    .4byte  0x303C60F3
    .4byte  0x61F2D310
    .4byte  0x70046802
    .4byte  0x430B6043
    .4byte  0x63F37304
    .4byte  0xE209323C
    .4byte  0x6220622C
    .4byte  0x6343332C
    .4byte  0x0037001A
    .4byte  0x308C7F10
    .4byte  0x4F164F26
    .4byte  0x000B68F6
    .4byte  0xE01D004C
    .4byte  0x600CC860
    .4byte  0x8B02D304
    .4byte  0x432B0009
    .4byte  0x1458E200
    .4byte  0x000B1429
    .4byte  sym_06034FFC
    .4byte  evt_error_code_return
