/* pre_race_camera -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06019EF0 - 0x06019FB2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Pre-race camera angle selector — adjusts the active camera angle index
 * based on D-pad Up/Down input (newly-pressed), clamped to [0, 4].
 * Near-identical algorithm to grid_position_camera (0x0601A0F0); differs
 * only in which per-course data pointer is used for the camera index.
 *
 * Algorithm:
 *   1. Read input struct ptr (r13) and camera_angle_index ptr (r14).
 *   2. Check game mode flag (word[0] of input struct, bit 0):
 *        - bit 0 clear  → r12 = 0, r5 = 0x06  (narrow angle range)
 *        - bit 0 set    → r12 = 0, r5 = 0x19  (wide angle range)
 *   3. Check newly-pressed Up (bit 15 = 0x8000) from word[+2]:
 *        - pressed → increment camera_angle_index, write 0 (r12) to anim_timer
 *   4. Check newly-pressed Down (bit 14 = 0x4000) from word[+2]:
 *        - pressed → decrement camera_angle_index, write 0 to anim_timer
 *   5. Check held Up (0x8000) from word[0]:
 *        - held and angle already at max (r5) → no change
 *        - held and angle < max             → increment, write 0 to anim_timer
 *   6. Check held Down (0x4000) from word[0]:
 *        - held and angle already at 0      → no change
 *        - held and angle > 0              → decrement, write 0 to anim_timer
 *   7. Clamp: if camera_angle_index >= 5 → cap at 4.
 *   8. Clamp: if camera_angle_index < 0  → floor at 0 (r12).
 *   9. Tail-call to next function (0x06019DB8) via bra.
 *
 * Key symbols:
 *   sym_06063D98 = input button state struct (word[0]=held, word[+2]=newly-pressed)
 *   sym_0605AD0C = camera angle index for course 1 (32-bit, shared with physics init)
 *   sym_0605D243 = anim timer / mode variant byte (reset to 0 on angle change)
 *   sym_06063750 = car object table base (referenced in pool, not used here)
 *   sym_06049B18 = course 1 display list offset table (referenced in pool, not used here)
 */

    .section .text.FUN_06019EF0


    .global pre_race_camera
    .type pre_race_camera, @function
pre_race_camera:
    mov.l r14, @-r15                ! push r14 (callee-save)
    mov.l r13, @-r15                ! push r13 (callee-save)
    mov.l r12, @-r15                ! push r12 (callee-save)
    mov.l   .L_pool_input_state, r13    ! r13 = &input_state struct (sym_06063D98)
    mov.l   .L_pool_camera_angle, r14   ! r14 = &camera_angle_index (sym_0605AD0C)
    mov.w @r13, r0                  ! r0 = input_state.held (word[0])
    extu.w r0, r0                   ! r0 = zero-extend held word to 32-bit
    tst #0x1, r0                    ! test game mode flag (bit 0 of held word)
    bt/s    .L_wide_range           ! if bit 0 set → use wide range (0x19)
    mov #0x0, r12                   ! (delay) r12 = 0 (reset/clamp floor value)
    bra     .L_check_new_up         ! bit 0 clear → narrow range, fall through
    mov #0x6, r5                    ! (delay) r5 = 0x6 (narrow max angle)
.L_wide_range:
    mov #0x19, r5                   ! r5 = 0x19 = 25 (wide max angle)
.L_check_new_up:
    mov.l   .L_fp_half, r7          ! r7 = 0x8000 (Up button mask, reused as 32-bit AND mask)
    mov.l   .L_pool_anim_timer, r4  ! r4 = &anim_timer (sym_0605D243)
    mov.w @(2, r13), r0             ! r0 = input_state.new_press (word[+2])
    mov r0, r2                      ! r2 = new_press copy
    extu.w r2, r2                   ! r2 = zero-extend to 32-bit
    and r7, r2                      ! r2 = new_press & 0x8000 (newly-pressed Up?)
    tst r2, r2                      ! Up newly pressed?
    bt      .L_check_new_down       ! no → check newly-pressed Down
    mov.l @r14, r3                  ! r3 = current camera_angle_index
    add #0x1, r3                    ! r3 = angle + 1
    mov.l r3, @r14                  ! camera_angle_index = angle + 1
    exts.b r12, r2                  ! r2 = sign-extend 0 → 0 (reset value)
    bra     .L_clamp_upper          ! go apply upper clamp
    mov.b r2, @r4                   ! (delay) anim_timer = 0 (reset on angle change)
.L_check_new_down:
    mov.w   .L_wpool_down_mask, r6  ! r6 = 0x4000 (Down button mask, 16-bit)
    mov.w @(2, r13), r0             ! r0 = input_state.new_press (word[+2])
    mov r0, r2                      ! r2 = new_press copy
    extu.w r2, r2                   ! r2 = zero-extend to 32-bit
    and r6, r2                      ! r2 = new_press & 0x4000 (newly-pressed Down?)
    tst r2, r2                      ! Down newly pressed?
    bt      .L_check_held_up        ! no → check held Up
    mov.l @r14, r3                  ! r3 = current camera_angle_index
    add #-0x1, r3                   ! r3 = angle - 1
    mov.l r3, @r14                  ! camera_angle_index = angle - 1
    exts.b r12, r2                  ! r2 = sign-extend 0 → 0 (reset value)
    bra     .L_clamp_upper          ! go apply upper clamp
    mov.b r2, @r4                   ! (delay) anim_timer = 0 (reset on angle change)
.L_wpool_down_mask:
    .2byte  0x4000                  /* Down button mask (16-bit) */
    .2byte  0xFFFF                  /* padding */
    .4byte  sym_06063750            /* car object table base (unused here, pool alignment) */
    .4byte  sym_06049B18            /* course 1 dlist offset table (unused here, pool alignment) */
.L_pool_input_state:
    .4byte  sym_06063D98            /* &input_state struct (word[0]=held, word[+2]=new_press) */
.L_pool_camera_angle:
    .4byte  sym_0605AD0C            /* &camera_angle_index for course 1 (32-bit) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_anim_timer:
    .4byte  sym_0605D243            /* &anim_timer / mode variant byte (reset on angle change) */
.L_check_held_up:
    mov.w @r13, r2                  ! r2 = input_state.held (word[0])
    extu.w r2, r2                   ! r2 = zero-extend held word to 32-bit
    and r7, r2                      ! r2 = held & 0x8000 (held Up?)
    tst r2, r2                      ! Up held?
    bt      .L_check_held_down      ! no → check held Down
    mov.b @r4, r3                   ! r3 = current anim_timer value (byte)
    extu.b r5, r5                   ! r5 = zero-extend max angle to 32-bit
    cmp/eq r5, r3                   ! is anim_timer already at max angle?
    bf      .L_clamp_upper          ! no → skip increment (already past max)
    mov.l @r14, r3                  ! r3 = current camera_angle_index
    add #0x1, r3                    ! r3 = angle + 1
    mov.l r3, @r14                  ! camera_angle_index = angle + 1
    exts.b r12, r2                  ! r2 = sign-extend 0 → 0
    bra     .L_clamp_upper          ! apply upper clamp
    mov.b r2, @r4                   ! (delay) anim_timer = 0 (reset on angle change)
.L_check_held_down:
    mov.w @r13, r2                  ! r2 = input_state.held (word[0])
    extu.w r2, r2                   ! r2 = zero-extend to 32-bit
    and r6, r2                      ! r2 = held & 0x4000 (held Down?)
    tst r2, r2                      ! Down held?
    bt      .L_clamp_upper          ! no → skip to clamp
    extu.b r5, r5                   ! r5 = zero-extend max angle to 32-bit
    mov.b @r4, r3                   ! r3 = current anim_timer value (byte)
    cmp/eq r5, r3                   ! is anim_timer at max angle (floor check)?
    bf      .L_clamp_upper          ! no → skip decrement
    mov.l @r14, r3                  ! r3 = current camera_angle_index
    add #-0x1, r3                   ! r3 = angle - 1
    mov.l r3, @r14                  ! camera_angle_index = angle - 1
    exts.b r12, r2                  ! r2 = sign-extend 0 → 0
    mov.b r2, @r4                   ! anim_timer = 0 (reset on angle change)
.L_clamp_upper:
    mov #0x5, r2                    ! r2 = 5 (exclusive upper bound)
    mov.l @r14, r3                  ! r3 = current camera_angle_index
    cmp/ge r2, r3                   ! T = (angle >= 5)?
    bf      .L_clamp_lower          ! if angle < 5 → skip upper clamp
    mov #0x4, r2                    ! r2 = 4 (maximum valid angle)
    mov.l r2, @r14                  ! camera_angle_index = 4 (cap at max)
.L_clamp_lower:
    mov.l @r14, r3                  ! r3 = current camera_angle_index
    cmp/pz r3                       ! T = (angle >= 0)?
    bt      .L_done                 ! if non-negative → no floor clamp needed
    mov.l r12, @r14                 ! camera_angle_index = 0 (floor at 0)
.L_done:
    mov.l @r15+, r12                ! pop r12 (callee-restore)
    mov.l @r15+, r13                ! pop r13 (callee-restore)
    .byte   0xAF, 0x03    /* bra 0x06019DB8 (external) */
    mov.l @r15+, r14                ! (delay) pop r14 (callee-restore)
