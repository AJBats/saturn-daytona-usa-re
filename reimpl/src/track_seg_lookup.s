/* track_seg_lookup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06012BE4 - 0x06012C3C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Disc-insertion prompt: displays "SET DAYTONA DISC !" on screen, polls CD
 * status until a disc is detected, clears the message, then initiates a CD
 * read via cd_status_reader.
 *
 * Entry context: cd_error_recover (0x06012BDC) pushes r14, r13, r12 and
 * sets r13 = 0xF before falling through here. This function pushes pr and
 * uses r13 as a 4-bit mask for the CD status poll.
 *
 * Flow:
 *   1. Render "SET DAYTONA DISC !" via geom_render_dispatch (mode 8)
 *   2. Copy 0x24 words of VRAM config via memcpy_word_idx
 *   3. Call ai_brake_zone_calc
 *   4. Poll cdb_read_status until (status & 0xF) == 1 (disc present)
 *   5. Clear message by rendering spaces (sym_0605ACCA) via geom_render_dispatch
 *   6. Copy VRAM config again
 *   7. Tail-call cd_status_reader to begin disc read
 *
 * Pool entries are in the neighboring cd_dma_setup section (0x06012C66..0x06012C88).
 *
 * Register allocation (inherited from cd_error_recover prolog):
 *   r12 = cdb_read_status (function pointer, for CD status polling)
 *   r13 = 0xF (4-bit mask for CD tray status)
 *   r14 = 0x1A (display offset / VRAM config index)
 */

    .section .text.FUN_06012BE4


    .global track_seg_lookup
    .type track_seg_lookup, @function
track_seg_lookup:
    sts.l pr, @-r15
    .byte   0xDC, 0x20    /* mov.l .L_fn_ptr_cdb_read_status, r12 */
    .byte   0x9E, 0x3D    /* mov.w .L_pool_const_0x1A, r14 */
    .byte   0xD7, 0x20    /* mov.l .L_str_set_daytona_disc, r7 */
    .byte   0xD6, 0x20    /* mov.l .L_pool_const_0xE000, r6 */
    .byte   0xD3, 0x21    /* mov.l .L_fn_ptr_geom_render_dispatch, r3 */
    mov r14, r5                                    ! r5 = 0x1A (display offset)
    jsr @r3                                        ! call geom_render_dispatch(8, 0x1A, 0xE000, "SET DAYTONA DISC !")
    mov #0x8, r4                                   ! r4 = 8 (render mode, delay slot)
    mov #0x24, r6                                  ! r6 = 0x24 (word count for memcpy)
    .byte   0xD5, 0x1F    /* mov.l .L_vram_cfg_src, r5 */
    .byte   0xD4, 0x20    /* mov.l .L_vram_cfg_dst_ptr, r4 */
    .byte   0xD3, 0x20    /* mov.l .L_fn_ptr_memcpy_word_idx, r3 */
    add r14, r5                                    ! r5 = sym_060612C4 + 0x1A (src with offset)
    mov.l @r4, r4                                  ! r4 = *sym_060612B4 (deref indirect ptr)
    jsr @r3                                        ! call memcpy_word_idx(dst, src, 0x24)
    add r14, r4                                    ! r4 = *sym_060612B4 + 0x1A (dst with offset, delay slot)
    .byte   0xD3, 0x1F    /* mov.l .L_fn_ptr_ai_brake_zone_calc, r3 */
    jsr @r3                                        ! call ai_brake_zone_calc
    nop
.L_06012C0C:
    jsr @r12                                       ! call cdb_read_status
    nop
    and r13, r0                                    ! r0 = status & 0xF (mask to tray status bits)
    cmp/eq #0x1, r0                                ! disc present? (tray status == 1)
    bf      .L_06012C0C                           ! keep polling until disc detected
    .byte   0xD7, 0x1C    /* mov.l .L_str_spaces_clear, r7 */
    mov r14, r5                                    ! r5 = 0x1A (display offset)
    .byte   0xD3, 0x16    /* mov.l .L_fn_ptr_geom_render_dispatch, r3 */
    .byte   0xD6, 0x14    /* mov.l .L_pool_const_0xE000, r6 */
    jsr @r3                                        ! call geom_render_dispatch(8, 0x1A, 0xE000, spaces) â€” clear message
    mov #0x8, r4                                   ! r4 = 8 (render mode, delay slot)
    mov #0x24, r6                                  ! r6 = 0x24 (word count for memcpy)
    .byte   0xD5, 0x14    /* mov.l .L_vram_cfg_src, r5 */
    .byte   0xD4, 0x15    /* mov.l .L_vram_cfg_dst_ptr, r4 */
    .byte   0xD3, 0x15    /* mov.l .L_fn_ptr_memcpy_word_idx, r3 */
    add r14, r5                                    ! r5 = sym_060612C4 + 0x1A (src with offset)
    mov.l @r4, r4                                  ! r4 = *sym_060612B4 (deref indirect ptr)
    jsr @r3                                        ! call memcpy_word_idx(dst, src, 0x24)
    add r14, r4                                    ! r4 = *sym_060612B4 + 0x1A (dst with offset, delay slot)
    lds.l @r15+, pr
    mov.l @r15+, r12
    mov.l @r15+, r13
    .byte   0xAF, 0x8E    /* bra 0x06012B58 (external) */  ! tail-call cd_status_reader
    mov.l @r15+, r14
