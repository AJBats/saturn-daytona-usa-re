/* results_best_laps -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601667A - 0x06016750
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Resets all 8 results entry slots to animation phase 6 (idle),
 * then marks the caller's slot (r4) as active (flag = 1 at +1).
 * Tail-calls clear_vdp2_registers to flush display state.
 *
 * On entry:
 *   r4 = caller's slot index (byte)
 *
 * Results entry struct (68 bytes per entry, at sym_06084FC8):
 *   +0x01 (byte):  active flag (1 = active)
 *   +0x02 (byte):  animation phase
 *   +0x38 (long):  cap/threshold value
 *   +0x40 (byte):  link index (references another slot)
 */

    .section .text.FUN_0601667A


    .global results_best_laps
    .type results_best_laps, @function
results_best_laps:
    mov.l r14, @-r15                               ! save r14
    mov.l r13, @-r15                               ! save r13
    mov.l r12, @-r15                               ! save r12
    add #-0x4, r15                                 ! allocate 4 bytes on stack
    mov #0x6, r12                                  ! r12 = 6 (idle animation phase)
    .byte   0xDD, 0x16    /* mov.l .L_pool_entry_table, r13 */  ! r13 = results entry table base
    mov #0x8, r14                                  ! r14 = 8 (total slot count)
    mov.b r4, @r15                                 ! save caller slot index on stack
    mov #0x0, r4                                   ! r4 = 0 (loop counter)
.L_reset_loop:
    extu.b r4, r3                                  ! r3 = loop index (zero-extended)
    extu.b r12, r1                                 ! r1 = 6 (idle phase, zero-extended)
    mov r3, r2                                     ! r2 = index (copy for x64 calc)
    add #0x1, r4                                   ! r4++ (advance loop counter)
    mov r1, r0                                     ! r0 = 6 (value to store)
    shll2 r3                                       ! r3 = index * 4
    shll2 r2                                       ! r2 = index * 4
    shll2 r2                                       ! r2 = index * 16
    shll2 r2                                       ! r2 = index * 64
    add r2, r3                                     ! r3 = index * 68 (struct stride)
    exts.w r3, r3                                  ! sign-extend offset
    add r13, r3                                    ! r3 = &entry[index]
    mov.b r0, @(2, r3)                             ! entry[index].anim_phase = 6 (idle)
    extu.b r4, r3                                  ! r3 = next index (zero-extended)
    cmp/ge r14, r3                                 ! index >= 8?
    bf      .L_reset_loop                          ! loop if more slots remain
    mov.b @r15, r3                                 ! r3 = caller slot index (from stack)
    extu.b r3, r3                                  ! r3 = slot index (zero-extended)
    mov r3, r2                                     ! r2 = slot index (copy for x64 calc)
    shll2 r3                                       ! r3 = index * 4
    shll2 r2                                       ! r2 = index * 4
    shll2 r2                                       ! r2 = index * 16
    shll2 r2                                       ! r2 = index * 64
    add r2, r3                                     ! r3 = index * 68 (struct stride)
    exts.w r3, r3                                  ! sign-extend offset
    add r13, r3                                    ! r3 = &entry[caller_slot]
    mov #0x1, r0                                   ! r0 = 1 (active flag)
    mov.b r0, @(1, r3)                             ! entry[caller_slot].active = 1
    mov.b @r15, r4                                 ! r4 = caller slot index (restore for tail-call arg)
    extu.b r4, r4                                  ! r4 = slot index (zero-extended)
    add #0x4, r15                                  ! free stack scratch space
    mov.l @r15+, r12                               ! restore r12
    mov.l @r15+, r13                               ! restore r13
    .byte   0xA6, 0x09    /* bra 0x060172E4 (external) */  ! tail-call clear_vdp2_registers
    mov.l @r15+, r14                               ! restore r14 (delay slot)
    .2byte  0xFFFF                                 ! padding
    .4byte  sym_0605BAFA                           ! pool data (unused in this function)
    .4byte  sym_06035228                           ! pool data (unused in this function)
    .4byte  sym_06085F89                           ! pool data (unused in this function)
.L_pool_entry_table:
    .4byte  sym_06084FC8                           ! results entry table base (68-byte structs)

    .global loc_060166E4
loc_060166E4:
    add #-0x4, r15                                 ! allocate 4 bytes on stack
    mov.b r4, @r15                                 ! save slot index on stack
    .byte   0xD5, 0x18    /* mov.l .L_pool_entry_table_b, r5 */  ! r5 = results entry table base
    mov.b @r15, r4                                 ! r4 = slot index (reload from stack)
    extu.b r4, r4                                  ! r4 = slot index (zero-extended)
    mov r4, r3                                     ! r3 = index (copy for x64 calc)
    shll2 r4                                       ! r4 = index * 4
    shll2 r3                                       ! r3 = index * 4
    shll2 r3                                       ! r3 = index * 16
    shll2 r3                                       ! r3 = index * 64
    add r3, r4                                     ! r4 = index * 68 (struct stride)
    exts.w r4, r4                                  ! sign-extend offset
    add r5, r4                                     ! r4 = &entry[slot_index]
    mov #0x40, r0                                  ! r0 = 0x40 (link_index field offset)
    mov.b @(r0, r4), r2                            ! r2 = entry[slot_index].link_index
    extu.b r2, r2                                  ! r2 = linked slot index (zero-extended)
    mov r2, r3                                     ! r3 = linked index (copy for x64 calc)
    shll2 r2                                       ! r2 = linked_index * 4
    shll2 r3                                       ! r3 = linked_index * 4
    shll2 r3                                       ! r3 = linked_index * 16
    shll2 r3                                       ! r3 = linked_index * 64
    add r3, r2                                     ! r2 = linked_index * 68 (struct stride)
    exts.w r2, r2                                  ! sign-extend offset
    add r5, r2                                     ! r2 = &entry[linked_slot]
    mov #0x4, r0                                   ! r0 = 4 (animation phase: rendering)
    mov.b r0, @(2, r2)                             ! entry[linked_slot].anim_phase = 4
    mov #0x1, r0                                   ! r0 = 1 (active flag)
    mov.b r0, @(1, r4)                             ! entry[slot_index].active = 1
    mov.b @r15, r4                                 ! r4 = slot index (restore for tail-call arg)
    extu.b r4, r4                                  ! r4 = slot index (zero-extended)
    .byte   0xA5, 0xE0    /* bra 0x060172E4 (external) */  ! tail-call clear_vdp2_registers
    add #0x4, r15                                  ! free stack scratch space (delay slot)

    .global loc_06016724
loc_06016724:
    mov #0x0, r6                                   ! r6 = 0 (clear value)
    extu.b r4, r5                                  ! r5 = slot index (zero-extended)
    .byte   0xD2, 0x08    /* mov.l .L_pool_entry_table_b, r2 */  ! r2 = results entry table base
    mov #0x40, r0                                  ! r0 = 0x40 (link_index field offset)
    mov r5, r3                                     ! r3 = index (copy for x64 calc)
    shll2 r5                                       ! r5 = index * 4
    shll2 r3                                       ! r3 = index * 4
    shll2 r3                                       ! r3 = index * 16
    shll2 r3                                       ! r3 = index * 64
    add r3, r5                                     ! r5 = index * 68 (struct stride)
    exts.w r5, r5                                  ! sign-extend offset
    add r2, r5                                     ! r5 = &entry[slot_index]
    mov.l r6, @(56, r5)                            ! entry.cap_value = 0 (clear +0x38)
    mov.b r6, @(r0, r5)                            ! entry.link_index = 0 (clear +0x40)
    mov.b @(2, r5), r0                             ! r0 = entry.anim_phase (current value)
    mov r0, r3                                     ! r3 = current phase
    add #0x1, r3                                   ! r3 = phase + 1
    mov r3, r0                                     ! r0 = incremented phase
    rts                                            ! return
    mov.b r0, @(2, r5)                             ! entry.anim_phase++ (delay slot)
.L_pool_entry_table_b:
    .4byte  sym_06084FC8                           ! results entry table base (68-byte structs)
