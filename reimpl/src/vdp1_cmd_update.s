/* vdp1_cmd_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06014A04 - 0x06014A42
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP1 command table update -- copies 32 bytes of command data from a ROM
 * source table into VDP1 VRAM at a state-dependent offset, then triggers
 * a VDP2 scroll update and sets post-update status flags.
 *
 * Algorithm:
 *   dest = VDP1_VRAM_BASE + (game_state_index * 8) + 0x260
 *   memcpy_word_idx(dest, cmd_source_table, 32)
 *   vdp2_loop_ctrl()
 *   race_state_flags |= 1          (bit 0 = cmd update done)
 *   *(word)status_word_a = 0       (clear)
 *   *(word)status_word_b = 1       (signal complete)
 *
 * 0x25C00000 = VDP1 VRAM base.  Offset 0x260 = command entry ~76
 * (each VDP1 command = 8 bytes, 0x260/8 = 76).
 *
 * Called from: state_race_complete, display mode init (FUN_06014A74)
 * Calls:       memcpy_word_idx (0x0602761E), vdp2_loop_ctrl (0x060172BC)
 */

    .section .text.FUN_06014A04


    .global vdp1_cmd_update
    .type vdp1_cmd_update, @function
vdp1_cmd_update:
    sts.l pr, @-r15                         ! save return address
    add #-0x4, r15                          ! allocate 4-byte stack frame
    .byte   0xD3, 0x11    /* mov.l .L_vdp1_vram_base, r3 */
    mov.l r3, @r15                          ! save VDP1 VRAM base on stack
    .byte   0xD5, 0x11    /* mov.l .L_cmd_source_table, r5 */
    .byte   0xD4, 0x12    /* mov.l .L_ptr_game_state_index, r4 */
    .byte   0x92, 0x1D    /* mov.w .L_vdp1_cmd_offset_0x260, r2 */
    mov.l @r4, r4                           ! r4 = *game_state_index
    shll2 r4                                ! r4 *= 4
    shll r4                                 ! r4 *= 2  (total: index * 8)
    add r3, r4                              ! r4 = VDP1_BASE + index*8
    add r2, r4                              ! r4 += 0x260 -> final VRAM dest
    .byte   0xD2, 0x0F    /* mov.l .L_fn_memcpy_word_idx, r2 */
    jsr @r2                                 ! memcpy_word_idx(dst=r4, src=r5, cnt=r6)
    mov #0x20, r6                           ! (delay) r6 = 32 bytes to copy
    .byte   0xD3, 0x0F    /* mov.l .L_fn_vdp2_loop_ctrl, r3 */
    jsr @r3                                 ! vdp2_loop_ctrl()
    nop
    .byte   0xD5, 0x0E    /* mov.l .L_ptr_race_state_flags, r5 */
    mov #0x1, r4                            ! r4 = 1
    mov #0x0, r3                            ! r3 = 0
    mov.l @r5, r2                           ! r2 = current race_state_flags
    or r4, r2                               ! set bit 0 (cmd update done)
    mov.l r2, @r5                           ! write back
    .byte   0xD2, 0x0C    /* mov.l .L_pool_status_word_a, r2 */
    mov.w r3, @r2                           ! *(word)status_word_a = 0
    .byte   0xD3, 0x0C    /* mov.l .L_pool_status_word_b, r3 */
    add #0x4, r15                           ! free stack frame
    lds.l @r15+, pr                         ! restore return address
    rts
    mov.w r4, @r3                           ! (delay) *(word)status_word_b = 1
