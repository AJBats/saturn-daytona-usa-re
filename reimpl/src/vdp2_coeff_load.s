/* vdp2_coeff_load -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602E2E0 - 0x0602E30C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP2 rotation coefficient table loader.
 * Calls hw_divide via r12 (pre-loaded by caller), then clamps the
 * result to [1, 127] and sets up args (r4=1, r5=clamped_value)
 * for the next stage.  Loads r12 from a cross-TU pool for the
 * subsequent call.
 */

    .section .text.FUN_0602E2E0


    .global vdp2_coeff_load
    .type vdp2_coeff_load, @function
vdp2_coeff_load:
    sts.l pr, @-r15                        ! save return address
    jsr @r12                               ! call hw_divide (pre-loaded by caller)
    nop                                    ! delay slot
    lds.l @r15+, pr                        ! restore return address
    nop                                    ! pipeline delay
    mov #0x7F, r4                          ! r4 = 127 (upper clamp bound)
    mov #0x1, r3                           ! r3 = 1   (lower clamp bound)
    cmp/gt r3, r0                          ! r0 > 1?
    bt      .L_check_upper                 ! yes — check upper bound
    mov r3, r0                             ! no  — clamp r0 = 1
    bra     .L_clamped                     ! skip upper-bound check
    nop                                    ! delay slot
    .4byte  0x14B40000                     ! (inline pool — unreachable padding)
    .4byte  sym_0602ECCC                   ! (inline pool — hw_divide address)
.L_check_upper:
    cmp/gt r0, r4                          ! 127 > r0?  (i.e. r0 <= 127?)
    bt      .L_clamped                     ! yes — value already in range
    mov r4, r0                             ! no  — clamp r0 = 127
.L_clamped:
    mov r0, r5                             ! r5 = clamped coefficient count
    mov #0x1, r4                           ! r4 = 1 (arg for next call)
    .byte   0xDC, 0x1C    /* mov.l .L_pool_0602E37C, r12 */  ! r12 = next fn ptr (cross-TU pool)
