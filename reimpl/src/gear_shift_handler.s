/* VERIFIED: called every physics frame during racing (part of player_physics_main pipeline)
 * Method: call-trace differential — 5 frames idle vs 5 frames with LEFT in race
 *   117 calls during LEFT (baseline 39, +78) — same delta as player_physics_main
 * Date: 2026-02-28
 */
/* gear_shift_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06008318 - 0x06008418
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Gear shift handler -- processes manual transmission gear changes.
 *
 * Called once per frame to manage gear shift state for manual transmission.
 *
 * If a shift is in progress (shift_timer > 0):
 *   - Decrement shift_timer
 *   - Look up gear ratio from table (indexed by remaining timer)
 *   - Apply positive or negative ratio based on shift direction (+0x1DC field)
 *   - Store interpolated gear value at +0x1D8 in car struct
 *
 * If no shift in progress and RPM > 600 (0x258):
 *   - Check button bits: 0x10 = shift down, 0x20 = shift up
 *   - Set shift_timer = 0x20 (32 frames), direction = -1 or +1
 *   - Store car pointer for shift tracking
 *   - Set shift duration = 0x28 (40) at +0xD4 offset
 *
 * Exit: call helper twice with mode bytes 0x0301 and 0x0201
 *       (gear indicator display update for two HUD elements)
 *
 * Arguments:
 *   None (reads car struct pointer from global sym_0607E940)
 *
 * Returns:
 *   Nothing (updates car struct fields and gear display)
 */

   .section .text.FUN_06008318


   .global gear_shift_handler
   .type gear_shift_handler, @function
gear_shift_handler:
    sts.l pr, @-r15                      ! save return address
    mov.l   .L_car_struct_ptr, r4        ! r4 = &car_struct_ptr (indirect)
    mov.w   .L_off_shift_timer, r0       ! r0 = offset 0xB8 (shift_timer in car struct)
    mov.l @r4, r3                        ! r3 = car struct base
    mov.l @(r0, r3), r0                  ! r0 = car.shift_timer
    tst r0, r0                           ! is shift_timer zero?
    bt      .L_check_new_shift           ! shift_timer == 0 -> check for new shift input
    mov.l @r4, r3                        ! --- shift in progress path ---
    mov.w   .L_off_shift_timer, r0       ! r0 = offset 0xB8
    mov.l @(r0, r3), r2                  ! r2 = car.shift_timer
    add #-0x1, r2                        ! decrement shift_timer by 1
    mov.l r2, @(r0, r3)                  ! store decremented timer back
    mov.l @r4, r5                        ! r5 = car struct base
    mov.l   .L_gear_ratio_table, r3      ! r3 = gear ratio interpolation table base
    mov.l @r4, r2                        ! r2 = car struct base (for later store)
    mov.l @(r0, r5), r5                  ! r5 = remaining timer value (table index)
    mov r2, r1                           ! r1 = car struct base (for direction read)
    shll r5                              ! r5 *= 2 (16-bit table entries)
    mov.w   DAT_0600835a, r0             ! r0 = offset 0x1DC (shift_direction)
    add r3, r5                           ! r5 = &ratio_table[timer] (table addr + index)
    mov.l @(r0, r1), r3                  ! r3 = car.shift_direction (+1 or -1)
    cmp/pl r3                            ! is direction positive (upshift)?
    bf/s    .L_negate_ratio              ! no -> downshift, negate the ratio
    mov.w @r5, r5                        ! r5 = gear_ratio_table[timer] (delay slot)
    bra     .L_store_gear_value          ! upshift -> use positive ratio
    exts.w r5, r3                        ! r3 = sign-extended ratio value (delay slot)
.L_negate_ratio:
    exts.w r5, r1                        ! r1 = sign-extended ratio value
    neg r1, r3                           ! r3 = -ratio (negate for downshift)
.L_store_gear_value:
    mov.w   .L_off_gear_interp, r0       ! r0 = offset 0x1D8 (interpolated gear value)
    mov.l r3, @(r0, r2)                  ! car.gear_interp = interpolated ratio
    bra     .L_exit_update_display       ! -> exit path (update gear display)
    nop
.L_off_shift_timer:
    .2byte  0x00B8                       ! car struct offset: shift timer (32-bit)

    .global DAT_0600835a
DAT_0600835a:
    .2byte  0x01DC                       ! car struct offset: shift direction
    .4byte  0x03010201                   ! embedded data: shift sound params
.L_off_gear_interp:
    .2byte  0x01D8                       ! car struct offset: interpolated gear value
    .2byte  0xFFFF
    .4byte  0xAE111BFF                   ! embedded data: gear change sound cmd
    .4byte  sound_cmd_dispatch           ! (used by adjacent inline code)
    .4byte  sym_06034F78                 ! gear display helper
.L_car_struct_ptr:
    .4byte  sym_0607E940                 ! pointer to current car struct
.L_gear_ratio_table:
    .4byte  sym_060453CC                 ! gear ratio interpolation table (16-bit entries)
.L_check_new_shift:                      ! --- no shift in progress -> check for new shift ---
    mov.l   .L_rpm_value, r2             ! r2 = &current_rpm
    mov.w   .L_rpm_threshold, r3         ! r3 = 0x258 (600 RPM minimum for shifting)
    mov.l @r2, r2                        ! r2 = current RPM value
    cmp/gt r3, r2                        ! RPM > 600?
    bf      .L_exit_update_display       ! RPM too low -> skip shift, go to exit
    mov.l   .L_car_struct_ptr_2, r3      ! r3 = &car_struct_ptr (second pool copy)
    mov.w   DAT_060083fc, r0             ! r0 = offset 0xBC (gear lock flag)
    mov.l @r3, r3                        ! r3 = car struct base
    mov.l @(r0, r3), r0                  ! r0 = car.gear_lock
    tst r0, r0                           ! is gear locked?
    bf      .L_exit_update_display       ! gear locked -> skip shift, go to exit
    mov #0x28, r6                        ! r6 = 40 (shift duration for display counter)
    mov.l @r4, r2                        ! r2 = car struct base
    mov.l   .L_shift_car_ptr, r7         ! r7 = &shift_car_ptr (global tracking)
    mov r2, r0                           ! r0 = car struct base
    mov.b @r0, r0                        ! r0 = button state byte (first byte of struct)
    tst #0x10, r0                        ! bit 4 = shift DOWN button pressed?
    bt/s    .L_check_shift_up            ! not pressed -> check shift up
    mov #0x20, r5                        ! r5 = 32 (shift timer frames, delay slot)
    mov.l @r4, r3                        ! --- SHIFT DOWN path ---
    mov.w   .L_off_shift_timer_2, r0     ! r0 = offset 0xB8 (shift timer)
    mov.l r5, @(r0, r3)                  ! car.shift_timer = 32
    mov.l @r4, r3                        ! r3 = car struct base
    mov #-0x1, r2                        ! r2 = -1 (downshift direction)
    mov.w   DAT_06008400, r0             ! r0 = offset 0x1DC (shift direction)
    mov.l r2, @(r0, r3)                  ! car.shift_direction = -1
    mov.l @r4, r3                        ! r3 = car struct base
    mov.l r3, @r7                        ! save car ptr for shift tracking
    mov.l @r4, r2                        ! r2 = car struct base
    exts.w r6, r6                        ! sign-extend duration to 32-bit
    mov.w   DAT_06008402, r0             ! r0 = offset 0xD4 (shift duration display)
    bra     .L_exit_update_display       ! -> exit path
    mov.w r6, @(r0, r2)                  ! car.shift_display_duration = 40 (delay slot)
.L_check_shift_up:
    mov.l @r4, r2                        ! --- check SHIFT UP button ---
    mov r2, r0                           ! r0 = car struct base
    mov.b @r0, r0                        ! r0 = button state byte
    tst #0x20, r0                        ! bit 5 = shift UP button pressed?
    bt      .L_exit_update_display       ! not pressed -> skip to exit
    mov.l @r4, r3                        ! --- SHIFT UP path ---
    mov.w   .L_off_shift_timer_2, r0     ! r0 = offset 0xB8 (shift timer)
    mov.l r5, @(r0, r3)                  ! car.shift_timer = 32
    mov.l @r4, r3                        ! r3 = car struct base
    mov #0x1, r2                         ! r2 = +1 (upshift direction)
    mov.w   DAT_06008400, r0             ! r0 = offset 0x1DC (shift direction)
    mov.l r2, @(r0, r3)                  ! car.shift_direction = +1
    mov.l @r4, r3                        ! r3 = car struct base
    mov.l r3, @r7                        ! save car ptr for shift tracking
    mov.l @r4, r2                        ! r2 = car struct base
    exts.w r6, r6                        ! sign-extend duration to 32-bit
    mov.w   DAT_06008402, r0             ! r0 = offset 0xD4 (shift duration display)
    mov.w r6, @(r0, r2)                  ! car.shift_display_duration = 40
.L_exit_update_display:                  ! --- exit: update gear indicator HUD ---
    mov #0x0, r5                         ! r5 = 0 (clear arg)
    mov.l @r4, r2                        ! r2 = car struct base (arg for helper)
    mov.w   .L_gear_mode_a, r1           ! r1 = 0x0301 (gear display mode A)
    mov.l   .L_fn_gear_helper, r3        ! r3 = gear display update function
    jsr @r3                              ! call gear_display_helper(r0=0, r1=0x0301, r2=car)
    mov r5, r0                           ! r0 = 0 (delay slot)
    mov.l @r4, r2                        ! r2 = car struct base (arg for helper)
    mov.w   .L_gear_mode_b, r1           ! r1 = 0x0201 (gear display mode B)
    mov.l   .L_fn_gear_helper, r3        ! r3 = gear display update function
    jsr @r3                              ! call gear_display_helper(r0=0, r1=0x0201, r2=car)
    mov r5, r0                           ! r0 = 0 (delay slot)
    lds.l @r15+, pr                      ! restore return address
    rts                                  ! return to caller
    nop                                  ! delay slot
.L_rpm_threshold:
    .2byte  0x0258                       ! 600 RPM -- minimum for gear shift

    .global DAT_060083fc
DAT_060083fc:
    .2byte  0x00BC                       ! car struct offset: gear lock flag
.L_off_shift_timer_2:
    .2byte  0x00B8                       ! car struct offset: shift timer

    .global DAT_06008400
DAT_06008400:
    .2byte  0x01DC                       ! car struct offset: shift direction

    .global DAT_06008402
DAT_06008402:
    .2byte  0x00D4                       ! car struct offset: shift duration display
.L_gear_mode_a:
    .2byte  0x0301                       ! gear indicator mode A
.L_gear_mode_b:
    .2byte  0x0201                       ! gear indicator mode B
.L_rpm_value:
    .4byte  sym_0607EBD0                 ! current RPM value (32-bit)
.L_car_struct_ptr_2:
    .4byte  sym_0607E940                 ! pointer to current car struct
.L_shift_car_ptr:
    .4byte  sym_0607EBE0                 ! car pointer saved during shift
.L_fn_gear_helper:
    .4byte  sym_06034F78                 ! gear display update helper
