/* motion_blur_effect -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060284BA - 0x06028580
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Three VRAM rendering/fill functions for the screen effects subsystem.
 *
 * motion_blur_effect (FUN_060284BA):
 *   Composites a motion-blur overlay into VRAM. Reads a null-terminated
 *   "blur map" byte array (pointed to by r7 on entry) that lists source
 *   tile indices. For each tile index in the blur map, looks up source
 *   pixel data via the object template table (sym_06063690), copies
 *   tile_width words from source to destination VRAM, adding a color
 *   bias (r2) to each pixel. Repeats across tile_height rows, advancing
 *   the source row pointer and skipping unused VRAM columns in the
 *   destination. The overall effect blends multiple source tiles into
 *   a single VRAM region, producing a motion blur.
 *
 *   Entry registers:
 *     r4  = VRAM pointer table index (selects which framebuffer)
 *     r5  = destination offset within VRAM buffer
 *     r6  = offset into template table (selects which template entry)
 *     r7  = pointer to null-terminated blur map (tile index array)
 *
 *   Template entry layout (12 bytes at sym_06063690 + r6):
 *     +0x00: .4byte  source pixel data base pointer
 *     +0x04: .2byte  color bias (added to each copied pixel)
 *     +0x06: .byte   tile width (words per row to copy)
 *     +0x07: .byte   tile height (number of row groups)
 *     +0x08: .byte   source row stride (bytes between rows)
 *     +0x09: .byte   tile base offset (subtracted from blur map value)
 *
 * vram_fill_indexed (sym_0602853E):
 *   Fills a VRAM buffer with a constant longword value. Reads the fill
 *   value from a default-color table (sym_06028644) and the VRAM
 *   destination from a pointer table (sym_0602862C), both indexed by
 *   r4. Writes 0x0800 (2048) longwords = 8 KB.
 *
 *   Entry registers:
 *     r4  = table index (selects buffer and fill color)
 *
 * vram_config_reset (sym_06028560):
 *   Resets VRAM config region at sym_060612C4 to a default pattern
 *   (0x00200020). Writes 0x0380 (896) longwords = 3.5 KB.
 *   No entry registers required.
 */

    .section .text.FUN_060284BA


    .global motion_blur_effect
    .type motion_blur_effect, @function
motion_blur_effect:
    mov.l r14, @-r15                  ! save r14
    sts.l pr, @-r15                   ! save return address
    .byte   0xD0, 0x1D    /* mov.l _pool_vram_ptr_table, r0 */ ! r0 = &vram_ptr_table
    mov.l @(r0, r4), r4              ! r4 = vram_ptr_table[index] (pointer to VRAM base ptr)
    mov.l @r4, r4                    ! r4 = *vram_ptr_table[index] (VRAM base address)
    add r4, r5                       ! r5 = dest = VRAM_base + dest_offset
    mov r7, r0                       ! r0 = blur_map pointer (null-terminated byte array)
    .byte   0xD1, 0x1B    /* mov.l _pool_template_base, r1 */ ! r1 = template table base (sym_06063690)
    add r1, r6                       ! r6 = &template_entry (template_base + entry_offset)
    mov.l @r6+, r1                   ! r1 = source pixel data base pointer
    mov.w @r6+, r2                   ! r2 = color bias (added to each pixel word)
    mov.b @r6+, r3                   ! r3 = tile_width (words per source row to copy)
    mov.b @r6+, r4                   ! r4 = tile_height (number of row groups)
    mov.b @r6+, r11                  ! r11 = src_row_stride (bytes between source rows)
    mov.b @r6+, r8                   ! r8 = tile_base_offset (subtracted from blur map value)
    mov r0, r14                      ! r14 = blur_map pointer (saved for reuse)
    mov #-0x1, r12                   ! r12 = -1 (blur_map length counter, pre-decremented)
.blur_map_strlen:
    mov.b @r0+, r7                   ! r7 = next byte from blur map
    tst r7, r7                       ! test if null terminator
    bf/s    .blur_map_strlen          ! loop if not null
    add #0x1, r12                    ! r12++ (count non-null entries)
    mulu.w r12, r3                   ! MACL = blur_map_len * tile_width
    mov r12, r10                     ! r10 = blur_map_len (saved for row counter)
    sts macl, r12                    ! r12 = blur_map_len * tile_width (pixels per row used)
    add #-0x40, r12                  ! r12 = (blur_map_len * tile_width) - 64
    neg r12, r12                     ! r12 = 64 - (blur_map_len * tile_width) = unused columns
    shll r12                         ! r12 *= 2 (bytes to skip per dest row; 2 bytes/pixel)
    mov r14, r0                      ! r0 = blur_map pointer (reset for first pass)
.row_group_loop:
    mov r10, r9                      ! r9 = blur_map_len (tile counter for this row)
    mov r14, r0                      ! r0 = blur_map pointer (reset for each row group)
.tile_loop:
    mov.b @r0+, r7                   ! r7 = blur_map[i] (source tile index)
    mov r3, r13                      ! r13 = tile_width (inner copy counter)
    sub r8, r7                       ! r7 = tile_index - tile_base_offset (relative index)
    mulu.w r7, r11                   ! MACL = relative_index * src_row_stride
    mov r1, r6                       ! r6 = source data base pointer
    sts macl, r7                     ! r7 = byte offset into source data for this tile
    add r7, r6                       ! r6 = &source_row[tile] (source read pointer)
.pixel_copy_loop:
    mov.w @r6, r7                    ! r7 = source pixel word
    add r2, r7                       ! r7 += color_bias (apply tint/blur blend)
    mov.w r7, @r5                    ! write blended pixel to destination VRAM
    add #0x2, r6                     ! advance source pointer (2 bytes per pixel)
    dt r13                           ! decrement tile_width counter
    bf/s    .pixel_copy_loop          ! loop until all columns copied for this tile
    add #0x2, r5                     ! advance destination pointer (delay slot)
    dt r9                            ! decrement tile counter
    bf      .tile_loop                ! loop until all blur map tiles processed
    add r3, r1                       ! advance source base by tile_width (once)
    add r3, r1                       ! advance source base by tile_width (twice; total 2*tile_width bytes)
    dt r4                            ! decrement row group counter (tile_height)
    bf/s    .row_group_loop           ! loop for next row group
    add r12, r5                      ! skip unused dest columns (delay slot)
    lds.l @r15+, pr                  ! restore return address
    mov.l @r15+, r14                 ! restore r14
    mov.l @r15+, r13                 ! restore r13
    mov.l @r15+, r12                 ! restore r12
    mov.l @r15+, r11                 ! restore r11
    mov.l @r15+, r10                 ! restore r10
    mov.l @r15+, r9                  ! restore r9
    rts                              ! return
    mov.l @r15+, r8                  ! restore r8 (delay slot)
    .2byte  0x0000
_pool_vram_ptr_table:
    .4byte  sym_06028614
_pool_template_base:
    .4byte  sym_06063690
    .2byte  0x0009

    .global sym_0602853E
sym_0602853E:
    .byte   0xD0, 0x06    /* mov.l _pool_default_color_table, r0 */ ! r0 = &default_color_table
    mov.l @(r0, r4), r2              ! r2 = default_color_table[index] (fill value)
    .byte   0xD0, 0x06    /* mov.l _pool_vram_buf_table, r0 */ ! r0 = &vram_buf_ptr_table
    mov.l @(r0, r4), r0              ! r0 = vram_buf_ptr_table[index] (pointer to VRAM base)
    mov.l @r0, r0                    ! r0 = *vram_buf_ptr (VRAM base address)
    mov.w   _wpool_fill_count, r1    ! r1 = 0x0800 (2048 longwords = 8 KB to fill)
.vram_fill_loop:
    mov.l r2, @r0                    ! write fill value to VRAM
    dt r1                            ! decrement fill counter
    bf/s    .vram_fill_loop           ! loop until all longwords written
    add #0x4, r0                     ! advance VRAM pointer by 4 bytes (delay slot)
    rts                              ! return
    nop                              ! delay slot (nop)
_wpool_fill_count:
    .2byte  0x0800
_pool_default_color_table:
    .4byte  sym_06028644
_pool_vram_buf_table:
    .4byte  sym_0602862C

    .global sym_06028560
sym_06028560:
    .byte   0xD0, 0x04    /* mov.l _pool_vram_config_addr, r0 */ ! r0 = VRAM config region base (sym_060612C4)
    mov.w   _wpool_config_count, r1  ! r1 = 0x0380 (896 longwords = 3.5 KB to fill)
    .byte   0xD2, 0x04    /* mov.l _pool_default_pattern, r2 */ ! r2 = 0x00200020 (default pixel pattern)
.config_fill_loop:
    mov.l r2, @r0                    ! write default pattern to VRAM config
    dt r1                            ! decrement fill counter
    bf/s    .config_fill_loop         ! loop until all longwords written
    add #0x4, r0                     ! advance pointer by 4 bytes (delay slot)
    rts                              ! return
    nop                              ! delay slot (nop)
_wpool_config_count:
    .2byte  0x0380
_pool_vram_config_addr:
    .4byte  sym_060612C4
_pool_default_pattern:
    .4byte  0x00200020
    .4byte  0x00002800
