/* bcd_sprite_map -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06016950 - 0x06016A18
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ---------------------------------------------------------------
 * bcd_sprite_map — BCD digit-to-sprite accumulator
 * ---------------------------------------------------------------
 * Indexes into a 68-byte struct array (sym_06084FC8) using the
 * slot index in r14.  Calls vdp2_data_lookup to obtain a sprite
 * increment value, accumulates it into struct[+0x30], and caps
 * at struct[+0x38].  When the accumulator overflows the cap, it
 * is clamped, an overflow flag is set (r11=1), and the struct's
 * state byte at [+2] is written to 0x02.
 *
 * Two entry paths controlled by cmp/ge r2,r3:
 *   - r2 < r3 (fall-through): increment-only mode; clamps and
 *     sets overflow flag if exceeded.
 *   - r2 >= r3 (bt path): increment + vertex-project mode;
 *     calls hud_sprite_vertex_project after accumulation, then
 *     checks overflow.
 *
 * After accumulation, always calls hud_sprite_vertex_project
 * (FUN_06016DD8) to commit the sprite vertices to the display.
 *
 * Arguments (register convention):
 *   r2  — comparison threshold A (checked against r3)
 *   r3  — comparison threshold B
 *   r14 — slot index (byte, zero-extended internally)
 *
 * Returns:
 *   r11 — overflow flag (1 if accumulator hit cap, 0 otherwise)
 *   Struct fields at [+0x30] and [+2] may be updated.
 *
 * Clobbers: r0-r5, r11-r14 (r12-r14 restored from stack on exit)
 * ---------------------------------------------------------------
 */

    .section .text.FUN_06016950


    .global bcd_sprite_map
    .type bcd_sprite_map, @function
bcd_sprite_map:
    sts.l pr, @-r15                       ! save return address
    mov.l   .L_pool_struct_base, r13      ! r13 = struct array base (sym_06084FC8)
    cmp/ge r2, r3                         ! is r3 >= r2?
    bt/s    .L_accum_with_project         ! yes → take accumulate-with-project path
    mov #0x4, r5                          ! r5 = 4 (digit count / lookup arg, delay slot)

    /* --- Fall-through path: increment-only mode (r2 < r3) --- */

    extu.b r14, r4                        ! r4 = slot_index (zero-extend byte)
    mov.l   .L_pool_fn_data_lookup, r2    ! r2 = &vdp2_data_lookup
    mov r4, r3                            ! r3 = slot_index (copy for stride calc)
    shll2 r4                              ! r4 = slot_index * 4
    shll2 r3                              ! r3 = slot_index * 4
    shll2 r3                              ! r3 = slot_index * 16
    shll2 r3                              ! r3 = slot_index * 64
    add r3, r4                            ! r4 = slot_index * 68 (struct stride)
    exts.w r4, r4                         ! sign-extend to word (offset fits 16 bits)
    add r13, r4                           ! r4 = &struct[slot_index] (base + offset)
    mov.l @(56, r4), r1                   ! r1 = struct[+0x38] cap/threshold value
    jsr @r2                               ! call vdp2_data_lookup(r0=4, r1=cap)
    mov r5, r0                            ! r0 = 4 (delay slot: first arg)
    mov.l @(48, r4), r3                   ! r3 = struct[+0x30] current accumulator
    add r0, r3                            ! r3 += lookup result (increment accumulator)
    mov.l r3, @(48, r4)                   ! store updated accumulator to struct[+0x30]
    mov r3, r2                            ! r2 = updated accumulator
    mov.l @(56, r4), r3                   ! r3 = cap value from struct[+0x38]
    cmp/gt r3, r2                         ! is accumulator > cap?
    bt      .L_commit_sprites             ! yes → clamp and commit

    /* Accumulator did not overflow — re-index and clamp anyway */
    extu.b r14, r4                        ! r4 = slot_index
    mov r4, r3                            ! r3 = slot_index
    shll2 r4                              ! r4 = slot_index * 4
    shll2 r3                              ! r3 *= 4
    shll2 r3                              ! r3 *= 16
    shll2 r3                              ! r3 *= 64
    add r3, r4                            ! r4 = slot_index * 68
    exts.w r4, r4                         ! sign-extend offset
    add r13, r4                           ! r4 = &struct[slot_index]
    mov.l @(56, r4), r2                   ! r2 = cap value
    mov.l r2, @(48, r4)                   ! clamp accumulator = cap
    bra     .L_commit_sprites             ! jump to sprite commit
    mov #0x1, r11                         ! r11 = 1 (overflow flag, delay slot)

.L_accum_with_project:
    /* --- Branch path: accumulate + vertex-project mode (r3 >= r2) --- */

    extu.b r14, r12                       ! r12 = slot_index (zero-extend)
    mov.l   .L_pool_fn_data_lookup, r2    ! r2 = &vdp2_data_lookup
    mov r12, r3                           ! r3 = slot_index
    shll2 r12                             ! r12 = slot_index * 4
    shll2 r3                              ! r3 *= 4
    shll2 r3                              ! r3 *= 16
    shll2 r3                              ! r3 *= 64
    add r3, r12                           ! r12 = slot_index * 68 (struct stride)
    exts.w r12, r12                       ! sign-extend offset
    add r13, r12                          ! r12 = &struct[slot_index]
    mov.l @(56, r12), r1                  ! r1 = cap value from struct[+0x38]
    jsr @r2                               ! call vdp2_data_lookup(r0=4, r1=cap)
    mov r5, r0                            ! r0 = 4 (delay slot: first arg)
    mov.l @(48, r12), r3                  ! r3 = current accumulator
    add r0, r3                            ! r3 += lookup result
    mov.l r3, @(48, r12)                  ! store updated accumulator
    .byte   0xB2, 0x0C    /* bsr 0x06016DD8 (external: hud_sprite_vertex_project) */
    extu.b r14, r4                        ! r4 = slot_index arg (delay slot)
    mov.l @(48, r12), r2                  ! r2 = updated accumulator
    mov.l @(56, r12), r3                  ! r3 = cap value
    cmp/ge r3, r2                         ! is accumulator >= cap?
    bf      .L_commit_sprites             ! no overflow → skip to commit

    /* Accumulator hit cap — clamp and set overflow flag */
    extu.b r14, r4                        ! r4 = slot_index
    mov r4, r3                            ! r3 = slot_index
    shll2 r4                              ! r4 *= 4
    shll2 r3                              ! r3 *= 4
    shll2 r3                              ! r3 *= 16
    shll2 r3                              ! r3 *= 64
    add r3, r4                            ! r4 = slot_index * 68
    exts.w r4, r4                         ! sign-extend offset
    add r13, r4                           ! r4 = &struct[slot_index]
    mov.l @(56, r4), r2                   ! r2 = cap value
    mov.l r2, @(48, r4)                   ! clamp accumulator = cap
    mov #0x1, r11                         ! r11 = 1 (overflow flag)

.L_commit_sprites:
    /* --- Common exit: project sprites and optionally set state --- */

    .byte   0xB1, 0xFA    /* bsr 0x06016DD8 (external: hud_sprite_vertex_project) */
    extu.b r14, r4                        ! r4 = slot_index arg (delay slot)
    extu.b r11, r11                       ! zero-extend overflow flag
    tst r11, r11                          ! is overflow flag zero?
    bt      .L_epilogue                   ! yes → no overflow, skip state write

    /* Overflow occurred — mark struct state byte as 0x02 */
    extu.b r14, r14                       ! r14 = slot_index
    mov r14, r3                           ! r3 = slot_index
    shll2 r14                             ! r14 *= 4
    shll2 r3                              ! r3 *= 4
    shll2 r3                              ! r3 *= 16
    shll2 r3                              ! r3 *= 64
    add r3, r14                           ! r14 = slot_index * 68
    exts.w r14, r14                       ! sign-extend offset
    add r13, r14                          ! r14 = &struct[slot_index]
    mov #0x2, r2                          ! r2 = 2 (state: overflow/complete)
    mov r2, r0                            ! r0 = 2
    mov.b r0, @(2, r14)                   ! struct[+2] = 0x02 (set state byte)

.L_epilogue:
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r11                      ! restore r11
    mov.l @r15+, r12                      ! restore r12
    mov.l @r15+, r13                      ! restore r13
    rts                                   ! return
    mov.l @r15+, r14                      ! restore r14 (delay slot)
    .2byte  0xFFFF                        ! padding to align pool

    /* --- Constant pool --- */

.L_pool_struct_base:
    .4byte  sym_06084FC8                  ! struct array base (68-byte slot structs)
.L_pool_fn_data_lookup:
    .4byte  sym_06034FE0                  ! vdp2_data_lookup (sprite data / scale-divide)
