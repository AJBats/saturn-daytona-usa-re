/* palette_engine_core -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06042ACA - 0x06042BEE
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP2 scroll screen parameter writer.
 *
 * palette_engine_core(r4=param_block, r5=reg_base_idx):
 *   Writes VDP2 scroll register fields from a parameter descriptor block.
 *   The reg_base_idx is scaled (<<4) to compute VDP2 register addresses.
 *   Register slots at offsets -0x80, -0x7C, -0x78, -0x74 from the scaled
 *   base are conditionally written based on flag bits in param_block[9]
 *   (offset +36).
 *
 *   Parameter block layout (10 longwords):
 *     [0] +0x00  base register value (always written to slot 0)
 *     [1] +0x04  slot 1 value (written if flags bit 0 set)
 *     [2] +0x08  slot 2 value (written if flags bit 1 set)
 *     [3] +0x0C  color bank field — shifted <<18 into bits [17:14]
 *     [4] +0x10  palette number field — shifted <<12 into bits [13:12]
 *     [5] +0x14  color offset field — merged into bits [11:10]
 *     [6] +0x18  special priority field — merged into bit 9
 *     [7] +0x1C  function bits — merged into bits [4:2] if flags bit 6 set
 *     [8] +0x20  byte write value (written if flags bit 7 set)
 *     [9] +0x24  flags — bitmask controlling which fields to update
 *
 * sym_06042BAC(r4=reg_base_idx):
 *   Sets bit 0 (enable) in the config register at reg_base_idx*16-0x74.
 *
 * sym_06042BBE(r4=reg_base_idx):
 *   Clears bit 0 (enable) in the config register at reg_base_idx*16-0x74.
 *
 * Trailing .4byte/.2byte data: additional helper functions encoded as
 *   raw byte data (not disassembled to mnemonics).
 */

    .section .text.FUN_06042ACA


    .global palette_engine_core
    .type palette_engine_core, @function
palette_engine_core:
    mov r5, r3                  ! r3 = reg_base_idx
    mov.l @r4, r2               ! r2 = param[0] (base register value)
    mov #0x1, r6                ! r6 = 1 (flag bit 0 mask)
    shll2 r3                    ! r3 = reg_base_idx << 2
    shll2 r3                    ! r3 = reg_base_idx << 4 (scaled address)
    add #-0x80, r3              ! r3 = scaled_base - 0x80 (register slot 0)
    mov.l r2, @r3               ! write param[0] to register slot 0
    mov.l @(36, r4), r3         ! r3 = flags (param[9])
    and r6, r3                  ! r3 = flags & 0x01
    cmp/eq r6, r3               ! test if flag bit 0 is set
    bf      .L_skip_slot1       ! skip if flag bit 0 not set
    mov r5, r3                  ! r3 = reg_base_idx
    shll2 r3                    ! r3 = reg_base_idx << 2
    shll2 r3                    ! r3 = reg_base_idx << 4
    add #-0x7C, r3              ! r3 = scaled_base - 0x7C (register slot 1)
    mov.l @(4, r4), r2          ! r2 = param[1] (slot 1 value)
    mov.l r2, @r3               ! write param[1] to register slot 1
.L_skip_slot1:
    mov #0x2, r6                ! r6 = 2 (flag bit 1 mask)
    mov.l @(36, r4), r3         ! r3 = flags
    and r6, r3                  ! r3 = flags & 0x02
    cmp/eq r6, r3               ! test if flag bit 1 is set
    bf      .L_skip_slot2       ! skip if flag bit 1 not set
    mov r5, r3                  ! r3 = reg_base_idx
    shll2 r3                    ! r3 = reg_base_idx << 2
    shll2 r3                    ! r3 = reg_base_idx << 4
    add #-0x78, r3              ! r3 = scaled_base - 0x78 (register slot 2)
    mov.l @(8, r4), r2          ! r2 = param[2] (slot 2 value)
    mov.l r2, @r3               ! write param[2] to register slot 2
.L_skip_slot2:
    mov r5, r7                  ! r7 = reg_base_idx (save for config reg)
    mov.l @(36, r4), r0         ! r0 = flags
    shll2 r7                    ! r7 = reg_base_idx << 2
    and #0x4, r0                ! r0 = flags & 0x04
    shll2 r7                    ! r7 = reg_base_idx << 4
    add #-0x74, r7              ! r7 = scaled_base - 0x74 (config register addr)
    cmp/eq #0x4, r0             ! test if flag bit 2 is set
    bf/s    .L_skip_color_bank  ! skip color bank update if not set
    mov.l @r7, r6               ! r6 = current config register value (delay slot)
    .byte   0xD2, 0x24    /* mov.l .L_pool_color_bank_mask, r2 */
    and r2, r6                  ! r6 &= 0xFFFF3FFF (clear color bank bits [15:14])
    mov.l @(12, r4), r3         ! r3 = param[3] (color bank field)
    shll8 r3                    ! r3 <<= 8
    shll2 r3                    ! r3 <<= 2 (total <<10)
    shll2 r3                    ! r3 <<= 2 (total <<12)
    shll2 r3                    ! r3 <<= 2 (total <<14, but overflows to <<18 from <<8)
    or r3, r6                   ! merge color bank value into config
.L_skip_color_bank:
    mov.l @(36, r4), r0         ! r0 = flags
    and #0x8, r0                ! r0 = flags & 0x08
    cmp/eq #0x8, r0             ! test if flag bit 3 is set
    bf      .L_skip_palette_num ! skip palette number update if not set
    mov.w   .L_wpool_palette_num_mask, r3 ! r3 = 0xCFFF (sign-ext to 0xFFFFCFFF)
    and r3, r6                  ! r6 &= ~0x3000 (clear palette number bits [13:12])
    mov.l @(16, r4), r2         ! r2 = param[4] (palette number field)
    shll8 r2                    ! r2 <<= 8
    shll2 r2                    ! r2 <<= 2 (total <<10)
    shll2 r2                    ! r2 <<= 2 (total <<12)
    or r2, r6                   ! merge palette number into config
.L_skip_palette_num:
    mov.l @(36, r4), r0         ! r0 = flags
    and #0x10, r0               ! r0 = flags & 0x10
    cmp/eq #0x10, r0            ! test if flag bit 4 is set
    bf      .L_skip_color_offset ! skip color offset update if not set
    mov.w   .L_wpool_color_offset_mask, r2 ! r2 = 0xF3FF (sign-ext to 0xFFFFF3FF)
    and r2, r6                  ! r6 &= ~0x0C00 (clear color offset bits [11:10])
    mov.l @(20, r4), r3         ! r3 = param[5] (color offset value)
    or r3, r6                   ! merge color offset into config
.L_skip_color_offset:
    mov.l @(36, r4), r0         ! r0 = flags
    and #0x20, r0               ! r0 = flags & 0x20
    cmp/eq #0x20, r0            ! test if flag bit 5 is set
    bf      .L_skip_special_pri ! skip special priority update if not set
    mov.w   .L_wpool_special_pri_mask, r3 ! r3 = 0xFDFF (sign-ext to 0xFFFFFDFF)
    and r3, r6                  ! r6 &= ~0x0200 (clear special priority bit 9)
    mov.l @(24, r4), r2         ! r2 = param[6] (special priority value)
    or r2, r6                   ! merge special priority into config
.L_skip_special_pri:
    mov #-0x11, r3              ! r3 = 0xFFFFFFEF (clear bit 4 mask)
    mov #-0x9, r2               ! r2 = 0xFFFFFFF7 (clear bit 3 mask)
    mov.l @(36, r4), r0         ! r0 = flags
    and r3, r6                  ! r6 &= ~0x10 (always clear bit 4)
    and #0x40, r0               ! r0 = flags & 0x40
    cmp/eq #0x40, r0            ! test if flag bit 6 is set
    bf/s    .L_skip_func_bits   ! skip function bits update if not set
    and r2, r6                  ! r6 &= ~0x08 (always clear bit 3, delay slot)
    mov #-0x5, r2               ! r2 = 0xFFFFFFFB (clear bit 2 mask)
    and r2, r6                  ! r6 &= ~0x04 (clear bit 2 before merge)
    mov.l @(28, r4), r3         ! r3 = param[7] (function bits)
    or r3, r6                   ! merge function bits into config
.L_skip_func_bits:
    mov.l @(36, r4), r2         ! r2 = flags
    mov.w   .L_wpool_enable_check_mask, r3 ! r3 = 0x0100
    and r3, r2                  ! r2 = flags & 0x0100
    mov r3, r1                  ! r1 = 0x0100 (compare value)
    cmp/eq r1, r2               ! test if flag bit 8 is set
    bf      .L_skip_clear_bit1  ! skip if flag bit 8 not set
    mov #-0x3, r2               ! r2 = 0xFFFFFFFD (clear bit 1 mask)
    and r2, r6                  ! r6 &= ~0x02 (clear transparency bit)
.L_skip_clear_bit1:
    mov.l r6, @r7               ! write updated config register back
    mov.w   .L_wpool_byte_write_flag, r6 ! r6 = 0x0080
    mov.l @(36, r4), r3         ! r3 = flags
    and r6, r3                  ! r3 = flags & 0x0080
    cmp/eq r6, r3               ! test if flag bit 7 is set
    bf      .L_done             ! skip byte write if not set
    mov.w   DAT_06042ba6, r3    ! r3 = 0xFFFFFE71 (sign-ext, byte offset = -0x18F)
    add r3, r5                  ! r5 = reg_base_idx + offset (byte register addr)
    mov.l @(32, r4), r2         ! r2 = param[8] (byte value)
    extu.b r2, r2               ! r2 = param[8] & 0xFF (zero-extend byte)
    mov.b r2, @r5               ! write byte to auxiliary register
.L_done:
    rts                         ! return
    nop                         ! delay slot
.L_wpool_palette_num_mask:
    .2byte  0xCFFF              /* ~0x3000: clear palette number bits [13:12] */
.L_wpool_color_offset_mask:
    .2byte  0xF3FF              /* ~0x0C00: clear color offset bits [11:10] */
.L_wpool_special_pri_mask:
    .2byte  0xFDFF              /* ~0x0200: clear special priority bit 9 */
.L_wpool_enable_check_mask:
    .2byte  0x0100              /* flag bit 8: enable/transparency control */
.L_wpool_byte_write_flag:
    .2byte  0x0080              /* flag bit 7: auxiliary byte write control */

    .global DAT_06042ba6
DAT_06042ba6:
    .2byte  0xFE71              /* sign-extended offset -0x18F for byte write */
.L_pool_color_bank_mask:
    .4byte  0xFFFF3FFF          /* ~0x0000C000: clear color bank bits [15:14] */

    .global sym_06042BAC
sym_06042BAC:
    mov r4, r5                  ! r5 = reg_base_idx
    mov #0x1, r3                ! r3 = 0x01 (bit 0 set mask)
    shll2 r5                    ! r5 = reg_base_idx << 2
    shll2 r5                    ! r5 = reg_base_idx << 4 (scaled address)
    add #-0x74, r5              ! r5 = scaled_base - 0x74 (config register addr)
    mov.l @r5, r4               ! r4 = current config register value
    or r3, r4                   ! r4 |= 0x01 (set enable bit 0)
    rts                         ! return
    mov.l r4, @r5               ! write back with bit 0 set (delay slot)

    .global sym_06042BBE
sym_06042BBE:
    mov r4, r5                  ! r5 = reg_base_idx
    mov #-0x2, r3               ! r3 = 0xFFFFFFFE (clear bit 0 mask)
    shll2 r5                    ! r5 = reg_base_idx << 2
    shll2 r5                    ! r5 = reg_base_idx << 4 (scaled address)
    add #-0x74, r5              ! r5 = scaled_base - 0x74 (config register addr)
    mov.l @r5, r4               ! r4 = current config register value
    and r3, r4                  ! r4 &= ~0x01 (clear enable bit 0)
    rts                         ! return
    mov.l r4, @r5               ! write back with bit 0 cleared (delay slot)
    .4byte  0xE5B0E3FE          /* additional helper functions (raw bytes) */
    .4byte  0x64522439
    .4byte  0x000B2542
    .4byte  0xE5B0E304
    .4byte  0xE2026552
    .4byte  0x23592529
    .4byte  0x2432000B
    .2byte  0x1451
