/* event_queue_flush -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040C60 - 0x06040C98
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Flushes the active event by running its handler, then dispatching
 * the result through evt_checkpoint_handler in absolute-set mode,
 * and finally clearing the event record's active flag.
 *
 * Arguments:
 *   r4 = event descriptor pointer
 *   r5 = callback parameter
 *
 * Stack frame (12 bytes):
 *   sp+0  = scratch (passed to ai_brake_handler as r4)
 *   sp+4  = saved r5 (callback parameter)
 *   sp+8  = saved r4 (event descriptor pointer)
 *
 * Flow:
 *   1. Call ai_brake_handler(sp) — returns handler result in r14
 *   2. If r14 == -1, load fallback callback from r5->callback[+0x0C]
 *   3. Call evt_checkpoint_handler(event_desc, r14, 1=absolute)
 *   4. Clear event record active flag (sym_0606367C[+0x10] = 0)
 *
 * Calls: ai_brake_handler, evt_checkpoint_handler
 */

    .section .text.FUN_06040C60


    .global event_queue_flush
    .type event_queue_flush, @function
event_queue_flush:
    sts.l pr, @-r15               ! save return address
    add #-0xC, r15                ! allocate 12 bytes of locals
    mov.l r5, @(4, r15)           ! save callback parameter
    mov.l r4, @(8, r15)           ! save event descriptor pointer
    mov.l   .L_pool_fn_brake_handler, r3 ! r3 = &ai_brake_handler
    jsr @r3                       ! call ai_brake_handler(sp)
    mov r15, r4                   ! r4 = sp (scratch buffer; delay slot)
    mov r14, r0                   ! r0 = handler result (returned in r14)
    cmp/eq #-0x1, r0              ! handler returned -1 (error)?
    bf      .L_dispatch           ! no — use r14 as checkpoint position
    mov.l @(4, r15), r14          ! r14 = saved callback parameter
    mov.l @(12, r14), r14         ! r14 = fallback callback from param[+0x0C]
.L_dispatch:
    mov #0x1, r6                  ! r6 = 1 (mode: absolute set)
    mov r14, r5                   ! r5 = checkpoint position (or fallback callback)
    .byte   0xBE, 0xB3    /* bsr 0x060409E6 (external) */ ! call evt_checkpoint_handler
    mov.l @(8, r15), r4           ! r4 = event descriptor pointer (delay slot)
    mov.l   .L_pool_evt_record_base, r2 ! r2 = &event record (sym_0606367C)
    mov #0x0, r3                  ! r3 = 0
    mov #0x10, r0                 ! r0 = 0x10 (offset to active flag byte)
    mov.b r3, @(r0, r2)           ! event_record[+0x10] = 0 (deactivate event)
    add #0xC, r15                 ! deallocate 12 bytes of locals
    lds.l @r15+, pr               ! restore return address
    rts                           ! return to caller
    mov.l @r15+, r14              ! restore r14 (delay slot)
.L_pool_fn_brake_handler:
    .4byte  ai_brake_handler
.L_pool_evt_record_base:
    .4byte  sym_0606367C
