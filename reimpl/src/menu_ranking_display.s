/* menu_ranking_display -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B6A8 - 0x0603B74C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Validates and inserts a ranking entry into the global command/display
 * state queue.  The logic mirrors cmd_queue_process: reads the same
 * global state struct (sym_060A4D14), checks the active-entry count and
 * entry capacity, selects a 12-byte or 24-byte stride depending on the
 * queue mode flag, then calls the appropriate index-multiply helper
 * (sym_0603F1E0 = index_mul12 or sym_0603F1F0 = index_mul24) before
 * delegating to sym_060360FC (memmove) to copy the ranking record into
 * the computed slot.  Returns -0xA on validation failure, otherwise
 * jumps tail-call to FUN_0603B93C (save_checksum_calc) and returns 0.
 *
 * Args:
 *   r4 = ranking entry index
 *   r5 = pointer to ranking record (saved on stack)
 *
 * Returns:
 *   r0 = -0xA on error (index invalid / out of range)
 *        0 on success (via tail-call to FUN_0603B93C)
 *
 * Calls:
 *   sym_0603F1F0 = index_mul24(idx, base) → idx*24 + base
 *   sym_0603F1E0 = index_mul12(idx, base) → idx*12 + base
 *   sym_060360FC = memmove: safe overlapping copy
 *   0x0603B93C   = save_checksum_calc (set status / tail-call)
 *
 * State struct fields (base = *sym_060A4D14):
 *   [0x00A0] = active entry count
 *   [0x00A4] = entry capacity
 *   [0x0098] = queue mode flag (0 = 12-byte narrow, nonzero = 24-byte wide)
 */

    .section .text.FUN_0603B6A8


    .global menu_ranking_display
    .type menu_ranking_display, @function
menu_ranking_display:
    mov.l r14, @-r15                        ! save r14 (caller-saved callee register)
    sts.l pr, @-r15                         ! save return address
    add #-0x4, r15                          ! reserve one stack slot (for r5 / record ptr)
    mov.l r5, @r15                          ! spill r5 (ranking record pointer) to stack
    mov.l   .L_pool_state_ptr, r14          ! r14 = &sym_060A4D14 (global state pointer)
    mov.w   .L_wpool_off_active_count, r0   ! r0 = 0x00A0 (offset to active entry count)
    mov.l @r14, r3                          ! r3 = state struct base pointer
    mov.l @(r0, r3), r0                     ! r0 = struct[0xA0] (active entry count)
    tst r0, r0                              ! is active count zero?
    bt      .L_error_return                 ! if no active entries, return error
    cmp/pz r4                               ! is entry index >= 0?
    bf      .L_error_return                 ! if negative index, return error
    mov.l @r14, r2                          ! r2 = state struct base pointer
    mov.w   .L_wpool_off_capacity, r0       ! r0 = 0x00A4 (offset to entry capacity)
    mov.l @(r0, r2), r3                     ! r3 = struct[0xA4] (entry capacity)
    cmp/ge r3, r4                           ! is index >= capacity?
    bf      .L_check_mode                   ! if index < capacity, proceed to mode check
.L_error_return:
    mov #-0xA, r0                           ! r0 = -0xA (error: invalid index or empty queue)
    add #0x4, r15                           ! restore stack (discard spilled r5)
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_check_mode:
    mov.l @r14, r0                          ! r0 = state struct base pointer
    mov.w   .L_wpool_off_mode_flag, r1      ! r1 = 0x0098 (offset to queue mode flag)
    mov.l @(r0, r1), r0                     ! r0 = struct[0x98] (mode: 0=narrow, nonzero=wide)
    cmp/eq #0x1, r0                         ! is mode flag == 1 (wide / 24-byte stride)?
    bf      .L_narrow_mode                  ! if not 1, use 12-byte (narrow) stride
    mov.l @r14, r5                          ! r5 = state struct base pointer
    mov.w   .L_wpool_off_active_count, r0   ! r0 = 0x00A0 (active count offset)
    mov.l   .L_pool_index_mul24, r3         ! r3 = &index_mul24 function
    jsr @r3                                 ! call index_mul24(r4=index, r5=active_count)
    mov.l @(r0, r5), r5                     ! r5 = struct[0xA0] (active count; delay slot)
    mov r0, r5                              ! r5 = computed wide byte offset (idx*24 + base)
    mov #0xC, r6                            ! r6 = 0xC (copy length = 12 bytes)
    mov.l   .L_pool_memmove, r3             ! r3 = &memmove (sym_060360FC)
    jsr @r3                                 ! call memmove(dst=r4, src=r5, len=r6)
    mov.l @r15, r4                          ! r4 = spilled record ptr from stack (delay slot)
    bra     .L_tail_call_result             ! jump to shared success tail
    nop                                     ! delay slot
.L_narrow_mode:
    mov.l @r14, r5                          ! r5 = state struct base pointer
    mov.w   .L_wpool_off_active_count, r0   ! r0 = 0x00A0 (active count offset)
    mov.l   .L_pool_index_mul12, r3         ! r3 = &index_mul12 function
    jsr @r3                                 ! call index_mul12(r4=index, r5=active_count)
    mov.l @(r0, r5), r5                     ! r5 = struct[0xA0] (active count; delay slot)
    mov r0, r5                              ! r5 = computed narrow byte offset (idx*12 + base)
    mov #0xC, r6                            ! r6 = 0xC (copy length = 12 bytes)
    mov.l   .L_pool_memmove, r3             ! r3 = &memmove (sym_060360FC)
    jsr @r3                                 ! call memmove(dst=r4, src=r5, len=r6)
    mov.l @r15, r4                          ! r4 = spilled record ptr from stack (delay slot)
.L_tail_call_result:
    mov #0x0, r4                            ! r4 = 0 (success status code for checksum calc)
    add #0x4, r15                           ! restore stack (discard spilled r5)
    lds.l @r15+, pr                         ! restore return address
    .byte   0xA1, 0x14    /* bra 0x0603B93C (external) */ ! tail-call save_checksum_calc
    mov.l @r15+, r14                        ! restore r14 (delay slot)
    .4byte  0x7F044F26                      ! (literal pool padding / non-instruction data)
    .4byte  0x000B6EF6                      ! (literal pool padding / non-instruction data)
.L_wpool_off_active_count:
    .2byte  0x00A0                          ! offset to active entry count field in state struct
.L_wpool_off_capacity:
    .2byte  0x00A4                          ! offset to entry capacity field in state struct
.L_wpool_off_mode_flag:
    .2byte  0x0098                          ! offset to queue mode flag (0=12B narrow, else 24B wide)
    .2byte  0xFFFF                          ! padding/alignment filler
.L_pool_state_ptr:
    .4byte  sym_060A4D14                    ! pointer to global command/display state struct
.L_pool_index_mul24:
    .4byte  sym_0603F1F0                    ! index_mul24: idx*24 + base
.L_pool_memmove:
    .4byte  sym_060360FC                    ! memmove: safe overlapping memory copy
.L_pool_index_mul12:
    .4byte  sym_0603F1E0                    ! index_mul12: idx*12 + base
    .4byte  0xD41DD31E                      ! (trailing data — not reachable code)
    .4byte  0x64427404                      ! (trailing data — not reachable code)
    .4byte  0x2432D21D                      ! (trailing data — not reachable code)
    .4byte  0x1421D31D                      ! (trailing data — not reachable code)
    .4byte  0x1432D21D                      ! (trailing data — not reachable code)
    .4byte  0x000B1423                      ! (trailing data — not reachable code)
