/* track_seg_render_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602F214 - 0x0602F270
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track segment render distance setup.
 * Calls fpdiv_setup (via r12) to compute a fixed-point divide, extracts the
 * integer result and stores it as the render position. Then computes the
 * remaining render distance (seg_length + seg_start - seg_end) and clamps it
 * to per-segment limits from the clamp table. The clamped distance is added
 * back to seg_end to produce the final render endpoint.
 *
 * Register inputs:
 *   r0  = render struct base (overwritten by jsr return value, restored from r14)
 *   r8  = offset to render position field (e.g. +0xE0)
 *   r9  = offset to segment index field (e.g. +0xDC)
 *   r12 = fpdiv_setup function pointer
 *   r14 = render struct base (preserved copy)
 *   r4, r5 = dividend/divisor for fpdiv_setup (set by caller)
 */

    .section .text.FUN_0602F214


    .global track_seg_render_setup
    .type track_seg_render_setup, @function
track_seg_render_setup:
    sts.l pr, @-r15                      ! save return address to stack
    jsr @r12                             ! call fpdiv_setup(r4, r5)
    nop                                  ! (delay slot)
    lds.l @r15+, pr                      ! restore return address from stack
    mov r0, r1                           ! r1 = fpdiv result (32-bit fixed-point)
    shlr16 r1                            ! r1 >>= 16 (extract integer part)
    mov r14, r0                          ! r0 = render struct base (restore from r14)
    mov.l r1, @(r0, r8)                 ! struct[r8] = integer divide result (render position)
    mov.w   DAT_0602f24e, r1            ! r1 = 0xE4 (seg_end offset)
    mov.l @(r0, r1), r4                 ! r4 = struct[0xE4] = seg_end position
    mov.w   DAT_0602f24c, r1            ! r1 = 0xE0 (seg_start offset)
    mov.l @(r0, r1), r5                 ! r5 = struct[0xE0] = seg_start position
    mov.w   .L_wpool_0602F250, r1       ! r1 = 0xC0 (seg_length offset)
    mov.l @(r0, r1), r6                 ! r6 = struct[0xC0] = segment length
    add r6, r5                           ! r5 = seg_start + seg_length (segment extent)
    sub r4, r5                           ! r5 = (seg_start + seg_length) - seg_end = remaining distance
    mov.w @(r0, r9), r3                 ! r3 = struct[r9] = segment index (16-bit)
    shll r3                              ! r3 *= 2
    shll2 r3                             ! r3 *= 4 (total: r3 = seg_index * 8, each table entry is 8 bytes)
    mov.l   .L_pool_clamp_table, r7     ! r7 = &clamp_limit_table base
    add r3, r7                           ! r7 = &clamp_limit_table[seg_index]
    mov.l @r7, r1                       ! r1 = clamp_min (lower bound for this segment)
    mov.l @(0x4, r7), r2                ! r2 = clamp_max (upper bound for this segment)
    cmp/gt r1, r5                        ! remaining_distance > clamp_min?
    bt      .L_check_upper_bound        ! yes -> check upper bound
    mov r1, r5                           ! no -> clamp to minimum
    bra     .L_apply_clamped_distance   ! skip upper bound check
    nop                                  ! (delay slot)

    .global DAT_0602f24c
DAT_0602f24c:
    .2byte  0x00E0

    .global DAT_0602f24e
DAT_0602f24e:
    .2byte  0x00E4
.L_wpool_0602F250:
    .2byte  0x00C0
    .2byte  0x0000
    .4byte  sym_060477CC
    .4byte  fpdiv_setup
.L_pool_clamp_table:
    .4byte  sym_0602F3CC
.L_check_upper_bound:
    cmp/ge r5, r2                        ! clamp_max >= remaining_distance?
    bt      .L_apply_clamped_distance   ! yes -> distance is within bounds, keep it
    mov r2, r5                           ! no -> clamp to maximum
.L_apply_clamped_distance:
    add r5, r4                           ! r4 = seg_end + clamped_distance = new render endpoint
    mov.w   .L_wpool_0602F26E, r1       ! r1 = 0xE4 (seg_end offset)
    rts                                  ! return
    mov.l r4, @(r0, r1)                 ! (delay slot) struct[0xE4] = new render endpoint
.L_wpool_0602F26E:
    .2byte  0x00E4
