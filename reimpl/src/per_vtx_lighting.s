/* per_vtx_lighting -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602E768 - 0x0602E7D4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Per-vertex lighting calculator for gouraud shading.
 *
 * Called as part of the lighting/shading pipeline. Computes per-vertex
 * light intensity by calling isqrt (integer square root) through a
 * function pointer in r13, then compares the result magnitude against
 * a threshold (0x000F0000). If the intensity exceeds the threshold,
 * copies final vertex lighting data from the vertex structure (r9) to
 * global output buffers (DAT_06083264, DAT_06083268) and returns by
 * popping all callee-saved registers. Otherwise, falls through to
 * compute vertex position deltas between two vertex structures (r9, r10)
 * for further lighting interpolation.
 *
 * Register convention on entry:
 *   r9  = pointer to current vertex structure
 *   r10 = pointer to reference vertex structure
 *   r13 = function pointer to isqrt (integer square root)
 *
 * Register convention on exit (early return path):
 *   r8-r14 restored from stack
 *
 * Register convention on exit (fallthrough path):
 *   r4 = delta X (r10[16] - r9[16])
 *   r5 = delta Y (r10[24] - r9[24])
 *   r6 = r9[16] (current vertex X)
 *   r7 = r9[24] (current vertex Y)
 *   r11 = r10[16] (reference vertex X)
 *   r12 = r10[24] (reference vertex Y)
 *   r0 pushed on stack, then loaded with cross-TU pool value
 */

    .section .text.FUN_0602E768


    .global per_vtx_lighting
    .type per_vtx_lighting, @function
per_vtx_lighting:
    sts.l pr, @-r15                     ! save return address to stack
    jsr @r13                            ! call isqrt via function pointer in r13
    nop                                 ! delay slot
    lds.l @r15+, pr                     ! restore return address from stack
    mov r0, r7                          ! r7 = isqrt result (light intensity)
    cmp/pz r7                           ! test if intensity >= 0
    bt      .L_abs_done                 ! if non-negative, skip negation
    neg r7, r7                          ! r7 = abs(intensity)
.L_abs_done:
    mov.l   .L_intensity_threshold, r11 ! r11 = 0x000F0000 (intensity threshold)
    cmp/ge r11, r7                      ! compare abs(intensity) >= threshold
    bt      .L_high_intensity_exit      ! if above threshold, take early exit
    bra     .L_compute_vertex_deltas    ! otherwise, compute vertex deltas
    nop                                 ! delay slot
    .2byte  0x0000                      ! alignment padding
    .4byte  isqrt                       ! pool: address of isqrt function
.L_intensity_threshold:
    .4byte  0x000F0000                  ! pool: intensity threshold (nibble 4 mask)

    /* Early exit path: intensity exceeds threshold.
     * Copy final vertex lighting values from vertex struct (r9)
     * to global output buffers, then restore all callee-saved
     * registers and return. */
.L_high_intensity_exit:
    mov.l   .L_vtx_offset_x, r0        ! r0 = 0x238 (offset to lighting field X in vertex struct)
    mov.l @(r0, r9), r3                ! r3 = vertex_struct[0x238] (lighting value X)
    mov.l   .L_light_output_x, r1      ! r1 = address of DAT_06083264 (global output X)
    mov.l r3, @r1                      ! store lighting value X to global output
    mov.l   .L_vtx_offset_y, r0        ! r0 = 0x23C (offset to lighting field Y in vertex struct)
    mov.l @(r0, r9), r3                ! r3 = vertex_struct[0x23C] (lighting value Y)
    mov.l   .L_light_output_y, r1      ! r1 = address of DAT_06083268 (global output Y)
    mov.l r3, @r1                      ! store lighting value Y to global output
    mov.l @r15+, r14                   ! restore r14 from stack
    mov.l @r15+, r13                   ! restore r13 from stack
    mov.l @r15+, r12                   ! restore r12 from stack
    mov.l @r15+, r11                   ! restore r11 from stack
    mov.l @r15+, r10                   ! restore r10 from stack
    mov.l @r15+, r9                    ! restore r9 from stack
    mov.l @r15+, r8                    ! restore r8 from stack
    rts                                ! return to caller
    nop                                ! delay slot
    .2byte  0x0000                     ! alignment padding
.L_vtx_offset_x:
    .4byte  0x00000238                 ! pool: offset to lighting field X in vertex struct
.L_light_output_x:
    .4byte  DAT_06083264               ! pool: global light output X address
.L_vtx_offset_y:
    .4byte  0x0000023C                 ! pool: offset to lighting field Y in vertex struct
.L_light_output_y:
    .4byte  DAT_06083268               ! pool: global light output Y address

    /* Fallthrough path: intensity below threshold.
     * Load vertex positions from current (r9) and reference (r10)
     * vertex structures, compute position deltas for lighting
     * interpolation. */
.L_compute_vertex_deltas:
    mov.l @(16, r9), r6                ! r6 = current vertex X position (r9[16])
    mov.l @(24, r9), r7                ! r7 = current vertex Y position (r9[24])
    mov.l @(16, r10), r11              ! r11 = reference vertex X position (r10[16])
    mov.l @(24, r10), r12              ! r12 = reference vertex Y position (r10[24])
    mov.l r0, @-r15                    ! push r0 (isqrt result) onto stack
    mov r11, r4                        ! r4 = reference X
    sub r6, r4                         ! r4 = delta X (reference X - current X)
    mov r12, r5                        ! r5 = reference Y
    sub r7, r5                         ! r5 = delta Y (reference Y - current Y)
    .byte   0xD0, 0x0E    /* mov.l .L_pool_0602E80C, r0 */ ! load cross-TU pool constant (in shadow_intensity)
