/* save_serialize -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BC86 - 0x0603BD1C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * save_serialize: Serialize a save-state block by initializing its
 * embedded object descriptor and registering event callbacks.
 *
 * Takes a save block pointer (r4), an output result pointer (r5),
 * and an object-init parameter (r7).  First calls obj_init_validate
 * to initialize the road-segment object at block+0x14.  On success,
 * stores the object pointer through the output pointer (r5), then
 * calls obj_setup_decomp to decompose the object into resource slots.
 * Finally links the object to the event system by storing the decomp
 * result at obj[+24] and populating a 6-field command descriptor at
 * block+0x78 with event callbacks (evt_cmd_enqueue, evt_status_flag_set,
 * event_priority_set, sym_06040C50, nop_stub_evt).  Clears byte +0x10
 * of the nop_stub_evt pointer struct before returning.
 *
 * Args:
 *   r4 = block_ptr  -- save-state block to serialize
 *   r5 = result_ptr -- pointer where the object address will be stored
 *   r7 = init_param -- passed to obj_init_validate as the source/flags arg
 *
 * Returns:
 *   r0 = cmd descriptor pointer on success, 0 on any failure
 *
 * Calls (via constant pool, all cross-TU):
 *   obj_init_validate   -- init road-segment object at block+0x14
 *   obj_setup_decomp    -- decompose object into resource slots
 *   sym_060401E4         -- store decomp result at obj[+24]
 *   sym_0603F8B8         -- cmd_desc_init: populate 6-field descriptor
 *
 * Descriptor fields written at block+0x78 (via cmd_desc_init):
 *   [+0x00] = decomp result ptr      (r5)
 *   [+0x04] = evt_cmd_enqueue        (r6)
 *   [+0x08] = evt_status_flag_set    (r7)
 *   [+0x0C] = event_priority_set     (stack arg 0)
 *   [+0x10] = sym_06040C50           (stack arg 1)
 *   [+0x14] = nop_stub_evt           (stack arg 2)
 *
 * Pool loads at 0x0603BD68..0x0603BD80 reach into save_deserialize's
 * constant pool (next TU, same section).
 */

    .section .text.FUN_0603BC86


    .global save_serialize
    .type save_serialize, @function
save_serialize:
    mov.l r14, @-r15                    ! push r14 (callee-save)
    mov.l r13, @-r15                    ! push r13 (callee-save)
    mov.l r12, @-r15                    ! push r12 (callee-save)
    sts.l pr, @-r15                     ! push return address
    mov r4, r12                         ! r12 = block_ptr (preserved across calls)
    add #-0x8, r15                      ! allocate 8 bytes on stack
    mov r12, r4                         ! r4 = block_ptr (arg for obj_init_validate)
    mov.l r5, @r15                      ! sp[0] = result_ptr (output pointer, saved)
    mov r7, r5                          ! r5 = init_param (source/flags for obj_init_validate)
    mov.l r7, @(4, r15)                 ! sp[4] = init_param (backup)
    .byte   0xD3, 0x0F    /* mov.l .L_pool_0603BCD8, r3 */  ! r3 = obj_init_validate
    jsr @r3                             ! call obj_init_validate(r4=block+0x14, r5=init_param)
    add #0x14, r4                       ! (delay) r4 = &block[+0x14] (embedded object)
    mov r0, r14                         ! r14 = initialized object ptr (or NULL)
    tst r14, r14                        ! object init succeeded?
    bf      .L_init_ok                  ! non-zero -> success, continue
    bra     .L_epilogue                 ! zero -> failure
    mov #0x0, r0                        ! (delay) r0 = 0 (failure return)
.L_init_ok:
    mov #0x1C, r0                       ! r0 = 0x1C (surface type byte offset in obj)
    mov r14, r5                         ! r5 = object ptr (arg for obj_setup_decomp)
    mov.l @r15, r3                      ! r3 = result_ptr (from sp[0])
    mov.l r14, @r3                      ! *result_ptr = object ptr (store result for caller)
    mov #0x0, r3                        ! r3 = 0 (extra arg pushed on stack below)
    mov.b @(r0, r14), r7               ! r7 = obj[+0x1C] (surface type byte / flags)
    extu.b r7, r7                       ! zero-extend flags byte
    mov.l r3, @-r15                     ! push 0 (5th arg for obj_setup_decomp)
    mov.l @(12, r14), r6               ! r6 = obj[+12] (stride / extra value)
    mov.w   .L_wpool_0603BCD0, r4       ! r4 = 0x00A8 (descriptor area offset)
    .byte   0xD3, 0x07    /* mov.l .L_pool_0603BCDC, r3 */  ! r3 = obj_setup_decomp
    jsr @r3                             ! call obj_setup_decomp(r4=block+0xA8, r5=obj, r6=stride, r7=flags)
    add r12, r4                         ! (delay) r4 = block_ptr + 0xA8 (descriptor area)
    mov r0, r13                         ! r13 = decomp result ptr (or NULL)
    tst r13, r13                        ! decomp succeeded?
    bf/s    .L_decomp_ok                ! non-zero -> success
    add #0x4, r15                       ! (delay) pop the extra 0 that was pushed
    bra     .L_epilogue                 ! zero -> failure
    mov #0x0, r0                        ! (delay) r0 = 0 (failure return)
.L_wpool_0603BCD0:
    .2byte  0x00A8                      /* offset 0xA8 within block (descriptor area) */
    .2byte  0xFFFF                      /* padding */
    .4byte  scene_frame_render          /* not referenced by this function (pool filler) */
.L_pool_obj_init_validate:
    .4byte  obj_init_validate           /* init road-segment object */
.L_pool_obj_setup_decomp:
    .4byte  obj_setup_decomp            /* decompose object into resource slots */
.L_decomp_ok:
    mov r13, r5                         ! r5 = decomp result (arg for sym_060401E4)
    .byte   0xD3, 0x21    /* mov.l .L_pool_0603BD68, r3 */  ! r3 = sym_060401E4 (obj[+24] setter)
    jsr @r3                             ! call sym_060401E4(r4=obj, r5=decomp_result) -- obj[+24] = decomp_result
    mov r14, r4                         ! (delay) r4 = object ptr
    .byte   0xD2, 0x20    /* mov.l .L_pool_0603BD6C, r2 */  ! r2 = nop_stub_evt (6th descriptor field)
    mov r13, r5                         ! r5 = decomp result (descriptor field 0)
    mov r12, r4                         ! r4 = block_ptr (descriptor base address)
    mov.l r2, @-r15                     ! push nop_stub_evt (stack arg 2 for cmd_desc_init)
    .byte   0xD3, 0x1F    /* mov.l .L_pool_0603BD70, r3 */  ! r3 = sym_06040C50 (5th descriptor field)
    mov.l r3, @-r15                     ! push sym_06040C50 (stack arg 1 for cmd_desc_init)
    .byte   0xD2, 0x1F    /* mov.l .L_pool_0603BD74, r2 */  ! r2 = event_priority_set (4th descriptor field)
    mov.l r2, @-r15                     ! push event_priority_set (stack arg 0 for cmd_desc_init)
    .byte   0xD7, 0x1F    /* mov.l .L_pool_0603BD78, r7 */  ! r7 = evt_status_flag_set (descriptor field 2)
    .byte   0xD6, 0x20    /* mov.l .L_pool_0603BD7C, r6 */  ! r6 = evt_cmd_enqueue (descriptor field 1)
    .byte   0xD3, 0x20    /* mov.l .L_pool_0603BD80, r3 */  ! r3 = sym_0603F8B8 (cmd_desc_init)
    jsr @r3                             ! call cmd_desc_init(r4=block+0x78, r5..r7, 3 stack args)
    add #0x78, r4                       ! (delay) r4 = &block[+0x78] (command descriptor)
    add #0xC, r15                       ! pop 3 stack args (12 bytes)
    mov r0, r4                          ! r4 = cmd_desc_init return (descriptor ptr)
    mov.l @r15, r2                      ! r2 = nop_stub_evt ptr (was stack arg 2, now at sp[0])
    mov #0x0, r3                        ! r3 = 0
    mov #0x10, r0                       ! r0 = 0x10 (byte offset within nop_stub_evt struct)
    mov.b r3, @(r0, r2)                 ! nop_stub_evt_struct[+0x10] = 0 (clear status byte)
    mov r4, r0                          ! r0 = descriptor ptr (success return value)
.L_epilogue:
    add #0x8, r15                       ! free 8 bytes of stack locals
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return (r0 = descriptor ptr or 0)
    mov.l @r15+, r14                    ! (delay) restore r14
