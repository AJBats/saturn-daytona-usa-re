/* minimap_car_dot -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060156AC - 0x0601574C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * minimap_car_dot(slot_index):
 *   Initializes a minimap car dot sprite for a given car slot. Sets up the
 *   slot's position, scale, and animation limit from a per-car template table,
 *   rebuilds the minimap vertices via track_vtx_builder, then configures the
 *   vertex table entry with the car's color palette and sprite parameters.
 *   Finally, resets the animation timer to 60 frames and advances the
 *   element_type to transition to the next animation state.
 *
 *   Steps:
 *     1. Copy 4 color palette bytes from sym_0605B8A0 template to stack
 *     2. Compute slot struct pointer (stride=68) into sym_06084FC8 array
 *     3. Copy 4 longwords from per-car init template (sym_0605B860):
 *          template[+0]  → slot[+0x04] (x_pos)
 *          template[+4]  → slot[+0x08] (y_pos)
 *          template[+8]  → slot[+0x0C] (z_pos / scale)
 *          template[+12] → slot[+0x34] (x_limit / anim bound)
 *     4. Call track_vtx_builder to recompute minimap corner vertices
 *     5. Compute vertex table pointer (stride=24) into sym_06085490
 *     6. Write sprite parameters to vertex entry:
 *          vtx[+4] = 0x01 (draw enable)
 *          vtx[+5] = 0x3A (sprite char number)
 *          vtx[+6] = color palette byte (indexed from template by slot)
 *     7. Set slot[+0x41] anim_timer = 0x3C (60 frames)
 *     8. Increment slot[+0x02] element_type (advance state)
 *
 *   Input:
 *     r13 = slot index (byte, callee-saved from caller)
 *     r14 = callee-saved (restored at epilogue)
 *   Output:
 *     slot struct and vertex table updated in-place
 *
 *   Persistent registers:
 *     r13 = slot index (passed in from caller, callee-saved)
 *     r14 = slot struct pointer (computed mid-function)
 */

    .section .text.FUN_060156AC


    .global minimap_car_dot
    .type minimap_car_dot, @function
minimap_car_dot:
    sts.l pr, @-r15                            ! save return address
    add #-0x4, r15                             ! allocate 4 bytes on stack (color template)
    mov r15, r1                                ! r1 = dst for memcpy (stack buffer)
    mov.l   .L_pool_color_template_src, r2     ! r2 = sym_0605B8A0 (4-byte color palette template)
    mov.l   .L_pool_memcpy_byte, r3            ! r3 = &memcpy_byte
    jsr @r3                                    ! memcpy_byte(nbytes=4, dst=r1, src=r2)
    mov #0x4, r0                               ! r0 = 4 bytes to copy (delay slot)
    /* --- compute slot struct pointer (stride = 68 bytes) --- */
    extu.b r13, r14                            ! r14 = slot_index (from callee-saved r13)
    mov.l   .L_pool_slot_data_base, r2         ! r2 = sym_06084FC8 (slot array base)
    extu.b r13, r4                             ! r4 = slot_index
    mov r14, r3                                ! r3 = slot_index
    shll2 r4                                   ! r4 = idx * 4
    shll2 r14                                  ! r14 = idx * 4
    shll2 r3                                   ! r3 = idx * 4
    shll2 r4                                   ! r4 = idx * 16
    shll2 r3                                   ! r3 = idx * 16
    shll2 r3                                   ! r3 = idx * 64
    add r3, r14                                ! r14 = idx*4 + idx*64 = idx * 68 (struct stride)
    exts.w r14, r14                            ! sign-extend offset to longword
    mov.l   .L_pool_car_init_template, r3      ! r3 = sym_0605B860 (per-car init template, stride=16)
    add r2, r14                                ! r14 = &slot_data[idx] (slot struct pointer)
    add r3, r4                                 ! r4 = &car_template[idx] (idx*16 offset)
    /* --- copy 4 longwords from per-car template into slot struct --- */
    mov.l @r4, r2                              ! r2 = car_template[+0x00]
    mov.l r2, @(4, r14)                        ! slot[+0x04] = x_pos (initial position)
    mov.l @(4, r4), r3                         ! r3 = car_template[+0x04]
    mov.l r3, @(8, r14)                        ! slot[+0x08] = y_pos (initial position)
    mov.l @(8, r4), r2                         ! r2 = car_template[+0x08]
    mov.l r2, @(12, r14)                       ! slot[+0x0C] = z_pos / scale (initial)
    mov.l @(12, r4), r3                        ! r3 = car_template[+0x0C]
    mov.l r3, @(52, r14)                       ! slot[+0x34] = x_limit / anim bound
    /* --- rebuild minimap vertices for this car --- */
    mov.l   .L_pool_track_vtx_builder, r3      ! r3 = &track_vtx_builder
    jsr @r3                                    ! track_vtx_builder(slot_index)
    extu.b r13, r4                             ! r4 = slot_index arg (delay slot)
    /* --- compute vertex table entry pointer (stride = 24 bytes) --- */
    extu.b r13, r4                             ! r4 = slot_index
    mov.l   .L_pool_vertex_table, r2           ! r2 = sym_06085490 (vertex table base)
    mov r4, r3                                 ! r3 = slot_index
    shll2 r4                                   ! r4 = idx * 4
    shll2 r3                                   ! r3 = idx * 4
    shll r4                                    ! r4 = idx * 8
    shll2 r3                                   ! r3 = idx * 16
    add r3, r4                                 ! r4 = idx*8 + idx*16 = idx * 24 (vtx stride)
    exts.w r4, r4                              ! sign-extend offset
    extu.b r13, r3                             ! r3 = slot_index (byte offset into template)
    add r2, r4                                 ! r4 = &vertex_entry[idx]
    mov r15, r2                                ! r2 = stack ptr (color template buffer)
    add r2, r3                                 ! r3 = &stack_template[slot_index]
    mov.b @r3, r3                              ! r3 = color palette byte for this car
    extu.b r3, r0                              ! r0 = color byte (zero-extended)
    mov.w r0, @(6, r4)                         ! vtx[+0x06] = car dot color palette index
    /* --- configure sprite parameters in vertex entry --- */
    mov #0x3C, r3                              ! r3 = 0x3C (60 frames — anim timer init)
    mov #0x1, r0                               ! r0 = 1 (draw enable flag)
    mov.b r0, @(4, r4)                         ! vtx[+0x04] = 1 (enable car dot sprite)
    mov #0x3A, r0                              ! r0 = 0x3A (sprite character number)
    mov.b r0, @(5, r4)                         ! vtx[+0x05] = 0x3A (car dot sprite char)
    /* --- reset animation timer and advance element type --- */
    mov #0x41, r0                              ! r0 = 0x41 (byte offset of anim_timer in slot)
    mov.b r3, @(r0, r14)                       ! slot[+0x41] = 0x3C (reset timer to 60 frames)
    mov.b @(2, r14), r0                        ! r0 = slot[+0x02] (current element_type)
    mov r0, r3                                 ! r3 = element_type
    add #0x1, r3                               ! r3 = element_type + 1
    mov r3, r0                                 ! r0 = new element_type
    mov.b r0, @(2, r14)                        ! slot[+0x02] = incremented element_type
    /* --- epilogue --- */
    add #0x4, r15                              ! deallocate stack template buffer
    lds.l @r15+, pr                            ! restore return address
    mov.l @r15+, r13                           ! restore r13
    rts                                        ! return to caller
    mov.l @r15+, r14                           ! restore r14 (delay slot)
.L_pool_slot_data_base:
    .4byte  sym_06084FC8
    .4byte  sym_0605B858
.L_pool_color_template_src:
    .4byte  sym_0605B8A0
.L_pool_memcpy_byte:
    .4byte  sym_06035228
.L_pool_car_init_template:
    .4byte  sym_0605B860
.L_pool_track_vtx_builder:
    .4byte  track_vtx_builder
.L_pool_vertex_table:
    .4byte  sym_06085490
