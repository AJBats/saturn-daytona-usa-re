/* engine_sound_body -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060302D2 - 0x06030540
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Engine sound parameter calculation and dispatch.
 * Two paths: live mode (reads input flags, updates engine sound detail level
 * 0-3, manages near/far scroll positions, writes packed state byte to ring
 * buffer) and replay mode (reads packed state byte from ring buffer, restores
 * engine sound parameters, applies same scroll logic).
 *
 * Structurally parallel to track_scenery_render (0x0602FDB0).
 * Ring buffer: sym_0607ED90 (base) + sym_0607ED88 (write index), size 0x2AF6.
 * Engine sound object offsets: 0xDE=detail level, 0x6C/0x74=near scroll,
 * 0x88/0x8C/0x90=far scroll.
 */

    .section .text.FUN_060302D2


    .global engine_sound_body
    .type engine_sound_body, @function
engine_sound_body:
    mov.l r14, @-r15                   ! save callee-saved regs
    sts.l pr, @-r15
    mov #0x0, r9                       ! r9 = packed state byte (accumulates flags)
    mov r0, r6
    mov #0x1, r5                       ! r5 = const 1 (activate flag)
    mov #0x0, r7                       ! r7 = const 0 (deactivate flag)
    .byte   0xD0, 0x04    /* mov.l .L_snd_obj_ptr, r0 */
    mov.l @r0, r0                      ! r0 = engine sound object base ptr
    .byte   0xD1, 0x04    /* mov.l .L_replay_mode_flag, r1 */
    mov.w @r1, r2                      ! r2 = replay mode flag
    tst r2, r2
    bt      .L_live_mode               ! zero => live (input-driven) mode
    bra     .L_replay_mode             ! nonzero => replay (ring buffer read) mode
    nop
    .2byte  0x0000
.L_snd_obj_ptr:
    .4byte  sym_0607E944               ! ptr to engine sound object base
.L_replay_mode_flag:
    .4byte  sym_0607ED8C               ! word: nonzero = replay playback
.L_live_mode:                          ! --- LIVE MODE: read input, update state ---
    .byte   0xD2, 0x08    /* mov.l .L_input_state_a, r2 */
    mov.w @r2, r1                      ! r1 = current button state word A
    extu.w r1, r1
    .byte   0xD2, 0x08    /* mov.l .L_btn_mask_zoom_in, r2 */
    mov.w @r2, r2                      ! r2 = zoom-in button mask
    mov.w   .L_off_detail_level, r3    ! r3 = offset 0xDE (detail level in obj)
    cmp/pl r2                          ! positive => buttons have priority direction
    bf      .L_check_detail_3          ! negative => check direct detail selectors
    tst r1, r2                         ! test zoom-in mask against input
    bt      .L_check_zoom_out          ! not pressed => try zoom-out
    mov.w @(r0, r3), r4               ! r4 = current detail level
    tst r4, r4
    bt      .L_store_detail            ! already 0 => no decrement
    add #-0x1, r4                      ! zoom in => decrease detail level
.L_store_detail:
    bra     .L_detail_done
    mov.w r4, @(r0, r3)               ! store updated detail level
.L_off_detail_level:
    .2byte  0x00DE                     ! engine sound detail level (0-3)
    .2byte  0x0000
.L_input_state_a:
    .4byte  sym_06063D9A               ! button state word A
.L_btn_mask_zoom_in:
    .4byte  sym_0608188A               ! mask: zoom-in / detail decrease
.L_check_zoom_out:
    .byte   0xD2, 0x05    /* mov.l .L_btn_mask_zoom_out, r2 */
    mov.w @r2, r2                      ! r2 = zoom-out button mask
    tst r1, r2                         ! test zoom-out mask against input
    bt      .L_detail_done             ! not pressed => keep current detail
    mov.w @(r0, r3), r4               ! r4 = current detail level
    mov #0x3, r2
    cmp/eq r4, r2                      ! already at max detail 3?
    bt      .L_zoom_out_clamped
    add #0x1, r4                       ! zoom out => increase detail level
.L_zoom_out_clamped:
    bra     .L_detail_done
    mov.w r4, @(r0, r3)               ! store updated detail level
    .2byte  0x0000
.L_btn_mask_zoom_out:
    .4byte  sym_06081888               ! mask: zoom-out / detail increase
.L_check_detail_3:
    .byte   0xD2, 0x03    /* mov.l .L_btn_mask_detail_3, r2 */
    mov.w @r2, r2                      ! r2 = detail-3 select mask
    tst r1, r2
    bt      .L_check_detail_2          ! not pressed => try detail 2
    mov #0x3, r4                       ! set detail = 3 directly
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_detail_3:
    .4byte  sym_06081896               ! mask: direct detail 3 select
.L_check_detail_2:
    .byte   0xD2, 0x03    /* mov.l .L_btn_mask_detail_2, r2 */
    mov.w @r2, r2                      ! r2 = detail-2 select mask
    tst r1, r2
    bt      .L_check_detail_1          ! not pressed => try detail 1
    mov #0x2, r4                       ! set detail = 2 directly
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_detail_2:
    .4byte  sym_06081894               ! mask: direct detail 2 select
.L_check_detail_1:
    .byte   0xD2, 0x03    /* mov.l .L_btn_mask_detail_1, r2 */
    mov.w @r2, r2                      ! r2 = detail-1 select mask
    tst r1, r2
    bt      .L_check_detail_0          ! not pressed => try detail 0
    mov #0x1, r4                       ! set detail = 1 directly
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_detail_1:
    .4byte  sym_06081892               ! mask: direct detail 1 select
.L_check_detail_0:
    .byte   0xD2, 0x0F    /* mov.l .L_btn_mask_detail_0, r2 */
    mov.w @r2, r2                      ! r2 = detail-0 select mask
    tst r1, r2
    bt      .L_detail_done             ! not pressed => keep current detail
    mov #0x0, r4                       ! set detail = 0 directly
    mov.w r4, @(r0, r3)
.L_detail_done:                        ! --- detail level resolved ---
    mov.w @(r0, r3), r4               ! r4 = final detail level
    mov r4, r9                         ! r9 bits[1:0] = detail level
    .byte   0xD3, 0x0C    /* mov.l .L_input_state_b, r3 */
    mov.w @r3, r1                      ! r1 = button state word B
    extu.w r1, r1
    mov #0x1, r5
    .byte   0xD2, 0x0B    /* mov.l .L_btn_mask_near_scroll, r2 */
    mov.w @r2, r2                      ! r2 = near-scroll button mask
    tst r1, r2
    bt      .L_no_near_scroll          ! not pressed => decay near scroll
    mov #-0x80, r8
    extu.b r8, r8                      ! r8 = 0x80
    or r8, r9                          ! r9 bit7 = near scroll active
    mov.w   DAT_060303b6, r2          ! r2 = offset 0x6C (near scroll active)
    mov.l r5, @(r0, r2)               ! obj[0x6C] = 1 (activate)
    add #0x8, r2                       ! r2 = 0x74 (near scroll position)
    mov.w   .L_near_scroll_max, r8     ! r8 = 0xB8 (max)
    mov.l @(r0, r2), r4               ! r4 = current near scroll pos
    cmp/gt r8, r4
    bt      .L_near_scroll_store       ! already past max => keep
    add #0x4, r4                       ! increment by 0x4 per frame
.L_near_scroll_store:
    bra     .L_check_far_scroll
    mov.l r4, @(r0, r2)               ! store updated near scroll pos

    .global DAT_060303b6
DAT_060303b6:
    .2byte  0x006C                     ! offset: near scroll active flag
.L_near_scroll_max:
    .2byte  0x00B8                     ! near scroll max value
    .2byte  0x0000
.L_btn_mask_detail_0:
    .4byte  sym_06081890               ! mask: direct detail 0 select
.L_input_state_b:
    .4byte  g_pad_state               ! button state word B
.L_btn_mask_near_scroll:
    .4byte  sym_0608188C               ! mask: near scroll trigger
.L_no_near_scroll:                     ! near scroll not pressed => decay
    mov.w   DAT_06030402, r3          ! r3 = offset 0x74 (near scroll pos)
    mov #0x38, r5                      ! r5 = floor 0x38
    mov.l @(r0, r3), r4               ! r4 = current near scroll pos
    add #-0x2, r4                      ! slow decay: subtract 2
    cmp/gt r5, r4                      ! still above floor?
    bt      .L_near_decay_store
    mov r5, r4                         ! clamp to floor 0x38
.L_near_decay_store:
    mov.l r4, @(r0, r3)               ! store decayed near scroll pos
    .byte   0xD2, 0x0B    /* mov.l .L_off_near_active_l, r2 */
    mov #0x0, r7
    mov.l r7, @(r0, r2)               ! obj[0x6C] = 0 (deactivate near scroll)
.L_check_far_scroll:                   ! --- check far scroll button ---
    .byte   0xD2, 0x0B    /* mov.l .L_btn_mask_far_scroll, r2 */
    mov.w @r2, r2                      ! r2 = far-scroll button mask
    tst r1, r2
    bt      .L_no_far_scroll           ! not pressed => decay far scroll
    mov #0x40, r8
    or r8, r9                          ! r9 bit6 = far scroll active
    .byte   0xD3, 0x09    /* mov.l .L_off_far_active, r3 */
    mov.l r5, @(r0, r3)               ! obj[0x88] = 1 (activate)
    .byte   0xD3, 0x09    /* mov.l .L_off_far_pos, r3 */
    mov.l @(r0, r3), r4               ! r4 = current far scroll pos
    .byte   0xD6, 0x09    /* mov.l .L_off_far_prev, r6 */
    mov.w   .L_far_scroll_max, r8     ! r8 = 0xB8 (max)
    mov.l r4, @(r0, r6)               ! save previous pos to obj[0x8C]
    cmp/gt r8, r4
    bt      .L_far_scroll_store        ! past max => keep
    add #0x5, r4                       ! increment by 0x5 per frame
.L_far_scroll_store:
    bra     .L_write_ringbuf
    mov.l r4, @(r0, r3)               ! store updated far scroll pos

    .global DAT_06030402
DAT_06030402:
    .2byte  0x0074                     ! offset: near scroll position
.L_far_scroll_max:
    .2byte  0x00B8                     ! far scroll max value
    .2byte  0x0000
.L_off_near_active_l:
    .4byte  0x0000006C                 ! offset: near scroll active (as .4byte)
.L_btn_mask_far_scroll:
    .4byte  sym_0608188E               ! mask: far scroll trigger
.L_off_far_active:
    .4byte  0x00000088                 ! offset: far scroll active flag
.L_off_far_pos:
    .4byte  0x00000090                 ! offset: far scroll position
.L_off_far_prev:
    .4byte  0x0000008C                 ! offset: far scroll previous pos
.L_no_far_scroll:                      ! far scroll not pressed => decay
    .byte   0xD3, 0x10    /* mov.l .L_off_far_pos_l, r3 */
    mov.l @(r0, r3), r4               ! r4 = current far scroll pos
    .byte   0xD6, 0x10    /* mov.l .L_off_far_prev_l, r6 */
    mov.l r4, @(r0, r6)               ! save previous pos to obj[0x8C]
    mov #0x38, r3                      ! r3 = floor 0x38
    add #-0x5, r4                      ! decay: subtract 5
    cmp/ge r3, r4                      ! still above floor?
    bt      .L_far_decay_clamped
    mov r3, r4                         ! clamp to floor 0x38
.L_far_decay_clamped:
    .byte   0xD3, 0x0C    /* mov.l .L_off_far_pos_l, r3 */
    mov.l r4, @(r0, r3)               ! store decayed far scroll pos
    .byte   0xD3, 0x0D    /* mov.l .L_off_far_active_l, r3 */
    mov.l r7, @(r0, r3)               ! obj[0x88] = 0 (deactivate far scroll)
.L_write_ringbuf:                      ! --- write packed state to ring buffer ---
    .byte   0xD2, 0x0D    /* mov.l .L_ringbuf_base, r2 */
    .byte   0xD4, 0x0D    /* mov.l .L_ringbuf_index, r4 */
    mov.l @r4, r6                      ! r6 = current write index
    add r6, r2                         ! r2 = ringbuf_base + index
    add #0x2, r6                       ! advance index by 2
    mov.b r9, @r2                      ! write packed state byte to ring buffer
    mov.w   DAT_0603045e, r3          ! r3 = 0x2AF6 (ring buffer size)
    cmp/gt r6, r3                      ! index < size?
    bt      .L_ringbuf_wrap            ! yes => no wrap needed
    add #-0x2, r6                      ! undo advance (wrap back)
.L_ringbuf_wrap:
    mov.l r6, @r4                      ! store updated write index
    lds.l @r15+, pr                    ! restore callee-saved regs + return
    mov.l @r15+, r14
    mov.l @r15+, r13
    mov.l @r15+, r12
    mov.l @r15+, r11
    mov.l @r15+, r10
    mov.l @r15+, r9
    rts
    mov.l @r15+, r8

    .global DAT_0603045e
DAT_0603045e:
    .2byte  0x2AF6                     ! ring buffer size
.L_off_far_pos_l:
    .4byte  0x00000090                 ! offset: far scroll pos (as .4byte)
.L_off_far_prev_l:
    .4byte  0x0000008C                 ! offset: far scroll prev (as .4byte)
.L_off_far_active_l:
    .4byte  0x00000088                 ! offset: far scroll active (as .4byte)
.L_ringbuf_base:
    .4byte  sym_0607ED90               ! ring buffer base address
.L_ringbuf_index:
    .4byte  sym_0607ED88               ! ring buffer write index
.L_replay_mode:                        ! --- REPLAY MODE: read state from ring buffer ---
    .byte   0xD2, 0x0F    /* mov.l .L_rp_ringbuf_base, r2 */
    .byte   0xD4, 0x10    /* mov.l .L_rp_ringbuf_index, r4 */
    mov.l @r4, r6                      ! r6 = current read index
    add r6, r2                         ! r2 = ringbuf_base + index
    add #0x2, r6                       ! advance index by 2
    mov.b @r2, r1                      ! r1 = packed state byte from ring buffer
    mov.w   DAT_060304ac, r3          ! r3 = offset 0xDE (detail level)
    extu.b r1, r1                      ! zero-extend state byte
    mov r1, r5
    mov #0x3, r2
    and r2, r5                         ! r5 = bits[1:0] = detail level
    mov.w r5, @(r0, r3)               ! obj[0xDE] = detail level from replay
    mov.l r6, @r4                      ! store updated read index
    mov #0x1, r5                       ! r5 = const 1 (activate flag)
    mov #-0x80, r2
    extu.b r2, r2                      ! r2 = 0x80
    tst r1, r2                         ! test bit7 (near scroll active)
    bt      .L_rp_no_near_scroll       ! bit7 clear => decay near scroll
    mov.w   DAT_060304ae, r2          ! r2 = offset 0x6C (near scroll active)
    mov.l r5, @(r0, r2)               ! obj[0x6C] = 1 (activate)
    add #0x8, r2                       ! r2 = 0x74 (near scroll position)
    mov.w   .L_rp_near_scroll_max, r8 ! r8 = 0xB8 (max)
    mov.l @(r0, r2), r4               ! r4 = current near scroll pos
    cmp/gt r8, r4
    bt      .L_rp_near_scroll_store    ! already past max => keep
    add #0x4, r4                       ! increment by 0x4 per frame
.L_rp_near_scroll_store:
    bra     .L_rp_check_far_scroll
    mov.l r4, @(r0, r2)               ! store updated near scroll pos

    .global DAT_060304ac
DAT_060304ac:
    .2byte  0x00DE                     ! offset: detail level (replay)

    .global DAT_060304ae
DAT_060304ae:
    .2byte  0x006C                     ! offset: near scroll active (replay)
.L_rp_near_scroll_max:
    .2byte  0x00B8                     ! near scroll max value (replay)
    .2byte  0x0000
.L_rp_ringbuf_base:
    .4byte  sym_0607ED90               ! ring buffer base address
.L_rp_ringbuf_index:
    .4byte  sym_0607ED88               ! ring buffer read index
.L_rp_no_near_scroll:                  ! replay: near scroll not active => decay
    mov.w   DAT_060304f0, r3          ! r3 = offset 0x74 (near scroll pos)
    mov #0x38, r5                      ! r5 = floor 0x38
    mov.l @(r0, r3), r4               ! r4 = current near scroll pos
    add #-0x2, r4                      ! slow decay: subtract 2
    cmp/ge r5, r4                      ! still above floor?
    bt      .L_rp_near_decay_store
    mov r5, r4                         ! clamp to floor 0x38
.L_rp_near_decay_store:
    mov.l r4, @(r0, r3)               ! store decayed near scroll pos
    .byte   0xD2, 0x09    /* mov.l .L_rp_off_near_active, r2 */
    mov #0x0, r7
    mov.l r7, @(r0, r2)               ! obj[0x6C] = 0 (deactivate near scroll)
.L_rp_check_far_scroll:                ! --- replay: check far scroll bit ---
    mov #0x40, r2                      ! r2 = 0x40 (bit6 mask)
    tst r1, r2                         ! test bit6 (far scroll active)
    bt      .L_rp_no_far_scroll        ! bit6 clear => decay far scroll
    .byte   0xD3, 0x07    /* mov.l .L_rp_off_far_active, r3 */
    mov.l r5, @(r0, r3)               ! obj[0x88] = 1 (activate)
    .byte   0xD3, 0x07    /* mov.l .L_rp_off_far_pos, r3 */
    mov.l @(r0, r3), r4               ! r4 = current far scroll pos
    .byte   0xD6, 0x07    /* mov.l .L_rp_off_far_prev, r6 */
    mov.w   .L_rp_far_scroll_max, r8  ! r8 = 0xB8 (max)
    mov.l r4, @(r0, r6)               ! save previous pos to obj[0x8C]
    cmp/gt r8, r4
    bt      .L_rp_far_scroll_store     ! past max => keep
    add #0x5, r4                       ! increment by 0x5 per frame
.L_rp_far_scroll_store:
    bra     .L_rp_epilogue
    mov.l r4, @(r0, r3)               ! store updated far scroll pos

    .global DAT_060304f0
DAT_060304f0:
    .2byte  0x0074                     ! offset: near scroll position (replay)
.L_rp_far_scroll_max:
    .2byte  0x00B8                     ! far scroll max value (replay)
.L_rp_off_near_active:
    .4byte  0x0000006C                 ! offset: near scroll active (replay, as .4byte)
.L_rp_off_far_active:
    .4byte  0x00000088                 ! offset: far scroll active (replay)
.L_rp_off_far_pos:
    .4byte  0x00000090                 ! offset: far scroll position (replay)
.L_rp_off_far_prev:
    .4byte  0x0000008C                 ! offset: far scroll previous (replay)
.L_rp_no_far_scroll:                   ! replay: far scroll not active => decay
    .byte   0xD3, 0x0A    /* mov.l .L_rp_off_far_pos_l, r3 */
    mov.l @(r0, r3), r4               ! r4 = current far scroll pos
    .byte   0xD6, 0x0A    /* mov.l .L_rp_off_far_prev_l, r6 */
    mov.l r4, @(r0, r6)               ! save previous pos to obj[0x8C]
    mov #0x38, r3                      ! r3 = floor 0x38
    add #-0x5, r4                      ! decay: subtract 5
    cmp/ge r3, r4                      ! still above floor?
    bt      .L_rp_far_decay_clamped
    mov r3, r4                         ! clamp to floor 0x38
.L_rp_far_decay_clamped:
    .byte   0xD3, 0x06    /* mov.l .L_rp_off_far_pos_l, r3 */
    mov.l r4, @(r0, r3)               ! store decayed far scroll pos
    .byte   0xD3, 0x07    /* mov.l .L_rp_off_far_active_l, r3 */
    mov.l r7, @(r0, r3)               ! obj[0x88] = 0 (deactivate far scroll)
.L_rp_epilogue:                        ! --- replay epilogue ---
    lds.l @r15+, pr                    ! restore callee-saved regs + return
    mov.l @r15+, r14
    mov.l @r15+, r13
    mov.l @r15+, r12
    mov.l @r15+, r11
    mov.l @r15+, r10
    mov.l @r15+, r9
    rts
    mov.l @r15+, r8
.L_rp_off_far_pos_l:
    .4byte  0x00000090                 ! offset: far scroll pos (replay, as .4byte)
.L_rp_off_far_prev_l:
    .4byte  0x0000008C                 ! offset: far scroll prev (replay, as .4byte)
.L_rp_off_far_active_l:
    .4byte  0x00000088                 ! offset: far scroll active (replay, as .4byte)

    .global sym_0603053C
sym_0603053C:
    mov.l r12, @-r15
    mov.l r13, @-r15
