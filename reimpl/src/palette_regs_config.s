/* palette_regs_config -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036E1C - 0x06036E90
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Word-aligned strcmp: compare two null-terminated strings using
 * longword reads (4 bytes at a time). Called as the fast path from
 * sym_06036D14 (strcmp) when both pointers are 4-byte aligned.
 *   Input:  r0 = str_a (word-aligned), r1 = str_b (word-aligned)
 *   Output: r0 = byte difference (0 if equal)
 * Caller has already pushed r3 and r4 onto the stack.
 */

    .section .text.FUN_06036E1C


    .global palette_regs_config
    .type palette_regs_config, @function
palette_regs_config:
    mov.l r5, @-r15                     ! save r5 (used as zero constant)
    mov.l @r0+, r3                      ! r3 = next word from str_a
    mov #0x0, r5                        ! r5 = 0 (null reference for cmp/str)
    mov.l @r1+, r4                      ! r4 = next word from str_b
.L_word_compare_loop:
    cmp/str r5, r4                      ! any byte in r4 == 0? (null terminator check)
    bt      .L_byte_fallback            ! yes — switch to byte-by-byte comparison
    cmp/eq r3, r4                       ! words match?
    bf      .L_done                     ! no — exit with difference
    mov.l @r1+, r4                      ! r4 = next word from str_b
    cmp/str r5, r4                      ! null terminator in r4?
    bt/s    .L_byte_fallback            ! yes — byte fallback (delay: load next str_a word)
    mov.l @r0+, r3                      ! r3 = next word from str_a
    cmp/eq r3, r4                       ! words match?
    bf      .L_done                     ! no — exit with difference
    mov.l @r1+, r4                      ! r4 = next word from str_b
    cmp/str r5, r4                      ! null terminator in r4?
    bt/s    .L_byte_fallback            ! yes — byte fallback (delay: load next str_a word)
    mov.l @r0+, r3                      ! r3 = next word from str_a
    cmp/eq r3, r4                       ! words match?
    bf      .L_done                     ! no — exit with difference
    mov.l @r1+, r4                      ! r4 = next word from str_b
    cmp/str r5, r4                      ! null terminator in r4?
    bt/s    .L_byte_fallback            ! yes — byte fallback (delay: load next str_a word)
    mov.l @r0+, r3                      ! r3 = next word from str_a
    cmp/eq r3, r4                       ! words match?
    bf      .L_done                     ! no — exit with difference
    mov.l @r0+, r3                      ! r3 = next word from str_a (5th iteration start)
    bra     .L_word_compare_loop        ! loop back for next batch of 4 words
    mov.l @r1+, r4                      ! r4 = next word from str_b (delay slot)
.L_byte_fallback:
    add #-0x4, r0                       ! back up str_a pointer (undo last post-increment)
    add #-0x4, r1                       ! back up str_b pointer (undo last post-increment)
    mov.b @r0+, r3                      ! r3 = byte 0 from str_a
    mov.b @r1+, r4                      ! r4 = byte 0 from str_b
    cmp/eq r5, r4                       ! str_b byte == null?
    bt      .L_done                     ! yes — end of string, compute difference
    cmp/eq r3, r4                       ! bytes match?
    bf      .L_done                     ! no — exit with difference
    mov.b @r0+, r3                      ! r3 = byte 1 from str_a
    mov.b @r1+, r4                      ! r4 = byte 1 from str_b
    cmp/eq r5, r4                       ! str_b byte == null?
    bt      .L_done                     ! yes — end of string
    cmp/eq r3, r4                       ! bytes match?
    bf      .L_done                     ! no — exit with difference
    mov.b @r0+, r3                      ! r3 = byte 2 from str_a
    mov.b @r1+, r4                      ! r4 = byte 2 from str_b
    cmp/eq r5, r4                       ! str_b byte == null?
    bt      .L_done                     ! yes — end of string
    cmp/eq r3, r4                       ! bytes match?
    bf      .L_done                     ! no — exit with difference
    mov.b @r0+, r3                      ! r3 = byte 3 from str_a
    mov.b @r1+, r4                      ! r4 = byte 3 from str_b
.L_done:
    sub r4, r3                          ! r3 = str_a_byte - str_b_byte (difference)
    mov.l @r15+, r5                     ! restore r5
    mov r3, r0                          ! r0 = return value (byte difference)
    mov.l @r15+, r4                     ! restore r4 (pushed by caller)
    rts                                 ! return to caller
    mov.l @r15+, r3                     ! restore r3 (pushed by caller, delay slot)
    .2byte  0x0000
