/* evt_validate_multi -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060405B8 - 0x06040668
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_060405B8

/*
 * evt_validate_multi
 *
 * Calls evt_validator_pair to validate an event, then distributes the
 * results to optional output pointers and maps the validator's type nibble
 * to a simplified category code via a jump table.
 *
 * Arguments:
 *   r4 — pointer to receive a 32-bit long result (or NULL to skip)
 *   r5 — pointer to receive a 16-bit word result (or NULL to skip)
 *
 * Returns:
 *   r0 — category code (0-5) derived from the low nibble of the
 *         validator's first output byte:
 *           nibble 0 → 2    nibble 6 → 3
 *           nibble 1 → 0    nibble 7 → 4
 *           nibble 2 → 0    nibble 8 → 1
 *           nibble 3 → 1    nibble 9 → 5
 *           nibble 4 → 2    nibble 10 → 5
 *           nibble 5 → 1    default (>=11) → 5
 *
 * Stack frame (20 bytes):
 *   [sp+0]  — saved r4 (out_long_ptr)
 *   [sp+4]  — saved r5 (out_word_ptr)
 *   [sp+8]  — 12-byte buffer passed to evt_validator_pair
 */

    .global evt_validate_multi
    .type evt_validate_multi, @function
evt_validate_multi:
    sts.l pr, @-r15                 ! save return address
    add #-0x14, r15                 ! allocate 20-byte stack frame
    mov.l r4, @r15                  ! [sp+0] = out_long_ptr
    mov r15, r4                     ! r4 = sp (will offset to buffer)
    mov.l r5, @(4, r15)            ! [sp+4] = out_word_ptr
    mov.l   .L_pool_validator_pair, r3 ! r3 = &evt_validator_pair
    jsr @r3                         ! call evt_validator_pair(sp+8)
    add #0x8, r4                    ! delay: r4 = sp+8 (validator buffer)
    mov r0, r4                      ! r4 = validator word result (return value)
    mov.l @(4, r15), r0             ! r0 = out_word_ptr
    tst r0, r0                      ! test if out_word_ptr is NULL
    bt      .L_skip_word_store      ! skip store if NULL
    mov.l @(4, r15), r3             ! r3 = out_word_ptr
    mov.w r4, @r3                   ! *out_word_ptr = validator word result
.L_skip_word_store:
    mov.l @r15, r0                  ! r0 = out_long_ptr
    tst r0, r0                      ! test if out_long_ptr is NULL
    bt      .L_skip_long_store      ! skip store if NULL
    mov.l @r15, r3                  ! r3 = out_long_ptr
    mov r15, r2                     ! r2 = sp
    add #0x8, r2                    ! r2 = sp+8 (validator buffer)
    mov.l @(8, r2), r1              ! r1 = buffer[8..11] (32-bit result from validator)
    mov.l r1, @r3                   ! *out_long_ptr = long result
.L_skip_long_store:
    mov r15, r0                     ! r0 = sp
    add #0x8, r0                    ! r0 = sp+8 (validator buffer)
    mov.b @r0, r0                   ! r0 = buffer[0] (validator type byte)
    extu.b r0, r0                   ! zero-extend byte to 32-bit
    bra     .L_switch_entry         ! jump to switch dispatch
    and #0xF, r0                    ! delay: isolate low nibble (case index 0-15)

    /* Inline return stubs — each restores stack+PR and returns a constant.
     * These are jump targets from the switch table below; encoded as raw
     * data because the L3 generator cannot recover them as code. */
    .4byte  0x7F144F26              ! case_ret_2: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE002              !             rts; mov #0x2,r0  → return 2
    .4byte  0x7F144F26              ! case_ret_0: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE000              !             rts; mov #0x0,r0  → return 0
    .4byte  0x7F144F26              ! case_ret_1: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE001              !             rts; mov #0x1,r0  → return 1
    .4byte  0x7F144F26              ! case_ret_2b: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE002              !              rts; mov #0x2,r0  → return 2
    .4byte  0x7F144F26              ! case_ret_1b: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE001              !              rts; mov #0x1,r0  → return 1
    .4byte  0x7F144F26              ! case_ret_3: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE003              !             rts; mov #0x3,r0  → return 3
    .4byte  0x7F144F26              ! case_ret_4: add #0x14,r15; lds.l @r15+,pr
    .4byte  0x000BE004              !             rts; mov #0x4,r0  → return 4
.L_default_ret_5:
    add #0x14, r15                  ! restore stack frame
    lds.l @r15+, pr                 ! restore return address
    rts                             ! return
    mov #0x5, r0                    ! delay: return value = 5 (default/unknown)

.L_pool_validator_pair:
    .4byte  evt_validator_pair      ! pool: address of evt_validator_pair

.L_switch_entry:
    mov #0xB, r1                    ! r1 = 11 (number of valid cases)
    cmp/hs r1, r0                   ! if case_index >= 11 (unsigned)
    bt      .L_default_ret_5        ! branch to default: return 5
    shll r0                         ! r0 = case_index * 2 (word offset)
    mov r0, r1                      ! r1 = word offset for table lookup
    .word 0xC702 /* mova @(8,PC),r0 — load jump table base address */
    mov.w @(r0, r1), r0             ! r0 = signed offset from jump table[case]
    braf r0                         ! branch to (PC+4 + offset) → inline return stub
    nop                             ! delay slot

    /* Jump table — 16-bit signed offsets from braf PC+4 to inline stubs.
     * First entry is alignment padding (never accessed by mova base). */
    .word 0xFFFF /* (padding) */
    .word 0xFFAA /* case 0  → case_ret_2  (return 2) */
    .word 0xFFB2 /* case 1  → case_ret_0  (return 0) */
    .word 0xFFB2 /* case 2  → case_ret_0  (return 0) */
    .word 0xFFBA /* case 3  → case_ret_1  (return 1) */
    .word 0xFFC2 /* case 4  → case_ret_2b (return 2) */
    .word 0xFFCA /* case 5  → case_ret_1b (return 1) */
    .word 0xFFD2 /* case 6  → case_ret_3  (return 3) */
    .word 0xFFDA /* case 7  → case_ret_4  (return 4) */
    .word 0xFFBA /* case 8  → case_ret_1  (return 1) */
    .word 0xFFE2 /* case 9  → default_ret_5 (return 5) */
    .word 0xFFE2 /* case 10 → default_ret_5 (return 5) */

    /* Unreachable epilogue — dead code after jump table (all switch paths
     * return via inline stubs above). Preserved for byte-identical output. */
    add #0x14, r15                  ! restore stack frame
    lds.l @r15+, pr                 ! restore return address
    rts                             ! return
    nop                             ! delay slot (no return value set)
    .2byte  0xE500                  ! dead code: mov #0x0, r5
