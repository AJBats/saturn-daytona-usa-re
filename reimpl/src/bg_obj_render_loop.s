/* bg_obj_render_loop -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06013FC4 - 0x060140C4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Simplified background 3D object render loop — iterates over 29 trackside
 * objects (same array as multi_obj_physics), applying Z rotation, fixed-point
 * scale from a global wind/environment factor, uniform mat_scale_columns, and
 * dual transform chain dispatch (A for object table, B for display table).
 * This is the "far/background" variant of the full 3D object render loop
 * (FUN_06013E3C) — fewer per-object steps, no special-case BSR branch.
 *
 * Each entry is 32 bytes (0x20) in the animation entry array at sym_0605AD5C:
 *   [+0]  = base angle (32-bit)
 *   [+24] = per-object Z rotation angle (16-bit)
 *
 * Per-iteration:
 *   1. Pre-transform setup (sym_06026DBC) for current entry
 *   2. Transform dispatch (sym_06026E2E) with base angle 0x8000 and 1.0 scale
 *   3. Apply Z rotation from entry[+24] via mat_rot_z
 *   4. Transform dispatch with entry[0] base angle
 *   5. Reverse Z rotation (-entry[+24])
 *   6. Compute environment scale: fpmul(wind_dir_word, 1.0) + 0xB334 offset
 *   7. Uniform scale via mat_scale_columns
 *   8. Dispatch transform chain A (sym_06031D8C) from object table
 *   9. Dispatch transform chain B (sym_06031A28) from display table
 *  10. Decrement global frame counter by 0x30
 *
 * Persistent registers:
 *   r8  = mat_rot_z function pointer
 *   r9  = &global_counter (sym_06089EDC)
 *   r10 = transform dispatch function (sym_06026E2E)
 *   r11 = table index offset (increments by 4 each iteration)
 *   r13 = 1.0 fixed-point constant (0x00010000)
 *   r14 = current entry pointer (increments by 0x20 each iteration)
 */

    .section .text.FUN_06013FC4


    .global bg_obj_render_loop
    .type bg_obj_render_loop, @function
bg_obj_render_loop:
    mov.l r14, @-r15                     ! save r14 (callee-saved)
    mov.l r13, @-r15                     ! save r13
    mov.l r12, @-r15                     ! save r12
    mov.l r11, @-r15                     ! save r11
    mov.l r10, @-r15                     ! save r10
    mov.l r9, @-r15                      ! save r9
    mov.l r8, @-r15                      ! save r8
    sts.l pr, @-r15                      ! save return address
    sts.l macl, @-r15                    ! save MACL (used by mul.l)
    add #-0x8, r15                       ! allocate 8 bytes of stack locals
    mov.l   _pool_fn_rot_z, r8           ! r8 = mat_rot_z function pointer
    mov.l   _pool_global_counter, r9     ! r9 = &global_counter (sym_06089EDC)
    mov.l   _pool_fn_transform_dispatch, r10 ! r10 = transform dispatch (sym_06026E2E)
    mov.l   _pool_fp_one, r13            ! r13 = 0x00010000 (1.0 in 16.16 fixed-point)
    mov.l   _pool_fn_camera_push, r3     ! r3 = camera state push function
    jsr @r3                              ! call camera_push() — save camera state
    nop
    mov #0x0, r5                         ! r5 = 0 (initial table index offset)
    mov r5, r11                          ! r11 = 0 (table index offset, +4 per iter)
    mov.l   _pool_entry_array_base, r4   ! r4 = &entry_array[0] (sym_0605AD5C)
    mov r4, r14                          ! r14 = current entry pointer (starts at base)
    add r5, r14                          ! r14 += 0 (no offset for first entry)
    mov.w   DAT_06014080, r2             ! r2 = 0x03A0 (29 entries * 32 bytes = array size)
    add r2, r4                           ! r4 = entry_array + 0x03A0 (end of array)
    mov.l r4, @(4, r15)                  ! stack[4] = end-of-array pointer (loop bound)
    mov.l   _pool_disp_table_ptr, r3     ! r3 = &display_table_base (sym_06089E4A)
    mov.l r3, @r15                       ! stack[0] = display table pointer
.L_loop_top:
    mov.l   _pool_fn_pre_transform, r3   ! r3 = pre-transform setup function
    jsr @r3                              ! call pre-transform setup for this entry
    mov r14, r12                         ! r12 = current entry pointer (delay slot)
    mov r13, r6                          ! r6 = 1.0 (scale factor for transform)
    mov.w   DAT_06014082, r5             ! r5 = 0x8000 (180-degree base angle)
    jsr @r10                             ! transform dispatch(0, 0x8000, 1.0)
    mov #0x0, r4                         ! r4 = 0 (position param, delay slot)
    mov.w @(24, r12), r0                 ! r0 = entry[+24] (per-object Z rotation angle)
    jsr @r8                              ! mat_rot_z(angle) — apply Z rotation
    mov r0, r4                           ! r4 = Z rotation angle (delay slot)
    mov #0x0, r6                         ! r6 = 0 (no scale for second dispatch)
    mov.l @r12, r5                       ! r5 = entry[0] (base angle, 32-bit)
    jsr @r10                             ! transform dispatch(0, base_angle, 0)
    mov r6, r4                           ! r4 = 0 (delay slot)
    mov.w @(24, r12), r0                 ! r0 = re-read Z rotation angle
    mov r0, r4                           ! r4 = Z angle
    jsr @r8                              ! mat_rot_z(-angle) — reverse Z rotation
    neg r4, r4                           ! r4 = -angle (delay slot)
    mov.l   _pool_wind_dir_addr, r5      ! r5 = &wind_dir_word (sym_06084AF6)
    mov.w   DAT_06014084, r4             ! r4 = 0x03D7 (scale factor / multiplier arg)
    mov.l   _pool_fn_fpmul, r3           ! r3 = fpmul function
    mov.w @r5, r5                        ! r5 = wind_dir_word (16-bit value)
    extu.w r5, r5                        ! zero-extend to 32-bit
    mul.l r13, r5                        ! MACL = 1.0 * wind_dir (promote to 16.16 FP)
    jsr @r3                              ! r0 = fpmul(0x03D7, wind_dir_fp) — env scale
    sts macl, r5                         ! r5 = wind_dir as 16.16 FP (delay slot)
    mov.w   DAT_06014086, r12            ! r12 = 0xB334 (base scale offset, signed)
    mov.l   _pool_fn_scale_columns, r3   ! r3 = mat_scale_columns function
    add r0, r12                          ! r12 = base_offset + env_scale (combined scale)
    mov r12, r6                          ! r6 = combined scale (Z axis)
    mov r12, r5                          ! r5 = combined scale (Y axis)
    jsr @r3                              ! mat_scale_columns(scale, scale, scale) — uniform
    mov r12, r4                          ! r4 = combined scale (X axis, delay slot)
    mov #0x4, r5                         ! r5 = 4 (chain A mode / stride param)
    mov r11, r12                         ! r12 = table index offset (for obj/disp tables)
    mov.l   _pool_obj_table, r4          ! r4 = &obj_table[0] (sym_06062338)
    mov.l   _pool_fn_chain_a, r3         ! r3 = transform chain dispatch A (sym_06031D8C)
    add r11, r4                          ! r4 = &obj_table[index] (offset by r11)
    jsr @r3                              ! chain A dispatch: obj_table[index]
    mov.l @r4, r4                        ! r4 = obj_table[index] value (delay slot)
    mov #0x1, r6                         ! r6 = 1 (chain B mode param)
    mov.l @r15, r5                       ! r5 = display table pointer from stack[0]
    mov.l   _pool_disp_table, r4         ! r4 = &disp_table[0] (sym_060622C0)
    mov.l   _pool_fn_chain_b, r3         ! r3 = transform chain dispatch B (sym_06031A28)
    mov.w @r5, r5                        ! r5 = display mode (16-bit word)
    add r12, r4                          ! r4 = &disp_table[index]
    jsr @r3                              ! chain B dispatch: disp_table[index]
    mov.l @r4, r4                        ! r4 = disp_table[index] value (delay slot)
    add #0x20, r14                       ! advance entry pointer by 32 bytes (next object)
    mov.l @r9, r2                        ! r2 = global_counter value
    add #-0x30, r2                       ! decrement counter by 0x30 (rendering budget)
    mov.l r2, @r9                        ! write back decremented counter
    mov.l @(4, r15), r3                  ! r3 = end-of-array pointer from stack[4]
    cmp/hs r3, r14                       ! r14 >= end? (unsigned compare)
    bf/s    .L_loop_top                  ! branch if more entries to process
    add #0x4, r11                        ! r11 += 4 (advance table index, delay slot)
    add #0x8, r15                        ! deallocate 8 bytes of stack locals
    lds.l @r15+, macl                    ! restore MACL
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r8                      ! restore r8
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return to caller
    mov.l @r15+, r14                     ! restore r14 (delay slot)

    .global DAT_06014080
DAT_06014080:
    .2byte  0x03A0                           /* 29 * 32 = 0x03A0 (array size in bytes) */

    .global DAT_06014082
DAT_06014082:
    .2byte  0x8000                           /* 180-degree base Z rotation angle */

    .global DAT_06014084
DAT_06014084:
    .2byte  0x03D7                           /* environment scale multiplier */

    .global DAT_06014086
DAT_06014086:
    .2byte  0xB334                           /* base scale offset (signed, ~-0.3) */
_pool_fn_rot_z:
    .4byte  mat_rot_z                        /* Z-axis rotation matrix function */
_pool_global_counter:
    .4byte  sym_06089EDC                     /* global rendering budget counter */
_pool_fn_transform_dispatch:
    .4byte  sym_06026E2E                     /* transform dispatch function */
_pool_fp_one:
    .4byte  0x00010000                       /* 1.0 (16.16 fixed-point) */
_pool_fn_camera_push:
    .4byte  sym_06026E0C                     /* camera state push/save */
_pool_entry_array_base:
    .4byte  sym_0605AD5C                     /* animation entry array (32 bytes each) */
_pool_disp_table_ptr:
    .4byte  sym_06089E4A                     /* display table base pointer (16-bit) */
_pool_fn_pre_transform:
    .4byte  sym_06026DBC                     /* per-object pre-transform setup */
_pool_wind_dir_addr:
    .4byte  sym_06084AF6                     /* wind/environment direction (16-bit word) */
_pool_fn_fpmul:
    .4byte  fpmul                            /* 16.16 fixed-point multiply */
_pool_fn_scale_columns:
    .4byte  mat_scale_columns                /* uniform column scale function */
_pool_obj_table:
    .4byte  sym_06062338                     /* object transform table A (32-bit entries) */
_pool_fn_chain_a:
    .4byte  sym_06031D8C                     /* transform chain dispatch A */
_pool_disp_table:
    .4byte  sym_060622C0                     /* display transform table B (32-bit entries) */
_pool_fn_chain_b:
    .4byte  sym_06031A28                     /* transform chain dispatch B */
