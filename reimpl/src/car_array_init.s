/* car_array_init -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600629C - 0x060064F2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Initializes the car struct array for a race or attract-mode session.
 *
 * Car struct stride: 0x268 bytes (616 bytes per car).
 * Car array base: sym_06078900.
 *
 * Flow:
 *   1. Zero-clear four global state words (sym_0605DF4E..54).
 *   2. If display_mode_flag != 0 (normal race):
 *      a. Init car[1] (offset +0x268) via car_type_init, set physics defaults.
 *      b. Read 3 car param bytes from sym_0607ED90 into struct fields
 *         at offsets +0x9C, +0x7C, and +0xA2.
 *      c. If attract_cycle != 0: clear attract positions in car struct.
 *         Else: set attract defaults to 3/3.
 *      d. Init car[0] (player) via car_type_init.
 *   3. If display_mode_flag == 0 (attract/demo):
 *      Loop from index 0 to total_car_count, init each car via car_type_init.
 *   4. Post-loop: set car struct fields at +0x74/+0x90 (physics constants),
 *      read car_type_param and hud_elem_index into struct, load player_car_index.
 *   5. Call collision_setup (sym_0600D280) and scroll_setup (sym_0602E5E4).
 *   6. Set race_active_flag based on game_mode == 0xE && attract_cycle == 0.
 *   7. Initialize camera parameter chain from car struct field @+0x20.
 *   8. Configure final state variables, then tailcall coord_grid_pack.
 */

    .section .text.FUN_0600629C


    .global car_array_init
    .type car_array_init, @function
car_array_init:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov #0x0, r13                      ! r13 = 0 (zero constant throughout)
    mov.l r11, @-r15
    extu.w r13, r1                      ! r1 = 0 (zero for clearing globals)
    extu.w r13, r0                      ! r0 = 0
    extu.w r13, r3                      ! r3 = 0
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    mov.l   .L_car_array_base, r8       ! r8 = &car_array[0] (sym_06078900)
    mov.w   .L_car_struct_stride, r9   ! r9 = 0x268 (car struct size)
    mov.l   .L_fn_car_type_init, r10   ! r10 = car_type_init function ptr
    mov.l   .L_car_struct_scratch, r12 ! r12 = &scratch car ptr (sym_0607E944)
    mov.l   .L_cur_car_ptr, r14        ! r14 = &current car ptr (sym_0607E940)
    mov.l   .L_global_clear_a, r2
    mov.w r13, @r2                      ! *sym_0605DF4E = 0
    mov.l   .L_global_clear_b, r2
    mov.w r1, @r2                       ! *sym_0605DF50 = 0
    mov.l   .L_global_clear_c, r2
    mov.w r0, @r2                       ! *sym_0605DF52 = 0
    mov.l   .L_global_clear_d, r2
    mov.w r3, @r2                       ! *sym_0605DF54 = 0
    mov.l   .L_display_mode_flag, r1
    mov.b @r1, r1                       ! r1 = *display_mode_flag
    extu.b r1, r1
    tst r1, r1
    bt      .L_skip_display_init        ! if display_mode == 0 -> skip to loop-only path
    mov r8, r3                          ! --- display_mode != 0: init car[1] first ---
    add r9, r3                          ! r3 = car_array_base + 0x268 = &car[1]
    mov.l r3, @r14                      ! cur_car_ptr = &car[1]
    mov r3, r2
    mov.l r3, @r12                      ! scratch_ptr = &car[1]
    mov.l @r14, r3
    jsr @r10                            ! car_type_init(&car[1])
    mov.l r13, @(4, r3)                 ! car[1].field_04 = 0 (delay slot)
    mov.l @r12, r2                      ! r2 = &car[1]
    mov #0x38, r3
    mov #0x74, r0                       ! offset +0x74
    mov.l r3, @(r0, r2)                 ! car[1]+0x74 = 0x38 (physics constant A)
    mov.l @r12, r3
    mov #0x38, r2
    add #0x1C, r0                       ! offset +0x90
    mov.l r2, @(r0, r3)                 ! car[1]+0x90 = 0x38 (physics constant B)
    mov.l   .L_car_param_table, r4      ! r4 = &car_param_table (3 bytes)
    add #0xE, r0                        ! offset +0x9E
    mov.l @r12, r3
    mov.b @r4, r2                       ! r2 = car_param[0]
    extu.b r2, r2
    mov.w r2, @(r0, r3)                 ! car[1]+0x9E = car_param[0]
    mov.l @r12, r3
    mov.b @(1, r4), r0                  ! r0 = car_param[1]
    mov r0, r2
    extu.b r2, r2
    mov #0x7C, r0
    mov.w r2, @(r0, r3)                 ! car[1]+0x7C = car_param[1]
    mov.l @r12, r3
    mov.b @(2, r4), r0                  ! r0 = car_param[2]
    mov r0, r2
    extu.b r2, r2
    mov.w   DAT_06006360, r0            ! r0 = 0x9C
    mov.w r2, @(r0, r3)                 ! car[1]+0x9C = car_param[2]
    mov.l   .L_attract_cycle_cnt, r0
    mov.l @r0, r0                       ! r0 = attract_cycle_count
    tst r0, r0
    bt      .L_set_attract_default      ! if attract_cycle == 0 -> use defaults
    mov.l @r14, r3                      ! --- attract_cycle != 0: clear positions ---
    mov.w   DAT_06006362, r0            ! r0 = 0xDC (attract field offset)
    mov.w r13, @(r0, r3)               ! car[1]+0xDC = 0
    mov.l @r14, r3
    exts.w r13, r2
    add #0x2, r0                        ! offset +0xDE
    mov.w r2, @(r0, r3)                 ! car[1]+0xDE = 0
    bra     .L_init_player_car
    nop
.L_set_attract_default:                          ! --- attract_cycle == 0: set defaults ---
    mov.l @r14, r2
    mov #0x3, r3
    mov.w   DAT_06006362, r0            ! r0 = 0xDC
    mov.w r3, @(r0, r2)                 ! car[1]+0xDC = 3
    mov.l @r14, r3
    mov #0x3, r2
    add #0x2, r0
    mov.w r2, @(r0, r3)                 ! car[1]+0xDE = 3
.L_init_player_car:                              ! --- init car[0] (player) ---
    mov r8, r3                          ! r3 = car_array_base = &car[0]
    mov.l r8, @r14                      ! cur_car_ptr = &car[0]
    mov r3, r2
    mov.l r3, @r12                      ! scratch_ptr = &car[0]
    mov.l @r14, r3
    jsr @r10                            ! car_type_init(&car[0])
    mov.l r13, @(4, r3)                 ! car[0].field_04 = 0 (delay slot)
    bra     .L_post_loop_setup          ! skip loop, go to post-init
    nop
.L_skip_display_init:                            ! --- display_mode == 0: loop-init all cars ---
    bra     .L_car_init_loop_cond
    mov r13, r11                        ! r11 = 0 (loop counter, delay slot)
.L_car_struct_stride:
    .2byte  0x0268                      /* car struct size: 616 bytes */

    .global DAT_06006360
DAT_06006360:
    .2byte  0x009C                      /* car struct offset for param[2] */

    .global DAT_06006362
DAT_06006362:
    .2byte  0x00DC                      /* car struct offset for attract fields */
.L_car_array_base:
    .4byte  sym_06078900               /* car struct array base address */
.L_fn_car_type_init:
    .4byte  car_type_init              /* per-car type initialization function */
.L_car_struct_scratch:
    .4byte  sym_0607E944               /* scratch car struct pointer */
.L_cur_car_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_global_clear_a:
    .4byte  sym_0605DF4E               /* global state word A (zeroed on init) */
.L_global_clear_b:
    .4byte  sym_0605DF50               /* global state word B (zeroed on init) */
.L_global_clear_c:
    .4byte  sym_0605DF52               /* global state word C (zeroed on init) */
.L_global_clear_d:
    .4byte  sym_0605DF54               /* global state word D (zeroed on init) */
.L_display_mode_flag:
    .4byte  sym_06078635               /* display mode flag (byte: 0=attract) */
.L_car_param_table:
    .4byte  sym_0607ED90               /* 3-byte car parameter table */
.L_attract_cycle_cnt:
    .4byte  sym_0607EAD8               /* attract cycle counter (dword) */
.L_car_init_loop_body:                           ! --- car init loop: r11 = index ---
    mul.l r9, r11                       ! macl = index * 0x268
    sts macl, r2
    add r8, r2                          ! r2 = &car_array[index]
    mov r2, r3
    mov.l r2, @r14                      ! cur_car_ptr = &car[index]
    jsr @r10                            ! car_type_init(&car[index])
    mov.l r11, @(4, r3)                 ! car[index].field_04 = index (delay slot)
    add #0x1, r11                       ! index++
.L_car_init_loop_cond:
    mov.l   .L_total_car_count, r2
    mov.l @r2, r2                       ! r2 = total_car_count
    cmp/ge r2, r11                      ! index >= total_car_count?
    bf      .L_car_init_loop_body       ! if not, continue loop
.L_post_loop_setup:                              ! --- post-loop: set car struct fields ---
    mov.l @r12, r2                      ! r2 = scratch car ptr
    mov #0x38, r3
    mov #0x74, r0                       ! offset +0x74
    mov.l r3, @(r0, r2)                 ! car+0x74 = 0x38 (physics constant A)
    mov.l @r12, r3
    mov #0x38, r2
    add #0x1C, r0                       ! offset +0x90
    mov.l r2, @(r0, r3)                 ! car+0x90 = 0x38 (physics constant B)
    mov.l @r12, r3
    add #0xC, r0                        ! offset +0x9C
    mov.l   .L_car_type_param, r2
    mov.l @r2, r2                       ! r2 = *car_type_param
    exts.w r2, r2                       ! sign-extend to 16-bit
    mov.w r2, @(r0, r3)                 ! car+0x9C = car_type_param (word)
    mov.l @r12, r3
    add #0x2, r0                        ! offset +0x9E
    mov.l   .L_hud_elem_index, r2
    mov.w @r2, r2                       ! r2 = *hud_elem_index (word)
    mov.w r2, @(r0, r3)                 ! car+0x9E = hud_elem_index
    mov #0x7C, r0
    mov.l @r12, r3
    mov.l   .L_player_car_index, r2
    mov.l @r2, r2                       ! r2 = *player_car_index
    mov.w r2, @(r0, r3)                 ! car+0x7C = player_car_index
    mov.l   .L_fn_collision_setup, r3
    jsr @r3                             ! call collision_setup (sym_0600D280)
    nop
    mov.l   .L_fn_scroll_setup, r3
    jsr @r3                             ! call scroll_setup (sym_0602E5E4)
    nop
    mov.l   .L_game_mode, r0
    mov.l @r0, r0                       ! r0 = game_mode
    cmp/eq #0xE, r0                     ! game_mode == 0xE (attract)?
    bf      .L_clear_race_flag          ! not attract -> race_active = 0
    mov.l   .L_attract_cycle_cnt_b, r0
    mov.l @r0, r0                       ! r0 = attract_cycle_count
    tst r0, r0
    bt      .L_set_race_flag            ! attract_cycle == 0 -> race_active = 1
.L_clear_race_flag:                              ! --- race_active = 0 ---
    mov #0x0, r3
    mov.l   .L_race_active_flag, r2
    mov.l r3, @r2                       ! *race_active_flag = 0
    bra     .L_init_camera_params
    nop
.L_set_race_flag:                                ! --- race_active = 1 ---
    mov #0x1, r3
    mov.l   .L_race_active_flag, r2
    mov.l r3, @r2                       ! *race_active_flag = 1
.L_init_camera_params:                           ! --- init camera parameter chain ---
    mov.l @r12, r4                      ! r4 = scratch car ptr
    mov.l   .L_camera_yaw_store, r3
    mov.l @(32, r4), r2                 ! r2 = car+0x20 (initial yaw angle)
    mov.l r2, @r3                       ! *camera_yaw_store = car.yaw
    add #0x4, r3                        ! next word in camera params
    mov.l r13, @r3                      ! camera_yaw_store+4 = 0
    mov.l   .L_y_rot_offset, r3
    mov.l r13, @r3                      ! *y_rot_offset = 0
    mov.l   .L_cam_param_a, r3
    mov.l r13, @r3                      ! *cam_param_a = 0
    mov r3, r2                          ! --- chain-copy: propagate value through params ---
    mov.l @r2, r2                       ! r2 = *cam_param_a (just wrote 0)
    mov.l   .L_cam_param_b, r3
    mov.l r2, @r3                       ! *cam_param_b = *cam_param_a
    mov r3, r2
    mov.l @r2, r2                       ! r2 = *cam_param_b
    mov.l   .L_cam_param_c, r3
    mov.l r2, @r3                       ! *cam_param_c = *cam_param_b
    mov r3, r2
    mov.l @r2, r2                       ! r2 = *cam_param_c
    mov.l   .L_cam_param_d, r3
    mov.l r2, @r3                       ! *cam_param_d = *cam_param_c
    mov.l   .L_fixed_neg_offset, r2     ! r2 = 0xFEA00000 (fixed-point camera offset)
    mov.l   .L_cam_param_e, r3
    mov.l r2, @r3                       ! *cam_param_e = 0xFEA00000
    mov.l   .L_attract_cycle_cnt_b, r0
    mov.l @r0, r0                       ! r0 = attract_cycle_count
    tst r0, r0
    bt      .L_set_attract_pos_default  ! if attract_cycle == 0 -> set default 3/3
    mov.w   .L_attract_field_off, r0    ! r0 = 0xDC
    mov.w r13, @(r0, r4)               ! car+0xDC = 0 (clear attract field A)
    exts.w r13, r3
    add #0x2, r0                        ! offset +0xDE
    mov.w r3, @(r0, r4)                 ! car+0xDE = 0 (clear attract field B)
    bra     .L_final_state_config
    nop
.L_attract_field_off:
    .2byte  0x00DC                      /* car struct offset for attract field A */
    .2byte  0xFFFF                      /* padding / alignment */
.L_total_car_count:
    .4byte  sym_0607EA98               /* total number of cars in race */
.L_car_type_param:
    .4byte  sym_0607EAB8               /* car type parameter (dword) */
.L_hud_elem_index:
    .4byte  sym_06063F42               /* HUD element index (word) */
.L_player_car_index:
    .4byte  sym_06078868               /* player car/sprite index (dword) */
.L_fn_collision_setup:
    .4byte  sym_0600D280               /* collision_setup (in collision_passive) */
.L_fn_scroll_setup:
    .4byte  sym_0602E5E4               /* scroll_setup (in rot_scroll_hscale) */
.L_game_mode:
    .4byte  sym_0607EBC0               /* current game mode (0xE = attract) */
.L_attract_cycle_cnt_b:
    .4byte  sym_0607EAD8               /* attract cycle counter (dword) */
.L_race_active_flag:
    .4byte  sym_0607EAD0               /* race active flag (0=inactive, 1=active) */
.L_camera_yaw_store:
    .4byte  sym_06063EF0               /* camera yaw angle storage */
.L_y_rot_offset:
    .4byte  sym_06063F10               /* Y-rotation angle offset */
.L_cam_param_a:
    .4byte  sym_06063E78               /* camera param chain A */
.L_cam_param_b:
    .4byte  sym_06063E8C               /* camera param chain B */
.L_cam_param_c:
    .4byte  sym_06063E64               /* camera param chain C */
.L_cam_param_d:
    .4byte  sym_06063E50               /* camera param chain D */
.L_fixed_neg_offset:
    .4byte  0xFEA00000                 /* fixed-point camera Z offset constant */
.L_cam_param_e:
    .4byte  sym_06063F14               /* camera param chain E */
.L_set_attract_pos_default:                      ! --- attract default: set 3/3 ---
    mov #0x3, r2
    .byte   0x90, 0x59    /* mov.w .L_wpool_0600654C, r0 */  ! r0 = 0xDC (external pool)
    mov.w r2, @(r0, r4)                 ! car+0xDC = 3
    mov r2, r3
    add #0x2, r0                        ! offset +0xDE
    mov.w r3, @(r0, r4)                 ! car+0xDE = 3
.L_final_state_config:                           ! --- configure final state variables ---
    .byte   0xD3, 0x2B    /* mov.l .L_pool_06006550, r3 */   ! (external pool refs below)
    mov #0x2, r2
    mov #0x0, r5
    mov.l r13, @r3                      ! state var 0 = 0
    .byte   0xD3, 0x2A    /* mov.l .L_pool_06006554, r3 */
    mov.l r2, @r3                       ! state var 1 = 2
    mov #0x1, r2
    .byte   0xD3, 0x2A    /* mov.l .L_pool_06006558, r3 */
    mov.l r2, @r3                       ! state var 2 = 1
    .byte   0xD3, 0x2A    /* mov.l .L_pool_0600655C, r3 */   ! function call via external pool
    jsr @r3                             ! call external setup function(r4=0x8, r5=0x0)
    mov #0x8, r4                        ! (delay slot)
    .byte   0xD2, 0x29    /* mov.l .L_pool_06006560, r2 */
    .byte   0xD3, 0x2A    /* mov.l .L_pool_06006564, r3 */
    mov.l r2, @r3                       ! store config value pair A
    .byte   0xD4, 0x2A    /* mov.l .L_pool_06006568, r4 */
    .byte   0xD3, 0x2A    /* mov.l .L_pool_0600656C, r3 */
    mov.l r4, @r3                       ! store config value pair B
    .byte   0xD2, 0x2A    /* mov.l .L_pool_06006570, r2 */
    .byte   0xD3, 0x2B    /* mov.l .L_pool_06006574, r3 */
    mov.l r2, @r3                       ! store config value pair C
    .byte   0xD2, 0x2B    /* mov.l .L_pool_06006578, r2 */
    .byte   0xD3, 0x2B    /* mov.l .L_pool_0600657C, r3 */
    mov.l r2, @r3                       ! store config value pair D
    .byte   0xD3, 0x2B    /* mov.l .L_pool_06006580, r3 */
    mov.l r13, @r3                      ! state var 3 = 0
    .byte   0xD3, 0x2B    /* mov.l .L_pool_06006584, r3 */
    mov.l r4, @r3                       ! state var 4 = r4 (from external call return)
    mov #0x2, r2
    .byte   0xD3, 0x2B    /* mov.l .L_pool_06006588, r3 */
    mov.l r2, @r3                       ! state var 5 = 2
    lds.l @r15+, macl                   ! --- epilogue: restore callee-saved regs ---
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    .byte   0xA1, 0x6B    /* bra 0x060067C8 (external) */    ! tailcall coord_grid_pack
    mov.l @r15+, r14                    ! (delay slot: restore r14)
