/* best_lap_display -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015AA4 - 0x06015B48
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Marks the caller's results entry slot as active, writes a cap/threshold
 * value (0xE000) into every slot's +0x30 field, conditionally sets
 * linked entries to animation phase 2, then increments the caller's
 * own animation phase.
 *
 * On entry:
 *   r4 = caller's slot index (byte)
 *
 * Results entry struct (68 bytes per entry, at sym_06084FC8):
 *   +0x01 (byte):  active flag (1 = active)
 *   +0x02 (byte):  animation phase
 *   +0x30 (long):  cap/threshold value
 *   +0x40 (byte):  link index (references another slot)
 */

    .section .text.FUN_06015AA4


    .global best_lap_display
    .type best_lap_display, @function
best_lap_display:
    mov.l r14, @-r15                                   ! save r14
    mov.l r13, @-r15                                   ! save r13
    mov.l r12, @-r15                                   ! save r12
    mov #0x8, r13                                      ! r13 = 8 (total slot count)
    mov.w   .L_wpool_06015B40, r14                     ! r14 = 0xE000 (cap/threshold value)
    mov #0x2, r7                                       ! r7 = 2 (animation phase: active display)
    mov.l   .L_pool_entry_table, r5                    ! r5 = results entry table base
    extu.b r4, r3                                      ! r3 = slot index (zero-extended)
    mov r3, r2                                         ! r2 = slot index (copy for x64 calc)
    shll2 r3                                           ! r3 = index * 4
    shll2 r2                                           ! r2 = index * 4
    shll2 r2                                           ! r2 = index * 16
    shll2 r2                                           ! r2 = index * 64
    add r2, r3                                         ! r3 = index * 68 (struct stride)
    exts.w r3, r3                                      ! sign-extend offset
    add r5, r3                                         ! r3 = &entry[caller_slot]
    mov #0x1, r1                                       ! r1 = 1 (active flag)
    mov r1, r0                                         ! r0 = 1
    mov.b r0, @(1, r3)                                 ! entry[caller_slot].active = 1
    mov #0x0, r6                                       ! r6 = 0 (loop counter)
    extu.b r4, r12                                     ! r12 = slot index (zero-extended)
    mov r12, r3                                        ! r3 = slot index (copy for x64 calc)
    shll2 r12                                          ! r12 = index * 4
    shll2 r3                                           ! r3 = index * 4
    shll2 r3                                           ! r3 = index * 16
    shll2 r3                                           ! r3 = index * 64
    add r3, r12                                        ! r12 = index * 68 (struct stride)
    exts.w r12, r12                                    ! sign-extend offset
    add r5, r12                                        ! r12 = &entry[caller_slot] (kept for link_index reads)
.L_slot_loop:
    extu.b r6, r2                                      ! r2 = loop index (zero-extended)
    mov #0x40, r0                                      ! r0 = 0x40 (link_index field offset)
    mov r2, r3                                         ! r3 = loop index (copy for x64 calc)
    shll2 r2                                           ! r2 = index * 4
    shll2 r3                                           ! r3 = index * 4
    shll2 r3                                           ! r3 = index * 16
    shll2 r3                                           ! r3 = index * 64
    add r3, r2                                         ! r2 = index * 68 (struct stride)
    exts.w r2, r2                                      ! sign-extend offset
    add r5, r2                                         ! r2 = &entry[loop_index]
    mov.l r14, @(48, r2)                               ! entry[loop_index].cap_value = 0xE000
    mov.b @(r0, r12), r0                               ! r0 = entry[caller_slot].link_index
    extu.b r0, r0                                      ! r0 = link_index (zero-extended)
    cmp/eq #0x1, r0                                    ! link_index == 1?
    bf      .L_skip_phase_set                          ! skip if not linked
    extu.b r6, r2                                      ! r2 = loop index (zero-extended)
    mov r2, r3                                         ! r3 = loop index (copy for x64 calc)
    shll2 r2                                           ! r2 = index * 4
    shll2 r3                                           ! r3 = index * 4
    shll2 r3                                           ! r3 = index * 16
    shll2 r3                                           ! r3 = index * 64
    add r3, r2                                         ! r2 = index * 68 (struct stride)
    exts.w r2, r2                                      ! sign-extend offset
    add r5, r2                                         ! r2 = &entry[loop_index]
    extu.b r7, r1                                      ! r1 = 2 (active display phase)
    mov r1, r0                                         ! r0 = 2
    mov.b r0, @(2, r2)                                 ! entry[loop_index].anim_phase = 2
.L_skip_phase_set:
    add #0x1, r6                                       ! r6++ (advance loop counter)
    extu.b r6, r3                                      ! r3 = next index (zero-extended)
    cmp/ge r13, r3                                     ! index >= 8?
    bf      .L_slot_loop                               ! loop if more slots remain
    extu.b r4, r4                                      ! r4 = caller slot index (zero-extended)
    mov r4, r3                                         ! r3 = slot index (copy for x64 calc)
    shll2 r4                                           ! r4 = index * 4
    shll2 r3                                           ! r3 = index * 4
    shll2 r3                                           ! r3 = index * 16
    shll2 r3                                           ! r3 = index * 64
    add r3, r4                                         ! r4 = index * 68 (struct stride)
    exts.w r4, r4                                      ! sign-extend offset
    add r5, r4                                         ! r4 = &entry[caller_slot]
    mov.b @(2, r4), r0                                 ! r0 = entry[caller_slot].anim_phase
    mov r0, r2                                         ! r2 = current phase
    add #0x1, r2                                       ! r2 = phase + 1
    mov r2, r0                                         ! r0 = incremented phase
    mov.b r0, @(2, r4)                                 ! entry[caller_slot].anim_phase++
    mov.l @r15+, r12                                   ! restore r12
    mov.l @r15+, r13                                   ! restore r13
    rts                                                ! return
    mov.l @r15+, r14                                   ! restore r14 (delay slot)
.L_wpool_06015B40:
    .2byte  0xE000                                     ! cap/threshold constant
    .2byte  0xFFFF                                     ! padding
.L_pool_entry_table:
    .4byte  sym_06084FC8                               ! results entry table base (68-byte structs)
