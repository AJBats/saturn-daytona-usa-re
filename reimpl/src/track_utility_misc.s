/* track_utility_misc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060185D8 - 0x06018738
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track camera/scroll utilities — two functions:
 *
 * track_utility_misc (0x060185D8):
 *   Track-specific camera setup. Only runs when game mode == 3.
 *   1. camera_init() — reset camera state
 *   2. camera_pos(position XYZ from param table)
 *   3. mat_rot_y(0x38E3) — fixed rotation angle
 *   4. vec_copy(src → WRAM Low + 0xBABE0, 0x178 bytes)
 *   5. vec_scale(src + 0xBBD80, scale, 0x145 bytes)
 *   6. Tail-call camera_finalize()
 *
 * sym_06018634 (scroll position reset):
 *   Dispatch on race_end_state (0/1/2):
 *     State 0: Clear 8 scroll position registers + 2 scroll offsets
 *     State 1: Clear 2 scroll position registers + all 8 + 2 offsets
 *     State 2: Clear 2 scroll position + 2 offsets only
 *   Then there are 2 additional small embedded sub-functions that clear
 *   subsets of scroll registers (encoded as raw bytes after the pool).
 */

   .section .text.FUN_060185D8


   .global track_utility_misc
   .type track_utility_misc, @function
/* track_utility_misc — set up track camera for game mode 3
 *
 * Checks if current rendering mode is 3 (in-race view). If not, returns
 * immediately. Otherwise initializes camera state, sets position from a
 * parameter table, applies a fixed Y rotation, copies/scales vector data
 * into Work RAM Low, and tail-calls camera_finalize.
 */
track_utility_misc:
    mov.l r14, @-r15                    ! save r14
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l   .L_game_mode, r0            ! r0 = &game_mode byte
    mov.b @r0, r0                       ! r0 = game_mode (signed byte)
    extu.b r0, r0                       ! zero-extend to 32-bit
    cmp/eq #0x3, r0                     ! game mode == 3?
    bf      .L_skip_camera_setup        ! no → skip camera setup, return
    mov.l   .L_fn_camera_init, r3       ! r3 = &camera_init
    jsr @r3                             ! camera_init() — reset camera state
    nop                                 ! delay slot
    mov.l   .L_camera_param_table, r14  ! r14 = &param_table (X/Y/Z positions)
    mov.l   .L_fn_camera_pos, r3        ! r3 = &camera_pos
    mov.l @(8, r14), r6                 ! r6 = param[+8] = Z position
    mov.l @(4, r14), r5                 ! r5 = param[+4] = Y position
    jsr @r3                             ! camera_pos(X, Y, Z)
    mov.l @r14, r4                      ! (delay) r4 = param[+0] = X position
    mov.w   DAT_06018660, r4            ! r4 = 0x38E3 (fixed rotation angle)
    mov.l   .L_fn_rot_y, r3             ! r3 = &mat_rot_y
    jsr @r3                             ! mat_rot_y(0x38E3)
    nop                                 ! delay slot
    mov.w   .L_vec_copy_size, r5        ! r5 = 0x178 (376 bytes to copy)
    mov.l   .L_wram_low, r2             ! r2 = 0x200000 (Work RAM Low base)
    mov.l   .L_wram_offset_a, r3        ! r3 = 0xBABE0 (vec copy offset)
    mov r2, r4                          ! r4 = WRAM base
    add r3, r4                          ! r4 = WRAM_Low + 0xBABE0 (copy dest)
    mov.l   .L_fn_vec_copy, r3          ! r3 = &vec_copy
    jsr @r3                             ! vec_copy(src, dest, 0x178)
    mov.l r2, @r15                      ! (delay) save WRAM base on stack
    mov.w   .L_vec_scale_size, r6       ! r6 = 0x145 (325 bytes to scale)
    mov.l   .L_scale_factor, r5         ! r5 = &scale_factor
    mov.l @r15, r4                      ! r4 = WRAM base (reload from stack)
    mov.l   .L_wram_offset_b, r2        ! r2 = 0xBBD80 (vec scale offset)
    mov.l   .L_fn_vec_scale, r3         ! r3 = &vec_scale
    mov.w @r5, r5                       ! r5 = scale value (16-bit from table)
    jsr @r3                             ! vec_scale(dest, scale, 0x145)
    add r2, r4                          ! (delay) r4 = WRAM_Low + 0xBBD80
    add #0x4, r15                       ! free stack slot
    lds.l @r15+, pr                     ! restore return address
    mov.l   .L_fn_camera_finalize, r3   ! r3 = &camera_finalize
    jmp @r3                             ! tail-call camera_finalize()
    mov.l @r15+, r14                    ! (delay) restore r14
.L_skip_camera_setup:
    add #0x4, r15                       ! free stack slot
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay) restore r14

    .global sym_06018634
/* sym_06018634 — reset scroll position registers based on race end state
 *
 * Dispatches on race_end_state (0, 1, or 2) to clear different subsets
 * of VDP2 scroll position registers and scroll offsets. Used during
 * post-race transitions to reset the background scroll state.
 *
 * State 0: Clear all 8 scroll registers (via sub-function)
 * State 1: Clear 2 scroll offsets, both scroll positions, then all 8 regs
 * State 2: Clear scroll_pos_b, scroll_pos_a only
 */
sym_06018634:
    mov.l   .L_scroll_pos_a, r6         ! r6 = &scroll_pos_a
    mov.l   .L_scroll_pos_b, r5         ! r5 = &scroll_pos_b
    mov #0x0, r4                        ! r4 = 0 (clear value)
    mov.l   .L_race_end_state, r0       ! r0 = &race_end_state
    bra     .L_end_state_dispatch       ! → dispatch on end state value
    mov.l @r0, r0                       ! (delay) r0 = race_end_state
.L_state0_entry:                             ! --- state 0: clear all scroll regs ---
    bra     .L_clear_all_scroll_regs    ! → clear all 8 scroll registers
    nop                                 ! delay slot
.L_state1_entry:                             ! --- state 1: clear offsets + all regs ---
    extu.w r4, r2                       ! r2 = 0 (zero-extended)
    mov.l   .L_scroll_offset_a, r3      ! r3 = &scroll_offset_a
    mov.w r2, @r3                       ! scroll_offset_a = 0
    extu.w r4, r1                       ! r1 = 0
    mov.l   .L_scroll_offset_b, r3      ! r3 = &scroll_offset_b
    mov.w r1, @r3                       ! scroll_offset_b = 0
    extu.w r4, r0                       ! r0 = 0
    bra     .L_clear_pos_b_then_a       ! → clear scroll_pos_b, then pos_a
    mov.w r0, @r5                       ! (delay) scroll_pos_b = 0
.L_state2_entry:                             ! --- state 2: clear pos + offsets only ---
    extu.w r4, r2                       ! r2 = 0
    mov.w r2, @r5                       ! scroll_pos_b = 0
.L_clear_pos_b_then_a:
    extu.w r4, r4                       ! r4 = 0 (zero-extended)
    bra     .L_done_scroll_reset        ! → write scroll_pos_a and return
    mov.w r4, @r6                       ! (delay) scroll_pos_a = 0

    .global DAT_06018660
DAT_06018660:
    .2byte  0x38E3                        /* fixed rotation angle for track camera */
.L_vec_copy_size:
    .2byte  0x0178                        /* vector copy byte count (376 bytes) */
.L_vec_scale_size:
    .2byte  0x0145                        /* vector scale byte count (325 bytes) */
    .2byte  0xFFFF
.L_game_mode:
    .4byte  sym_06083254               /* game rendering mode (byte) */
.L_fn_camera_init:
    .4byte  sym_06026DBC               /* camera state initialization */
.L_camera_param_table:
    .4byte  sym_06048140               /* camera position parameters (X/Y/Z) */
.L_fn_camera_pos:
    .4byte  sym_06026E2E               /* set camera base position */
.L_fn_rot_y:
    .4byte  mat_rot_y                  /* Y-axis rotation */
.L_wram_low:
    .4byte  0x00200000                  /* Work RAM Low base */
.L_wram_offset_a:
    .4byte  0x000BABE0                  /* WRAM offset A (vec copy dest) */
.L_fn_vec_copy:
    .4byte  sym_06031D8C               /* vector copy function */
.L_scale_factor:
    .4byte  sym_06089E98               /* per-mode scale factor (16-bit) */
.L_wram_offset_b:
    .4byte  0x000BBD80                  /* WRAM offset B (vec scale dest) */
.L_fn_vec_scale:
    .4byte  sym_06031A28               /* scaled vector copy function */
.L_fn_camera_finalize:
    .4byte  sym_06026DF8               /* camera state finalization */
.L_scroll_pos_a:
    .4byte  sym_0605BE38               /* scroll position register A (16-bit) */
.L_scroll_pos_b:
    .4byte  sym_0605BE36               /* scroll position register B (16-bit) */
.L_race_end_state:
    .4byte  sym_0607EAD8               /* race end state (0/1/2 dispatch) */
.L_scroll_offset_a:
    .4byte  sym_0605BE1C               /* scroll offset A (16-bit) */
.L_scroll_offset_b:
    .4byte  sym_0605BE1E               /* scroll offset B (16-bit) */
.L_end_state_dispatch:                       ! --- end state dispatch ---
    cmp/eq #0x0, r0                     ! state == 0?
    bt      .L_state0_entry             ! → clear all scroll regs
    cmp/eq #0x1, r0                     ! state == 1?
    bt      .L_state1_entry             ! → clear offsets then all regs
    cmp/eq #0x2, r0                     ! state == 2?
    bt      .L_state2_entry             ! → clear pos only
.L_done_scroll_reset:
    rts                                 ! return
    nop                                 ! delay slot
.L_clear_all_scroll_regs:                    ! --- state 0: clear all 8+2 scroll regs ---
    mov #0x0, r4                        ! r4 = 0 (clear value)
    mov.l   .L_scroll_reg_0, r2         ! r2 = &scroll_reg_0
    exts.w r4, r0                       ! r0 = 0 (sign-extended)
    mov.w r4, @r2                       ! scroll_reg_0 = 0
    mov.l   .L_scroll_reg_1, r2         ! r2 = &scroll_reg_1
    mov.w r4, @r2                       ! scroll_reg_1 = 0
    mov.l   .L_scroll_reg_2, r2         ! r2 = &scroll_reg_2
    mov.w r0, @r2                       ! scroll_reg_2 = 0
    mov.l   .L_scroll_reg_3, r2         ! r2 = &scroll_reg_3
    exts.w r4, r0                       ! r0 = 0 (sign-extended, reload)
    mov.w r4, @r2                       ! scroll_reg_3 = 0
    mov.l   .L_scroll_reg_4, r2         ! r2 = &scroll_reg_4
    mov.w r4, @r2                       ! scroll_reg_4 = 0
    mov.l   .L_scroll_reg_5, r2         ! r2 = &scroll_reg_5
    mov.w r0, @r2                       ! scroll_reg_5 = 0
    mov.l   .L_scroll_reg_6, r2         ! r2 = &scroll_reg_6
    mov.w r4, @r2                       ! scroll_reg_6 = 0
    mov.l   .L_scroll_reg_7, r2         ! r2 = &scroll_reg_7
    rts                                 ! return
    mov.w r4, @r2                       ! (delay) scroll_reg_7 = 0
    .4byte  0xE400D20D                  /* (embedded sub-fn: raw bytes) */
    .4byte  0x634D604D                  /* clears 4 scroll regs + offsets */
    .4byte  0x2231D20C
    .4byte  0x2241D208
    .4byte  0x2201D308
    .4byte  0x000B2341
.L_scroll_reg_0:
    .4byte  sym_0605BE24               /* scroll register 0 (16-bit) */
.L_scroll_reg_1:
    .4byte  sym_0605BE22               /* scroll register 1 (16-bit) */
.L_scroll_reg_2:
    .4byte  sym_0605BE20               /* scroll register 2 (16-bit) */
.L_scroll_reg_3:
    .4byte  sym_0605BE2A               /* scroll register 3 (16-bit) */
.L_scroll_reg_4:
    .4byte  sym_0605BE26               /* scroll register 4 (16-bit) */
.L_scroll_reg_5:
    .4byte  sym_0605BE28               /* scroll register 5 (16-bit) */
.L_scroll_reg_6:
    .4byte  sym_0605BE36               /* scroll register 6 (16-bit) */
.L_scroll_reg_7:
    .4byte  sym_0605BE38               /* scroll register 7 (16-bit) */
    .4byte  sym_0605BE1C               /* (embedded pool: scroll offset A) */
    .4byte  sym_0605BE1E               /* (embedded pool: scroll offset B) */
    .4byte  0xE400D202                  /* (embedded sub-fn: raw bytes) */
    .4byte  0x2241D202                  /* clears 2 regs + offsets */
    .4byte  0x000B2241
    .4byte  sym_0605BE36               /* (embedded pool: scroll pos B) */
    .4byte  sym_0605BE38               /* (embedded pool: scroll pos A) */
