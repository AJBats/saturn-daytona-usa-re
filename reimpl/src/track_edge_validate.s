/* track_edge_validate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041EE8 - 0x06042088
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track boundary validation state machine — multi-step road edge detection
 * for AI cars. Uses a 6-state progression to validate car position against
 * track edges, road width, and post-collision recovery.
 *
 * State machine (state stored at car_state[+0x348]):
 *   State 0: Idle (no validation active, reset state)
 *   State 1: Initial edge check — call track_road_edge_b with road data
 *            (+0x035C) and road params (+0x034C), then call
 *            track_road_width_main. If width OK -> state 2, else -> exit 1.
 *   State 2: Post-collision validation — call track_post_collision with
 *            4 position parameters (+0x034C..+0x0358). If OK -> state 3,
 *            else -> exit 1.
 *   State 3: Input bit check (0x0100 mask on input status) — if set -> state 4,
 *            otherwise remain in state 3.
 *   State 4: Road width recheck with offset parameters (+0x035C, +0x034C).
 *            If OK -> state 5, else -> exit 1.
 *   State 5: Final input bit check (0x0040 mask) — if set -> state 0 (reset
 *            to idle), otherwise remain in state 5.
 *
 * Return value:
 *   r0 = current state phase (0-5) on normal exit, or 1 on validation failure
 *
 * Parameters:
 *   r4 = pointer to iteration counter (incremented at each validation step)
 *
 * Persistent registers:
 *   r12 = ai_checkpoint_validate function pointer
 *   r13 = pointer to iteration counter (passed as r4)
 *   r14 = car state base pointer (sym_060A5400, dereferenced)
 *
 * Car state struct offsets:
 *   +0x0040 = checkpoint byte (written from stack after validation)
 *   +0x0338 = data word (unused in this function, pool entry only)
 *   +0x0348 = state machine phase (0-5)
 *   +0x034C = road position parameter 0
 *   +0x0350 = road position parameter 1
 *   +0x0354 = road position parameter 2
 *   +0x0358 = road position parameter 3
 *   +0x035C = road edge data
 */

   .section .text.FUN_06041EE8


   .global track_edge_validate
   .type track_edge_validate, @function
track_edge_validate:
    mov.l r14, @-r15                     ! save r14 (car state ptr) to stack
    mov.l r13, @-r15                     ! save r13 (iteration counter ptr) to stack
    mov.l r12, @-r15                     ! save r12 (checkpoint fn ptr) to stack
    sts.l pr, @-r15                      ! save return address to stack
    add #-0x10, r15                      ! allocate 16 bytes of local stack space
    mov.l   .L_fn_checkpoint_validate, r12 ! r12 = ai_checkpoint_validate function
    mov.l   .L_car_state_base, r14       ! r14 = &car_state_base (sym_060A5400)
    mov.w   .L_off_state_phase, r1       ! r1 = 0x0348 (state phase offset)
    mov.l @r14, r0                       ! r0 = car state base pointer (deref)
    mov.l @(r0, r1), r0                  ! r0 = car_state[+0x348] = current phase
    cmp/eq #0x1, r0                      ! === State 1: initial edge check ===
    bf/s    .L_state2_check              ! if phase != 1, skip to state 2 check
    mov r4, r13                          ! r13 = iteration counter pointer (delay slot)
    mov.l @r14, r5                       ! r5 = car state base (for road edge call)
    mov.w   DAT_06041f94, r3             ! r3 = 0x035C (road edge data offset)
    mov.l @r14, r4                       ! r4 = car state base (for param load)
    mov.w   DAT_06041f96, r0             ! r0 = 0x034C (road params offset)
    add r3, r5                           ! r5 = car_state + 0x035C (road edge data ptr)
    mov.l   .L_fn_road_edge, r3          ! r3 = track_road_edge_b function
    jsr @r3                              ! call track_road_edge_b(state[+0x034C], state+0x035C)
    mov.l @(r0, r4), r4                  ! r4 = car_state[+0x034C] (delay slot: road param)
    mov r15, r4                          ! r4 = stack pointer (for checkpoint output)
    mov.l @r13, r2                       ! r2 = current iteration count
    add #0x1, r2                         ! r2 = count + 1
    mov.l r2, @r13                       ! store incremented counter
    jsr @r12                             ! call ai_checkpoint_validate(stack+4)
    add #0x4, r4                         ! r4 = stack + 4 (delay slot: output buffer)
    mov r15, r2                          ! r2 = stack pointer base
    mov #0x40, r0                        ! r0 = 0x40 (checkpoint byte offset in state)
    mov #0x0, r5                         ! r5 = 0 (unused, cleared for safety)
    mov.l @r14, r3                       ! r3 = car state base
    add #0x4, r2                         ! r2 = stack + 4 (checkpoint result location)
    mov.b @r2, r1                        ! r1 = checkpoint result byte from stack
    mov.b r1, @(r0, r3)                  ! car_state[+0x40] = checkpoint byte
    mov.l @r14, r4                       ! r4 = car state base (for road width call)
    mov.w   DAT_06041f96, r0             ! r0 = 0x034C (road params offset)
    mov.l   .L_fn_road_width, r3         ! r3 = track_road_width_main function
    jsr @r3                              ! call track_road_width_main(state[+0x034C])
    mov.l @(r0, r4), r4                  ! r4 = car_state[+0x034C] (delay slot)
    mov r0, r4                           ! r4 = road width result
    tst r4, r4                           ! test if width result == 0 (OK)
    bt      .L_state1_revalidate         ! width OK -> continue to re-validate
    bra     .L_epilogue                  ! width fail -> exit
    mov #0x1, r0                         ! r0 = 1 (delay slot: failure return code)
.L_state1_revalidate:                    ! --- re-validate checkpoint and advance to state 2 ---
    mov r15, r4                          ! r4 = stack pointer (for checkpoint output)
    jsr @r12                             ! call ai_checkpoint_validate(stack+4)
    add #0x4, r4                         ! r4 = stack + 4 (delay slot: output buffer)
    mov.l @r14, r3                       ! r3 = car state base
    mov r15, r2                          ! r2 = stack pointer base
    add #0x4, r2                         ! r2 = stack + 4
    mov.b @r2, r1                        ! r1 = checkpoint result byte
    mov #0x40, r0                        ! r0 = 0x40 (checkpoint byte offset)
    mov.b r1, @(r0, r3)                  ! car_state[+0x40] = new checkpoint byte
    mov.l @r13, r3                       ! r3 = current iteration count
    add #0x1, r3                         ! r3 = count + 1
    mov.l r3, @r13                       ! store incremented counter
    mov.l @r14, r2                       ! r2 = car state base
    mov #0x2, r3                         ! r3 = 2 (next state)
    mov.w   .L_off_state_phase, r0       ! r0 = 0x0348 (state phase offset)
    mov.l r3, @(r0, r2)                  ! car_state[+0x348] = 2 (advance to state 2)
.L_state2_check:                         ! === State 2: post-collision validation ===
    mov.l @r14, r0                       ! r0 = car state base
    mov.w   .L_off_state_phase, r1       ! r1 = 0x0348 (state phase offset)
    mov.l @(r0, r1), r0                  ! r0 = current state phase
    cmp/eq #0x2, r0                      ! is phase == 2?
    bf      .L_state3_check              ! not state 2 -> check state 3
    mov.l @r14, r7                       ! r7 = car state base (for position param 0)
    mov.w   DAT_06041f96, r0             ! r0 = 0x034C (road params offset)
    mov.l @r14, r6                       ! r6 = car state base (for position param 3)
    mov.l @r14, r5                       ! r5 = car state base (for position param 2)
    mov.l @r14, r4                       ! r4 = car state base (for position param 1)
    mov.l   .L_fn_post_collision, r3     ! r3 = track_post_collision function
    mov.l @(r0, r7), r7                  ! r7 = car_state[+0x034C] (position param 0)
    add #0xC, r0                         ! r0 = 0x0358 (position param 3 offset)
    mov.l @(r0, r6), r6                  ! r6 = car_state[+0x0358] (position param 3)
    add #-0x4, r0                        ! r0 = 0x0354 (position param 2 offset)
    mov.l @(r0, r5), r5                  ! r5 = car_state[+0x0354] (position param 2)
    add #-0x4, r0                        ! r0 = 0x0350 (position param 1 offset)
    jsr @r3                              ! call track_post_collision(p1, p2, p3, p0)
    mov.l @(r0, r4), r4                  ! r4 = car_state[+0x0350] (delay slot: param 1)
    mov r0, r4                           ! r4 = post-collision result
    tst r4, r4                           ! test if result == 0 (OK)
    bt      .L_state2_advance            ! OK -> advance to state 3
    bra     .L_epilogue                  ! fail -> exit
    mov #0x1, r0                         ! r0 = 1 (delay slot: failure return code)

    .global DAT_06041f90
DAT_06041f90:
    .word 0x0338 /* UNKNOWN */
.L_off_state_phase:
    .2byte  0x0348                       /* car state offset: validation phase (0-5) */

    .global DAT_06041f94
DAT_06041f94:
    .2byte  0x035C                       /* car state offset: road edge data */

    .global DAT_06041f96
DAT_06041f96:
    .2byte  0x034C                       /* car state offset: road parameters */
    .4byte  0x0000FFF7                   /* (adjacent pool data) */
    .4byte  smpc_cmd_helper_b            /* (adjacent pool: SMPC helper) */
.L_fn_checkpoint_validate:
    .4byte  ai_checkpoint_validate       /* AI checkpoint validation function */
.L_car_state_base:
    .4byte  sym_060A5400                 /* AI car state base (ptr to struct) */
.L_fn_road_edge:
    .4byte  track_road_edge_b            /* track road edge detection */
.L_fn_road_width:
    .4byte  track_road_width_main        /* track road width validation */
.L_fn_post_collision:
    .4byte  track_post_collision         /* post-collision track recovery */
.L_state2_advance:                       ! --- advance to state 3 ---
    mov r15, r4                          ! r4 = stack pointer (for checkpoint output)
    jsr @r12                             ! call ai_checkpoint_validate(stack+4)
    add #0x4, r4                         ! r4 = stack + 4 (delay slot: output buffer)
    mov.l @r14, r3                       ! r3 = car state base
    mov r15, r2                          ! r2 = stack pointer base
    add #0x4, r2                         ! r2 = stack + 4
    mov.b @r2, r1                        ! r1 = checkpoint result byte
    mov #0x40, r0                        ! r0 = 0x40 (checkpoint byte offset)
    mov.b r1, @(r0, r3)                  ! car_state[+0x40] = checkpoint byte
    mov.l @r13, r3                       ! r3 = current iteration count
    add #0x1, r3                         ! r3 = count + 1
    mov.l r3, @r13                       ! store incremented counter
    mov.l @r14, r2                       ! r2 = car state base
    mov #0x3, r3                         ! r3 = 3 (next state)
    mov.w   .L_off_state_phase_b, r0     ! r0 = 0x0348 (state phase offset, second pool)
    mov.l r3, @(r0, r2)                  ! car_state[+0x348] = 3 (advance to state 3)
.L_state3_check:                         ! === State 3: input bit check (0x0100) ===
    mov.l @r14, r0                       ! r0 = car state base
    mov.w   .L_off_state_phase_b, r1     ! r1 = 0x0348 (state phase offset)
    mov.l @(r0, r1), r0                  ! r0 = current state phase
    cmp/eq #0x3, r0                      ! is phase == 3?
    bf      .L_state4_check              ! not state 3 -> check state 4
    mov.w   DAT_0604207c, r2             ! r2 = 0x0100 (input bit mask for state 3)
    mov.l   .L_fn_input_check, r3        ! r3 = input status check function
    jsr @r3                              ! call input_check()
    mov.l r2, @r15                       ! save mask to stack (delay slot)
    mov r0, r4                           ! r4 = input status result
    mov.l @r15, r3                       ! r3 = restore mask (0x0100) from stack
    exts.w r4, r5                        ! r5 = sign-extend input result to longword
    and r3, r5                           ! r5 = result & 0x0100
    tst r5, r5                           ! test if masked bit is zero
    bt      .L_state3_bit_clear          ! bit clear -> set flag = 0
    bra     .L_state3_test_flag          ! bit set -> skip to flag test
    mov #0x1, r5                         ! r5 = 1 (delay slot: flag = bit is set)
.L_state3_bit_clear:
    mov #0x0, r5                         ! r5 = 0 (flag = bit is not set)
.L_state3_test_flag:
    tst r5, r5                           ! test flag
    bt      .L_state4_check              ! flag == 0 -> stay in state 3
    mov.l @r14, r3                       ! r3 = car state base
    mov #0x4, r2                         ! r2 = 4 (next state)
    mov.w   .L_off_state_phase_b, r0     ! r0 = 0x0348 (state phase offset)
    mov.l r2, @(r0, r3)                  ! car_state[+0x348] = 4 (advance to state 4)
.L_state4_check:                         ! === State 4: road width recheck ===
    mov.l @r14, r0                       ! r0 = car state base
    mov.w   .L_off_state_phase_b, r1     ! r1 = 0x0348 (state phase offset)
    mov.l @(r0, r1), r0                  ! r0 = current state phase
    cmp/eq #0x4, r0                      ! is phase == 4?
    bf      .L_state5_check              ! not state 4 -> check state 5
    mov.l @r14, r5                       ! r5 = car state base (for road data)
    mov.w   DAT_0604207e, r0             ! r0 = 0x035C (road edge data offset)
    mov.l @r14, r4                       ! r4 = car state base (for road params)
    mov.l   .L_fn_road_width_b, r3       ! r3 = track_road_width_main function
    mov.l @(r0, r5), r5                  ! r5 = car_state[+0x035C] (road edge data)
    add #-0x10, r0                       ! r0 = 0x034C (road params offset)
    jsr @r3                              ! call track_road_width_main(state[+0x034C])
    mov.l @(r0, r4), r4                  ! r4 = car_state[+0x034C] (delay slot)
    mov r0, r4                           ! r4 = road width result
    tst r4, r4                           ! test if result == 0 (OK)
    bt      .L_state4_advance            ! OK -> advance to state 5
    bra     .L_epilogue                  ! fail -> exit
    mov #0x1, r0                         ! r0 = 1 (delay slot: failure return code)
.L_state4_advance:                       ! --- advance to state 5 ---
    mov.l @r13, r3                       ! r3 = current iteration count
    add #0x1, r3                         ! r3 = count + 1
    mov.l r3, @r13                       ! store incremented counter
    mov.l @r14, r2                       ! r2 = car state base
    mov #0x5, r3                         ! r3 = 5 (next state)
    mov.w   .L_off_state_phase_b, r0     ! r0 = 0x0348 (state phase offset)
    mov.l r3, @(r0, r2)                  ! car_state[+0x348] = 5 (advance to state 5)
.L_state5_check:                         ! === State 5: final input check (0x0040) ===
    mov.l @r14, r0                       ! r0 = car state base
    mov.w   .L_off_state_phase_b, r1     ! r1 = 0x0348 (state phase offset)
    mov.l @(r0, r1), r0                  ! r0 = current state phase
    cmp/eq #0x5, r0                      ! is phase == 5?
    bf      .L_read_final_state          ! not state 5 -> read current state for return
    mov #0x40, r2                        ! r2 = 0x40 (input bit mask for state 5)
    mov.l   .L_fn_input_check, r3        ! r3 = input status check function
    jsr @r3                              ! call input_check()
    mov.l r2, @r15                       ! save mask to stack (delay slot)
    mov r0, r4                           ! r4 = input status result
    mov.l @r15, r3                       ! r3 = restore mask (0x40) from stack
    exts.w r4, r5                        ! r5 = sign-extend input result to longword
    and r3, r5                           ! r5 = result & 0x40
    tst r5, r5                           ! test if masked bit is zero
    bt      .L_state5_bit_clear          ! bit clear -> set flag = 0
    bra     .L_state5_test_flag          ! bit set -> skip to flag test
    mov #0x1, r5                         ! r5 = 1 (delay slot: flag = bit is set)
.L_state5_bit_clear:
    mov #0x0, r5                         ! r5 = 0 (flag = bit is not set)
.L_state5_test_flag:
    mov r5, r0                           ! r0 = flag value
    cmp/eq #0x1, r0                      ! is flag == 1?
    bf      .L_read_final_state          ! flag != 1 -> stay in state 5
    mov.l @r14, r3                       ! r3 = car state base
    mov #0x0, r2                         ! r2 = 0 (reset to idle state)
    mov.w   .L_off_state_phase_b, r0     ! r0 = 0x0348 (state phase offset)
    mov.l r2, @(r0, r3)                  ! car_state[+0x348] = 0 (reset to idle)
.L_read_final_state:                     ! --- read final state phase for return ---
    mov.l @r14, r0                       ! r0 = car state base
    mov.w   .L_off_state_phase_b, r1     ! r1 = 0x0348 (state phase offset)
    mov.l @(r0, r1), r0                  ! r0 = current state phase (return value)
.L_epilogue:                             ! --- function epilogue ---
    add #0x10, r15                       ! deallocate 16 bytes of local stack space
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return to caller
    mov.l @r15+, r14                     ! restore r14 (delay slot)
.L_off_state_phase_b:
    .2byte  0x0348                       /* state phase offset (dup for PC-relative reach) */

    .global DAT_0604207c
DAT_0604207c:
    .2byte  0x0100                       /* input bit mask: state 3 check */

    .global DAT_0604207e
DAT_0604207e:
    .2byte  0x035C                       /* road data offset (dup for PC-relative reach) */
.L_fn_input_check:
    .4byte  sym_06035C4E                 /* input status check function */
.L_fn_road_width_b:
    .4byte  track_road_width_main        /* road width validation (dup for reach) */
