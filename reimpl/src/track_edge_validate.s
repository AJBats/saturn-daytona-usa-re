/* track_edge_validate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041EE8 - 0x06042088
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track boundary validation state machine — multi-step road edge detection
 * for AI cars. Uses a 6-state progression to validate car position against
 * track edges, road width, and post-collision recovery.
 *
 * State machine (state stored at car_state[+0x348]):
 *   State 0: Idle (no validation)
 *   State 1: Initial edge check — call track_road_edge_b, then
 *            track_road_width_main. If width OK → state 2, else → exit 1.
 *   State 2: Post-collision validation — call track_post_collision with
 *            4 position parameters. If OK → state 3, else → exit 1.
 *   State 3: Input bit check (0x0100 mask) — if set → state 4.
 *   State 4: Road width recheck with offset parameters (+0x035C, +0x034C).
 *            If OK → state 5, else → exit 1.
 *   State 5: Input bit check (0x0040 mask) — if set → state 0 (reset).
 *
 * Parameters:
 *   r4 = iteration counter (incremented at each validation step)
 *
 * Persistent registers:
 *   r12 = ai_checkpoint_validate function
 *   r13 = iteration counter (passed as r4)
 *   r14 = car state base pointer (sym_060A5400, dereferenced)
 *
 * Car state struct offsets (larger than normal car struct):
 *   +0x0040 = checkpoint byte (written from stack)
 *   +0x0338 = UNKNOWN data word
 *   +0x0348 = state machine phase (0-5)
 *   +0x034C = road parameters (position data)
 *   +0x035C = road data (edge positions)
 */

    .section .text.FUN_06041EE8


    .global track_edge_validate
    .type track_edge_validate, @function
track_edge_validate:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    sts.l pr, @-r15
    add #-0x10, r15
    mov.l   .L_fn_checkpoint_validate, r12
    mov.l   .L_car_state_base, r14
    mov.w   .L_off_state_phase, r1   /* 0x0348 = state phase offset */
    mov.l @r14, r0                    /* dereference → car state */
    mov.l @(r0, r1), r0              /* state[+0x348] = phase */
    cmp/eq #0x1, r0                   /* === State 1: initial edge check === */
    bf/s    .L_06041F60
    mov r4, r13                       /* r13 = iteration counter */
    mov.l @r14, r5                    /* --- road edge check --- */
    mov.w   DAT_06041f94, r3        /* 0x035C = road data offset */
    mov.l @r14, r4
    mov.w   DAT_06041f96, r0        /* 0x034C = road params offset */
    add r3, r5                        /* r5 = state + 0x035C (road data) */
    mov.l   .L_fn_road_edge, r3
    jsr @r3                            /* track_road_edge_b(state+0x034C, state+0x035C) */
    mov.l @(r0, r4), r4             /* r4 = state[+0x034C] */
    mov r15, r4                       /* --- checkpoint validate --- */
    mov.l @r13, r2
    add #0x1, r2
    mov.l r2, @r13                   /* counter++ */
    jsr @r12                          /* ai_checkpoint_validate(stack+4) */
    add #0x4, r4
    mov r15, r2                       /* --- copy checkpoint byte to state --- */
    mov #0x40, r0
    mov #0x0, r5
    mov.l @r14, r3
    add #0x4, r2
    mov.b @r2, r1                     /* read checkpoint result from stack */
    mov.b r1, @(r0, r3)             /* state[+0x40] = checkpoint byte */
    mov.l @r14, r4                    /* --- road width check --- */
    mov.w   DAT_06041f96, r0
    mov.l   .L_fn_road_width, r3
    jsr @r3                            /* track_road_width_main(state[+0x034C]) */
    mov.l @(r0, r4), r4
    mov r0, r4                        /* r4 = width result */
    tst r4, r4
    bt      .L_06041F40              /* width OK → continue to re-validate */
    bra     .L_0604206E              /* width fail → exit with r0=1 */
    mov #0x1, r0
.L_06041F40:                              /* --- re-validate checkpoint and advance --- */
    mov r15, r4
    jsr @r12                          /* ai_checkpoint_validate(stack+4) */
    add #0x4, r4
    mov.l @r14, r3
    mov r15, r2
    add #0x4, r2
    mov.b @r2, r1
    mov #0x40, r0
    mov.b r1, @(r0, r3)             /* state[+0x40] = new checkpoint byte */
    mov.l @r13, r3
    add #0x1, r3
    mov.l r3, @r13                   /* counter++ */
    mov.l @r14, r2
    mov #0x2, r3
    mov.w   .L_off_state_phase, r0
    mov.l r3, @(r0, r2)             /* state[+0x348] = 2 (advance to state 2) */
.L_06041F60:                              /* === State 2: post-collision check === */
    mov.l @r14, r0
    mov.w   .L_off_state_phase, r1
    mov.l @(r0, r1), r0
    cmp/eq #0x2, r0
    bf      .L_06041FD4              /* not state 2 → check state 3 */
    mov.l @r14, r7                    /* --- load 4 position parameters --- */
    mov.w   DAT_06041f96, r0        /* 0x034C */
    mov.l @r14, r6
    mov.l @r14, r5
    mov.l @r14, r4
    mov.l   .L_fn_post_collision, r3
    mov.l @(r0, r7), r7             /* r7 = state[+0x034C] */
    add #0xC, r0                      /* 0x0358 */
    mov.l @(r0, r6), r6             /* r6 = state[+0x0358] */
    add #-0x4, r0                     /* 0x0354 */
    mov.l @(r0, r5), r5             /* r5 = state[+0x0354] */
    add #-0x4, r0                     /* 0x0350 */
    jsr @r3                            /* track_post_collision(pos[0..3]) */
    mov.l @(r0, r4), r4             /* r4 = state[+0x0350] */
    mov r0, r4
    tst r4, r4
    bt      .L_06041FB4              /* OK → advance to state 3 */
    bra     .L_0604206E              /* fail → exit with r0=1 */
    mov #0x1, r0

    .global DAT_06041f90
DAT_06041f90:
    .word 0x0338 /* UNKNOWN */
.L_off_state_phase:
    .2byte  0x0348                        /* car state offset: validation phase (0-5) */

    .global DAT_06041f94
DAT_06041f94:
    .2byte  0x035C                        /* car state offset: road edge data */

    .global DAT_06041f96
DAT_06041f96:
    .2byte  0x034C                        /* car state offset: road parameters */
    .4byte  0x0000FFF7                  /* (adjacent pool data) */
    .4byte  smpc_cmd_helper_b          /* (adjacent pool: SMPC helper) */
.L_fn_checkpoint_validate:
    .4byte  ai_checkpoint_validate     /* AI checkpoint validation function */
.L_car_state_base:
    .4byte  sym_060A5400               /* AI car state base (ptr to struct) */
.L_fn_road_edge:
    .4byte  track_road_edge_b          /* track road edge detection */
.L_fn_road_width:
    .4byte  track_road_width_main      /* track road width validation */
.L_fn_post_collision:
    .4byte  track_post_collision       /* post-collision track recovery */
.L_06041FB4:                              /* --- advance to state 3 --- */
    mov r15, r4
    jsr @r12                          /* ai_checkpoint_validate(stack+4) */
    add #0x4, r4
    mov.l @r14, r3
    mov r15, r2
    add #0x4, r2
    mov.b @r2, r1
    mov #0x40, r0
    mov.b r1, @(r0, r3)             /* state[+0x40] = checkpoint byte */
    mov.l @r13, r3
    add #0x1, r3
    mov.l r3, @r13                   /* counter++ */
    mov.l @r14, r2
    mov #0x3, r3
    mov.w   .L_off_state_phase_2, r0
    mov.l r3, @(r0, r2)             /* state[+0x348] = 3 */
.L_06041FD4:                              /* === State 3: input bit check (0x0100) === */
    mov.l @r14, r0
    mov.w   .L_off_state_phase_2, r1
    mov.l @(r0, r1), r0
    cmp/eq #0x3, r0
    bf      .L_06042004              /* not state 3 → check state 4 */
    mov.w   DAT_0604207c, r2        /* 0x0100 = input bit mask */
    mov.l   .L_fn_input_check, r3
    jsr @r3                            /* input_check() */
    mov.l r2, @r15
    mov r0, r4
    mov.l @r15, r3
    exts.w r4, r5
    and r3, r5                        /* result & 0x0100 */
    tst r5, r5
    bt      .L_06041FF6
    bra     .L_06041FF8
    mov #0x1, r5                      /* bit set → flag = 1 */
.L_06041FF6:
    mov #0x0, r5                      /* bit clear → flag = 0 */
.L_06041FF8:
    tst r5, r5
    bt      .L_06042004              /* flag == 0 → stay in state 3 */
    mov.l @r14, r3
    mov #0x4, r2
    mov.w   .L_off_state_phase_2, r0
    mov.l r2, @(r0, r3)             /* state[+0x348] = 4 */
.L_06042004:                              /* === State 4: road width recheck === */
    mov.l @r14, r0
    mov.w   .L_off_state_phase_2, r1
    mov.l @(r0, r1), r0
    cmp/eq #0x4, r0
    bf      .L_06042036              /* not state 4 → check state 5 */
    mov.l @r14, r5
    mov.w   DAT_0604207e, r0        /* 0x035C = road data offset */
    mov.l @r14, r4
    mov.l   .L_fn_road_width_2, r3
    mov.l @(r0, r5), r5             /* state[+0x035C] = road data */
    add #-0x10, r0                    /* 0x034C */
    jsr @r3                            /* track_road_width_main(state[+0x034C]) */
    mov.l @(r0, r4), r4
    mov r0, r4
    tst r4, r4
    bt      .L_06042028              /* OK → advance to state 5 */
    bra     .L_0604206E              /* fail → exit with r0=1 */
    mov #0x1, r0
.L_06042028:                              /* --- advance to state 5 --- */
    mov.l @r13, r3
    add #0x1, r3
    mov.l r3, @r13                   /* counter++ */
    mov.l @r14, r2
    mov #0x5, r3
    mov.w   .L_off_state_phase_2, r0
    mov.l r3, @(r0, r2)             /* state[+0x348] = 5 */
.L_06042036:                              /* === State 5: final input check (0x0040) === */
    mov.l @r14, r0
    mov.w   .L_off_state_phase_2, r1
    mov.l @(r0, r1), r0
    cmp/eq #0x5, r0
    bf      .L_06042068              /* not state 5 → read current state */
    mov #0x40, r2                     /* 0x40 = input bit mask */
    mov.l   .L_fn_input_check, r3
    jsr @r3                            /* input_check() */
    mov.l r2, @r15
    mov r0, r4
    mov.l @r15, r3
    exts.w r4, r5
    and r3, r5                        /* result & 0x40 */
    tst r5, r5
    bt      .L_06042058
    bra     .L_0604205A
    mov #0x1, r5                      /* bit set → flag = 1 */
.L_06042058:
    mov #0x0, r5                      /* bit clear → flag = 0 */
.L_0604205A:
    mov r5, r0
    cmp/eq #0x1, r0
    bf      .L_06042068              /* flag != 1 → stay in state 5 */
    mov.l @r14, r3
    mov #0x0, r2
    mov.w   .L_off_state_phase_2, r0
    mov.l r2, @(r0, r3)             /* state[+0x348] = 0 (reset) */
.L_06042068:                              /* --- read final state for return --- */
    mov.l @r14, r0
    mov.w   .L_off_state_phase_2, r1
    mov.l @(r0, r1), r0             /* r0 = current state phase */
.L_0604206E:
    add #0x10, r15
    lds.l @r15+, pr
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_off_state_phase_2:
    .2byte  0x0348                        /* state phase offset (dup for reach) */

    .global DAT_0604207c
DAT_0604207c:
    .2byte  0x0100                        /* input bit mask: state 3 check */

    .global DAT_0604207e
DAT_0604207e:
    .2byte  0x035C                        /* road data offset (dup for reach) */
.L_fn_input_check:
    .4byte  sym_06035C4E               /* input status check function */
.L_fn_road_width_2:
    .4byte  track_road_width_main      /* road width validation (dup for reach) */
