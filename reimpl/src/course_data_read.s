/* course_data_read -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036310 - 0x06036380
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Reads SMPC peripheral data via input_proc_analog, then issues
 * a digital read command (0x43) via input_proc_digital, and copies
 * the response bytes into the caller's output struct (r14), remapping
 * SMPC response byte order to the game's internal input layout.
 */

    .section .text.FUN_06036310


    .global course_data_read
    .type course_data_read, @function
course_data_read:
    sts.l pr, @-r15             ! save return address
    add #-0x10, r15             ! allocate 16-byte local buffer
    mov r15, r4                 ! r4 = buffer base (sp)
    mov.l   .L_pool_read_analog, r3  ! r3 = &input_proc_analog
    jsr @r3                     ! call input_proc_analog(buffer + 8)
    add #0x8, r4                ! (delay) r4 = sp + 8 — SMPC data area
    mov r15, r2                 ! r2 = sp
    mov #0x43, r3               ! r3 = 0x43 — SMPC digital read command ID
    extu.b r13, r13             ! zero-extend peripheral index to byte
    mov r15, r6                 ! r6 = sp — response destination
    mov r15, r5                 ! r5 = sp (will become sp+8 below)
    add #0x8, r2                ! r2 = sp + 8 — command buffer
    mov r13, r0                 ! r0 = peripheral index
    add #0x8, r5                ! r5 = sp + 8 — command buffer
    mov.b r3, @r2               ! [sp+8] = 0x43 — set command byte
    mov r15, r2                 ! r2 = sp
    add #0x8, r2                ! r2 = sp + 8
    mov.b r0, @(4, r2)          ! [sp+12] = peripheral index
    mov.l   .L_pool_read_digital, r3 ! r3 = &input_proc_digital
    jsr @r3                     ! call input_proc_digital(0, sp+8, sp)
    mov #0x0, r4                ! (delay) r4 = 0 — first arg
    mov r0, r4                  ! r4 = return value (status)
    mov r15, r2                 ! r2 = sp — response buffer
    mov.b @(1, r2), r0          ! r0 = response byte 1
    mov r0, r3                  ! r3 = response byte 1 (unused copy)
    mov.b r0, @(1, r14)         ! output[1] = response byte 1
    mov r15, r3                 ! r3 = sp
    mov.b @(2, r3), r0          ! r0 = response byte 2
    mov r15, r3                 ! r3 = sp
    mov.b r0, @(2, r14)         ! output[2] = response byte 2
    mov.b @(3, r3), r0          ! r0 = response byte 3
    mov r15, r3                 ! r3 = sp
    mov.b r0, @(4, r14)         ! output[4] = response byte 3
    mov.b @(5, r3), r0          ! r0 = response byte 5
    mov r15, r3                 ! r3 = sp
    mov r0, r2                  ! r2 = response byte 5
    mov.b r2, @r14              ! output[0] = response byte 5
    mov.b @(6, r3), r0          ! r0 = response byte 6
    mov r15, r3                 ! r3 = sp
    mov.b r0, @(3, r14)         ! output[3] = response byte 6
    mov.b @(7, r3), r0          ! r0 = response byte 7
    mov r0, r2                  ! r2 = response byte 7
    mov.b r0, @(5, r14)         ! output[5] = response byte 7
    mov r4, r0                  ! r0 = status return value
    add #0x10, r15              ! deallocate local buffer
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r13            ! restore r13
    rts                         ! return
    mov.l @r15+, r14            ! (delay) restore r14
    .2byte  0xFFFF              ! alignment padding
.L_pool_read_analog:
    .4byte  input_proc_analog
    .4byte  input_proc_buttons
.L_pool_read_digital:
    .4byte  input_proc_digital
