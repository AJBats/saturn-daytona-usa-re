/* ai_brake_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041258 - 0x060412B2
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06041258


    .global ai_brake_handler
    .type ai_brake_handler, @function
ai_brake_handler:
    mov.l r14, @-r15            ! save r14
    sts.l pr, @-r15             ! save return address
    add #-0xC, r15              ! allocate 12 bytes of locals
    mov.l   .L_pool_ai_car_state_ptr, r14 ! r14 = &ai_car_state_ptr
    mov.l @r14, r3              ! r3 = ai_car_state_ptr
    mov.l @(52, r3), r0         ! r0 = car[0x34] (brake zone active flag)
    tst r0, r0                  ! brake zone active?
    bf      .L_brake_zone_active ! yes — process brake zone
    mov #-0x7, r0               ! return -7 (no brake zone)
    add #0xC, r15               ! free locals
    lds.l @r15+, pr             ! restore return address
    rts                         ! return
    mov.l @r15+, r14            ! restore r14 (delay slot)
.L_brake_zone_active:
    mov.l   .L_pool_fn_brake_zone_main, r3 ! r3 = &ai_brake_zone_main
    jsr @r3                     ! call ai_brake_zone_main()
    nop                         ! (delay slot)
    mov r0, r4                  ! r4 = brake zone result
    mov #0x0, r3                ! r3 = 0
    mov.l @r14, r2              ! r2 = ai_car_state_ptr
    tst r4, r4                  ! brake zone result == 0?
    bt/s    .L_brake_calc       ! yes — proceed to calc
    mov.l r3, @(52, r2)         ! car[0x34] = 0 (clear brake flag; delay slot)
    mov #-0xA, r0               ! return -10 (brake zone error)
    add #0xC, r15               ! free locals
    lds.l @r15+, pr             ! restore return address
    rts                         ! return
    mov.l @r15+, r14            ! restore r14 (delay slot)
    .2byte  0x0328              ! (alignment padding)
.L_pool_ai_car_state_ptr:
    .4byte  sym_060A5400
.L_pool_fn_brake_zone_main:
    .4byte  ai_brake_zone_main
.L_brake_calc:
    .byte   0xD3, 0x1B    /* mov.l .L_pool_06041308, r3 — ai_brake_zone_calc */
    jsr @r3                     ! call ai_brake_zone_calc(locals)
    mov r15, r4                 ! r4 = locals buffer (delay slot)
    mov.l @r14, r2              ! r2 = ai_car_state_ptr
    mov r15, r3                 ! r3 = locals buffer
    mov.b @r3, r1               ! r1 = calc result byte [0]
    mov #0x40, r0               ! offset 0x40 in car struct
    mov.b r1, @(r0, r2)         ! car[0x40] = brake calc result
    mov #0x0, r0                ! return 0 (success)
    add #0xC, r15               ! free locals
    lds.l @r15+, pr             ! restore return address
    rts                         ! return
    mov.l @r15+, r14            ! restore r14 (delay slot)
