/* render_stage_2 -- VDP2 rendering pipeline stage 2
 * Translation unit: 0x0601CAEE - 0x0601D2DC
 *
 * Orchestrates multi-pass VDP2 Color RAM (CRAM) rendering:
 *   render_stage_2     — Top-level dispatcher: checks game status flags,
 *                        dispatches to render stages 3-6 based on pass results,
 *                        performs DMA transfers to VDP2 CRAM banks.
 *   render_stage_3     — Palette interpolation pass (blend toward black).
 *   render_stage_4     — Palette interpolation pass (blend toward white).
 *   render_stage_5     — Full CRAM DMA + display list update (palette bank A).
 *   render_stage_6     — Full CRAM DMA + display list update (palette bank B).
 *   render_matrix_calc — Frame-synchronized render state machine (11 states).
 *   .L_rgb_unpack (0x0601D0BC) — Unpack 15-bit RGB555 into separate R/G/B words.
 *
 * VDP2 CRAM base: 0x25F00000 (banks at +0x000, +0x200, +0x400).
 * DMA transfers via r12 = dma_transfer function pointer.
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 */

    .section .text.FUN_0601CAEE


    .global render_stage_2
    .type render_stage_2, @function
render_stage_2:
    mov.l r14, @-r15                        ! save r14-r8, pr
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    .byte   0xD8, 0x1A    /* mov.l .L_stage_counter, r8 */
    .byte   0xD9, 0x1A    /* mov.l .L_vdp2_cram_0x200, r9 */
    .byte   0xDA, 0x1B    /* mov.l .L_vdp2_cram_0x400, r10 */
    .byte   0xDC, 0x1B    /* mov.l .L_fn_dma_transfer, r12 */  ! r12 = dma_transfer (persists)
    .byte   0xDD, 0x1C    /* mov.l .L_dma_pending_flag, r13 */ ! r13 = &dma_pending
    .byte   0xDE, 0x1C    /* mov.l .L_frame_counter, r14 */    ! r14 = &frame_counter
    mov.l @r14, r3                          ! frame_counter--
    add #-0x1, r3
    mov.l r3, @r14
    .byte   0xD2, 0x1B    /* mov.l .L_game_status_flags, r2 */
    mov.w @r2, r3
    mov.w   DAT_0601cb48, r2               ! r2 = 0x0800 (status bit mask)
    extu.w r3, r3
    and r2, r3                              ! test bit 0x0800 in game status
    tst r3, r3
    bt/s    .L_dispatch_start               ! skip render if status bit clear
    mov #0x0, r11                           ! r11 = 0 (cleared anim state)
    .byte   0xD0, 0x15    /* mov.l .L_dma_pending_flag, r0 */
    mov.l @r0, r0
    tst r0, r0
    bf      .L_dispatch_start              ! skip if DMA still pending
    mov.l @r14, r0                          ! r0 = frame_counter (pass as arg)
    add #-0x8, r15                          ! allocate 8 bytes on stack
    .byte   0xD3, 0x15    /* mov.l .L_fn_render_proc_a, r3 */
    jsr @r3                                 ! render_setup(frame_counter, sp)
    mov.l r15, @-r15
    mov #0x0, r2
    mov.l r2, @-r15
    .byte   0xD2, 0x14    /* mov.l .L_vdp2_cfg_mode_a, r2 */  ! 0x40680000
    .byte   0xD3, 0x14    /* mov.l .L_fn_render_proc_b, r3 */
    jsr @r3                                 ! render_exec(cfg_mode_a)
    mov.l r2, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_2                   ! pass 1 failed, try pass 2
    mov #0x1, r2                            ! pass 1 succeeded → DMA state 1
    bra     .L_dispatch_start
    mov.l r2, @r13

    .global DAT_0601cb48
DAT_0601cb48:
    .2byte  0x0800
    .2byte  0xFFFF
    .4byte  sym_06086028
    .4byte  0x25F00FFE
    .4byte  tilemap_dma_update
    .4byte  sym_0605B6D8
    .4byte  0x40000000
    .4byte  sym_06026CE0
    .4byte  sym_06059F44
.L_stage_counter:
    .4byte  sym_06086020                    /* render stage step counter */
.L_vdp2_cram_0x200:
    .4byte  0x25F00200                      /* VDP2 color RAM bank 1 */
.L_vdp2_cram_0x400:
    .4byte  0x25F00400                      /* VDP2 color RAM bank 2 */
.L_fn_dma_transfer:
    .4byte  dma_transfer                    /* SCU DMA transfer function */
.L_dma_pending_flag:
    .4byte  sym_06086024                    /* DMA pending flag (non-zero = busy) */
.L_frame_counter:
    .4byte  sym_0608601C                    /* frame countdown for render cycle */
.L_game_status_flags:
    .4byte  g_pad_state                    /* game status word (bit 0x0800) */
.L_fn_render_proc_a:
    .4byte  sym_060358EC                    /* render setup / parameter load */
.L_vdp2_cfg_mode_a:
    .4byte  0x40680000                      /* VDP2 config value for pass 1 */
.L_fn_render_proc_b:
    .4byte  sym_06035844                    /* render execute / commit */
.L_try_pass_2:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x67    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x66    /* mov.l .L_vdp2_cfg_pass_1, r3 */
    .byte   0xD2, 0x66    /* mov.l .L_fn_render_exec, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bt      .L_set_state_3
    mov #0x2, r3
    mov.l r3, @r13
    bra     .L_dispatch_start
    nop
.L_set_state_3:
    mov #0x3, r2
    mov.l r2, @r13
.L_dispatch_start:
    bsr     render_matrix_calc              ! advance render state machine
    nop
    mov.l @r13, r0                          ! r0 = DMA pending state
    tst r0, r0
    bt      .L_state_zero_path              ! state 0 → run render passes
    bra     .L_dma_dispatch                 ! state 1/2/3 → DMA palette transfers
    nop
.L_state_zero_path:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD3, 0x5A    /* mov.l .L_fn_render_setup, r3 */
    jsr @r3
    mov.l r15, @-r15
    mov #0x0, r2
    mov.l r2, @-r15
    .byte   0xD2, 0x5B    /* mov.l .L_vdp2_cfg_pass_2, r2 */
    .byte   0xD3, 0x59    /* mov.l .L_fn_render_exec, r3 */
    jsr @r3
    mov.l r2, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_3
    bra     .L_epilog
    nop
.L_try_pass_3:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x53    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x54    /* mov.l .L_vdp2_cfg_pass_3, r3 */
    .byte   0xD2, 0x52    /* mov.l .L_fn_render_exec, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_3_check
    bsr     render_stage_3
    nop
    bra     .L_epilog
    nop
.L_try_pass_3_check:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x4A    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x4C    /* mov.l .L_vdp2_cfg_pass_3, r3 */
    .byte   0xD2, 0x4C    /* mov.l .L_fn_render_check, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bf      .L_try_pass_4
    mov.l r11, @r8
.L_try_pass_4:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD3, 0x43    /* mov.l .L_fn_render_setup, r3 */
    jsr @r3
    mov.l r15, @-r15
    mov #0x0, r2
    mov.l r2, @-r15
    .byte   0xD2, 0x47    /* mov.l .L_vdp2_cfg_pass_4, r2 */
    .byte   0xD3, 0x42    /* mov.l .L_fn_render_exec, r3 */
    jsr @r3
    mov.l r2, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_4_check
    bsr     render_stage_4
    nop
    bra     .L_epilog
    nop
.L_try_pass_4_check:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x3B    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x3E    /* mov.l .L_vdp2_cfg_pass_4, r3 */
    .byte   0xD2, 0x3D    /* mov.l .L_fn_render_check, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bf      .L_try_pass_5
    bsr     render_stage_5
    nop
    bra     .L_epilog
    nop
.L_try_pass_5:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x32    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x37    /* mov.l .L_vdp2_cfg_pass_5, r3 */
    .byte   0xD2, 0x31    /* mov.l .L_fn_render_exec, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_5_check
    bsr     render_stage_3
    nop
    bra     .L_epilog
    nop
.L_try_pass_5_check:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x2A    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x2E    /* mov.l .L_vdp2_cfg_pass_5, r3 */
    .byte   0xD2, 0x2C    /* mov.l .L_fn_render_check, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bf      .L_try_pass_6
    mov.l r11, @r8
.L_try_pass_6:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD3, 0x23    /* mov.l .L_fn_render_setup, r3 */
    jsr @r3
    mov.l r15, @-r15
    mov #0x0, r2
    mov.l r2, @-r15
    .byte   0xD2, 0x21    /* mov.l .L_vdp2_cfg_pass_1, r2 */
    .byte   0xD3, 0x22    /* mov.l .L_fn_render_exec, r3 */
    jsr @r3
    mov.l r2, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_6_check
    bsr     render_stage_4
    nop
    bra     .L_epilog
    nop
.L_try_pass_6_check:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x1A    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x19    /* mov.l .L_vdp2_cfg_pass_1, r3 */
    .byte   0xD2, 0x1C    /* mov.l .L_fn_render_check, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bf      .L_try_pass_7
    bsr     render_stage_6
    nop
    bra     .L_epilog
    nop
.L_try_pass_7:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x12    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x17    /* mov.l .L_vdp2_cfg_pass_6, r3 */
    .byte   0xD2, 0x11    /* mov.l .L_fn_render_exec, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bt      .L_try_pass_7_check
    bsr     render_stage_3
    nop
    bra     .L_epilog
    nop
.L_try_pass_7_check:
    mov.l @r14, r0
    add #-0x8, r15
    .byte   0xD2, 0x09    /* mov.l .L_fn_render_setup, r2 */
    jsr @r2
    mov.l r15, @-r15
    mov #0x0, r3
    mov.l r3, @-r15
    .byte   0xD3, 0x0F    /* mov.l .L_vdp2_cfg_pass_6, r3 */
    .byte   0xD2, 0x0B    /* mov.l .L_fn_render_check, r2 */
    jsr @r2
    mov.l r3, @-r15
    cmp/eq #0x0, r0
    bf      .L_final_frame_check
    mov.l r11, @r8
.L_final_frame_check:
    mov.l @r14, r3
    cmp/pl r3
    bf      .L_epilog_set_mode
    bsr     render_stage_4
    nop
    bra     .L_epilog
    nop
    .2byte  0xFFFF
.L_fn_render_setup:
    .4byte  sym_060358EC                    /* render parameter setup */
.L_vdp2_cfg_pass_1:
    .4byte  0x40568000                      /* VDP2 config: pass 1 */
.L_fn_render_exec:
    .4byte  sym_06035844                    /* render execute */
.L_vdp2_cfg_pass_2:
    .4byte  0x40726000                      /* VDP2 config: pass 2 */
.L_vdp2_cfg_pass_3:
    .4byte  0x406D4000                      /* VDP2 config: pass 3 */
.L_fn_render_check:
    .4byte  sym_06035B34                    /* render pass check/validate */
.L_vdp2_cfg_pass_4:
    .4byte  0x40680000                      /* VDP2 config: pass 4 */
.L_vdp2_cfg_pass_5:
    .4byte  0x40608000                      /* VDP2 config: pass 5 */
.L_vdp2_cfg_pass_6:
    .4byte  0x403E0000                      /* VDP2 config: pass 6 */
.L_dma_dispatch:                                ! DMA palette to VDP2 CRAM based on state
    mov.l @r13, r0
    cmp/eq #0x1, r0
    bf      .L_dma_state_2
    mov #0x20, r6                           ! 0x20 bytes = 16 palette entries
    .byte   0xD5, 0x26    /* mov.l .L_dma_src_pal_a0, r5 */
    jsr @r12                                ! dma_transfer(cram_0x200, pal_a0, 0x20)
    mov r9, r4
    mov #0x20, r6
    .byte   0xD5, 0x25    /* mov.l .L_dma_src_pal_a1, r5 */
    jsr @r12                                ! dma_transfer(cram_0x400, pal_a1, 0x20)
    mov r10, r4
.L_dma_state_2:
    mov.l @r13, r0
    cmp/eq #0x2, r0
    bf      .L_dma_state_3
    bsr     render_stage_5                  ! full CRAM DMA + display list (bank A)
    nop
    mov #0x20, r6
    .byte   0xD5, 0x22    /* mov.l .L_dma_src_pal_b0, r5 */
    jsr @r12
    mov r9, r4
    mov #0x20, r6
    .byte   0xD5, 0x21    /* mov.l .L_dma_src_pal_b1, r5 */
    jsr @r12
    mov r10, r4
.L_dma_state_3:
    mov.l @r13, r0
    cmp/eq #0x3, r0
    bf      .L_epilog_set_mode
    mov #0x20, r6
    .byte   0xD5, 0x1E    /* mov.l .L_dma_src_pal_c0, r5 */
    jsr @r12
    mov r9, r4
    mov #0x20, r6
    .byte   0xD5, 0x1D    /* mov.l .L_dma_src_pal_c1, r5 */
    jsr @r12
    mov r10, r4
.L_epilog_set_mode:
    mov #0x2, r3                            ! render_mode_state = 2 (render complete)
    .byte   0xD2, 0x1C    /* mov.l .L_render_mode_state, r2 */
    mov.l r3, @r2
.L_epilog:
    .byte   0xD3, 0x1C    /* mov.l .L_fn_display_update, r3 */
    jsr @r3                                 ! call display update
    nop
    .byte   0xD3, 0x1C    /* mov.l .L_anim_state, r3 */
    mov.l r11, @r3                          ! clear animation state
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14

    .global render_stage_3
    .type render_stage_3, @function
render_stage_3:                                 ! palette blend toward black (fade out)
    mov.l r14, @-r15
    mov #0x12, r2                           ! max steps = 0x12 (18)
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    add #-0x54, r15                         ! local frame: 0x54 bytes
    mov r15, r10
    .byte   0xDC, 0x12    /* mov.l .L_s3_stage_counter, r12 */
    add #0x14, r10                          ! r10 = output buffer pointer
    mov.l @r12, r3                          ! r3 = current step
    cmp/ge r2, r3                           ! step >= 18?
    bt/s    .L_s3_done                      ! done, skip to epilog
    mov #0x64, r13                          ! r13 = 100 (lerp denominator)
    mov.l @r12, r11
    shll r11                                ! r11 = step * 2 (index into table)
    .byte   0xD3, 0x0F    /* mov.l .L_s3_palette_table, r3 */
    add r3, r11
    mov.w @r11, r11                         ! r11 = palette_table[step] (lerp weight)
    mov r13, r14
    sub r11, r14                            ! r14 = 100 - weight (complement)
    .byte   0xD2, 0x0D    /* mov.l .L_vdp2_cram_0x000, r2 */
    mov.l r2, @(12, r15)
    mov r10, r2
    mov.l r2, @(16, r15)
    bra     .L_s3_loop_test
    mov #0x0, r9
.L_dma_src_pal_a0:
    .4byte  sym_0604880C                    /* palette source A, CRAM bank 1 */
.L_dma_src_pal_a1:
    .4byte  sym_0604882C                    /* palette source A, CRAM bank 2 */
.L_dma_src_pal_b0:
    .4byte  sym_0604884C                    /* palette source B, CRAM bank 1 */
.L_dma_src_pal_b1:
    .4byte  sym_0604886C                    /* palette source B, CRAM bank 2 */
.L_dma_src_pal_c0:
    .4byte  sym_0605D17C                    /* palette source C, CRAM bank 1 */
.L_dma_src_pal_c1:
    .4byte  sym_0605D19C                    /* palette source C, CRAM bank 2 */
.L_render_mode_state:
    .4byte  g_game_state                    /* game state dispatch value */
.L_fn_display_update:
    .4byte  sym_06026CE0                    /* display update function */
.L_anim_state:
    .4byte  sym_06059F44                    /* animation state (32-bit) */
.L_s3_stage_counter:
    .4byte  sym_06086020                    /* render stage step counter */
.L_s3_palette_table:
    .4byte  sym_0605DF58                    /* palette lerp weight table (18 entries) */
.L_vdp2_cram_0x000:
    .4byte  0x25F00000                      /* VDP2 color RAM base */
.L_s3_color_loop:                               ! process 32 colors (16 per CRAM bank)
    mov r15, r7                             ! r7 = &B channel (sp+8)
    mov r15, r6                             ! r6 = &G channel (sp+4)
    mov r15, r5                             ! r5 = &R channel (sp+0)
    mov.l @(12, r15), r4                    ! r4 = CRAM read pointer
    add #0x8, r7
    add #0x4, r6
    add #0x2, r4                            ! advance CRAM pointer
    mov.l r4, @(12, r15)
    add #-0x2, r4
    mov.w @r4, r4                           ! r4 = RGB555 color word from CRAM
    bsr     .L_rgb_unpack                   ! split into R, G, B at sp+0/4/8
    extu.w r4, r4
    mov.w @r15, r1                          ! r1 = R component
    mov #0x1D, r4                           ! r4 = 29 (scale for target color)
    .byte   0xD3, 0x28    /* mov.l .L_fn_color_lerp, r3 */
    extu.w r1, r1
    mul.l r14, r1                           ! R * complement
    sts macl, r1
    mul.l r4, r11                           ! target * weight
    sts macl, r4
    add r4, r1                              ! weighted sum
    jsr @r3                                 ! color_lerp(100, weighted_sum) → clamped R
    mov r13, r0
    extu.w r0, r0
    mov.w r0, @r15                          ! store interpolated R
    mov.w @(4, r15), r0
    .byte   0xD3, 0x22    /* mov.l .L_fn_color_lerp, r3 */
    mov r0, r1
    extu.w r1, r1
    mul.l r14, r1
    sts macl, r1
    add r4, r1
    jsr @r3
    mov r13, r0
    extu.w r0, r0
    mov.w r0, @(4, r15)
    mov.w @(8, r15), r0
    .byte   0xD3, 0x1D    /* mov.l .L_fn_color_lerp, r3 */
    mov r0, r1
    extu.w r1, r1
    mul.l r14, r1
    sts macl, r1
    add r4, r1
    jsr @r3
    mov r13, r0
    extu.w r0, r0
    mov.w r0, @(8, r15)
    mov r0, r7                              ! r7 = B result
    mov.w @r15, r4                          ! r4 = R result
    extu.w r7, r5                           ! repack RGB555: B<<10 | G<<5 | R
    mov.w @(4, r15), r0
    shll8 r5                                ! B << 8
    mov r0, r6
    shll2 r5                                ! B << 10
    extu.w r6, r3
    shll2 r3                                ! G << 2
    shll2 r3                                ! G << 4
    shll r3                                 ! G << 5
    add r3, r5                              ! | G<<5
    extu.w r4, r2
    add r2, r5                              ! | R
    extu.w r5, r5
    mov.l @(16, r15), r2                    ! output buffer pointer
    add #0x2, r2
    mov.l r2, @(16, r15)
    add #-0x2, r2
    mov.w r5, @r2                           ! write packed RGB555 to output
    add #0x1, r9                            ! color index++
.L_s3_loop_test:
    mov #0x20, r3                           ! 32 colors per pass
    cmp/ge r3, r9
    bf      .L_s3_color_loop
    mov #0x20, r6                           ! DMA 32 bytes to CRAM bank 1
    .byte   0xD4, 0x0C    /* mov.l .L_s3_cram_bank_1, r4 */
    .byte   0xD3, 0x0D    /* mov.l .L_s3_fn_dma, r3 */
    jsr @r3
    mov r10, r5
    mov #0x20, r6                           ! DMA 32 bytes to CRAM bank 2
    mov r10, r5
    .byte   0xD4, 0x0B    /* mov.l .L_s3_cram_bank_2, r4 */
    .byte   0xD3, 0x0A    /* mov.l .L_s3_fn_dma, r3 */
    jsr @r3
    add #0x20, r5                           ! second half of output buffer
.L_s3_done:
    mov.l @r12, r2                          ! stage_counter++
    add #0x1, r2
    mov.l r2, @r12
    add #0x54, r15
    lds.l @r15+, macl
    lds.l @r15+, pr
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
    .2byte  0xFFFF
.L_fn_color_lerp:
    .4byte  sym_06034FE0                    /* color linear interpolation function */
.L_s3_cram_bank_1:
    .4byte  0x25F00200                      /* VDP2 CRAM bank 1 */
.L_s3_fn_dma:
    .4byte  dma_transfer                    /* SCU DMA transfer function */
.L_s3_cram_bank_2:
    .4byte  0x25F00400                      /* VDP2 CRAM bank 2 */

    .global render_stage_4
    .type render_stage_4, @function
render_stage_4:                                 ! palette blend toward white (fade in)
    mov.l r14, @-r15
    mov #0x12, r2                           ! max steps = 18
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    add #-0x58, r15
    mov r15, r10
    .byte   0xDD, 0x09    /* mov.l .L_s4_stage_counter, r13 */
    add #0x18, r10
    mov.l @r13, r3
    cmp/ge r2, r3
    bt/s    .L_s4_done
    mov #0x64, r12
    mov.l @r13, r14
    shll r14
    .byte   0xD3, 0x06    /* mov.l .L_s4_palette_table, r3 */
    add r3, r14
    mov.w @r14, r14
    mov r12, r2
    sub r14, r2
    mov.l r2, @(16, r15)
    .byte   0xD1, 0x04    /* mov.l .L_s4_cram_base, r1 */
    mov.l r1, @(12, r15)
    mov r10, r1
    mov.l r1, @(20, r15)
    bra     .L_s4_loop_test
    mov #0x0, r11
.L_s4_stage_counter:
    .4byte  sym_06086020
.L_s4_palette_table:
    .4byte  sym_0605DF58
.L_s4_cram_base:
    .4byte  0x25F00000                  /* VDP2 color RAM +0x000 */
.L_s4_color_loop:
    mov r15, r7
    mov r15, r6
    mov r15, r5
    mov.l @(12, r15), r4
    add #0x8, r7
    add #0x4, r6
    add #0x2, r4
    mov.l r4, @(12, r15)
    add #-0x2, r4
    mov.w @r4, r4
    bsr     .L_rgb_unpack
    extu.w r4, r4
    mov.w @r15, r1
    mov #0x1D, r3
    mov.l @(16, r15), r4
    extu.w r1, r1
    mul.l r14, r1
    sts macl, r1
    mul.l r3, r4
    .byte   0xD3, 0x26    /* mov.l .L_s4_fn_color_lerp, r3 */
    sts macl, r4
    add r4, r1
    jsr @r3
    mov r12, r0
    extu.w r0, r0
    mov.w r0, @r15
    mov.w @(4, r15), r0
    .byte   0xD3, 0x22    /* mov.l .L_s4_fn_color_lerp, r3 */
    mov r0, r1
    extu.w r1, r1
    mul.l r14, r1
    sts macl, r1
    add r4, r1
    jsr @r3
    mov r12, r0
    extu.w r0, r0
    mov.w r0, @(4, r15)
    mov.w @(8, r15), r0
    .byte   0xD3, 0x1C    /* mov.l .L_s4_fn_color_lerp, r3 */
    mov r0, r1
    extu.w r1, r1
    mul.l r14, r1
    sts macl, r1
    add r4, r1
    jsr @r3
    mov r12, r0
    extu.w r0, r0
    mov r0, r7
    mov.w r0, @(8, r15)
    extu.w r7, r6
    mov.w @(4, r15), r0
    mov.w @r15, r5
    shll8 r6
    mov r0, r4
    shll2 r6
    extu.w r4, r3
    shll2 r3
    shll2 r3
    shll r3
    add r3, r6
    extu.w r5, r2
    add r2, r6
    extu.w r6, r6
    mov.l @(20, r15), r2
    add #0x2, r2
    mov.l r2, @(20, r15)
    add #-0x2, r2
    mov.w r6, @r2
    add #0x1, r11
.L_s4_loop_test:
    mov #0x20, r3
    cmp/ge r3, r11
    bf      .L_s4_color_loop
    mov #0x20, r6
    .byte   0xD4, 0x0C    /* mov.l .L_s4_cram_bank_1, r4 */
    .byte   0xD3, 0x0C    /* mov.l .L_s4_fn_dma, r3 */
    jsr @r3
    mov r10, r5
    mov #0x20, r6
    mov r10, r5
    .byte   0xD4, 0x0B    /* mov.l .L_s4_cram_bank_2, r4 */
    .byte   0xD3, 0x09    /* mov.l .L_s4_fn_dma, r3 */
    jsr @r3
    add #0x20, r5
.L_s4_done:
    mov.l @r13, r2
    add #0x1, r2
    mov.l r2, @r13
    add #0x58, r15
    lds.l @r15+, macl
    lds.l @r15+, pr
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
    .2byte  0xFFFF
.L_s4_fn_color_lerp:
    .4byte  sym_06034FE0                    /* color linear interpolation function */
.L_s4_cram_bank_1:
    .4byte  0x25F00200                      /* VDP2 CRAM bank 1 */
.L_s4_fn_dma:
    .4byte  dma_transfer                    /* SCU DMA transfer function */
.L_s4_cram_bank_2:
    .4byte  0x25F00400                      /* VDP2 CRAM bank 2 */

    .global render_stage_5
    .type render_stage_5, @function
render_stage_5:                                 ! full palette DMA + display list load (bank A)
    sts.l pr, @-r15
    add #-0x4, r15
    .byte   0xD5, 0x0F    /* mov.l .L_s5_dma_src_cram, r5 */
    .byte   0xD4, 0x10    /* mov.l .L_s5_cram_base, r4 */
    .byte   0xD3, 0x10    /* mov.l .L_s5_fn_dma, r3 */
    jsr @r3                                 ! dma_transfer(cram_base, src, 0x40)
    mov #0x40, r6                           ! 64 bytes = full palette bank
    .byte   0xD2, 0x10    /* mov.l .L_s5_dlist_a, r2 */
    mov.l r2, @r15                          ! load display list descriptor A
    mov r2, r7
    mov r2, r5
    mov.w   .L_s5_dlist_size, r6            ! r6 = 0x0518 (display list size)
    .byte   0xD3, 0x0E    /* mov.l .L_fn_dlist_loader, r3 */
    mov.l @(4, r7), r7                      ! r7 = dlist_a.dest
    mov.l @r5, r5                           ! r5 = dlist_a.src
    jsr @r3                                 ! dlist_loader(4, src, size, dest)
    mov #0x4, r4
    .byte   0xD2, 0x0D    /* mov.l .L_s5_dlist_b, r2 */
    mov.l r2, @r15                          ! load display list descriptor B
    mov r2, r7
    mov r2, r5
    mov.w   .L_s5_dlist_size, r6
    .byte   0xD3, 0x09    /* mov.l .L_fn_dlist_loader, r3 */
    mov.l @(4, r7), r7
    mov.l @r5, r5
    jsr @r3                                 ! dlist_loader(0, src, size, dest)
    mov #0x0, r4
    mov #0x0, r2
    .byte   0xD3, 0x08    /* mov.l .L_s5_stage_counter, r3 */
    add #0x4, r15
    lds.l @r15+, pr
    rts
    mov.l r2, @r3                           ! stage_counter = 0 (reset)
.L_s5_dlist_size:
    .2byte  0x0518                          /* display list transfer size */
.L_s5_dma_src_cram:
    .4byte  sym_0604884C                    /* CRAM source data (bank A) */
.L_s5_cram_base:
    .4byte  0x25F00000                      /* VDP2 CRAM base address */
.L_s5_fn_dma:
    .4byte  dma_transfer                    /* SCU DMA transfer function */
.L_s5_dlist_a:
    .4byte  sym_06063968                    /* display list descriptor A */
.L_fn_dlist_loader:
    .4byte  sym_06028400                    /* display list loader function */
.L_s5_dlist_b:
    .4byte  sym_06063970                    /* display list descriptor B */
.L_s5_stage_counter:
    .4byte  sym_06086020                    /* render stage step counter */

    .global render_stage_6
    .type render_stage_6, @function
render_stage_6:                                 ! full palette DMA + display list load (bank B)
    sts.l pr, @-r15
    add #-0x4, r15
    .byte   0xD3, 0x1E    /* mov.l .L_fn_disp_chan_cfg, r3 */
    jsr @r3                                 ! configure display channel (mode 4)
    mov #0x4, r4
    .byte   0xD5, 0x1E    /* mov.l .L_s6_dma_src_cram, r5 */
    .byte   0xD4, 0x1E    /* mov.l .L_s6_cram_base, r4 */
    .byte   0xD3, 0x1F    /* mov.l .L_s6_fn_dma, r3 */
    jsr @r3
    mov #0x40, r6
    .byte   0xD2, 0x1E    /* mov.l .L_s6_dlist_a, r2 */
    mov.l r2, @r15
    mov r2, r7
    mov r2, r5
    mov.w   .L_s6_dlist_size, r6
    .byte   0xD3, 0x1D    /* mov.l .L_s6_fn_dlist_loader, r3 */
    mov.l @(4, r7), r7
    mov.l @r5, r5
    jsr @r3
    mov #0x4, r4
    .byte   0xD2, 0x1B    /* mov.l .L_s6_dlist_b, r2 */
    mov.l r2, @r15
    mov r2, r7
    mov r2, r5
    mov.w   .L_s6_dlist_size, r6
    .byte   0xD3, 0x18    /* mov.l .L_s6_fn_dlist_loader, r3 */
    mov.l @(4, r7), r7
    mov.l @r5, r5
    jsr @r3
    mov #0x0, r4
    mov #0x0, r2
    .byte   0xD3, 0x17    /* mov.l .L_s6_stage_counter, r3 */
    add #0x4, r15
    lds.l @r15+, pr
    rts
    mov.l r2, @r3
.L_rgb_unpack:                                  ! unpack RGB555 word → R, G, B (5 bits each)
    mov #0x1F, r1                           ! r1 = 0x1F (5-bit mask)
    extu.w r4, r0                           ! r0 = RGB555 input
    mov r0, r3
    mov r0, r2
    and r1, r3                              ! r3 = R = bits[4:0]
    shar r2
    shar r0
    mov.w r3, @r5                           ! *r5 = R
    shar r2
    shar r0
    shar r2
    shar r0
    shar r2
    shar r0
    shar r2
    shar r0
    and r1, r2                              ! r2 = G = bits[9:5]
    shar r0
    mov.w r2, @r6                           ! *r6 = G
    shar r0
    shar r0
    shar r0
    shar r0
    and r1, r0                              ! r0 = B = bits[14:10]
    extu.w r0, r0
    rts
    mov.w r0, @r7                           ! *r7 = B
.L_s6_dlist_size:
    .2byte  0x0518                          /* display list transfer size */
.L_fn_disp_chan_cfg:
    .4byte  sym_0602853E                    /* display channel configure */
.L_s6_dma_src_cram:
    .4byte  sym_0605D17C                    /* CRAM source data (bank B) */
.L_s6_cram_base:
    .4byte  0x25F00000                      /* VDP2 CRAM base address */
.L_s6_fn_dma:
    .4byte  dma_transfer                    /* SCU DMA transfer function */
.L_s6_dlist_a:
    .4byte  sym_06063CF8                    /* display list descriptor A (bank B) */
.L_s6_fn_dlist_loader:
    .4byte  sym_06028400                    /* display list loader function */
.L_s6_dlist_b:
    .4byte  sym_06063D00                    /* display list descriptor B (bank B) */
.L_s6_stage_counter:
    .4byte  sym_06086020                    /* render stage step counter */
    .4byte  0x606D635D
    .4byte  0x624D4018
    .4byte  0x43084008
    .4byte  0x43084300
    .4byte  0x303C302C
    .4byte  0x000B600D

    .global render_matrix_calc
    .type render_matrix_calc, @function
render_matrix_calc:                             ! 11-state render synchronization machine
    mov.l r14, @-r15                        ! states 0-10: wait for specific input bits
    .byte   0xDE, 0x18    /* mov.l .L_mc_state_var, r14 */  ! r14 = &state variable
    mov.l @r14, r4                          ! r4 = current state (saved for wrap check)
    mov r4, r0
    tst r0, r0                              ! state == 0?
    bf      .L_mc_state_1
    .byte   0xD3, 0x16    /* mov.l .L_mc_button_state, r3 */
    mov.w @r3, r2                           ! r2 = button/input state word
    extu.w r2, r2
    mov.w   DAT_0601d18c, r3               ! mask = 0x1000
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_1                   ! bit not set → skip advance
    mov.l @r14, r3                          ! state++ (advance to next)
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_1:
    mov.l @r14, r0
    cmp/eq #0x1, r0
    bf      .L_mc_state_2
    .byte   0xD3, 0x0F    /* mov.l .L_mc_button_state, r3 */
    mov.w @r3, r2
    mov.w   DAT_0601d18c, r3
    extu.w r2, r2
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_2
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_2:
    mov.l @r14, r0
    cmp/eq #0x2, r0
    bf      .L_mc_state_3
    .byte   0xD3, 0x07    /* mov.l .L_mc_button_state, r3 */
    mov.w @r3, r2
    extu.w r2, r2
    mov.w   DAT_0601d18e, r3
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_3
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop

    .global DAT_0601d18c
DAT_0601d18c:
    .2byte  0x1000

    .global DAT_0601d18e
DAT_0601d18e:
    .2byte  0x2000
.L_mc_state_var:
    .4byte  sym_0608602C                    /* render state machine variable */
.L_mc_button_state:
    .4byte  sym_06063D9A                    /* input/button state word */
.L_mc_state_3:
    mov.l @r14, r0
    cmp/eq #0x3, r0
    bf      .L_mc_state_4
    .byte   0xD3, 0x2D    /* mov.l .L_mc_button_state_b, r3 */
    mov.w @r3, r2
    mov.w   DAT_0601d24c, r3
    extu.w r2, r2
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_4
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_4:
    mov.l @r14, r0
    cmp/eq #0x4, r0
    bf      .L_mc_state_5
    .byte   0xD3, 0x25    /* mov.l .L_mc_button_state_b, r3 */
    mov.w @r3, r2
    extu.w r2, r2
    mov.w   DAT_0601d24e, r3
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_5
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_5:
    mov.l @r14, r0
    cmp/eq #0x5, r0
    bf      .L_mc_state_6
    .byte   0xD3, 0x1E    /* mov.l .L_mc_button_state_b, r3 */
    mov.w @r3, r2
    .byte   0xD3, 0x1E    /* mov.l .L_fp_half, r3 */
    extu.w r2, r2
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_6
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_6:
    mov.l @r14, r0
    cmp/eq #0x6, r0
    bf      .L_mc_state_7
    .byte   0xD3, 0x16    /* mov.l .L_mc_button_state_b, r3 */
    mov.w @r3, r2
    extu.w r2, r2
    mov.w   DAT_0601d24e, r3
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_7
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_7:
    mov.l @r14, r0
    cmp/eq #0x7, r0
    bf      .L_mc_state_8
    .byte   0xD3, 0x0F    /* mov.l .L_mc_button_state_b, r3 */
    mov.w @r3, r2
    .byte   0xD3, 0x0F    /* mov.l .L_fp_half, r3 */
    extu.w r2, r2
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_8
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_8:
    mov.l @r14, r0
    cmp/eq #0x8, r0
    bf      .L_mc_state_9
    .byte   0xD3, 0x07    /* mov.l .L_mc_button_state_b, r3 */
    mov.w @r3, r2
    extu.w r2, r2
    mov.w   .L_mc_mask_0400, r3
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_9
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop

    .global DAT_0601d24c
DAT_0601d24c:
    .2byte  0x2000

    .global DAT_0601d24e
DAT_0601d24e:
    .2byte  0x4000
.L_mc_mask_0400:
    .2byte  0x0400
    .2byte  0xFFFF
.L_mc_button_state_b:
    .4byte  sym_06063D9A                    /* input/button state word (pool 2) */
.L_fp_half:
    .4byte  0x00008000                      /* 0.5 (16.16 fixed-point) */
.L_mc_state_9:
    mov.l @r14, r0
    cmp/eq #0x9, r0
    bf      .L_mc_state_10
    .byte   0xD3, 0x1A    /* mov.l .L_mc_button_state_c, r3 */
    mov.w @r3, r2
    mov.w   DAT_0601d2c6, r3
    extu.w r2, r2
    and r3, r2
    tst r2, r2
    bt      .L_mc_state_10
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
    bra     .L_mc_advance_done
    nop
.L_mc_state_10:
    mov.l @r14, r0
    cmp/eq #0xA, r0
    bf      .L_mc_advance_done
    .byte   0xD3, 0x12    /* mov.l .L_mc_button_state_c, r3 */
    mov.w @r3, r2
    extu.w r2, r2
    mov.w   .L_mc_mask_0200, r3
    and r3, r2
    tst r2, r2
    bt      .L_mc_advance_done
    mov.l @r14, r3
    add #0x1, r3
    mov.l r3, @r14
.L_mc_advance_done:
    mov.l @r14, r2                          ! did state change?
    cmp/eq r4, r2                           ! compare with entry state
    bf      .L_mc_check_completion          ! changed → check for completion
    .byte   0xD2, 0x0C    /* mov.l .L_mc_button_state_c, r2 */
    mov.w @r2, r0                           ! any input at all?
    extu.w r0, r0
    tst r0, r0
    bt      .L_mc_check_completion          ! no input → keep state
    mov #0x0, r3                            ! input present but state didn't advance
    mov.l r3, @r14                          ! reset state to 0 (wrap around)
.L_mc_check_completion:
    mov.l @r14, r0
    cmp/eq #0xB, r0                         ! reached state 11?
    bf      .L_mc_return                    ! no → return
    mov #0x1, r3                            ! set completion flag
    .byte   0xD2, 0x07    /* mov.l .L_mc_completion_flag, r2 */
    mov.b r3, @r2                           ! completion_flag = 1
    mov #0x0, r3
    mov.l r3, @r14                          ! reset state to 0
    .byte   0xD5, 0x06    /* mov.l .L_mc_sound_param, r5 */  ! sound effect param
    mov r3, r4
    .byte   0xD3, 0x06    /* mov.l .L_fn_sound_cmd, r3 */
    jmp @r3                                 ! tail-call sound_cmd_dispatch
    mov.l @r15+, r14
.L_mc_return:
    rts
    mov.l @r15+, r14

    .global DAT_0601d2c6
DAT_0601d2c6:
    .2byte  0x0100
.L_mc_mask_0200:
    .2byte  0x0200
    .2byte  0xFFFF
.L_mc_button_state_c:
    .4byte  sym_06063D9A                    /* input/button state word (pool 3) */
.L_mc_completion_flag:
    .4byte  sym_06086030                    /* render cycle completion flag */
.L_mc_sound_param:
    .4byte  0xAE1146FF                      /* sound effect parameter (completion jingle) */
.L_fn_sound_cmd:
    .4byte  sound_cmd_dispatch              /* sound command dispatch function */
