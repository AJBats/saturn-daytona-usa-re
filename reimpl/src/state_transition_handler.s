/* state_transition_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041CC8 - 0x06041D6C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Two-phase state transition processor for event channel 3.
 *
 * Called from evt_callback_handler when event_index == 3.
 *
 * Entry: state_transition_handler(r4 = state_buffer_ptr)
 *   r4: pointer to the AI/game state buffer for this entity
 *
 * Phase 1 (transition_state == 1):
 *   Calls track_impact_force(state[+0x032C], state[+0x0330], state[+0x0334])
 *   to evaluate collision/impact forces on this entity. If the result is
 *   nonzero (impact detected), returns 1 immediately.
 *   Otherwise, calls ai_checkpoint_validate(&local_result) to compute a
 *   checkpoint validation byte, stores it into state[+0x40], increments
 *   the transfer counter at *state_buffer_ptr, and advances to phase 2.
 *
 * Phase 2 (transition_state == 2):
 *   Calls ai_brake_zone_adjust(0) to finalize braking zone adjustments.
 *   If the result is nonzero (adjustment still in progress), returns 1.
 *   Otherwise, resets transition_state to 0 and returns 0 (transition complete).
 *
 * Returns:
 *   0 — transition completed successfully
 *   1 — transition still in progress (or no transition active)
 *
 * Game state struct fields used (base = *sym_060A5400):
 *   +0x0328  transition_state    (0=idle, 1=phase1, 2=phase2)
 *   +0x032C  impact_param_a      (passed to track_impact_force as r4)
 *   +0x0330  impact_param_b      (passed to track_impact_force as r5)
 *   +0x0334  impact_param_c      (passed to track_impact_force as r6)
 *   +0x0040  checkpoint_result   (byte written from ai_checkpoint_validate)
 */

    .section .text.FUN_06041CC8


    .global state_transition_handler
    .type state_transition_handler, @function
state_transition_handler:
    mov.l r14, @-r15                            ! save r14 (callee-saved)
    sts.l pr, @-r15                             ! save return address
    add #-0x10, r15                             ! allocate 16 bytes of local stack
    mov.l   .L_pool_game_state_ptr, r14         ! r14 = &game_state_base_ptr
    mov.l r4, @r15                              ! local[0] = state_buffer_ptr (save arg)
    mov.l @r14, r0                              ! r0 = game_state_base
    mov.w   .L_wpool_transition_state_offset, r1               ! r1 = 0x0328 (transition_state offset)
    mov.l @(r0, r1), r0                         ! r0 = game_state[+0x0328] = transition_state
    cmp/eq #0x1, r0                             ! transition_state == 1 (phase 1)?
    bf      .L_check_phase2                     ! no -> skip to phase 2 check
    ! --- Phase 1: evaluate impact forces ---
    mov.l @r14, r6                              ! r6 = game_state_base
    mov.w   DAT_06041d5a, r0                    ! r0 = 0x0334 (impact_param_c offset)
    mov.l @r14, r5                              ! r5 = game_state_base
    mov.l @r14, r4                              ! r4 = game_state_base
    mov.l   .L_pool_track_impact_force, r3      ! r3 = &track_impact_force
    mov.l @(r0, r6), r6                         ! r6 = game_state[+0x0334] (impact_param_c)
    add #-0x4, r0                               ! r0 = 0x0330 (impact_param_b offset)
    mov.l @(r0, r5), r5                         ! r5 = game_state[+0x0330] (impact_param_b)
    add #-0x4, r0                               ! r0 = 0x032C (impact_param_a offset)
    jsr @r3                                     ! call track_impact_force(param_a, param_b, param_c)
    mov.l @(r0, r4), r4                         ! r4 = game_state[+0x032C] (impact_param_a) [delay slot]
    mov r0, r4                                  ! r4 = impact_result
    tst r4, r4                                  ! impact_result == 0?
    bt      .L_impact_clear                     ! yes -> impact clear, proceed with checkpoint
    ! --- Impact detected: return 1 (still in progress) ---
    mov #0x1, r0                                ! return value = 1 (in progress)
    add #0x10, r15                              ! deallocate local stack
    lds.l @r15+, pr                             ! restore return address
    rts                                         ! return
    mov.l @r15+, r14                            ! restore r14 [delay slot]
.L_impact_clear:
    ! --- No impact: validate checkpoint and advance to phase 2 ---
    mov r15, r4                                 ! r4 = &local[1] (output buffer for validate)
    mov.l   .L_pool_ai_checkpoint_validate, r3  ! r3 = &ai_checkpoint_validate
    jsr @r3                                     ! call ai_checkpoint_validate(&local[1])
    add #0x4, r4                                ! r4 = &local[1] (sp+4) [delay slot]
    mov.l @r14, r2                              ! r2 = game_state_base
    mov r15, r3                                 ! r3 = sp
    add #0x4, r3                                ! r3 = &local[1] (result byte location)
    mov.b @r3, r1                               ! r1 = checkpoint validation result byte
    mov #0x40, r0                               ! r0 = 0x40 (checkpoint_result offset)
    mov.b r1, @(r0, r2)                         ! game_state[+0x40] = checkpoint result byte
    mov.l @r15, r3                              ! r3 = state_buffer_ptr (from local[0])
    mov.l @r3, r2                               ! r2 = *state_buffer_ptr (transfer counter)
    add #0x1, r2                                ! r2 = transfer_counter + 1
    mov.l r2, @r3                               ! *state_buffer_ptr = incremented counter
    mov.l @r14, r3                              ! r3 = game_state_base
    mov #0x2, r2                                ! r2 = 2 (phase 2)
    mov.w   .L_wpool_transition_state_offset, r0               ! r0 = 0x0328 (transition_state offset)
    mov.l r2, @(r0, r3)                         ! game_state[+0x0328] = 2 (advance to phase 2)
.L_check_phase2:
    ! --- Phase 2 check: finalize brake zone adjustment ---
    mov.l @r14, r0                              ! r0 = game_state_base
    mov.w   .L_wpool_transition_state_offset, r1               ! r1 = 0x0328 (transition_state offset)
    mov.l @(r0, r1), r0                         ! r0 = transition_state
    cmp/eq #0x2, r0                             ! transition_state == 2 (phase 2)?
    bf      .L_return_in_progress               ! no -> not in phase 2, return 1
    mov.l   .L_pool_ai_brake_zone_adjust, r3    ! r3 = &ai_brake_zone_adjust
    jsr @r3                                     ! call ai_brake_zone_adjust(0)
    mov #0x0, r4                                ! r4 = 0 (arg) [delay slot]
    mov r0, r4                                  ! r4 = brake_adjust_result
    tst r4, r4                                  ! brake_adjust_result == 0?
    bf      .L_return_in_progress               ! no -> adjustment still in progress, return 1
    ! --- Transition complete: reset state and return 0 ---
    mov #0x0, r4                                ! r4 = 0
    mov.l @r14, r3                              ! r3 = game_state_base
    mov.w   .L_wpool_transition_state_offset, r0               ! r0 = 0x0328 (transition_state offset)
    mov.l r4, @(r0, r3)                         ! game_state[+0x0328] = 0 (reset to idle)
    mov r4, r0                                  ! r0 = 0 (return value: transition complete)
    add #0x10, r15                              ! deallocate local stack
    lds.l @r15+, pr                             ! restore return address
    rts                                         ! return
    mov.l @r15+, r14                            ! restore r14 [delay slot]
.L_return_in_progress:
    ! --- Return 1: transition not complete or not active ---
    mov #0x1, r0                                ! return value = 1 (in progress / inactive)
    add #0x10, r15                              ! deallocate local stack
    lds.l @r15+, pr                             ! restore return address
    rts                                         ! return
    mov.l @r15+, r14                            ! restore r14 [delay slot]
.L_wpool_transition_state_offset:
    .2byte  0x0328                      /* [HIGH] offset to transition_state in game state struct */

    .global DAT_06041d5a
DAT_06041d5a:
    .2byte  0x0334
.L_pool_game_state_ptr:
    .4byte  sym_060A5400
.L_pool_track_impact_force:
    .4byte  track_impact_force
.L_pool_ai_checkpoint_validate:
    .4byte  ai_checkpoint_validate
.L_pool_ai_brake_zone_adjust:
    .4byte  ai_brake_zone_adjust
