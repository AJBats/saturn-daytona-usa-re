#include "game.h"

extern int DAT_06018212;
extern int DAT_06018214;
extern int DAT_06018216;
extern int DAT_06018218;
extern int DAT_0601821a;
extern int DAT_060182f2;
extern int DAT_060183ec;
extern int DAT_060183ee;
extern int DAT_060183f0;
extern int DAT_060183f2;
extern int DAT_06018504;
extern int DAT_06018506;
extern int DAT_060185a0;
extern int DAT_060185a2;
extern int DAT_06018660;
extern int DAT_06018662;
extern int DAT_06018b8e;
extern int DAT_06018cc6;
extern int DAT_060193c4;
extern int DAT_060193c6;
extern int DAT_060195ac;
extern int DAT_060195ae;
extern int DAT_06019694;
extern int DAT_06019696;
extern int DAT_06019762;
extern int DAT_06019864;
extern int DAT_06019b22;
extern int DAT_06019bfc;
extern void FUN_06018320();
extern void FUN_060185d8();
extern void FUN_060192e8();
extern void FUN_06019324();
extern void FUN_0601938c();
extern void FUN_06019928();
extern int FUN_06019bc8();
extern int FUN_06019db8();
extern int FUN_06019fb2();
extern int FUN_0601a65e();
extern void course_select_display_update();
extern int cd_register_double_read();
extern int FUN_06034DEA();
extern int PTR_DAT_060185a4;
extern int PTR_DAT_06018664;
extern int PTR_DAT_060195b0;
extern int PTR_DAT_06019764;
extern int PTR_DAT_06019a24;
extern int PTR_DAT_06019b24;
extern short PTR_DAT_060182f4;

/* hud_position_ticker -- Animate HUD position/lap indicator sprites.
 * Increments frame counter at 0x0605BE2C. For first 6 frames, slides
 * two sprite slots (position/lap) by +0x90 each tick. After 6 frames,
 * snaps to final positions and resets counter.
 * On final lap: uses sprite set at 0x06089E28, otherwise 0x06089E2C.
 * Dispatches to start_banner_state or FUN_060185d8 based on GAME_STATE_BIT. */
#if 0 /* FUN_06018166 -- replaced by ASM import */
void FUN_06018166()
{
  int is_final_lap;
  int sprite_value;
  int slot_a_off = (int)DAT_06018212;
  int slot_b_off = (int)DAT_06018216;
  int car = CAR_PTR_TARGET;
  char *sprite_table = (char *)0x060684EC;    /* HUD sprite index table */
  char *vdp_slots = (char *)0x06063F64;       /* VDP1 sprite slot array */
  short *frame_counter = (short *)0x0605BE2C;
  *frame_counter = *frame_counter + 1;
  is_final_lap = *(unsigned int *)(car + DAT_06018214) < *(int *)0x06063F28 - 1U;
  if (is_final_lap) {
    sprite_value = *(int *)0x06089E28;  /* final lap sprite */
  } else {
    sprite_value = *(int *)0x06089E2C;  /* normal lap sprite */
  }
  if (*frame_counter < 6) {
    /* slide-in animation: add 0x90 per frame */
    *(int *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_a_off) << 3)) =
         *(int *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_a_off) << 3)) + 0x90;
    *(int *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_b_off) << 3)) =
         *(int *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_b_off) << 3)) + 0x90;
  } else {
    /* snap to final position, reset counter */
    *(int *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_a_off) << 3)) = sprite_value;
    *(int *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_b_off) << 3)) =
         *(int *)0x06089E30;
    *frame_counter = 0;
  }
  if (is_final_lap) {
    *(short *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_a_off) << 3) + 6) = DAT_060182f2;
  } else {
    *(short *)(vdp_slots + ((unsigned int)*(unsigned short *)(sprite_table + slot_a_off) << 3) + 6) = DAT_0601821a;
  }
  if ((GAME_STATE_BIT & (unsigned int)0x00800000) != 0) {
    FUN_060185d8();
    return;
  }
  FUN_06018320();
  return;
}
#endif

/* FUN_06018166 -- original binary (274 bytes) */
__asm__(
    ".section .text.FUN_06018166, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06018166\n"
    ".type _FUN_06018166, @function\n"
    "_FUN_06018166:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x9B, 0x50, 0xDC, 0x2C, 0xDD, 0x2D, 0xDE, 0x2D\n"  /* 0x06018166 */
    ".byte 0xD4, 0x2E, 0x63, 0xC1, 0x64, 0x42, 0x73, 0x01, 0x2C, 0x31, 0xD2, 0x2C, 0x90, 0x47, 0x62, 0x22\n"  /* 0x06018176 */
    ".byte 0x03, 0x4E, 0x72, 0xFF, 0x33, 0x22, 0x8B, 0x03, 0xD4, 0x2A, 0x64, 0x42, 0xA0, 0x03, 0xE5, 0x01\n"  /* 0x06018186 */
    ".byte 0xD4, 0x29, 0x64, 0x42, 0xE5, 0x00, 0x96, 0x3B, 0xE3, 0x05, 0x62, 0xC1, 0x32, 0x37, 0x89, 0x15\n"  /* 0x06018196 */
    ".byte 0x94, 0x37, 0x63, 0xE3, 0x36, 0xEC, 0x33, 0xBC, 0x62, 0x31, 0x62, 0x2D, 0x42, 0x08, 0x42, 0x00\n"  /* 0x060181A6 */
    ".byte 0x32, 0xDC, 0x63, 0x22, 0x33, 0x4C, 0x22, 0x32, 0x62, 0x61, 0x62, 0x2D, 0x42, 0x08, 0x42, 0x00\n"  /* 0x060181B6 */
    ".byte 0x32, 0xDC, 0x63, 0x22, 0x33, 0x4C, 0x22, 0x32, 0xA0, 0x13, 0x00, 0x09, 0x62, 0xE3, 0x36, 0xEC\n"  /* 0x060181C6 */
    ".byte 0x32, 0xBC, 0x63, 0x21, 0x63, 0x3D, 0x43, 0x08, 0x43, 0x00, 0x33, 0xDC, 0x23, 0x42, 0x62, 0x61\n"  /* 0x060181D6 */
    ".byte 0x62, 0x2D, 0x42, 0x08, 0x42, 0x00, 0x32, 0xDC, 0xD3, 0x14, 0x63, 0x32, 0x22, 0x32, 0xE2, 0x00\n"  /* 0x060181E6 */
    ".byte 0x2C, 0x21, 0x65, 0x5D, 0x25, 0x58, 0x89, 0x22, 0x63, 0xE3, 0x33, 0xBC, 0x62, 0x31, 0x62, 0x2D\n"  /* 0x060181F6 */
    ".byte 0x42, 0x08, 0x42, 0x00, 0x32, 0xDC, 0x90, 0x05, 0xA0, 0x23, 0x81, 0x23, 0x16, 0x18, 0x02, 0x1C\n"  /* 0x06018206 */
    ".byte 0x16, 0x30, 0x00, 0x90, 0x05, 0x6C, 0x06, 0x02, 0x6D, 0xF8, 0x06, 0x02, 0x11, 0x78, 0x06, 0x05\n"  /* 0x06018216 */
    ".byte 0xBE, 0x2C, 0x06, 0x06, 0x3F, 0x64, 0x06, 0x06, 0x84, 0xEC, 0x06, 0x07, 0xE9, 0x44, 0x06, 0x06\n"  /* 0x06018226 */
    ".byte 0x3F, 0x28, 0x06, 0x08, 0x9E, 0x2C, 0x06, 0x08, 0x9E, 0x28, 0x06, 0x08, 0x9E, 0x30, 0x62, 0xE3\n"  /* 0x06018236 */
    ".byte 0x32, 0xBC, 0x63, 0x21, 0x63, 0x3D, 0x43, 0x08, 0x43, 0x00, 0x33, 0xDC, 0x92, 0x4E, 0x60, 0x23\n"  /* 0x06018246 */
    ".byte 0x81, 0x33, 0xD3, 0x27, 0xD2, 0x28, 0x63, 0x32, 0x23, 0x29, 0x23, 0x38, 0x89, 0x04, 0x6B, 0xF6\n"  /* 0x06018256 */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0xA1, 0xB5, 0x6E, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xA0, 0x54\n"  /* 0x06018266 */
    ".byte 0x6E, 0xF6\n"  /* 0x06018276 */
);


#if 0 /* track_calculation -- redirected to ASM import via linker PROVIDE */
unsigned int track_calculation()
{
  unsigned int uVar3;
  unsigned short *puVar4;
  unsigned int uVar5;

  uVar3 = (unsigned int)*(unsigned short *)0x0605BE1C;
  uVar5 = (unsigned int)*(unsigned short *)0x06063D9A;

  if ((uVar3 == 0) && (uVar5 != 0)) {
    puVar4 = (unsigned short *)0x0605BE1E;

    uVar3 = (*(int(*)())0x06035280)();

    if ((uVar3 & uVar5) == 0) {
      *puVar4 = 0;
      uVar3 = 0;
    }
    else {
      *puVar4 = *puVar4 + 1;
      uVar3 = (unsigned int)*puVar4;

      if (uVar3 == 7) {
        int idx;
        *puVar4 = 0;
        *(short *)0x0605BE1C = 1;

        idx = (unsigned int)*(unsigned short *)0x06069BB6 << 3;
        *(int *)(0x06063F64 + idx) = *(int *)0x06089E3C;
        uVar3 = (unsigned int)PTR_DAT_060182f4;
        *(short *)(0x06063F64 + idx + 6) = PTR_DAT_060182f4;
      }
    }
  }

  return uVar3;
}
#endif /* track_calculation */
/* REMOVED: conflicting alias */ // void FUN_06018278(void) __attribute__((alias("track_calculation")));

/* start_banner_state -- START banner scaling/display state machine.
 * Checks if player car is in start zone (position between DAT_060183ee..DAT_060183f0).
 * When in zone: detects button press (bit 0x40 toggle), manages 6-state
 * animation sequence controlling scale_x (puVar6+0) and scale_y (puVar6+4)
 * with thresholds 0x8000, 0x10000, 0x18000, 0x20000.
 * Then renders banner via primary matrix pipeline + mesh/texture.
 * When outside zone: resets all state to zero. */
#if 0 /* FUN_06018320 -- replaced by ASM import */
void FUN_06018320()
{
  char anim_phase;
  unsigned short btn_raw, btn_edge;
  int scale_step;
  char *in_zone_flag = (char *)0x0605BE33;
  char *prev_zone = (char *)0x0605BE34;
  char *scale_data = (char *)0x06085FC0;  /* scale_x at +0, scale_y at +4 */
  char *anim_state = (char *)0x0605BE32;
  char *car_ptr_base = (char *)0x0607E940;
  char *display_flag = (char *)0x0605BE35;
  *(int *)0x0605BE34 = *(int *)0x0605BE33;
  if (((int)DAT_060183ee <= *(int *)(*(int *)car_ptr_base + (int)DAT_060183ec)) &&
     (*(int *)(*(int *)car_ptr_base + (int)DAT_060183ec) <= (int)DAT_060183f0)) {
    /* player car is in start zone */
    *in_zone_flag = 1;
    btn_raw = *(unsigned short *)0x06063D98 & 0x40;   /* controller input */
    btn_edge = (*(unsigned short *)0x0605BE30 ^ btn_raw) & btn_raw;
    *(unsigned short *)0x0605BE30 = btn_raw;
    if (*(int *)0x0605DE3C == '\0') {
      if ((((*(unsigned char *)(*(int *)car_ptr_base + 3) & 8) == 0 & (*in_zone_flag ^ *prev_zone)) != 0) &&
         ((*(unsigned int *)0x0605A010 & 0x3f) == 0)) {
        *display_flag = 1;
      }
    } else {
      *display_flag = 1;
    }
    if (*(int *)0x06085FF4 == '\0') {
      /* normal mode: 3-state scale animation */
      if ((*(int *)(*(int *)car_ptr_base + 8) == 0) && (btn_edge != 0)) {
        scale_step = (int)DAT_060183f2;
        if (*anim_state == '\0') {
          /* state 0: grow scale_y until 0x10000 */
          *(int *)scale_data = 0;
          scale_step = *(int *)(scale_data + 4) + scale_step;
          *(int *)(scale_data + 4) = scale_step;
          if ((int)0x00010000 <= scale_step) {
            *(int *)scale_data = 0x00008000;
            *(int *)(scale_data + 4) = 0x00008000;
            *anim_state = *anim_state + '\x01';
          }
        } else if (*anim_state == '\x01') {
          /* state 1: grow scale_y until 0x18000 */
          *(int *)scale_data = 0x00008000;
          scale_step = *(int *)(scale_data + 4) + scale_step;
          *(int *)(scale_data + 4) = scale_step;
          if ((int)0x00018000 <= scale_step) {
            *(int *)scale_data = 0;
            *(int *)(scale_data + 4) = 0;
            *anim_state = *anim_state + '\x01';
          }
        } else {
          /* state 2+: hold at zero */
          *(int *)scale_data = 0;
          *(int *)(scale_data + 4) = 0;
        }
      }
    } else {
      /* alternate mode: 6-state scale animation */
      anim_phase = *anim_state;
      if (anim_phase == '\0') {
        *(int *)scale_data = 0;
        *(int *)(scale_data + 4) = 0;
        if ((*(int *)(*(int *)car_ptr_base + 8) == 0) && (btn_edge != 0)) {
          *anim_state = *anim_state + '\x01';
        }
      } else if (anim_phase == '\x01') {
        /* grow scale_y by 0x100 until 0x10000 */
        scale_step = *(int *)(scale_data + 4) + 0x100;
        *(int *)(scale_data + 4) = scale_step;
        if ((int)0x00010000 <= scale_step) {
          *(int *)(scale_data + 4) = 0x00010000;
          *anim_state = *anim_state + '\x01';
        }
      } else if (anim_phase == '\x02') {
        /* grow scale_x by 0x200 until 0x8000 */
        scale_step = *(int *)scale_data + 0x200;
        *(int *)scale_data = scale_step;
        if ((int)0x00008000 <= scale_step) {
          *(int *)scale_data = 0x00008000;
          *anim_state = *anim_state + '\x01';
        }
      } else if (anim_phase == '\x03') {
        /* grow scale_y by 0x100 until 0x20000 */
        scale_step = *(int *)(scale_data + 4) + 0x100;
        *(int *)(scale_data + 4) = scale_step;
        if ((int)0x00020000 <= scale_step) {
          *(int *)(scale_data + 4) = 0x00020000;
          *anim_state = *anim_state + '\x01';
        }
      } else if (anim_phase == '\x04') {
        /* grow scale_x by 0x200 until 0x10000 then reset */
        scale_step = *(int *)scale_data + 0x200;
        *(int *)scale_data = scale_step;
        if ((int)0x00010000 <= scale_step) {
          *(int *)scale_data = 0;
          *anim_state = *anim_state + '\x01';
        }
      } else {
        /* state 5+: hold at zero */
        *(int *)scale_data = 0;
        *(int *)(scale_data + 4) = 0;
      }
    }
    if (*display_flag != '\0') {
      *(int *)scale_data = 0x00008000;
      *(int *)(scale_data + 4) = 0x00008000;
    }
    /* render banner via primary matrix pipeline */
    (*(int(*)())0x06026DBC)();                          /* matrix_push */
    (*(int(*)())0x06026E2E)(*(int *)0x06048140, *(int *)(0x06048140 + 4),
               *(int *)(0x06048140 + 8));               /* matrix_translate */
    (*(int(*)())0x06026EDE)(*(int *)(scale_data + 4) + (int)DAT_060185a0);  /* matrix_scale_y */
    (*(int(*)())0x06026E94)(*(int *)scale_data);        /* matrix_scale_x */
    (*(int(*)())0x06031D8C)(0x00200000 + (int)0x000BABE0, 0x178);  /* mesh_submit */
    (*(int(*)())0x06031A28)((char *)0x00200000 + (int)0x000BBD80,
               (int)*(short *)0x06089E98, (int)PTR_DAT_060185a4);  /* texture_submit */
    (*(int(*)())0x06026DF8)();                          /* matrix_pop */
    return;
  }
  /* outside start zone: reset all state */
  *(int *)scale_data = 0;
  *(int *)(scale_data + 4) = 0;
  *in_zone_flag = 0;
  *display_flag = 0;
  *anim_state = 0;
  return;
}
#endif

/* FUN_06018320 -- original binary (696 bytes) */
__asm__(
    ".section .text.FUN_06018320, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06018320\n"
    ".type _FUN_06018320, @function\n"
    "_FUN_06018320:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x4F, 0x22\n"  /* 0x06018320 */
    ".byte 0x7F, 0xFC, 0xD9, 0x30, 0xDA, 0x30, 0xDB, 0x31, 0xDD, 0x31, 0xDE, 0x32, 0xD6, 0x32, 0xD4, 0x33\n"  /* 0x06018330 */
    ".byte 0x63, 0x40, 0x26, 0x30, 0x65, 0xA2, 0x90, 0x51, 0x93, 0x51, 0x05, 0x5E, 0x35, 0x33, 0x8F, 0x03\n"  /* 0x06018340 */
    ".byte 0xEC, 0x00, 0x93, 0x4D, 0x35, 0x37, 0x8B, 0x05, 0x2E, 0xC2, 0x1E, 0xC1, 0x24, 0xC0, 0x29, 0xC0\n"  /* 0x06018350 */
    ".byte 0xA1, 0x14, 0x2D, 0xC0, 0xE7, 0x01, 0x62, 0x7C, 0x24, 0x20, 0xD0, 0x29, 0xD3, 0x29, 0x60, 0x01\n"  /* 0x06018360 */
    ".byte 0x63, 0x31, 0x60, 0x0D, 0x63, 0x3D, 0xC9, 0x40, 0x68, 0x0D, 0x23, 0x8A, 0x23, 0x89, 0x65, 0x3D\n"  /* 0x06018370 */
    ".byte 0xD3, 0x24, 0x23, 0x81, 0xD0, 0x24, 0x60, 0x00, 0x60, 0x0C, 0x20, 0x08, 0x89, 0x02, 0x67, 0x7C\n"  /* 0x06018380 */
    ".byte 0xA0, 0x17, 0x29, 0x70, 0x62, 0x40, 0x63, 0x60, 0x61, 0xA2, 0x62, 0x2C, 0x63, 0x3C, 0x60, 0x13\n"  /* 0x06018390 */
    ".byte 0x22, 0x3A, 0x84, 0x03, 0xC8, 0x08, 0x03, 0x29, 0x73, 0xFF, 0x63, 0x3B, 0x23, 0x38, 0x00, 0x29\n"  /* 0x060183A0 */
    ".byte 0x22, 0x09, 0x22, 0x28, 0x89, 0x05, 0xD0, 0x19, 0x60, 0x02, 0xC8, 0x3F, 0x8B, 0x01, 0x67, 0x7C\n"  /* 0x060183B0 */
    ".byte 0x29, 0x70, 0xD4, 0x17, 0xD0, 0x17, 0x60, 0x00, 0x60, 0x0C, 0x20, 0x08, 0x8B, 0x53, 0x63, 0xA2\n"  /* 0x060183C0 */
    ".byte 0x50, 0x32, 0x20, 0x08, 0x89, 0x01, 0xA0, 0xA7, 0x00, 0x09, 0x65, 0x5D, 0x25, 0x58, 0x8B, 0x01\n"  /* 0x060183D0 */
    ".byte 0xA0, 0xA2, 0x00, 0x09, 0x95, 0x05, 0x60, 0xD0, 0xA0, 0x3D, 0x60, 0x0C, 0x01, 0xEC, 0x00, 0x86\n"  /* 0x060183E0 */
    ".byte 0x00, 0x9F, 0x10, 0x00, 0x06, 0x05, 0xBE, 0x35, 0x06, 0x07, 0xE9, 0x40, 0x00, 0x00, 0x80, 0x00\n"  /* 0x060183F0 */
    ".byte 0x06, 0x05, 0xBE, 0x32, 0x06, 0x08, 0x5F, 0xC0, 0x06, 0x05, 0xBE, 0x34, 0x06, 0x05, 0xBE, 0x33\n"  /* 0x06018400 */
    ".byte 0x06, 0x06, 0x3D, 0x98, 0x06, 0x05, 0xBE, 0x30, 0x06, 0x05, 0xDE, 0x3C, 0x06, 0x05, 0xA0, 0x10\n"  /* 0x06018410 */
    ".byte 0x00, 0x01, 0x00, 0x00, 0x06, 0x08, 0x5F, 0xF4, 0x2E, 0xC2, 0x52, 0xE1, 0x32, 0x5C, 0x63, 0x23\n"  /* 0x06018420 */
    ".byte 0x1E, 0x21, 0x33, 0x43, 0x8B, 0x1D, 0x2E, 0xB2, 0x1E, 0xB1, 0x63, 0xD0, 0x73, 0x01, 0x2D, 0x30\n"  /* 0x06018430 */
    ".byte 0xA0, 0x17, 0x00, 0x09, 0x2E, 0xB2, 0x52, 0xE1, 0x32, 0x5C, 0x63, 0x23, 0x1E, 0x21, 0xD2, 0x2E\n"  /* 0x06018440 */
    ".byte 0x33, 0x23, 0x8B, 0x0E, 0x2E, 0xC2, 0x1E, 0xC1, 0x62, 0xD0, 0x72, 0x01, 0xA0, 0x09, 0x2D, 0x20\n"  /* 0x06018450 */
    ".byte 0x2E, 0xC2, 0xA0, 0x06, 0x1E, 0xC1, 0x88, 0x00, 0x89, 0xDE, 0x88, 0x01, 0x89, 0xEA, 0xAF, 0xF7\n"  /* 0x06018460 */
    ".byte 0x00, 0x09, 0xA0, 0x59, 0x00, 0x09, 0x97, 0x45, 0x96, 0x45, 0x60, 0xD0, 0xA0, 0x48, 0x60, 0x0C\n"  /* 0x06018470 */
    ".byte 0x2E, 0xC2, 0x1E, 0xC1, 0x62, 0xA2, 0x50, 0x22, 0x20, 0x08, 0x8B, 0x4D, 0x65, 0x5D, 0x25, 0x58\n"  /* 0x06018480 */
    ".byte 0x89, 0x4A, 0x63, 0xD0, 0x73, 0x01, 0x2D, 0x30, 0xA0, 0x46, 0x00, 0x09, 0x52, 0xE1, 0x32, 0x6C\n"  /* 0x06018490 */
    ".byte 0x1E, 0x21, 0x63, 0x23, 0x33, 0x43, 0x8B, 0x3F, 0x1E, 0x41, 0x63, 0xD0, 0x73, 0x01, 0x2D, 0x30\n"  /* 0x060184A0 */
    ".byte 0xA0, 0x3A, 0x00, 0x09, 0x62, 0xE2, 0x32, 0x7C, 0x2E, 0x22, 0x63, 0x23, 0x33, 0xB3, 0x8B, 0x33\n"  /* 0x060184B0 */
    ".byte 0x2E, 0xB2, 0x63, 0xD0, 0x73, 0x01, 0x2D, 0x30, 0xA0, 0x2E, 0x00, 0x09, 0x52, 0xE1, 0x32, 0x6C\n"  /* 0x060184C0 */
    ".byte 0x1E, 0x21, 0x63, 0x23, 0xD4, 0x0D, 0x33, 0x43, 0x8B, 0x26, 0x1E, 0x41, 0x63, 0xD0, 0x73, 0x01\n"  /* 0x060184D0 */
    ".byte 0x2D, 0x30, 0xA0, 0x21, 0x00, 0x09, 0x62, 0xE2, 0x32, 0x7C, 0x63, 0x23, 0x2E, 0x22, 0x33, 0x43\n"  /* 0x060184E0 */
    ".byte 0x8B, 0x1A, 0x2E, 0xC2, 0x63, 0xD0, 0x73, 0x01, 0x2D, 0x30, 0xA0, 0x15, 0x00, 0x09, 0x2E, 0xC2\n"  /* 0x060184F0 */
    ".byte 0xA0, 0x12, 0x1E, 0xC1, 0x02, 0x00, 0x01, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00\n"  /* 0x06018500 */
    ".byte 0x88, 0x00, 0x89, 0xB5, 0x88, 0x01, 0x89, 0xC1, 0x88, 0x02, 0x89, 0xCB, 0x88, 0x03, 0x89, 0xD5\n"  /* 0x06018510 */
    ".byte 0x88, 0x04, 0x89, 0xE0, 0xAF, 0xEB, 0x00, 0x09, 0x60, 0x90, 0x60, 0x0C, 0x20, 0x08, 0x89, 0x01\n"  /* 0x06018520 */
    ".byte 0x2E, 0xB2, 0x1E, 0xB1, 0xD3, 0x1C, 0x43, 0x0B, 0x00, 0x09, 0xD8, 0x1C, 0xD3, 0x1C, 0x56, 0x82\n"  /* 0x06018530 */
    ".byte 0x55, 0x81, 0x43, 0x0B, 0x64, 0x82, 0x54, 0xE1, 0x92, 0x2A, 0xD3, 0x1A, 0x43, 0x0B, 0x34, 0x2C\n"  /* 0x06018540 */
    ".byte 0xD3, 0x19, 0x43, 0x0B, 0x64, 0xE2, 0x95, 0x24, 0xD2, 0x18, 0xD3, 0x19, 0x64, 0x23, 0x34, 0x3C\n"  /* 0x06018550 */
    ".byte 0xD3, 0x18, 0x43, 0x0B, 0x2F, 0x22, 0x96, 0x1D, 0xD5, 0x17, 0x64, 0xF2, 0xD2, 0x17, 0xD3, 0x18\n"  /* 0x06018560 */
    ".byte 0x65, 0x51, 0x43, 0x0B, 0x34, 0x2C, 0x7F, 0x04, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6\n"  /* 0x06018570 */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xD3, 0x13, 0x43, 0x2B, 0x6E, 0xF6, 0x7F, 0x04, 0x4F, 0x26\n"  /* 0x06018580 */
    ".byte 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x06018590 */
    ".byte 0x38, 0xE3, 0x01, 0x78, 0x01, 0x45, 0xFF, 0xFF, 0x06, 0x02, 0x6D, 0xBC, 0x06, 0x04, 0x81, 0x40\n"  /* 0x060185A0 */
    ".byte 0x06, 0x02, 0x6E, 0x2E, 0x06, 0x02, 0x6E, 0xDE, 0x06, 0x02, 0x6E, 0x94, 0x00, 0x20, 0x00, 0x00\n"  /* 0x060185B0 */
    ".byte 0x00, 0x0B, 0xAB, 0xE0, 0x06, 0x03, 0x1D, 0x8C, 0x06, 0x08, 0x9E, 0x98, 0x00, 0x0B, 0xBD, 0x80\n"  /* 0x060185C0 */
    ".byte 0x06, 0x03, 0x1A, 0x28, 0x06, 0x02, 0x6D, 0xF8\n"  /* 0x060185D0 */
);


/* scene_object_render_state3 -- Render scene overlay object in game state 3.
 * Guards on state flag (0x06083254 == 3). Pushes matrix, sets position from
 * table at 0x06048140, applies rotation (DAT_06018660), renders texture
 * from ROM offsets 0x002BABE0 (tiles) and 0x002BBD80 (palette), pops matrix. */
#if 0 /* FUN_060185D8 -- replaced by ASM import */
void FUN_060185d8(void)
{
    if (*(int *)0x06083254 == '\x03') {
        (*(int(*)())0x06026DBC)();  /* matrix_push */
        (*(int(*)())0x06026E2E)(*(int *)0x06048140, *(int *)(0x06048140 + 4),
                   *(int *)(0x06048140 + 8));  /* set_position */
        (*(int(*)())0x06026EDE)((int)DAT_06018660);  /* set_rotation */
        (*(int(*)())0x06031D8C)(0x00200000 + (int)0x000BABE0, 0x178);  /* texture_select */
        (*(int(*)())0x06031A28)((char *)0x00200000 + (int)0x000BBD80,
                   (int)*(short *)0x06089E98, (int)PTR_DAT_06018664);  /* palette_draw */
        (*(int(*)())0x06026DF8)();  /* matrix_pop */
    }
}
#endif

/* FUN_060185D8 -- original binary (352 bytes) */
__asm__(
    ".section .text.FUN_060185D8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060185D8\n"
    ".global _FUN_060185d8\n"
    ".type _FUN_060185D8, @function\n"
    "_FUN_060185D8:\n"
    "_FUN_060185d8:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0x7F, 0xFC, 0xD0, 0x22, 0x60, 0x00, 0x60, 0x0C, 0x88, 0x03, 0x8B, 0x21\n"  /* 0x060185D8 */
    ".byte 0xD3, 0x20, 0x43, 0x0B, 0x00, 0x09, 0xDE, 0x20, 0xD3, 0x20, 0x56, 0xE2, 0x55, 0xE1, 0x43, 0x0B\n"  /* 0x060185E8 */
    ".byte 0x64, 0xE2, 0x94, 0x31, 0xD3, 0x1E, 0x43, 0x0B, 0x00, 0x09, 0x95, 0x2E, 0xD2, 0x1D, 0xD3, 0x1E\n"  /* 0x060185F8 */
    ".byte 0x64, 0x23, 0x34, 0x3C, 0xD3, 0x1D, 0x43, 0x0B, 0x2F, 0x22, 0x96, 0x27, 0xD5, 0x1C, 0x64, 0xF2\n"  /* 0x06018608 */
    ".byte 0xD2, 0x1C, 0xD3, 0x1D, 0x65, 0x51, 0x43, 0x0B, 0x34, 0x2C, 0x7F, 0x04, 0x4F, 0x26, 0xD3, 0x1B\n"  /* 0x06018618 */
    ".byte 0x43, 0x2B, 0x6E, 0xF6, 0x7F, 0x04, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6, 0xD6, 0x18, 0xD5, 0x19\n"  /* 0x06018628 */
    ".byte 0xE4, 0x00, 0xD0, 0x19, 0xA0, 0x36, 0x60, 0x02, 0xA0, 0x3C, 0x00, 0x09, 0x62, 0x4D, 0xD3, 0x17\n"  /* 0x06018638 */
    ".byte 0x23, 0x21, 0x61, 0x4D, 0xD3, 0x16, 0x23, 0x11, 0x60, 0x4D, 0xA0, 0x02, 0x25, 0x01, 0x62, 0x4D\n"  /* 0x06018648 */
    ".byte 0x25, 0x21, 0x64, 0x4D, 0xA0, 0x2C, 0x26, 0x41, 0x38, 0xE3, 0x01, 0x78, 0x01, 0x45, 0xFF, 0xFF\n"  /* 0x06018658 */
    ".byte 0x06, 0x08, 0x32, 0x54, 0x06, 0x02, 0x6D, 0xBC, 0x06, 0x04, 0x81, 0x40, 0x06, 0x02, 0x6E, 0x2E\n"  /* 0x06018668 */
    ".byte 0x06, 0x02, 0x6E, 0xDE, 0x00, 0x20, 0x00, 0x00, 0x00, 0x0B, 0xAB, 0xE0, 0x06, 0x03, 0x1D, 0x8C\n"  /* 0x06018678 */
    ".byte 0x06, 0x08, 0x9E, 0x98, 0x00, 0x0B, 0xBD, 0x80, 0x06, 0x03, 0x1A, 0x28, 0x06, 0x02, 0x6D, 0xF8\n"  /* 0x06018688 */
    ".byte 0x06, 0x05, 0xBE, 0x38, 0x06, 0x05, 0xBE, 0x36, 0x06, 0x07, 0xEA, 0xD8, 0x06, 0x05, 0xBE, 0x1C\n"  /* 0x06018698 */
    ".byte 0x06, 0x05, 0xBE, 0x1E, 0x88, 0x00, 0x89, 0xC7, 0x88, 0x01, 0x89, 0xC7, 0x88, 0x02, 0x89, 0xCE\n"  /* 0x060186A8 */
    ".byte 0x00, 0x0B, 0x00, 0x09, 0xE4, 0x00, 0xD2, 0x0F, 0x60, 0x4F, 0x22, 0x41, 0xD2, 0x0E, 0x22, 0x41\n"  /* 0x060186B8 */
    ".byte 0xD2, 0x0E, 0x22, 0x01, 0xD2, 0x0E, 0x60, 0x4F, 0x22, 0x41, 0xD2, 0x0E, 0x22, 0x41, 0xD2, 0x0E\n"  /* 0x060186C8 */
    ".byte 0x22, 0x01, 0xD2, 0x0E, 0x22, 0x41, 0xD2, 0x0E, 0x00, 0x0B, 0x22, 0x41, 0xE4, 0x00, 0xD2, 0x0D\n"  /* 0x060186D8 */
    ".byte 0x63, 0x4D, 0x60, 0x4D, 0x22, 0x31, 0xD2, 0x0C, 0x22, 0x41, 0xD2, 0x08, 0x22, 0x01, 0xD3, 0x08\n"  /* 0x060186E8 */
    ".byte 0x00, 0x0B, 0x23, 0x41, 0x06, 0x05, 0xBE, 0x24, 0x06, 0x05, 0xBE, 0x22, 0x06, 0x05, 0xBE, 0x20\n"  /* 0x060186F8 */
    ".byte 0x06, 0x05, 0xBE, 0x2A, 0x06, 0x05, 0xBE, 0x26, 0x06, 0x05, 0xBE, 0x28, 0x06, 0x05, 0xBE, 0x36\n"  /* 0x06018708 */
    ".byte 0x06, 0x05, 0xBE, 0x38, 0x06, 0x05, 0xBE, 0x1C, 0x06, 0x05, 0xBE, 0x1E, 0xE4, 0x00, 0xD2, 0x02\n"  /* 0x06018718 */
    ".byte 0x22, 0x41, 0xD2, 0x02, 0x00, 0x0B, 0x22, 0x41, 0x06, 0x05, 0xBE, 0x36, 0x06, 0x05, 0xBE, 0x38\n"  /* 0x06018728 */
);


/* hud_state_reset -- Reset course-specific HUD state registers.
 * Dispatches on CAR_COUNT (course index 0/1/2):
 *   Course 0: clears 8 registers at 0x0605BE20..0x0605BE38
 *   Course 1: clears 4 registers at 0x0605BE1C..0x0605BE38
 *   Course 2: clears 2 registers at 0x0605BE36..0x0605BE38
 * Returns CAR_COUNT (or 0 for course 0). */
int FUN_06018634()
{
  int course = CAR_COUNT;
  if (course == 0) {
    *(short *)0x0605BE24 = 0;
    *(short *)0x0605BE22 = 0;
    *(short *)0x0605BE20 = 0;
    *(short *)0x0605BE2A = 0;
    *(short *)0x0605BE26 = 0;
    *(short *)0x0605BE28 = 0;
    *(short *)0x0605BE36 = 0;
    *(short *)0x0605BE38 = 0;
    return 0;
  }
  if (course == 1) {
    *(short *)0x0605BE1C = 0;
    *(short *)0x0605BE1E = 0;
    course = 0;
    *(short *)0x0605BE36 = 0;
  } else {
    if (course != 2) {
      return course;
    }
    *(short *)0x0605BE36 = 0;
    course = 2;
  }
  *(short *)0x0605BE38 = 0;
  return course;
}

/* race_scene_init -- initialize racing scene with course geometry, textures, and subsystems */
void FUN_06018a3c()
{
  char *track_index_ptr;
  char *segment_count_ptr;
  char *total_segments_ptr;
  int table_offset;
  int course_offset;
  int palette_mask;
  int cd_cmd_buf;
  char cd_cmd_type;
  char cd_cmd_flag;
  int cd_subcmd;
  char cd_timeout_lo;
  char cd_timeout_hi;
  char cd_end_marker;

  track_index_ptr = (char *)0x0607EAD8; /* current track index */

  /* Set track complexity flags based on track index */
  if (*(int *)0x06078868 < 10) {
    *(int *)0x0607867C = 0; /* extra_geometry_flag */
    *(int *)0x06083255 = 0; /* extended_track_flag */
  }
  else {
    if (*(int *)0x06078868 < 0xc) {
      *(int *)0x0607867C = 0;
    }
    else {
      *(int *)0x0607867C = 1; /* enable extra geometry for tracks >= 12 */
    }
    *(int *)0x06083255 = 1; /* enable extended track for tracks >= 10 */
  }

  /* Run rendering subsystem chain if not in skip mode */
  if (*(int *)0x0605AD08 == 0) {
    (*(int(*)())0x0600736C)();        /* car_array_init */
    (*(int(*)())0x06012DB4)(*(int *)track_index_ptr); /* track_geometry_load */
    (*(int(*)())(*(int *)(0x0605D1BC + *(int *)((int)(int)track_index_ptr << 2))))(); /* track_type_dispatch */
    (*(int(*)())0x06012D7C)(*(int *)track_index_ptr); /* track_collision_load */
    if (*(int *)0x06078635 == '\0') {
      (*(int(*)())0x06012E7C)();      /* scenery_object_load */
    }
    if (*(short *)0x0607ED8C == 0) {
      (*(int(*)())0x06018FF8)();      /* music_init */
    }
  }

  if (*(short *)0x0607ED8C != 0) {
    (*(int(*)())0x06018FF8)();        /* music_init (force if flag set) */
  }

  /* Course-specific palette/texture setup */
  if ((GAME_STATE_BIT & (int)DAT_06018b8e) == 0) {
    palette_mask = 0;
    course_offset = 3;
  }
  else {
    if (*(int *)0x0605AB18 == '\0') {
      if (COURSE_SELECT == 2) {
        /* Course 2 (expert): build CD command for special asset load */
        (*(int(*)())0x06018E1E)((unsigned char)*(int *)0x06078648 + 6);
        cd_cmd_buf = 2;
        cd_cmd_type = 6;
        cd_cmd_flag = 1;
        cd_subcmd = 2;
        cd_timeout_lo = 9;
        cd_timeout_hi = 99;
        cd_end_marker = 0x8f;
        (*(int(*)())0x06034D1C)(&cd_cmd_buf); /* cd_command_dispatch */
      }
      else {
        (*(int(*)())0x06018DDC)((unsigned char)*(int *)0x06078648 + 6,(unsigned char)*(int *)0x06078648 + 6,0xf);
      }
      goto LAB_06018bd8;
    }
    palette_mask = 0xf;
    course_offset = (int)(char)((int *)0x0605D23C)[(unsigned char)*(int *)0x06078648];
  }

  (*(int(*)())0x06018DDC)(course_offset,course_offset,palette_mask);

LAB_06018bd8:
  *(int *)0x0607EBE4 = 0;
  table_offset = *(int *)((int)(int)track_index_ptr << 1);

  /* Load track geometry parameters from ROM tables at 0x0604800C */
  *(unsigned int *)0x0607EA9C = (unsigned int)*(unsigned short *)(0x0604806C + table_offset); /* polygon_count */
  *(char **)0x0607EB84 = 0x060D5840; /* texture_base_a */
  *(char **)0x0607EB88 = 0x060C6000; /* texture_base_b */
  *(char **)0x06063F3C = 0x0604800C + *(int *)((int)(int)track_index_ptr << 3); /* track_segment_table */

  course_offset = (*(int(*)())0x06035280)(); /* cd_get_track_segment_count */
  *(int *)0x06063F18 = course_offset + -1; /* max_segment_index */
  *(int *)0x060786AC = 0;   /* render_segment_start */
  *(int *)0x06063F1C = 1;   /* render_direction */
  *(int *)0x06063F20 = 0;   /* render_wrap_flag */
  *(int *)0x06063F24 = 0;   /* render_lod_bias */
  *(int *)0x06086034 = 0;   /* scenery_counter */

  segment_count_ptr = (char *)0x06063F28;
  course_offset = (int)(char)((char)COURSE_SELECT * '\x06'); /* course * 6 table stride */
  *(unsigned int *)0x06063F28 = (unsigned int)*(unsigned short *)(0x0604805A + table_offset + course_offset); /* road_segment_count */
  *(unsigned int *)0x0607EA98 = (unsigned int)*(unsigned short *)(0x06048072 + table_offset); /* track_width */
  *(unsigned int *)0x0607EAA0 = (unsigned int)*(unsigned short *)(0x06048024 + table_offset); /* track_height */

  total_segments_ptr = (char *)0x0607EAAC;
  *(unsigned int *)0x0607EAAC = (unsigned int)*(unsigned short *)(0x0604802A + table_offset + course_offset); /* total_road_polygons */
  *(unsigned int *)total_segments_ptr =
       *(int *)total_segments_ptr +
       (unsigned int)*(unsigned short *)
              (0x0604803C + table_offset + (char)((char)*(int *)0x0605AD0C * '\x06')) *
       *(int *)segment_count_ptr;

  /* DMA copy VDP1 command table */
  (*(int(*)())0x0602761E)(0x25C00220 + *(int *)(0x06059FFC << 3),0x0605CDDC,0xa0);

  /* Initialize rendering subsystems */
  (*(int(*)())0x060149E0)(); /* vdp1_sprite_table_init */
  (*(int(*)())0x060148FC)(); /* vdp1_palette_init */
  (*(int(*)())0x06026CE0)(); /* matrix_pipeline_init */
  VBLANK_OUT_COUNTER = 0;

  /* Initialize game subsystems */
  (*(int(*)())0x0600A026)(); /* car_physics_init */
  *(int *)0x0605AD08 = 0;   /* clear skip flag */
  *(char **)0x0607E944 = 0x06078900; /* car_array_base = 0x06078900 */

  (*(int(*)())0x06010994)(); /* selection_screen_init */
  (*(int(*)())0x060038D4)(); /* input_init */
  (*(int(*)())0x060039C8)(); /* timer_init */
  (*(int(*)())(*(int *)(0x0605D1CC + *(int *)((int)(int)track_index_ptr << 2))))(); /* course_specific_init */
  (*(int(*)())0x060032D4)(); /* hud_init */
  (*(int(*)())0x06003430)(); /* camera_init */
  (*(int(*)())0x06014994)(); /* collision_map_init */
  (*(int(*)())0x06021128)(); /* track_sprite_init */

  return;
}

/* cd_command_build_type2 -- Build and send a CD command type 2 buffer.
 * Constructs a command buffer on stack with fixed fields (cmd=2, flag=1,
 * subcmd=2, timeout=99) and caller-supplied parameters. Dispatches
 * via CD command handler at 0x06034D1C. */
int FUN_06018ddc(param_1, param_2, param_3)
    char param_1;
    char param_2;
    char param_3;
{
    int result;
    int cmd_buf[2];     /* 8-byte command buffer on stack */
    char cmd_params[8]; /* parameter bytes */

    /* Build command buffer */
    cmd_buf[0] = 2;            /* command type */
    ((char *)cmd_buf)[5] = 1;  /* flag byte */
    cmd_buf[1] = 2;            /* sub-command */
    cmd_params[1] = 99;        /* timeout */
    ((char *)cmd_buf)[4] = param_1;  /* user param 1 */
    cmd_params[0] = param_2;         /* user param 2 */
    cmd_params[4] = param_3;         /* user param 3 */

    result = (*(int(*)())0x06034D1C)(cmd_buf);  /* cd_command_dispatch */
    return result;
}

/* cd_command_send_type2 -- Send CD command type 2 with parameter.
 * Builds a 3-word command buffer: {cmd=2, flag=1, param=param_1}
 * and dispatches via CD command handler at 0x06034DEA. */
int FUN_06018e1e(char param_1)
{
    int buf[2];
    char *bytes = (char *)buf;

    buf[0] = 2;       /* command type */
    bytes[5] = 1;     /* flag byte */
    bytes[4] = param_1; /* parameter */

    return (*(int(*)())0x06034DEA)(buf);
}

#if 0 /* FUN_06018e70 -- replaced by ASM import in cd_command.c */
int
FUN_06018e70()
{
    int buf[2];
    buf[0] = 3;
    return FUN_06034DEA(buf);
}
#endif

#if 0 /* FUN_06018eac -- replaced by ASM import in cd_command.c */
int
FUN_06018eac()
{
    char buf[16];
    cd_register_double_read(buf);
    return buf[0] & 0x1f;
}
#endif

/* scsp_load_driver_a -- Load sound driver bank A into SCSP RAM.
 * Sends stop+init commands to sound channel 0xF, waits for SCSP ready,
 * calls loader at 0x06012EDC, clears SCSP register, re-sends stop. */
#if 0 /* FUN_06018FA4 -- replaced by ASM import */
void FUN_06018fa4(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);   /* stop */
    snd_cmd(0xf, 0xAE0005FF);   /* init */
    FUN_060192e8();              /* busy-wait timeout */

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x06012EDC)();
        *(short *)0x25A02DBE = 0;  /* clear SCSP control */
    }
    snd_cmd(0xf, 0xAE0001FF);   /* stop */
}
#endif

/* FUN_06018ff8: L2 version in sound_init.c */
extern void FUN_06018FF8(void);
#if 0 /* FUN_06018FF8 -- replaced by ASM import */
void FUN_06018ff8(void) { FUN_06018FF8(); }
#endif

/* scsp_load_driver_c -- Load sound driver bank C into SCSP RAM.
 * Calls loader at 0x06012F10, sends stop then master volume after. */
/* scsp_load_driver_c -- Load sound driver bank C into SCSP RAM.
 * Stops sound channel 0xF, waits for busy timeout via FUN_060192e8,
 * calls loader at 0x06012F10, clears SCSP register, restores volume. */
#if 0 /* FUN_06019058 -- replaced by ASM import */
void FUN_06019058(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);   /* stop */
    snd_cmd(0xf, 0xAE0005FF);   /* init */
    FUN_060192e8();              /* wait for sound CPU ready */

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x06012F10)();       /* load bank C data */
        *(short *)0x25A02DBE = 0;        /* clear SCSP status */
    }
    snd_cmd(0xf, 0xAE0001FF);   /* stop */
    snd_cmd(0xf, 0xAE0600FF);   /* master volume restore */
}
#endif

/* scsp_load_driver_d -- Load sound driver bank D into SCSP RAM.
 * Calls loader at 0x06012F20. */
#if 0 /* FUN_060190B8 -- replaced by ASM import */
void FUN_060190b8(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);
    snd_cmd(0xf, 0xAE0005FF);
    FUN_060192e8();

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x06012F20)();
        *(short *)0x25A02DBE = 0;
    }
    snd_cmd(0xf, 0xAE0001FF);
}
#endif

/* scsp_load_driver_e -- Load sound driver bank E into SCSP RAM.
 * Calls loader at 0x06012F50. */
#if 0 /* FUN_060190F4 -- replaced by ASM import */
void FUN_060190f4(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);
    snd_cmd(0xf, 0xAE0005FF);
    FUN_060192e8();

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x06012F50)();
        *(short *)0x25A02DBE = 0;
    }
    snd_cmd(0xf, 0xAE0001FF);
}
#endif

/* scsp_load_driver_f -- Load sound driver bank F into SCSP RAM.
 * Calls loader at 0x06012F58. */
#if 0 /* FUN_0601914C -- replaced by ASM import */
void FUN_0601914c(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);
    snd_cmd(0xf, 0xAE0005FF);
    FUN_060192e8();

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x06012F58)();
        *(short *)0x25A02DBE = 0;
    }
    snd_cmd(0xf, 0xAE0001FF);
}
#endif

/* scsp_load_driver_g -- Load sound driver bank G into SCSP RAM.
 * Calls loader at 0x06012F60. */
#if 0 /* FUN_06019188 -- replaced by ASM import */
void FUN_06019188(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);
    snd_cmd(0xf, 0xAE0005FF);
    FUN_060192e8();

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x06012F60)();
        *(short *)0x25A02DBE = 0;
    }
    snd_cmd(0xf, 0xAE0001FF);
}
#endif

/* scsp_dma_load -- Load sound data via DMA into SCSP RAM at 0x25A03000.
 * Source: 0x00200000, size: 0x0006D000 (445KB). */
#if 0 /* FUN_060191E0 -- replaced by ASM import */
void FUN_060191e0(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);
    snd_cmd(0xf, 0xAE0005FF);
    FUN_060192e8();

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x0602760C)(0x25A03000, 0x00200000, 0x0006D000);
        *(short *)0x25A02DBE = 0;
    }
    snd_cmd(0xf, 0xAE0001FF);
}
#endif

/* scsp_dma_load_alt -- Load alternate sound data via DMA into SCSP RAM.
 * Source: 0x0026D000, size: 0x0006D000 (445KB). Same dest as scsp_dma_load. */
#if 0 /* FUN_06019248 -- replaced by ASM import */
void FUN_06019248(void)
{
    void (*snd_cmd)(int, int) = (void (*)(int, int))0x0601D5F4;

    SOUND_TIMEOUT_FLAG = 0;
    snd_cmd(0xf, 0xAE0001FF);
    snd_cmd(0xf, 0xAE0005FF);
    FUN_060192e8();

    if (SOUND_TIMEOUT_FLAG == 0) {
        (*(int(*)())0x0602760C)(0x25A03000, 0x0026D000, 0x0006D000);
        *(short *)0x25A02DBE = 0;
    }
    snd_cmd(0xf, 0xAE0001FF);
}
#endif


#if 0 /* sound_channels_stop -- redirected to ASM import via linker PROVIDE */
/* 0x0601935E: sound_channels_stop */
/* sound_channels_stop -- Stop sound channels 1-3.
 * Sends stop command (data=0) to channels 1, 3, 2.
 * Lighter version of sound_channels_reset (no SCSP slot writes).
 * Called during race state transitions (states 15, 16). */
extern void sound_cmd_dispatch(int channel, int command);

void sound_channels_stop(void)
{
    sound_cmd_dispatch(1, 0);  /* stop channel 1 */
    sound_cmd_dispatch(3, 0);  /* stop channel 3 */
    sound_cmd_dispatch(2, 0);  /* stop channel 2 */
}
#endif /* sound_channels_stop */


/* peripheral_config_setup -- Configure peripheral interrupt priorities.
 * Calls SCU interrupt config function at 0x06038BD4 with (mask, priority) pairs.
 * Sets bit 30 of INPUT_STATE to signal peripheral system ready. */
/* FUN_06019324 -- original binary (58 bytes) */
__asm__(
    ".section .text.FUN_06019324, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019324\n"
    ".type _FUN_06019324, @function\n"
    "_FUN_06019324:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0xDE, 0x13, 0x94, 0x23, 0x4E, 0x0B, 0xE5, 0x01, 0xE5, 0x04, 0x4E, 0x0B\n"  /* 0x06019324 */
    ".byte 0x64, 0x53, 0xE5, 0x05, 0x4E, 0x0B, 0xE4, 0x08, 0xE5, 0x06, 0x4E, 0x0B, 0xE4, 0x10, 0xE5, 0x07\n"  /* 0x06019334 */
    ".byte 0x4E, 0x0B, 0xE4, 0x20, 0xE5, 0x00, 0x4E, 0x0B, 0xE4, 0x01, 0xD4, 0x0B, 0xD3, 0x0B, 0x62, 0x42\n"  /* 0x06019344 */
    ".byte 0x22, 0x3B, 0x24, 0x22, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x06019354 */
);


/* sound_vdp2_scroll_setup -- DMA-copy 5 scroll plane data blocks to VDP2 VRAM.
 * Loads sound system visualization data (waveform/spectrum display).
 *   0x25F00540: color data (0x20 bytes)
 *   0x25F00000: pattern names (0x20 bytes)
 *   0x25F00600: cell data (0x20 bytes)
 *   0x25F00620: animation cells (0xE0 bytes)
 *   0x25F00780: palette data (0x80 bytes) */
#if 0 /* FUN_0601938C -- replaced by ASM import */
void FUN_0601938c(void)
{
    register int dma_copy asm("r3") = 0x0602761E;
    (*(int(*)())dma_copy)(0x25F00540, 0x0605CE9C, 0x20);
    (*(int(*)())dma_copy)(0x25F00000, 0x0605CD9C, 0x20);
    (*(int(*)())dma_copy)(0x25F00600, 0x0605CF9C, 0x20);
    (*(int(*)())dma_copy)(0x25F00620, 0x0605CEBC, 0xE0);
    (*(int(*)())dma_copy)(0x25F00780, 0x06049DC4, 0x80);
}
#endif

/* FUN_0601938C -- original binary (104 bytes) */
__asm__(
    ".section .text.FUN_0601938C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601938C\n"
    ".global _FUN_0601938c\n"
    ".type _FUN_0601938C, @function\n"
    "_FUN_0601938C:\n"
    "_FUN_0601938c:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0xDE, 0x0D, 0xD5, 0x0E, 0xD4, 0x0E, 0x4E, 0x0B, 0xE6, 0x20, 0xD5, 0x0E\n"  /* 0x0601938C */
    ".byte 0xD4, 0x0E, 0x4E, 0x0B, 0xE6, 0x20, 0xD5, 0x0E, 0xD4, 0x0E, 0x4E, 0x0B, 0xE6, 0x20, 0x96, 0x0B\n"  /* 0x0601939C */
    ".byte 0xD5, 0x0D, 0xD4, 0x0E, 0x4E, 0x0B, 0x00, 0x09, 0x96, 0x07, 0xD5, 0x0D, 0xD4, 0x0D, 0x4E, 0x0B\n"  /* 0x060193AC */
    ".byte 0x00, 0x09, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6, 0x00, 0xE0, 0x00, 0x80, 0x06, 0x02, 0x76, 0x1E\n"  /* 0x060193BC */
    ".byte 0x06, 0x05, 0xCE, 0x9C, 0x25, 0xF0, 0x05, 0x40, 0x06, 0x05, 0xCD, 0x9C, 0x25, 0xF0, 0x00, 0x00\n"  /* 0x060193CC */
    ".byte 0x06, 0x05, 0xCF, 0x9C, 0x25, 0xF0, 0x06, 0x00, 0x06, 0x05, 0xCE, 0xBC, 0x25, 0xF0, 0x06, 0x20\n"  /* 0x060193DC */
    ".byte 0x06, 0x04, 0x9D, 0xC4, 0x25, 0xF0, 0x07, 0x80\n"  /* 0x060193EC */
);


/* scene_state_init_flush -- Reset state flags, flush render pipeline, load VDP2 scroll data. */
#if 0 /* FUN_060193F4 -- replaced by ASM import */
void FUN_060193f4()
{
  char *render_flags;
  char *scu_int_clear;
  /* Clear scene state flags */
  *(int *)0x06085FF0 = 0;
  *(int *)0x0605D245 = 0;
  *(int *)0x06085FF1 = 1;
  *(int *)0x06085FF2 = 0;
  *(int *)0x06085FF3 = 0;
  *(int *)0x06085FF5 = 0;
  /* Sound command: stop/reset */
  (*(int(*)())0x0601D5F4)(0xf,0xAE0003FF);
  scu_int_clear = (char *)0x06026CE0;
  render_flags = (char *)0x0605B6D8;
  INPUT_STATE = INPUT_STATE | 0x80000000;  /* disable input processing */
  /* Flush render pipeline (twice) */
  (*(int(*)())scu_int_clear)();
  (*(int(*)())0x06026CE0)();
  /* DMA copy VDP register blocks */
  FUN_0601938c();
  (*(int(*)())0x0601A73E)();
  /* Load VDP2 scroll plane data */
  (*(int(*)())0x0600511E)(0x25E76174,0x00014000,0,9);   /* scroll plane A */
  (*(int(*)())0x0600511E)(0x25E761FC,0x00017700,0,8);   /* scroll plane B */
  /* Clear SCU interrupt masks */
  scu_int_clear = (char *)0x06014884;
  (*(int(*)())0x06014884)(8,0);
  (*(int(*)())scu_int_clear)(0x10,0);
  (*(int(*)())scu_int_clear)(0x20,0);
  /* VDP1 command list setup */
  (*(int(*)())0x0602853E)(4);
  (*(int(*)())0x0602853E)(0xc);
  scu_int_clear = (char *)0x06028560;
  *(unsigned int *)render_flags = *(unsigned int *)render_flags | 4;  /* enable render flag */
  (*(int(*)())scu_int_clear)();  /* flush VDP1 commands */
  /* Render initial scene object */
  (*(int(*)())0x06028400)(4,*(int *)0x06063AF8,0,0x0000A000 + *(int *)(0x06063AF8 + 4),
             0x06063AF8);
  FUN_06019324();
  return;
}
#endif

/* scene_selection_render -- Render 4 selectable menu items with blinking highlight.
 * Draws unselected items normally, selected item blinks when anim counter >= 0x10. */
#if 0 /* FUN_0601950C -- replaced by ASM import */
unsigned int FUN_0601950c()
{
  char *sprite_dims;
  char *selection_idx;
  char *obj_table;
  char *vdp_render;
  char *sprite_ids;
  char *anim_counter;
  unsigned int result;
  int *obj_entry;
  char item;
  sprite_dims = (char *)0x06049AEC;
  selection_idx = (char *)0x0605D244;
  obj_table = (char *)0x06063750;
  vdp_render = (char *)0x06028400;
  sprite_ids = (char *)0x06049AF4;
  if (*(int *)0x06085FF1 != '\0') {
    /* Render background/frame object */
    (*(int(*)())0x06028400)(0xc,*(int *)(0x06063750 + DAT_060195ac),0x14,
               *(int *)((int)(0x06063750 + DAT_060195ac) + 4) + (int)DAT_060195ae);
    /* Render 4 items, skip currently selected one */
    item = '\0';
    do {
      if (item != *selection_idx) {
        obj_entry = (int *)(obj_table + ((unsigned int)*(unsigned short *)(sprite_ids + (item << 1)) << 3));
        (*(int(*)())vdp_render)(0xc,*obj_entry,
                          ((unsigned int)(unsigned char)(sprite_dims + (item << 1))[1] * 0x40 +
                          (unsigned int)(unsigned char)sprite_dims[(item << 1)]) << 1,obj_entry[1] + (int)PTR_DAT_060195b0
                         );
      }
      item = item + '\x01';
      *(int *)0x06085FF1 = 0;   /* clear dirty flag */
    } while (item < '\x04');
  }
  /* Render selected item with blink effect */
  anim_counter = (char *)0x0605D242;
  result = (unsigned int)(unsigned char)*(int *)0x06085FF5;
  if (result == 0) {
    if ((unsigned char)*(int *)0x0605D242 < 0x10) {
      /* Normal render of selected item */
      obj_entry = (int *)(obj_table + ((unsigned int)*(unsigned short *)(sprite_ids + (char)(*selection_idx << 1)) << 3));
      result = (*(int(*)())vdp_render)(0xc,*obj_entry,
                                ((unsigned int)(unsigned char)(sprite_dims + (char)(*selection_idx << 1))[1] * 0x40 +
                                (unsigned int)(unsigned char)sprite_dims[(char)(*selection_idx << 1)]) << 1,
                                obj_entry[1] + (int)DAT_06019694);
    }
    else {
      /* Blink phase: render as split sprite pair */
      (*(int(*)())0x060284AE)(0xc,((unsigned int)(unsigned char)(sprite_dims + (char)(*selection_idx << 1))[1] * 0x40 +
                     (unsigned int)(unsigned char)sprite_dims[(char)(*selection_idx << 1)]) << 1,0x90,
                 *(int *)0x0605D4EC);
      result = (*(int(*)())0x060284AE)(0xc,(((unsigned char)(sprite_dims + (char)(*selection_idx << 1))[1] + 2) << 6 +
                             (unsigned int)(unsigned char)sprite_dims[(char)(*selection_idx << 1)]) << 1,0x90,
                         *(int *)0x0605D4EC);
      if (0x1e < (unsigned char)*anim_counter) {
        *anim_counter = 0;           /* reset blink cycle */
      }
    }
  }
  return result;
}
#endif

/* scene_selection_input -- Handle input for 4-option selection menu.
 * Start/Accept confirms, Left/Right cycles through options 0-3,
 * dispatches to per-option handler via jump table at 0x0605D250. */
#if 0 /* FUN_060196A4 -- replaced by ASM import */
void FUN_060196a4()
{
  char *dirty_flag;
  char *anim_counter;
  char *selection_idx;
  selection_idx = (char *)0x0605D244;
  anim_counter = (char *)0x0605D242;
  dirty_flag = (char *)0x06085FF1;
  (*(int(*)())0x06026110)();    /* poll input */
  /* Start/Accept button pressed */
  if ((*(unsigned short *)(0x06063D98 + 2) & DAT_06019762) != 0) {
    /* Render confirmed selection */
    (*(int(*)())0x06028400)(0xc,*(int *)
                    (0x06063750 + (unsigned int)*(unsigned short *)(0x06049AF4 + (char)(*selection_idx << 1)) << 3)
               ,((unsigned int)(unsigned char)((char *)(0x06049AEC + (char)(*selection_idx << 1)))[1] * 0x40 +
                (unsigned int)(unsigned char)((int *)0x06049AEC)[(char)(*selection_idx << 1)]) << 1,
               *(int *)((int)(0x06063750 +
                             (unsigned int)*(unsigned short *)(0x06049AF4 + (char)(*selection_idx << 1)) << 3) + 4) +
               (int)(short)PTR_DAT_06019764);
    if ('\x01' < (char)*selection_idx) {
      *selection_idx = 0;       /* clamp to valid range */
    }
    VBLANK_OUT_COUNTER = 0;
    *anim_counter = 0;
    GAME_STATE = 4;             /* transition to next state */
    *dirty_flag = 1;
    *(int *)0x06085FF5 = 1;
    return;
  }
  /* Right/Down button: increment selection */
  if ((*(unsigned short *)(0x06063D98 + 2) & PTR_DAT_06019764) == 0) {
    /* Left/Up button: decrement selection */
    if ((*(unsigned short *)(0x06063D98 + 2) & DAT_06019864) != 0) {
      *dirty_flag = 1;
      *anim_counter = 5;
      *selection_idx = *selection_idx + -1;
      if ((char)*selection_idx < '\0') {
        *selection_idx = 3;     /* wrap to last option */
      }
    }
  }
  else {
    *dirty_flag = 1;
    *anim_counter = 5;
    *selection_idx = *selection_idx + '\x01';
    if ('\x03' < (char)*selection_idx) {
      *selection_idx = 0;       /* wrap to first option */
    }
  }
  /* Advance frame and animation counters */
  *(int *)0x0605D243 = *(int *)0x0605D243 + '\x01';
  *anim_counter = *anim_counter + '\x01';
  /* Dispatch to per-option handler */
  (*(int(*)())(*(int *)((char)(*selection_idx << 2) + 0x0605D250)))();
  return;
}
#endif

/* FUN_060198e0: L2 version in subsystem_setup.c */
extern void FUN_060198E0(void);
extern void FUN_060192b4();
#if 0 /* FUN_060198E0 -- replaced by ASM import of original bytes */
void FUN_060198e0(void) { FUN_060198E0(); }
#endif

/* sound_test_render -- Render sound test channel display when dirty flag set.
 * When 0x06085FF1 == 1: renders 8 channel indicator sprites via VDP1
 * command dispatcher (0x060284AE). Highlights selected channel at
 * 0x06085FF0 with priority 0xC. Calls 4 sub-renderers for additional
 * display elements (FUN_06019bc8..FUN_0601a65e). Clears dirty flag. */
/* FUN_06019928 -- original binary (288 bytes) */
__asm__(
    ".section .text.FUN_06019928, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019928\n"
    ".type _FUN_06019928, @function\n"
    "_FUN_06019928:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x4F, 0x22\n"  /* 0x06019928 */
    ".byte 0x7F, 0xFC, 0xD9, 0x3B, 0xDB, 0x3B, 0xDC, 0x3C, 0x9D, 0x70, 0xD0, 0x3C, 0x60, 0x00, 0x88, 0x01\n"  /* 0x06019938 */
    ".byte 0x8F, 0x62, 0xEA, 0x08, 0xD4, 0x3A, 0x60, 0x42, 0xCB, 0x04, 0x24, 0x02, 0xEE, 0x00, 0x60, 0xEC\n"  /* 0x06019948 */
    ".byte 0x66, 0xD3, 0x68, 0xEC, 0x40, 0x08, 0x48, 0x00, 0x07, 0x9E, 0x38, 0xBC, 0x84, 0x81, 0x63, 0x80\n"  /* 0x06019958 */
    ".byte 0x65, 0x03, 0x63, 0x3C, 0x65, 0x5C, 0x45, 0x08, 0x45, 0x08, 0x45, 0x08, 0x35, 0x3C, 0x45, 0x00\n"  /* 0x06019968 */
    ".byte 0x4C, 0x0B, 0xE4, 0x08, 0x7E, 0x01, 0x62, 0xEC, 0x32, 0xA3, 0x8B, 0xE8, 0x66, 0xD3, 0xDE, 0x2D\n"  /* 0x06019978 */
    ".byte 0x60, 0xE0, 0x65, 0xE0, 0x40, 0x08, 0x45, 0x00, 0x07, 0x9E, 0x35, 0xBC, 0x2F, 0x52, 0x84, 0x51\n"  /* 0x06019988 */
    ".byte 0x63, 0xF2, 0x65, 0x03, 0x63, 0x30, 0x65, 0x5C, 0x63, 0x3C, 0x45, 0x08, 0x45, 0x08, 0x45, 0x08\n"  /* 0x06019998 */
    ".byte 0x35, 0x3C, 0x45, 0x00, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xD3, 0x65, 0xE0, 0xD7, 0x22, 0x45, 0x00\n"  /* 0x060199A8 */
    ".byte 0x35, 0xBC, 0x84, 0x51, 0x65, 0x03, 0x65, 0x5C, 0x45, 0x08, 0x45, 0x08, 0x45, 0x08, 0x75, 0x01\n"  /* 0x060199B8 */
    ".byte 0x45, 0x00, 0x4C, 0x0B, 0xE4, 0x0C, 0x60, 0xE0, 0x88, 0x06, 0x89, 0x12, 0xD7, 0x1B, 0x66, 0xD3\n"  /* 0x060199C8 */
    ".byte 0x63, 0xB3, 0x67, 0x72, 0x73, 0x0C, 0x2F, 0xB2, 0x84, 0xBD, 0x63, 0x30, 0x65, 0x03, 0x63, 0x3C\n"  /* 0x060199D8 */
    ".byte 0x65, 0x5C, 0x45, 0x08, 0x45, 0x08, 0x45, 0x08, 0x35, 0x3C, 0x75, 0x0D, 0x45, 0x00, 0x4C, 0x0B\n"  /* 0x060199E8 */
    ".byte 0xE4, 0x0C, 0xB0, 0xE5, 0x00, 0x09, 0xB1, 0xDB, 0x00, 0x09, 0xB2, 0xD6, 0x00, 0x09, 0xB6, 0x2A\n"  /* 0x060199F8 */
    ".byte 0x00, 0x09, 0xE2, 0x00, 0xD3, 0x09, 0x23, 0x20, 0x7F, 0x04, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6\n"  /* 0x06019A08 */
    ".byte 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x00, 0x90, 0xFF, 0xFF\n"  /* 0x06019A18 */
    ".byte 0x06, 0x05, 0xD2, 0x94, 0x06, 0x04, 0x9A, 0xFC, 0x06, 0x02, 0x84, 0xAE, 0x06, 0x08, 0x5F, 0xF1\n"  /* 0x06019A28 */
    ".byte 0x06, 0x05, 0xB6, 0xD8, 0x06, 0x08, 0x5F, 0xF0, 0x06, 0x04, 0x9E, 0x44, 0x06, 0x05, 0xD4, 0xF0\n"  /* 0x06019A38 */
);


/* options_menu_input -- Handle input for 8-option settings/sound-test menu.
 * Start/Accept confirms (transitions to state 7 or selects option 7),
 * Right/Left cycles through options 0-7, dispatches via jump table at 0x0605D260. */
#if 0 /* FUN_06019A48 -- replaced by ASM import */
void FUN_06019a48()
{
  char *dirty_flag;
  char *selection_idx;
  int sprite_size;
  selection_idx = (char *)0x06085FF0;
  dirty_flag = (char *)0x06085FF1;
  if (*(int *)0x06085FF3 == '\0') {
    sprite_size = 0x90;
    /* Start/Accept button */
    if (((unsigned int)*(unsigned short *)(0x06063D98 + 2) & sprite_size + 0x70U) == 0) {
      /* Right/Down button */
      if ((*(unsigned short *)(0x06063D98 + 2) & PTR_DAT_06019b24) == 0) {
        /* Left/Up button */
        if ((*(unsigned short *)(0x06063D98 + 2) & DAT_06019bfc) != 0) {
          (*(int(*)())0x060284AE)(0xc,((unsigned int)(unsigned char)((char *)(0x06049AFC + (char)*(int *)(0x06085FF0 << 1)))[1] * 0x40 +
                         (unsigned int)(unsigned char)((int *)0x06049AFC)[(char)*(int *)(0x06085FF0 << 1)]) << 1,sprite_size,
                     *(int *)0x0605D4F0);
          *selection_idx = *selection_idx + -1;
          if ((char)*selection_idx < '\0') {
            *selection_idx = 7;   /* wrap to last option */
          }
          *dirty_flag = 1;
        }
      }
      else {
        (*(int(*)())0x060284AE)(0xc,((unsigned int)(unsigned char)((char *)(0x06049AFC + (char)*(int *)(0x06085FF0 << 1)))[1] * 0x40 +
                       (unsigned int)(unsigned char)((int *)0x06049AFC)[(char)*(int *)(0x06085FF0 << 1)]) << 1,sprite_size,
                   *(int *)0x0605D4F0);
        *selection_idx = *selection_idx + '\x01';
        if ('\a' < (char)*selection_idx) {
          *selection_idx = 0;     /* wrap to first option */
        }
        *dirty_flag = 1;
      }
    }
    else {
      /* Start/Accept: confirm selection */
      (*(int(*)())0x060284AE)(0xc,((unsigned int)(unsigned char)((char *)(0x06049AFC + (char)*(int *)(0x06085FF0 << 1)))[1] * 0x40 +
                     (unsigned int)(unsigned char)((int *)0x06049AFC)[(char)*(int *)(0x06085FF0 << 1)]) << 1,sprite_size,
                 *(int *)0x0605D4F0);
      if (*selection_idx == '\a') {
        GAME_STATE = 7;           /* exit to state 7 */
      }
      else {
        *selection_idx = 7;
        *dirty_flag = 1;
        VBLANK_OUT_COUNTER = 0;
        (*(int(*)())0x06026CE0)();  /* flush render */
      }
    }
  }
  /* Advance frame and animation counters */
  *(int *)0x0605D243 = *(int *)0x0605D243 + '\x01';
  *(int *)0x0605D242 = *(int *)0x0605D242 + '\x01';
  /* Dispatch to per-option handler */
  (*(int(*)())(*(int *)(0x0605D260 + (char)(*selection_idx << 2))))();
  return;
}
#endif

/* volume_display_render -- Render 3 volume level indicators with highlight/blink.
 * Active item (matching COURSE_SELECT) blinks when anim counter >= 8,
 * priority: 3=dim, 5=inactive, 6=selected, 7=blink. */
#if 0 /* FUN_06019BC8 -- replaced by ASM import */
int FUN_06019bc8()
{
  char *anim_counter;
  char *sprite_ids;
  char *vdp_render;
  int result;
  int priority;
  unsigned char item;
  vdp_render = (char *)0x06028400;
  sprite_ids = (char *)0x06049B12;
  anim_counter = (char *)0x0605D242;
  if (*(int *)0x06085FF0 == '\0') {
    /* Active selection on this row  blink selected item */
    item = 0;
    do {
      if ((unsigned int)item == COURSE_SELECT) {
        if ((unsigned char)*anim_counter < 8) {
          priority = 6;                /* highlight */
        }
        else {
          priority = 7;               /* blink phase */
          if (0x10 < (unsigned char)*anim_counter) {
            *anim_counter = 0;        /* reset blink cycle */
          }
        }
      }
      else {
        priority = 3;                  /* dim unselected */
      }
      result = (*(int(*)())vdp_render)(0xc,*(int *)
                                     (0x06063750 +
                                     (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3),
                                ((unsigned int)(unsigned char)((char *)(0x06049B0C + (unsigned int)(item << 1)))[1] * 0x40 +
                                (unsigned int)(unsigned char)((int *)0x06049B0C)[(unsigned int)(item << 1)]) << 1,
                                (priority << 12) +
                                *(int *)((int)(0x06063750 +
                                              (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3) + 4))
      ;
      item = item + 1;
    } while (item < 3);
  }
  else {
    /* Inactive row  static display */
    item = 0;
    do {
      if ((unsigned int)item == COURSE_SELECT) {
        priority = 6;                  /* selected */
      }
      else {
        priority = 5;                  /* inactive */
      }
      result = (*(int(*)())vdp_render)(0xc,*(int *)
                                     (0x06063750 +
                                     (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3),
                                ((unsigned int)(unsigned char)((char *)(0x06049B0C + (unsigned int)(item << 1)))[1] * 0x40 +
                                (unsigned int)(unsigned char)((int *)0x06049B0C)[(unsigned int)(item << 1)]) << 1,
                                (priority << 12) +
                                *(int *)((int)(0x06063750 +
                                              (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3) + 4))
      ;
      item = item + 1;
    } while (item < 3);
  }
  return result;
}
#endif

/* FUN_06019BC8 -- original binary (332 bytes) */
__asm__(
    ".section .text.FUN_06019BC8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019BC8\n"
    ".global _FUN_06019bc8\n"
    ".type _FUN_06019BC8, @function\n"
    "_FUN_06019BC8:\n"
    "_FUN_06019bc8:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0xEB, 0x06, 0x2F, 0x96, 0x2F, 0x86\n"  /* 0x06019BC8 */
    ".byte 0x4F, 0x22, 0x7F, 0xF4, 0xD8, 0x0C, 0xD9, 0x0D, 0xDC, 0x09, 0xD3, 0x0D, 0x63, 0x30, 0x23, 0x38\n"  /* 0x06019BD8 */
    ".byte 0x8D, 0x44, 0xEE, 0x03, 0xED, 0x00, 0x63, 0xDC, 0xD2, 0x0A, 0x62, 0x22, 0x33, 0x20, 0x8B, 0x13\n"  /* 0x06019BE8 */
    ".byte 0xA0, 0x13, 0x6A, 0xBC, 0x10, 0x00, 0xFF, 0xFF, 0x06, 0x05, 0xD4, 0xF0, 0x06, 0x05, 0xD2, 0x43\n"  /* 0x06019BF8 */
    ".byte 0x06, 0x05, 0xD2, 0x42, 0x06, 0x05, 0xD2, 0x60, 0x06, 0x04, 0x9B, 0x12, 0x06, 0x02, 0x84, 0x00\n"  /* 0x06019C08 */
    ".byte 0x06, 0x08, 0x5F, 0xF0, 0x06, 0x05, 0xAD, 0x00, 0xEA, 0x05, 0x67, 0xAC, 0x60, 0xDC, 0x47, 0x18\n"  /* 0x06019C18 */
    ".byte 0x40, 0x00, 0x47, 0x08, 0x1F, 0x02, 0x47, 0x08, 0x03, 0x8D, 0xD2, 0x35, 0x63, 0x3D, 0x43, 0x08\n"  /* 0x06019C28 */
    ".byte 0x43, 0x00, 0x32, 0x3C, 0x1F, 0x21, 0x53, 0x21, 0x56, 0xF2, 0x37, 0x3C, 0xD3, 0x31, 0x36, 0x3C\n"  /* 0x06019C38 */
    ".byte 0x2F, 0x62, 0x84, 0x61, 0x62, 0xF2, 0x66, 0x03, 0x62, 0x20, 0x66, 0x6C, 0x62, 0x2C, 0x46, 0x08\n"  /* 0x06019C48 */
    ".byte 0x46, 0x08, 0x46, 0x08, 0x36, 0x2C, 0x46, 0x00, 0x55, 0xF1, 0x65, 0x52, 0x49, 0x0B, 0xE4, 0x0C\n"  /* 0x06019C58 */
    ".byte 0x7D, 0x01, 0x63, 0xDC, 0x33, 0xE3, 0x8B, 0xBE, 0xA0, 0x3F, 0x00, 0x09, 0xED, 0x00, 0x62, 0xDC\n"  /* 0x06019C68 */
    ".byte 0xD3, 0x25, 0x63, 0x32, 0x32, 0x30, 0x8B, 0x10, 0xE2, 0x08, 0x63, 0xC0, 0x63, 0x3C, 0x33, 0x23\n"  /* 0x06019C78 */
    ".byte 0x89, 0x01, 0xA0, 0x0B, 0x6A, 0xBC, 0xE3, 0x10, 0x62, 0xC0, 0x62, 0x2C, 0x32, 0x37, 0x8F, 0x02\n"  /* 0x06019C88 */
    ".byte 0xEA, 0x07, 0xE3, 0x00, 0x2C, 0x30, 0xA0, 0x01, 0x00, 0x09, 0x6A, 0xEC, 0x67, 0xAC, 0x60, 0xDC\n"  /* 0x06019C98 */
    ".byte 0x47, 0x18, 0x40, 0x00, 0x47, 0x08, 0x2F, 0x02, 0x47, 0x08, 0x03, 0x8D, 0xD2, 0x14, 0x63, 0x3D\n"  /* 0x06019CA8 */
    ".byte 0x43, 0x08, 0x43, 0x00, 0x32, 0x3C, 0x1F, 0x22, 0x53, 0x21, 0x66, 0xF2, 0x37, 0x3C, 0xD3, 0x11\n"  /* 0x06019CB8 */
    ".byte 0x36, 0x3C, 0x1F, 0x61, 0x84, 0x61, 0x52, 0xF1, 0x66, 0x03, 0x62, 0x20, 0x66, 0x6C, 0x62, 0x2C\n"  /* 0x06019CC8 */
    ".byte 0x46, 0x08, 0x46, 0x08, 0x46, 0x08, 0x36, 0x2C, 0x46, 0x00, 0x55, 0xF2, 0x65, 0x52, 0x49, 0x0B\n"  /* 0x06019CD8 */
    ".byte 0xE4, 0x0C, 0x7D, 0x01, 0x63, 0xDC, 0x33, 0xE3, 0x8B, 0xC1, 0x7F, 0x0C, 0x4F, 0x26, 0x68, 0xF6\n"  /* 0x06019CE8 */
    ".byte 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xFF, 0xFF\n"  /* 0x06019CF8 */
    ".byte 0x06, 0x06, 0x37, 0x50, 0x06, 0x04, 0x9B, 0x0C, 0x06, 0x05, 0xAD, 0x00\n"  /* 0x06019D08 */
);


/* frequency_display_render -- Render 5 frequency/mode indicators with highlight/blink.
 * Active item (matching selection at 0x0605AD0C) blinks when anim counter >= 8,
 * priority: 3=dim, 5=inactive, 6=selected, 7=blink. */
#if 0 /* FUN_06019DB8 -- replaced by ASM import */
int FUN_06019db8()
{
  char *sprite_ids;
  char *vdp_render;
  char *anim_counter;
  int result;
  int priority;
  unsigned char item;
  anim_counter = (char *)0x0605D242;
  vdp_render = (char *)0x06028400;
  sprite_ids = (char *)0x06049B2C;
  if (*(int *)0x06085FF0 == '\x01') {
    /* Active selection on this row  blink selected item */
    item = 0;
    do {
      if ((unsigned int)item == *(unsigned int *)0x0605AD0C) {
        if ((unsigned char)*anim_counter < 8) {
          priority = 6;                /* highlight */
        }
        else {
          priority = 7;               /* blink phase */
          if (0x10 < (unsigned char)*anim_counter) {
            *anim_counter = 0;        /* reset blink cycle */
          }
        }
      }
      else {
        priority = 3;                  /* dim unselected */
      }
      result = (*(int(*)())vdp_render)(0xc,*(int *)
                                     (0x06063750 +
                                     (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3),
                                ((unsigned int)(unsigned char)((char *)(0x06049B18 + (unsigned int)(item << 1)))[1] * 0x40 +
                                (unsigned int)(unsigned char)((int *)0x06049B18)[(unsigned int)(item << 1)]) << 1,
                                (priority << 12) +
                                *(int *)((int)(0x06063750 +
                                              (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3) + 4))
      ;
      item = item + 1;
    } while (item < 5);
  }
  else {
    /* Inactive row  static display */
    item = 0;
    do {
      if ((unsigned int)item == *(unsigned int *)0x0605AD0C) {
        priority = 6;                  /* selected */
      }
      else {
        priority = 5;                  /* inactive */
      }
      result = (*(int(*)())vdp_render)(0xc,*(int *)
                                     (0x06063750 +
                                     (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3),
                                ((unsigned int)(unsigned char)((char *)(0x06049B18 + (unsigned int)(item << 1)))[1] * 0x40 +
                                (unsigned int)(unsigned char)((int *)0x06049B18)[(unsigned int)(item << 1)]) << 1,
                                (priority << 12) +
                                *(int *)((int)(0x06063750 +
                                              (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3) + 4))
      ;
      item = item + 1;
    } while (item < 5);
  }
  return result;
}
#endif

/* FUN_06019DB8 -- original binary (312 bytes) */
__asm__(
    ".section .text.FUN_06019DB8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019DB8\n"
    ".global _FUN_06019db8\n"
    ".type _FUN_06019DB8, @function\n"
    "_FUN_06019DB8:\n"
    "_FUN_06019db8:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0xEB, 0x06, 0x2F, 0x96, 0x2F, 0x86\n"  /* 0x06019DB8 */
    ".byte 0x4F, 0x22, 0x7F, 0xF4, 0xD8, 0x28, 0xD9, 0x29, 0xDC, 0x29, 0xD0, 0x2A, 0x60, 0x00, 0x88, 0x01\n"  /* 0x06019DC8 */
    ".byte 0x8D, 0x32, 0xEE, 0x05, 0xED, 0x00, 0x62, 0xDC, 0xD3, 0x27, 0x63, 0x32, 0x32, 0x30, 0x8B, 0x01\n"  /* 0x06019DD8 */
    ".byte 0xA0, 0x01, 0x6A, 0xBC, 0x6A, 0xEC, 0x67, 0xAC, 0x60, 0xDC, 0x47, 0x18, 0x40, 0x00, 0x47, 0x08\n"  /* 0x06019DE8 */
    ".byte 0x1F, 0x02, 0x47, 0x08, 0x03, 0x8D, 0xD2, 0x21, 0x63, 0x3D, 0x43, 0x08, 0x43, 0x00, 0x32, 0x3C\n"  /* 0x06019DF8 */
    ".byte 0x1F, 0x21, 0x53, 0x21, 0x56, 0xF2, 0x37, 0x3C, 0xD3, 0x1D, 0x36, 0x3C, 0x2F, 0x62, 0x84, 0x61\n"  /* 0x06019E08 */
    ".byte 0x62, 0xF2, 0x66, 0x03, 0x62, 0x20, 0x66, 0x6C, 0x62, 0x2C, 0x46, 0x08, 0x46, 0x08, 0x46, 0x08\n"  /* 0x06019E18 */
    ".byte 0x36, 0x2C, 0x46, 0x00, 0x55, 0xF1, 0x65, 0x52, 0x49, 0x0B, 0xE4, 0x0C, 0x7D, 0x01, 0x63, 0xDC\n"  /* 0x06019E28 */
    ".byte 0x33, 0xE3, 0x8B, 0xD0, 0xA0, 0x4E, 0x00, 0x09, 0xED, 0x00, 0x62, 0xDC, 0xD3, 0x0E, 0x63, 0x32\n"  /* 0x06019E38 */
    ".byte 0x32, 0x30, 0x8B, 0x1F, 0xE2, 0x08, 0x63, 0xC0, 0x63, 0x3C, 0x33, 0x23, 0x89, 0x01, 0xA0, 0x1A\n"  /* 0x06019E48 */
    ".byte 0x6A, 0xBC, 0xE3, 0x10, 0x62, 0xC0, 0x62, 0x2C, 0x32, 0x37, 0x8F, 0x02, 0xEA, 0x07, 0xE3, 0x00\n"  /* 0x06019E58 */
    ".byte 0x2C, 0x30, 0xA0, 0x10, 0x00, 0x09, 0xFF, 0xFF, 0x06, 0x04, 0x9B, 0x2C, 0x06, 0x02, 0x84, 0x00\n"  /* 0x06019E68 */
    ".byte 0x06, 0x05, 0xD2, 0x42, 0x06, 0x08, 0x5F, 0xF0, 0x06, 0x05, 0xAD, 0x0C, 0x06, 0x06, 0x37, 0x50\n"  /* 0x06019E78 */
    ".byte 0x06, 0x04, 0x9B, 0x18, 0xEA, 0x03, 0x67, 0xAC, 0x60, 0xDC, 0x47, 0x18, 0x40, 0x00, 0x47, 0x08\n"  /* 0x06019E88 */
    ".byte 0x2F, 0x02, 0x47, 0x08, 0x03, 0x8D, 0xD2, 0x29, 0x63, 0x3D, 0x43, 0x08, 0x43, 0x00, 0x32, 0x3C\n"  /* 0x06019E98 */
    ".byte 0x1F, 0x22, 0x53, 0x21, 0x66, 0xF2, 0x37, 0x3C, 0xD3, 0x25, 0x36, 0x3C, 0x1F, 0x61, 0x84, 0x61\n"  /* 0x06019EA8 */
    ".byte 0x52, 0xF1, 0x66, 0x03, 0x62, 0x20, 0x66, 0x6C, 0x62, 0x2C, 0x46, 0x08, 0x46, 0x08, 0x46, 0x08\n"  /* 0x06019EB8 */
    ".byte 0x36, 0x2C, 0x46, 0x00, 0x55, 0xF2, 0x65, 0x52, 0x49, 0x0B, 0xE4, 0x0C, 0x7D, 0x01, 0x63, 0xDC\n"  /* 0x06019EC8 */
    ".byte 0x33, 0xE3, 0x8B, 0xB2, 0x7F, 0x0C, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6\n"  /* 0x06019ED8 */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x06019EE8 */
);


/* waveform_display_render -- Render 5 waveform/balance indicators with highlight/blink.
 * Active when selection row == 2. Compares against selection at 0x0605AD04,
 * priority: 3=dim, 5=inactive, 6=selected, 7=blink. */
#if 0 /* FUN_06019FB2 -- replaced by ASM import */
int FUN_06019fb2()
{
  char *sprite_ids;
  char *vdp_render;
  char *anim_counter;
  int result;
  int priority;
  unsigned char item;
  anim_counter = (char *)0x0605D242;
  vdp_render = (char *)0x06028400;
  sprite_ids = (char *)0x06049B2C;
  if (*(int *)0x06085FF0 == '\x02') {
    /* Active selection on this row  blink selected item */
    item = 0;
    do {
      if ((unsigned int)item == *(unsigned int *)0x0605AD04) {
        if ((unsigned char)*anim_counter < 8) {
          priority = 6;                /* highlight */
        }
        else {
          priority = 7;               /* blink phase */
          if (0x10 < (unsigned char)*anim_counter) {
            *anim_counter = 0;        /* reset blink cycle */
          }
        }
      }
      else {
        priority = 3;                  /* dim unselected */
      }
      result = (*(int(*)())vdp_render)(0xc,*(int *)
                                     (0x06063750 +
                                     (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3),
                                ((unsigned int)(unsigned char)((char *)(0x06049B22 + (unsigned int)(item << 1)))[1] * 0x40 +
                                (unsigned int)(unsigned char)((int *)0x06049B22)[(unsigned int)(item << 1)]) << 1,
                                (priority << 12) +
                                *(int *)((int)(0x06063750 +
                                              (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3) + 4))
      ;
      item = item + 1;
    } while (item < 5);
  }
  else {
    /* Inactive row  static display */
    item = 0;
    do {
      if ((unsigned int)item == *(unsigned int *)0x0605AD04) {
        priority = 6;                  /* selected */
      }
      else {
        priority = 5;                  /* inactive */
      }
      result = (*(int(*)())vdp_render)(0xc,*(int *)
                                     (0x06063750 +
                                     (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3),
                                ((unsigned int)(unsigned char)((char *)(0x06049B22 + (unsigned int)(item << 1)))[1] * 0x40 +
                                (unsigned int)(unsigned char)((int *)0x06049B22)[(unsigned int)(item << 1)]) << 1,
                                (priority << 12) +
                                *(int *)((int)(0x06063750 +
                                              (unsigned int)*(unsigned short *)(sprite_ids + (unsigned int)(item << 1)) << 3) + 4))
      ;
      item = item + 1;
    } while (item < 5);
  }
  return result;
}
#endif

/* FUN_06019FB2 -- original binary (318 bytes) */
__asm__(
    ".section .text.FUN_06019FB2, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019FB2\n"
    ".global _FUN_06019fb2\n"
    ".type _FUN_06019FB2, @function\n"
    "_FUN_06019FB2:\n"
    "_FUN_06019fb2:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0xEB, 0x06, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86\n"  /* 0x06019FB2 */
    ".byte 0x4F, 0x22, 0x7F, 0xF4, 0xD8, 0x08, 0xD9, 0x08, 0xDC, 0x09, 0xD0, 0x09, 0x60, 0x00, 0x88, 0x02\n"  /* 0x06019FC2 */
    ".byte 0x8D, 0x3D, 0xEE, 0x05, 0xED, 0x00, 0x62, 0xDC, 0xD3, 0x07, 0x63, 0x32, 0x32, 0x30, 0x8B, 0x0C\n"  /* 0x06019FD2 */
    ".byte 0xA0, 0x0C, 0x6A, 0xBC, 0xFF, 0xFF, 0x06, 0x04, 0x9B, 0x2C, 0x06, 0x02, 0x84, 0x00, 0x06, 0x05\n"  /* 0x06019FE2 */
    ".byte 0xD2, 0x42, 0x06, 0x08, 0x5F, 0xF0, 0x06, 0x05, 0xAD, 0x04, 0x6A, 0xEC, 0x67, 0xAC, 0x60, 0xDC\n"  /* 0x06019FF2 */
    ".byte 0x47, 0x18, 0x40, 0x00, 0x47, 0x08, 0x1F, 0x02, 0x47, 0x08, 0x03, 0x8D, 0xD2, 0x35, 0x63, 0x3D\n"  /* 0x0601A002 */
    ".byte 0x43, 0x08, 0x43, 0x00, 0x32, 0x3C, 0x1F, 0x21, 0x53, 0x21, 0x56, 0xF2, 0x37, 0x3C, 0xD3, 0x31\n"  /* 0x0601A012 */
    ".byte 0x36, 0x3C, 0x2F, 0x62, 0x84, 0x61, 0x62, 0xF2, 0x66, 0x03, 0x62, 0x20, 0x66, 0x6C, 0x62, 0x2C\n"  /* 0x0601A022 */
    ".byte 0x46, 0x08, 0x46, 0x08, 0x46, 0x08, 0x36, 0x2C, 0x46, 0x00, 0x55, 0xF1, 0x65, 0x52, 0x49, 0x0B\n"  /* 0x0601A032 */
    ".byte 0xE4, 0x0C, 0x7D, 0x01, 0x63, 0xDC, 0x33, 0xE3, 0x8B, 0xC5, 0xA0, 0x3F, 0x00, 0x09, 0xED, 0x00\n"  /* 0x0601A042 */
    ".byte 0x62, 0xDC, 0xD3, 0x25, 0x63, 0x32, 0x32, 0x30, 0x8B, 0x10, 0xE2, 0x08, 0x63, 0xC0, 0x63, 0x3C\n"  /* 0x0601A052 */
    ".byte 0x33, 0x23, 0x89, 0x01, 0xA0, 0x0B, 0x6A, 0xBC, 0xE3, 0x10, 0x62, 0xC0, 0x62, 0x2C, 0x32, 0x37\n"  /* 0x0601A062 */
    ".byte 0x8F, 0x02, 0xEA, 0x07, 0xE3, 0x00, 0x2C, 0x30, 0xA0, 0x01, 0x00, 0x09, 0xEA, 0x03, 0x67, 0xAC\n"  /* 0x0601A072 */
    ".byte 0x60, 0xDC, 0x47, 0x18, 0x40, 0x00, 0x47, 0x08, 0x2F, 0x02, 0x47, 0x08, 0x03, 0x8D, 0xD2, 0x14\n"  /* 0x0601A082 */
    ".byte 0x63, 0x3D, 0x43, 0x08, 0x43, 0x00, 0x32, 0x3C, 0x1F, 0x22, 0x53, 0x21, 0x66, 0xF2, 0x37, 0x3C\n"  /* 0x0601A092 */
    ".byte 0xD3, 0x11, 0x36, 0x3C, 0x1F, 0x61, 0x84, 0x61, 0x52, 0xF1, 0x66, 0x03, 0x62, 0x20, 0x66, 0x6C\n"  /* 0x0601A0A2 */
    ".byte 0x62, 0x2C, 0x46, 0x08, 0x46, 0x08, 0x46, 0x08, 0x36, 0x2C, 0x46, 0x00, 0x55, 0xF2, 0x65, 0x52\n"  /* 0x0601A0B2 */
    ".byte 0x49, 0x0B, 0xE4, 0x0C, 0x7D, 0x01, 0x63, 0xDC, 0x33, 0xE3, 0x8B, 0xC1, 0x7F, 0x0C, 0x4F, 0x26\n"  /* 0x0601A0C2 */
    ".byte 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601A0D2 */
    ".byte 0xFF, 0xFF, 0x06, 0x06, 0x37, 0x50, 0x06, 0x04, 0x9B, 0x22, 0x06, 0x05, 0xAD, 0x04\n"  /* 0x0601A0E2 */
);


/* --- FUN_06018278 (L1 import from src/FUN_06018278.c) --- */

#if 0 /* FUN_06018278 -- replaced by ASM import of original bytes */
unsigned int FUN_06018278()
{
  unsigned int uVar3;
  unsigned short *puVar4;
  unsigned int uVar5;

  uVar3 = (unsigned int)*(unsigned short *)0x0605BE1C;
  uVar5 = (unsigned int)*(unsigned short *)0x06063D9A;

  if ((uVar3 == 0) && (uVar5 != 0)) {
    puVar4 = (unsigned short *)0x0605BE1E;

    uVar3 = (*(int(*)())0x06035280)();

    if ((uVar3 & uVar5) == 0) {
      *puVar4 = 0;
      uVar3 = 0;
    }
    else {
      *puVar4 = *puVar4 + 1;
      uVar3 = (unsigned int)*puVar4;

      if (uVar3 == 7) {
        int idx;
        *puVar4 = 0;
        *(short *)0x0605BE1C = 1;

        idx = (unsigned int)*(unsigned short *)0x06069BB6 << 3;
        *(int *)(0x06063F64 + idx) = *(int *)0x06089E3C;
        uVar3 = (unsigned int)PTR_DAT_060182f4;
        *(short *)(0x06063F64 + idx + 6) = PTR_DAT_060182f4;
      }
    }
  }

  return uVar3;
}
#endif

/* --- FUN_06018EE4 (L1 import from src/FUN_06018EE4.c) --- */

#if 0 /* FUN_06018EE4 -- replaced by ASM import */
extern int DAT_06018f74;
extern int DAT_06018f76;

void FUN_06018ee4()
{

  char *puVar1;

  char *puVar2;

  unsigned int uVar3;

  puVar2 = (char *)0x20100063;

  puVar1 = (char *)0x25A02DBC;

  uVar3 = (unsigned int)DAT_06018f74;

  do {

  } while ((*(int *)0x20100063 & 1) == 1);

  *(int *)0x20100063 = 1;

  *(int *)0x2010001F = 7;

  do {

  } while ((*puVar2 & 1) != 0);

  FUN_060192b4();

  *(short *)0x25B00400 = DAT_06018f76;

  (*(int(*)())0x06012E84)();

  (*(int(*)())0x06012EBC)();

  do {

  } while ((*puVar2 & 1) == 1);

  *puVar2 = 1;

  *(int *)0x2010001F = 6;

  do {

  } while ((*puVar2 & 1) != 0);

  do {

  } while (*(unsigned short *)puVar1 != uVar3);

  (*(int(*)())0x0601D5F4)(0xf,0xAE0600FF);

  (*(int(*)())0x0601D5F4)(0xf,0xAE0007FF);

  *(int *)0x06086038 = 0;

  (*(int(*)())0x06018EC8)();

  return;

}
#endif

/* FUN_06018EE4 -- original binary (192 bytes) */
__asm__(
    ".section .text.FUN_06018EE4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06018EE4\n"
    ".global _FUN_06018ee4\n"
    ".type _FUN_06018EE4, @function\n"
    "_FUN_06018EE4:\n"
    "_FUN_06018ee4:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x4F, 0x22, 0xDB, 0x22, 0x9C, 0x40, 0xDD, 0x22\n"  /* 0x06018EE4 */
    ".byte 0xEE, 0x01, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x89, 0xFA, 0x62, 0xEC, 0x2D, 0x20\n"  /* 0x06018EF4 */
    ".byte 0xE3, 0x07, 0xD2, 0x1E, 0x22, 0x30, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x22, 0x28, 0x8B, 0xFA\n"  /* 0x06018F04 */
    ".byte 0xB1, 0xCE, 0x00, 0x09, 0x92, 0x2D, 0xD3, 0x1A, 0x23, 0x21, 0xD3, 0x1A, 0x43, 0x0B, 0x00, 0x09\n"  /* 0x06018F14 */
    ".byte 0xD3, 0x19, 0x43, 0x0B, 0x00, 0x09, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x89, 0xFA\n"  /* 0x06018F24 */
    ".byte 0x62, 0xEC, 0x2D, 0x20, 0xE3, 0x06, 0xD2, 0x11, 0x22, 0x30, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9\n"  /* 0x06018F34 */
    ".byte 0x22, 0x28, 0x8B, 0xFA, 0x63, 0xB1, 0x63, 0x3D, 0x33, 0xC0, 0x8B, 0xFB, 0xD5, 0x0F, 0xD3, 0x10\n"  /* 0x06018F44 */
    ".byte 0x43, 0x0B, 0xE4, 0x0F, 0xD5, 0x0F, 0xD3, 0x0E, 0x43, 0x0B, 0xE4, 0x0F, 0xE2, 0x00, 0xD3, 0x0E\n"  /* 0x06018F54 */
    ".byte 0x23, 0x22, 0x4F, 0x26, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xD3, 0x0C, 0x43, 0x2B, 0x6E, 0xF6\n"  /* 0x06018F64 */
    ".byte 0x4F, 0x4B, 0x02, 0x00, 0x25, 0xA0, 0x2D, 0xBC, 0x20, 0x10, 0x00, 0x63, 0x20, 0x10, 0x00, 0x1F\n"  /* 0x06018F74 */
    ".byte 0x25, 0xB0, 0x04, 0x00, 0x06, 0x01, 0x2E, 0x84, 0x06, 0x01, 0x2E, 0xBC, 0xAE, 0x06, 0x00, 0xFF\n"  /* 0x06018F84 */
    ".byte 0x06, 0x01, 0xD5, 0xF4, 0xAE, 0x00, 0x07, 0xFF, 0x06, 0x08, 0x60, 0x38, 0x06, 0x01, 0x8E, 0xC8\n"  /* 0x06018F94 */
);


/* FUN_06018278 -- original binary (168 bytes) */
__asm__(
    ".section .text.FUN_06018278, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06018278\n"
    ".type _FUN_06018278, @function\n"
    "_FUN_06018278:\n"
    ".byte 0x4F, 0x22, 0xD5, 0x21, 0xD7, 0x21, 0x65, 0x51, 0x60, 0x71, 0x60, 0x0D, 0x20, 0x08, 0x8F, 0x31\n"  /* 0x06018278 */
    ".byte 0x65, 0x5D, 0x25, 0x58, 0x89, 0x2E, 0xE6, 0x00, 0xD4, 0x1D, 0xD3, 0x1E, 0xD2, 0x1E, 0x61, 0x41\n"  /* 0x06018288 */
    ".byte 0x61, 0x1D, 0x31, 0x3C, 0x61, 0x10, 0x61, 0x1C, 0x42, 0x0B, 0xE0, 0x01, 0x20, 0x59, 0x20, 0x08\n"  /* 0x06018298 */
    ".byte 0x89, 0x1E, 0x63, 0x41, 0x73, 0x01, 0x24, 0x31, 0x60, 0x41, 0x60, 0x0D, 0x88, 0x07, 0x8B, 0x19\n"  /* 0x060182A8 */
    ".byte 0x66, 0x6D, 0xE2, 0x01, 0x24, 0x61, 0x27, 0x21, 0xD5, 0x14, 0xD4, 0x15, 0xD2, 0x15, 0x63, 0x41\n"  /* 0x060182B8 */
    ".byte 0x62, 0x22, 0x63, 0x3D, 0x43, 0x08, 0x43, 0x00, 0x33, 0x5C, 0x23, 0x22, 0x63, 0x41, 0x63, 0x3D\n"  /* 0x060182C8 */
    ".byte 0x43, 0x08, 0x43, 0x00, 0x33, 0x5C, 0x92, 0x09, 0x60, 0x23, 0x81, 0x33, 0xA0, 0x02, 0x00, 0x09\n"  /* 0x060182D8 */
    ".byte 0x66, 0x6D, 0x24, 0x61, 0x4F, 0x26, 0x00, 0x0B, 0x00, 0x09, 0x05, 0x34, 0x04, 0x60, 0xFF, 0xFF\n"  /* 0x060182E8 */
    ".byte 0x06, 0x07, 0xEB, 0xC4, 0x00, 0x80, 0x00, 0x00, 0x06, 0x06, 0x3D, 0x9A, 0x06, 0x05, 0xBE, 0x1C\n"  /* 0x060182F8 */
    ".byte 0x06, 0x05, 0xBE, 0x1E, 0x06, 0x04, 0x81, 0x20, 0x06, 0x03, 0x52, 0x80, 0x06, 0x06, 0x3F, 0x64\n"  /* 0x06018308 */
    ".byte 0x06, 0x06, 0x9B, 0xB6, 0x06, 0x08, 0x9E, 0x3C\n"  /* 0x06018318 */
);

/* FUN_06019248 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_06019248, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019248\n"
    ".type _FUN_06019248, @function\n"
    "_FUN_06019248:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x06019248 */
);

/* FUN_060191E0 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_060191E0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060191E0\n"
    ".global _FUN_060191e0\n"
    ".type _FUN_060191E0, @function\n"
    "_FUN_060191E0:\n"
    "_FUN_060191e0:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x060191E0 */
);

/* FUN_06019058 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_06019058, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019058\n"
    ".type _FUN_06019058, @function\n"
    "_FUN_06019058:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x06019058 */
);

/* FUN_06019188 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_06019188, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06019188\n"
    ".type _FUN_06019188, @function\n"
    "_FUN_06019188:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x06019188 */
);

/* FUN_060190F4 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_060190F4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_060190F4\n"
    ".global _FUN_060190f4\n"
    ".type _FUN_060190F4, @function\n"
    "_FUN_060190F4:\n"
    "_FUN_060190f4:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x060190F4 */
);

/* FUN_0601914C -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_0601914C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601914C\n"
    ".global _FUN_0601914c\n"
    ".type _FUN_0601914C, @function\n"
    "_FUN_0601914C:\n"
    "_FUN_0601914c:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x0601914C */
);

/* FUN_06018FF8 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_06018FF8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_06018FF8\n"
    ".global _FUN_06018ff8\n"
    ".type _FUN_06018FF8, @function\n"
    "_FUN_06018FF8:\n"
    "_FUN_06018ff8:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00\n"  /* 0x06018FF8 */
);
