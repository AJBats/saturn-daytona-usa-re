/* validator_dispatch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060422F0 - 0x060423A0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains two functions:
 *   validator_dispatch  -- test CD status register against a bitmask
 *   sym_0604231E        -- game state structure full reset (zeros arrays + fields)
 */

    .section .text.FUN_060422F0


/* ----------------------------------------------------------------
 * validator_dispatch  (FUN_060422F0)
 *
 * Reads the CD block HIRQ status register via sym_06035C4E and tests
 * the result against a caller-supplied bitmask.
 *
 * Arguments:
 *   r4 -- bitmask of HIRQ bits to test
 *
 * Returns:
 *   r0 -- 1 if any masked bits are set, 0 otherwise
 * ---------------------------------------------------------------- */
    .global validator_dispatch
    .type validator_dispatch, @function
validator_dispatch:
    sts.l pr, @-r15                         ! save return address
    add #-0x4, r15                          ! allocate 4 bytes on stack
    mov.l   .L_fn_read_hirq, r3             ! r3 = &sym_06035C4E (read CD HIRQ status)
    jsr @r3                                 ! call read_hirq() -> r0 = raw status word
    mov.l r4, @r15                          ! [delay] save bitmask arg on stack
    mov r0, r4                              ! r4 = raw HIRQ status
    mov.l @r15, r3                          ! r3 = original bitmask arg
    exts.w r4, r0                           ! r0 = sign-extend status to 32 bits
    and r3, r0                              ! r0 = status & bitmask
    tst r0, r0                              ! any bits set?
    bt      .L_no_match                     ! no matching bits -> return 0
    bra     .L_return                       ! matching bits found
    mov #0x1, r0                            ! [delay] r0 = 1 (match)

    .global DAT_0604230a
DAT_0604230a:
    mov.b r14, @(r0, r1)

    .global DAT_0604230c
DAT_0604230c:
    mov.b @(r0, r13), r1
    .word 0x01E0 /* UNKNOWN */
.L_fn_read_hirq:
    .4byte  sym_06035C4E
.L_no_match:
    mov #0x0, r0                            ! r0 = 0 (no match)
.L_return:
    add #0x4, r15                           ! deallocate stack frame
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    nop                                     ! [delay]


/* ----------------------------------------------------------------
 * sym_0604231E  (game state full reset)
 *
 * Zeros out the game state structure pointed to indirectly by
 * sym_060A5400. Clears:
 *   - Zone flag array:     bytes [0x00..0x16] (23 entries)
 *   - Extended flag array: bytes [0x18..0x2E] (23 entries)
 *   - Longword fields at offsets 0x30, 0x34, 0x3C, 0x4C..0x58
 *   - Sets field at offset 0x38 to -1 (0xFFFFFFFF)
 *   - High-offset fields at 0x0304, 0x030C, 0x0328, 0x0338,
 *     0x0348, 0x0360, 0x01DC, 0x01E0
 *
 * Arguments: none
 * Returns:   nothing (void)
 * ---------------------------------------------------------------- */
    .global sym_0604231E
sym_0604231E:
    mov #0x17, r7                           ! r7 = 23 (array length / loop limit)
    mov.l   .L_game_state_ptr, r5           ! r5 = &sym_060A5400 (game state indirect ptr)
    mov #0x0, r4                            ! r4 = 0 (zero constant)
    mov r4, r6                              ! r6 = 0 (loop index)
.L_clear_loop:
    exts.b r4, r2                           ! r2 = 0 (sign-extended byte)
    mov.l @r5, r0                           ! r0 = game state base address
    mov.b r4, @(r0, r6)                     ! base[r6] = 0 (zone flag array byte)
    mov.l @r5, r0                           ! r0 = game state base (reload)
    mov r0, r3                              ! r3 = base
    add #0x18, r3                           ! r3 = base + 0x18 (extended flag array)
    add r6, r3                              ! r3 = base + 0x18 + index
    mov.b r2, @r3                           ! base[0x18 + index] = 0 (extended flag byte)
    add #0x1, r6                            ! index++
    cmp/ge r7, r6                           ! index >= 23?
    bf      .L_clear_loop                   ! no -> continue clearing
    mov.l @r5, r2                           ! r2 = game state base
    mov.l r4, @(48, r2)                     ! base[0x30] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov.l r4, @(52, r3)                     ! base[0x34] = 0
    mov.l @r5, r2                           ! r2 = game state base
    mov #-0x1, r3                           ! r3 = -1 (0xFFFFFFFF)
    mov.l r3, @(56, r2)                     ! base[0x38] = -1 (sentinel value)
    mov.l @r5, r2                           ! r2 = game state base
    mov.l r4, @(60, r2)                     ! base[0x3C] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov #0x4C, r0                           ! r0 = 0x4C
    mov.l r4, @(r0, r3)                     ! base[0x4C] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov #0x50, r0                           ! r0 = 0x50
    mov.l r4, @(r0, r3)                     ! base[0x50] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov #0x54, r0                           ! r0 = 0x54
    mov.l r4, @(r0, r3)                     ! base[0x54] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov #0x58, r0                           ! r0 = 0x58
    mov.l r4, @(r0, r3)                     ! base[0x58] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov.w   DAT_06042398, r0                ! r0 = 0x0304
    mov.l r4, @(r0, r3)                     ! base[0x0304] = 0
    mov.l @r5, r3                           ! r3 = game state base
    add #0x8, r0                            ! r0 = 0x030C
    mov.l r4, @(r0, r3)                     ! base[0x030C] = 0
    mov.l @r5, r3                           ! r3 = game state base
    add #0x1C, r0                           ! r0 = 0x0328
    mov.l r4, @(r0, r3)                     ! base[0x0328] = 0
    mov.l @r5, r3                           ! r3 = game state base
    add #0x10, r0                           ! r0 = 0x0338
    mov.l r4, @(r0, r3)                     ! base[0x0338] = 0
    add #0x10, r0                           ! r0 = 0x0348
    mov.l @r5, r3                           ! r3 = game state base
    mov.l r4, @(r0, r3)                     ! base[0x0348] = 0
    mov.l @r5, r3                           ! r3 = game state base
    add #0x18, r0                           ! r0 = 0x0360
    mov.l r4, @(r0, r3)                     ! base[0x0360] = 0
    mov.l @r5, r3                           ! r3 = game state base
    mov.w   DAT_0604239a, r0                ! r0 = 0x01DC
    mov.l r4, @(r0, r3)                     ! base[0x01DC] = 0
    mov.l @r5, r3                           ! r3 = game state base
    add #0x4, r0                            ! r0 = 0x01E0
    rts                                     ! return to caller
    mov.l r4, @(r0, r3)                     ! [delay] base[0x01E0] = 0

    .global DAT_06042398
DAT_06042398:
    .2byte  0x0304

    .global DAT_0604239a
DAT_0604239a:
    .2byte  0x01DC
.L_game_state_ptr:
    .4byte  sym_060A5400
