/* throttle_state_toggle -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06010470 - 0x060104E0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Throttle state toggle â€” reads the input word, XORs with 0xFFFF to invert,
 * masks to low byte, and compares against threshold 0xC0 (192). If the
 * inverted input exceeds the threshold, the throttle counter increments;
 * otherwise the counter resets to zero. The counter is then copied to two
 * output locations (display mirror + state shadow), and two DMA transfers
 * load the appropriate throttle tile data (on/off graphics).
 *
 * Structure is identical to brake_state_toggle but uses XOR + threshold
 * instead of checking individual pressed/released flag bits.
 *
 * Symbols:
 *   sym_0607EADC = throttle counter (dword)
 *   sym_06063D9C = input state word (button/analog, 16-bit)
 *   sym_0607EAB8 = display mirror (dword, copy of counter)
 *   sym_06078868 = state shadow (dword, second copy of counter)
 *   sym_06078884 = DMA destination A (tile slot A address, dword ptr)
 *   sym_06078880 = DMA destination B (tile slot B address, dword ptr)
 *   sym_0605D084 = throttle-on tile source table A (array of pointers)
 *   sym_0605D060 = throttle-on tile source table B (array of pointers)
 *   sym_0605D05C = throttle-off tile source table A (array of pointers)
 *   sym_0605D088 = throttle-off tile source table B (array of pointers)
 *   dma_transfer = DMA transfer function: dma_transfer(dst, src, size)
 */

    .section .text.FUN_06010470


    .global throttle_state_toggle
    .type throttle_state_toggle, @function
throttle_state_toggle:
    mov.l r14, @-r15                    ! save r14
    mov #0x0, r2                        ! r2 = 0 (counter reset value)
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    sts.l pr, @-r15                     ! save return address
    .byte   0xDD, 0x24    /* mov.l .L_pool_throttle_counter, r13 */
    .byte   0x9E, 0x44    /* mov.w .L_wpool_06010508, r14 */
    .byte   0xD0, 0x24    /* mov.l .L_pool_input_word, r0 */
    .byte   0xD3, 0x24    /* mov.l .L_pool_xor_mask, r3 */
    mov.w @r0, r0                       ! r0 = input state word (16-bit read)
    extu.w r0, r0                       ! r0 = zero-extend to 32-bit
    xor r3, r0                          ! r0 = input XOR 0xFFFF (invert all bits)
    and #0xFF, r0                       ! r0 = inverted low byte only
    extu.w r0, r4                       ! r4 = zero-extend result
    cmp/gt r14, r4                      ! inverted input > 0xC0 (threshold)?
    bf/s    .L_copy_counter             !   no -> skip increment, keep counter at 0
    mov.l r2, @r13                      ! (delay) counter = 0 (unconditional reset)
    mov.l @r13, r2                      ! r2 = counter (just set to 0)
    add #0x1, r2                        ! r2 = 1 (throttle is active)
    mov.l r2, @r13                      ! counter = 1
.L_copy_counter:
    .byte   0xD4, 0x1F    /* mov.l .L_pool_display_mirror, r4 */
    mov.l @r13, r3                      ! r3 = counter value
    mov.l r3, @r4                       ! display_mirror = counter
    mov.l @r13, r2                      ! r2 = counter value
    .byte   0xD3, 0x1E    /* mov.l .L_pool_state_shadow, r3 */
    mov.l r2, @r3                       ! state_shadow = counter
    .byte   0xDC, 0x1E    /* mov.l .L_pool_fn_dma_transfer, r12 */
    mov.l @r4, r0                       ! r0 = display_mirror value
    tst r0, r0                          ! counter == 0? (throttle off?)
    bt      .L_throttle_off             !   yes -> use throttle-off tile tables
    mov r14, r6                         ! r6 = 0xC0 (DMA size = 192 bytes)
    .byte   0xD5, 0x1D    /* mov.l .L_pool_tile_on_a, r5 */
    .byte   0xD4, 0x1D    /* mov.l .L_pool_dma_dst_a, r4 */
    mov.l @r5, r5                       ! r5 = tile_on_a source address
    jsr @r12                            ! dma_transfer(dst_a, tile_on_a_src, 0xC0)
    mov.l @r4, r4                       ! (delay) r4 = dma_dst_a
    .byte   0xD5, 0x1C    /* mov.l .L_pool_tile_on_b, r5 */
    bra     .L_dma_second_tile          ! -> DMA second tile block
    mov r14, r6                         ! (delay) r6 = 0xC0 (DMA size)
.L_throttle_off:
    mov r14, r6                         ! r6 = 0xC0 (DMA size = 192 bytes)
    .byte   0xD5, 0x1B    /* mov.l .L_pool_tile_off_a, r5 */
    .byte   0xD4, 0x19    /* mov.l .L_pool_dma_dst_a, r4 */
    mov.l @r5, r5                       ! r5 = tile_off_a source address
    jsr @r12                            ! dma_transfer(dst_a, tile_off_a_src, 0xC0)
    mov.l @r4, r4                       ! (delay) r4 = dma_dst_a
    mov r14, r6                         ! r6 = 0xC0 (DMA size)
    .byte   0xD5, 0x19    /* mov.l .L_pool_tile_off_b, r5 */
.L_dma_second_tile:
    mov.l @r5, r5                       ! r5 = tile source address (on_b or off_b)
    .byte   0xD4, 0x19    /* mov.l .L_pool_dma_dst_b, r4 */
    jsr @r12                            ! dma_transfer(dst_b, tile_src, 0xC0)
    mov.l @r4, r4                       ! (delay) r4 = dma_dst_b
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay) restore r14
