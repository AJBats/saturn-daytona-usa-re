/* geom_rotation_apply -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601EB1C - 0x0601EB70
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Conditionally dispatches HUD handler for the current player's geometry
 * rotation state. Checks the player's status flag; if non-zero, calls
 * hud_handler_main with the player's element state, course name table
 * entry, and geometry output buffer pointer.
 *
 * Arguments: none (reads player index from global sym_060877D8)
 *
 * Returns: r0 = result from hud_handler_main, or unchanged if skipped
 *
 * Key symbols:
 *   sym_060877D8 = current player/car index (byte)
 *   sym_060877D9 = player element state array (indexed by player, byte each)
 *   sym_060877DD = player status flags array (indexed by player, byte each)
 *   sym_0605E098 = geometry output buffer pointer (deref'd)
 *   sym_0604A57C = course name string table (12 bytes per entry)
 *
 * Called functions:
 *   hud_handler_main (0x0601E810) â€” HUD element rendering dispatcher
 */

    .section .text.FUN_0601EB1C


    .global geom_rotation_apply
    .type geom_rotation_apply, @function
geom_rotation_apply:
    mov.l r14, @-r15                   ! save r14 (callee-saved)
    sts.l pr, @-r15                    ! save return address
    mov.l   .L_pool_player_index, r14  ! r14 = &player_index byte (sym_060877D8)
    mov.l   .L_pool_status_flags, r2   ! r2 = player_status_flags base (sym_060877DD)
    mov.b @r14, r3                     ! r3 = player_index (signed byte)
    extu.b r3, r3                      ! r3 = player_index (unsigned)
    add r2, r3                         ! r3 = &status_flags[player_index]
    mov.b @r3, r0                      ! r0 = status_flags[player_index]
    extu.b r0, r0                      ! r0 = status flag (unsigned)
    tst r0, r0                         ! status flag == 0?
    bt      .L_skip_dispatch           ! yes: player needs no update, skip to return
    mov.l   .L_pool_geom_output_ptr, r6 ! r6 = &geom_output_buf_ptr (sym_0605E098)
    mov.b @r14, r5                     ! r5 = player_index (for course table offset)
    mov.l   .L_pool_course_table, r2   ! r2 = course_name_table base (sym_0604A57C)
    mov.b @r14, r4                     ! r4 = player_index (for element state lookup)
    mov.l @r6, r6                      ! r6 = *geom_output_buf_ptr (actual buffer address, arg3)
    extu.b r5, r5                      ! r5 = player_index (unsigned)
    extu.b r4, r4                      ! r4 = player_index (unsigned)
    mov r5, r3                         ! r3 = player_index (copy for x12 multiply)
    shll2 r5                           ! r5 = player_index * 4
    shll2 r3                           ! r3 = player_index * 4
    shll r3                            ! r3 = player_index * 8
    add r3, r5                         ! r5 = player_index * 12 (entry stride)
    add r2, r5                         ! r5 = &course_table[player_index] (arg2: name string ptr)
    mov.l   .L_pool_elem_state, r3     ! r3 = player_elem_state base (sym_060877D9)
    add r3, r4                         ! r4 = &elem_state[player_index]
    mov.b @r4, r4                      ! r4 = elem_state[player_index] (signed byte)
    .byte   0xBE, 0x5D    /* bsr 0x0601E810 (hud_handler_main) */
    extu.b r4, r4                      ! (delay) r4 = element state index (unsigned, arg1)
.L_skip_dispatch:
    lds.l @r15+, pr                    ! restore return address
    rts                                ! return
    mov.l @r15+, r14                   ! (delay) restore r14
.L_pool_elem_state:
    .4byte  sym_060877D9
.L_pool_player_index:
    .4byte  sym_060877D8
.L_pool_status_flags:
    .4byte  sym_060877DD
.L_pool_geom_output_ptr:
    .4byte  sym_0605E098
.L_pool_course_table:
    .4byte  sym_0604A57C
