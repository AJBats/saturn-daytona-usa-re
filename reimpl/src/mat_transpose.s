/* mat_transpose -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E770 - 0x0601E810
 * Auto-generated by tools/generate_l3_tu.py
 *
 * HUD element dispatch helper — brackets a vtable call with SMPC
 * RESDISA (0x1A) / RESENAB (0x19) for inter-CPU synchronization.
 *
 * Flow:
 *   1. Calls strlen (sym_06035C1C) on the name buffer in r12.
 *   2. If length > 11, null-terminates at byte 11 to clamp the name.
 *   3. Polls SMPC SF, issues RESDISA (0x1A) to disable reset button.
 *   4. Waits for RESDISA completion.
 *   5. Reads the function dispatch table (sym_06000354), indexes into
 *      the HUD element array (sym_06087094, 0x20 bytes per element),
 *      and calls vtable slot 5 (offset +20) with the element's
 *      display ID from field +0x1C.
 *   6. Polls SMPC SF, issues RESENAB (0x19) to re-enable reset button.
 *   7. Waits for RESENAB completion and returns the dispatch result.
 *
 * Caller contract (registers set by caller, e.g. hud_handler_main):
 *   r0  = element index (word, saved to stack at +4)
 *   r6  = callback/extra parameter (saved to stack at +0)
 *   r12 = name string buffer pointer
 *   r13 = (overwritten) loaded with SMPC SF address
 *   r14 = SMPC SF bit mask (typically 1)
 *
 * Returns:
 *   r0 = result from vtable dispatch call
 *
 * Key data:
 *   sym_06035C1C = strlen — counts bytes until null terminator
 *   sym_06000354 = function dispatch table pointer
 *   sym_06087094 = HUD element array (0x20 bytes per element)
 */

    .section .text.FUN_0601E770


    .global mat_transpose
    .type mat_transpose, @function
mat_transpose:
    sts.l pr, @-r15                     ! save return address
    add #-0x8, r15                      ! allocate 8 bytes of stack frame
    mov.l   .L_smpc_sf, r13             ! r13 = 0x20100063 (SMPC SF register, cache-through)
    mov.w r0, @(4, r15)                 ! stack[4] = element index (word)
    mov.l r6, @r15                      ! stack[0] = callback/extra parameter
    mov.l   .L_fn_strlen, r3            ! r3 = strlen function address (sym_06035C1C)
    jsr @r3                             ! call strlen(r4=r12) — returns length in r0
    mov r12, r4                         ! (delay) r4 = name buffer pointer (arg for strlen)
    mov #0xB, r2                        ! r2 = 11 (max allowed name length)
    cmp/gt r2, r0                       ! T = (length > 11)?
    bf      .L_name_ok                  ! if length <= 11, skip clamping
    mov #0x0, r2                        ! r2 = 0 (null terminator)
    mov r2, r0                          ! r0 = 0
    mov.b r0, @(11, r12)               ! name_buf[11] = '\0' — clamp name to 11 chars
.L_name_ok:
/* --- SMPC sync: wait for SF ready, issue RESDISA (0x1A) command --- */
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend to 32 bits
    and r14, r2                         ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                      ! SF.bit0 == 1? (previous command still active)
    bt      .L_name_ok                  ! spin while SMPC is busy
    extu.b r14, r2                      ! r2 = 1 (SF busy flag value)
    mov.b r2, @r13                      ! SF = 1 (set busy before issuing new command)
    mov #0x1A, r3                       ! 0x1A = SMPC RESDISA command (Reset Disable)
    mov.l   .L_smpc_comreg_ct, r2       ! r2 = 0x2010001F (SMPC COMREG, cache-through)
    mov.b r3, @r2                       ! write RESDISA command to COMREG
.L_poll_resdisa_done:
/* --- Wait for RESDISA completion --- */
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend
    and r14, r2                         ! isolate bit 0
    tst r2, r2                          ! SF.bit0 == 0? (command completed)
    bf      .L_poll_resdisa_done        ! spin while busy
/* --- Read dispatch table and call vtable slot 5 for this HUD element --- */
    mov.l   .L_dispatch_table_ptr, r3   ! r3 = &dispatch_table_ptr (sym_06000354)
    mov r12, r5                         ! r5 = name buffer pointer (arg2 for dispatch)
    mov.w @(4, r15), r0                 ! r0 = element index (word, from stack)
    mov.l @r15, r6                      ! r6 = callback/extra parameter (from stack)
    mov.l @r3, r3                       ! r3 = *dispatch_table_ptr (actual dispatch table)
    mov r0, r4                          ! r4 = element index
    mov.l @(20, r3), r2                 ! r2 = dispatch_table[5] (vtable slot 5, offset +20)
    extu.w r4, r4                       ! zero-extend element index to 32 bits
    mov.l   .L_hud_element_array, r3    ! r3 = HUD element array base (sym_06087094)
    shll2 r4                            ! r4 = index * 4
    shll2 r4                            ! r4 = index * 16
    shll r4                             ! r4 = index * 32 (element stride = 0x20)
    add r3, r4                          ! r4 = &hud_element[index]
    mov.w @(28, r4), r0                 ! r0 = element[index].field_1C (display ID, word at +0x1C)
    mov r0, r4                          ! r4 = display_id
    jsr @r2                             ! call vtable_slot5(display_id, name_buf, callback, ...)
    extu.w r4, r4                       ! (delay) zero-extend display_id to 32 bits
    mov r0, r4                          ! r4 = dispatch result (saved for return)
.L_poll_sf_set_resenab:
/* --- SMPC sync: wait for SF ready, issue RESENAB (0x19) command --- */
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend
    and r14, r2                         ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                      ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_set_resenab      ! spin while busy
    extu.b r14, r2                      ! r2 = 1 (SF busy flag value)
    mov.b r2, @r13                      ! SF = 1 (set busy before issuing new command)
    mov #0x19, r3                       ! 0x19 = SMPC RESENAB command (Reset Enable)
    mov.l   .L_smpc_comreg_ct, r2       ! r2 = 0x2010001F (SMPC COMREG, cache-through)
    mov.b r3, @r2                       ! write RESENAB command to COMREG
.L_poll_resenab_done:
/* --- Wait for RESENAB completion, then return --- */
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend
    and r14, r2                         ! isolate bit 0
    tst r2, r2                          ! SF.bit0 == 0? (command completed)
    bf      .L_poll_resenab_done        ! spin while busy
    mov r4, r0                          ! r0 = dispatch result (return value)
    add #0x8, r15                       ! deallocate 8 bytes of stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12 (callee-saved)
    mov.l @r15+, r13                    ! restore r13 (callee-saved)
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14 (callee-saved)
    .2byte  0xFFFF
/* --- Constant pool --- */
.L_smpc_sf:
    .4byte  0x20100063                  /* SMPC SF — status flag */
.L_fn_strlen:
    .4byte  sym_06035C1C
.L_smpc_comreg_ct:
    .4byte  0x2010001F                  /* SMPC COMREG (cache-through) */
.L_dispatch_table_ptr:
    .4byte  sym_06000354
.L_hud_element_array:
    .4byte  sym_06087094
