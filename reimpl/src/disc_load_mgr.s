/* disc_load_mgr -- Disc loading manager: resource init for course transitions
 * Translation unit: 0x0601B170 - 0x0601B418
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 *
 * Called during course loading to set up VDP1 sprites, VDP2 scroll planes,
 * palettes, tile data, and display channel configuration for the new scene.
 *
 * Phases:
 *   1. Store config param, init timing register, call vdp2_scroll_update
 *   2. Call screen coord bounds setup (sym_060393FC) with screen extents
 *   3. Store DMA config, write 0.5 FP to car array base, call CD texture loader
 *   4. Memcpy from CD-ROM base into car array (game_state_index * 6 + base)
 *   5. Register VDP1 sprites via vdp1_sprite_render (slots 0x0101-0x0103)
 *   6. Register game objects via sym_06007540 (obj_register)
 *   7. Repeat sprite + object registration for second pass
 *   8. DMA palettes into VDP2 CRAM, tile data into VDP2 VRAM
 *   9. Configure display channels and nibble priority
 *  10. Set display layer config, render state commit
 *  11. Set render mode flags (sign bit + bit 30), clear disc state flags
 *
 * Register allocation (persistent across phases):
 *   r14 = obj_register fn ptr (phase 6-7) / dma_transfer (phase 8 onward)
 *   r13 = 0x002A0000 CD-ROM base (phase 4-7) / render_mode_flags ptr (phase 8+)
 *   r12 = vdp1_sprite_render fn ptr (phase 5-7)
 *   r11 = sprite slot ID B (0x0102)
 *   r10 = sprite slot ID A (0x0101)
 *   r9  = sprite slot ID C (0x0103)
 *   r8  = 0 (constant zero, passed as r8 arg to this function)
 */

    .section .text.FUN_0601B170


    .global disc_load_mgr
    .type disc_load_mgr, @function
disc_load_mgr:
    sts.l pr, @-r15                         ! save return address
    add #-0xC, r15                          ! allocate 12 bytes of stack locals
                                            ! --- Phase 1: store config, init timing ---
    mov.l   .L_race_state_a, r3
    mov.l r8, @r3                           ! *race_state_a = r8 (config param)
    mov.w   DAT_0601b246, r2                ! r2 = 0x20D8 (timing constant)
    mov.l   .L_race_timer_init, r3
    mov.l r2, @r3                           ! *race_timer_init = 0x20D8
    mov.l   .L_car_array_base, r4           ! r4 = &car_array_base (arg for scroll update)
    mov.l   .L_fn_vdp2_scroll_update, r3
    jsr @r3                                 ! vdp2_scroll_update(car_array_base)
    nop
                                            ! --- Phase 2: screen coord bounds ---
    mov r8, r6                              ! r6 = 0
    mov r8, r5                              ! r5 = 0
    mov.w   DAT_0601b248, r2                ! r2 = 0x00DF (screen height - 1 = 223)
    mov.l r2, @-r15                         ! push screen height to stack
    mov.w   DAT_0601b24a, r7                ! r7 = 0x015F (screen width - 1 = 351)
    mov.l   .L_fn_screen_coord_setup, r3
    jsr @r3                                 ! screen_coord_setup(0, 0, 0, 351) [+stack 223]
    mov r8, r4                              ! r4 = 0
                                            ! --- Phase 3: DMA config + CD texture load ---
    mov.l   .L_dma_config, r3
    mov.l r8, @r3                           ! *dma_config = 0 (clear DMA state)
    mov.l   .L_car_array_base, r2
    mov.l   .L_fp_half, r3                  ! r3 = 0x8000 (0.5 fixed-point)
    mov.l @r2, r2                           ! r2 = *car_array_base
    mov.w r3, @r2                           ! write 0.5 FP at car_array_base[0] (16-bit)
    mov.l   .L_fn_cd_texture_load, r3
    jsr @r3                                 ! cd_texture_load() — load textures from disc
    nop
                                            ! --- Phase 4: memcpy CD-ROM data to car array ---
    mov.w   .L_memcpy_size, r6             ! r6 = 0x0640 (byte count for copy)
    mov.l   .L_cdrom_base, r14             ! r14 = 0x002A0000 (CD-ROM memory base)
    mov.l   .L_game_state_index, r4
    mov.l   .L_car_array_base, r3
    mov.l   .L_fn_memcpy_word_idx, r2
    mov r14, r5                             ! r5 = CD-ROM base (source)
    mov.l @r4, r4                           ! r4 = game_state_index
    mov.l @r3, r3                           ! r3 = *car_array_base
    shll2 r4                                ! r4 *= 4
    shll r4                                 ! r4 *= 2 (total: index * 8 → struct offset)
    jsr @r2                                 ! memcpy_word_idx(dest, cdrom_base, 0x0640)
    add r3, r4                              ! r4 = car_array_base + index * 8 (destination)
                                            ! --- Phase 5: register VDP1 sprites (first batch) ---
    mov.w   .L_spr_slot_a, r10             ! r10 = 0x0101 (sprite slot A, persistent)
    mov #0x78, r6                           ! r6 = 0x78 (sprite type/flags)
    mov.l   .L_fn_vdp1_sprite, r12         ! r12 = vdp1_sprite_render (persistent fn ptr)
    mov.w   .L_spr_size_param, r13         ! r13 = 0x0B40 (sprite size param, persistent)
    mov.w   .L_cdrom_offset_a, r7          ! r7 = 0x4B46 (CD-ROM offset for sprite A)
    mov r13, r5                             ! r5 = size param
    add r14, r7                             ! r7 = cdrom_base + 0x4B46 (absolute addr)
    mov.l r7, @(12, r15)                    ! save sprite A addr to stack[12]
    jsr @r12                                ! vdp1_sprite_render(0x0101, 0x0B40, 0x78, addr)
    mov r10, r4                             ! r4 = slot 0x0101 (delay slot)
    mov.w   DAT_0601b254, r11              ! r11 = 0x0102 (sprite slot B, persistent)
    mov #0x7C, r6                           ! r6 = 0x7C (sprite type/flags)
    mov r13, r5                             ! r5 = size param
    mov.w   DAT_0601b256, r7               ! r7 = 0x5313 (CD-ROM offset for sprite B)
    add r14, r7                             ! r7 = cdrom_base + 0x5313
    mov.l r7, @(4, r15)                     ! save sprite B addr to stack[4]
    jsr @r12                                ! vdp1_sprite_render(0x0102, 0x0B40, 0x7C, addr)
    mov r11, r4                             ! r4 = slot 0x0102 (delay slot)
    mov.w   .L_spr_slot_c, r9             ! r9 = 0x0103 (sprite slot C, persistent)
    mov r13, r5                             ! r5 = size param
    mov.w   DAT_0601b25a, r7               ! r7 = 0x5B86 (CD-ROM offset for sprite C)
    add r14, r7                             ! r7 = cdrom_base + 0x5B86
    mov.l r7, @(8, r15)                     ! save sprite C addr to stack[8]
    mov.w   .L_spr_flags_small, r6         ! r6 = 0x0080 (small sprite flags)
    jsr @r12                                ! vdp1_sprite_render(0x0103, 0x0B40, 0x80, addr)
    mov r9, r4                              ! r4 = slot 0x0103 (delay slot)
                                            ! --- Phase 6: register game objects ---
    mov.l   .L_fn_obj_register, r14        ! r14 = obj_register fn ptr (replaces cdrom_base)
    mov.w   DAT_0601b25e, r6               ! r6 = 0x0084 (object flags)
    mov.w   DAT_0601b260, r4               ! r4 = 0x0104 (object slot)
    jsr @r14                                ! obj_register(0x0104, 0x0101, 0x0084)
    mov r10, r5                             ! r5 = slot A (0x0101)
    mov r11, r5                             ! r5 = slot B (0x0102) — for next call
    mov.w   DAT_0601b262, r6               ! r6 = 0x0088 (object flags)
    mov r6, r4                              ! r4 = 0x0088
    jsr @r14                                ! obj_register(0x0088+0x7D, 0x0102, 0x0088)
    add #0x7D, r4                           ! r4 = 0x0088 + 0x7D = 0x0105
    mov.w   .L_obj_flags_c, r6             ! r6 = 0x008C (object flags)
    mov r9, r5                              ! r5 = slot C (0x0103)
    mov r6, r4                              ! r4 = 0x008C
    jsr @r14                                ! obj_register(0x008C+0x7A, 0x0103, 0x008C)
    add #0x7A, r4                           ! r4 = 0x008C + 0x7A = 0x0106
                                            ! --- Phase 5b: re-register sprites (second set) ---
    mov #0x78, r6                           ! r6 = 0x78 (sprite type/flags)
    mov r13, r5                             ! r5 = size param (0x0B40)
    mov.l @(12, r15), r7                    ! r7 = saved sprite A addr from stack
    jsr @r12                                ! vdp1_sprite_render(0x0101, 0x0B40, 0x78, addr)
    mov r10, r4                             ! r4 = slot 0x0101
    mov.l @(4, r15), r7                     ! r7 = saved sprite B addr from stack
    mov #0x7C, r6                           ! r6 = 0x7C
    mov r13, r5                             ! r5 = size param
    jsr @r12                                ! vdp1_sprite_render(0x0102, 0x0B40, 0x7C, addr)
    mov r11, r4                             ! r4 = slot 0x0102
    mov r13, r5                             ! r5 = size param
    mov.l @(8, r15), r7                     ! r7 = saved sprite C addr from stack
    mov.w   .L_spr_flags_small, r6         ! r6 = 0x0080
    jsr @r12                                ! vdp1_sprite_render(0x0103, 0x0B40, 0x80, addr)
    mov r9, r4                              ! r4 = slot 0x0103
                                            ! --- Phase 6b: re-register objects (second set) ---
    mov.w   DAT_0601b25e, r6               ! r6 = 0x0084
    mov.w   DAT_0601b260, r4               ! r4 = 0x0104
    jsr @r14                                ! obj_register(0x0104, 0x0101, 0x0084)
    mov r10, r5                             ! r5 = slot A
    mov.w   DAT_0601b262, r6               ! r6 = 0x0088
    mov r11, r5                             ! r5 = slot B
    mov r6, r4
    jsr @r14                                ! obj_register(0x0105, 0x0102, 0x0088)
    add #0x7D, r4                           ! r4 = 0x0088 + 0x7D = 0x0105
    bra     .L_second_pass                  ! continue to third pass
    nop

    ! --- Inline data pool (word constants) ---
    .global DAT_0601b246
DAT_0601b246:
    .2byte  0x20D8                          /* timing init constant (8408 decimal) */

    .global DAT_0601b248
DAT_0601b248:
    .2byte  0x00DF                          /* screen height - 1 (223) */

    .global DAT_0601b24a
DAT_0601b24a:
    .2byte  0x015F                          /* screen width - 1 (351) */
.L_memcpy_size:
    .2byte  0x0640                          /* memcpy byte count (1600) */
.L_spr_slot_a:
    .2byte  0x0101                          /* VDP1 sprite slot A */
.L_spr_size_param:
    .2byte  0x0B40                          /* sprite dimension param */
.L_cdrom_offset_a:
    .2byte  0x4B46                          /* CD-ROM data offset for sprite A */

    .global DAT_0601b254
DAT_0601b254:
    .2byte  0x0102                          /* VDP1 sprite slot B */

    .global DAT_0601b256
DAT_0601b256:
    .2byte  0x5313                          /* CD-ROM data offset for sprite B */
.L_spr_slot_c:
    .2byte  0x0103                          /* VDP1 sprite slot C */

    .global DAT_0601b25a
DAT_0601b25a:
    .2byte  0x5B86                          /* CD-ROM data offset for sprite C */
.L_spr_flags_small:
    .2byte  0x0080                          /* small sprite type flags */

    .global DAT_0601b25e
DAT_0601b25e:
    .2byte  0x0084                          /* object flags for slot A */

    .global DAT_0601b260
DAT_0601b260:
    .2byte  0x0104                          /* object slot ID for A registration */

    .global DAT_0601b262
DAT_0601b262:
    .2byte  0x0088                          /* object flags for slot B */
.L_obj_flags_c:
    .2byte  0x008C                          /* object flags for slot C */
    .2byte  0xFFFF                          /* alignment padding */
    ! --- Long constant pool ---
.L_race_state_a:
    .4byte  sym_0606A4F4                    /* race state config parameter (32-bit) */
.L_race_timer_init:
    .4byte  sym_0606A4EC                    /* timing register (32-bit) */
.L_car_array_base:
    .4byte  sym_06063F5C                    /* car struct array base pointer */
.L_fn_vdp2_scroll_update:
    .4byte  vdp2_scroll_update              /* scroll plane setup function */
.L_fn_screen_coord_setup:
    .4byte  sym_060393FC                    /* screen coordinate bounds setup */
.L_dma_config:
    .4byte  sym_0605A008                    /* DMA configuration state word */
.L_fp_half:
    .4byte  0x00008000                      /* 0.5 (16.16 fixed-point) */
.L_fn_cd_texture_load:
    .4byte  sym_06012E00                    /* CD texture loader entry point */
.L_cdrom_base:
    .4byte  0x002A0000                      /* CD-ROM memory-mapped base address */
.L_game_state_index:
    .4byte  sym_06059FFC                    /* current game state index */
.L_fn_memcpy_word_idx:
    .4byte  memcpy_word_idx                 /* word-indexed memory copy */
.L_fn_vdp1_sprite:
    .4byte  vdp1_sprite_render              /* VDP1 sprite registration */
.L_fn_obj_register:
    .4byte  sym_06007540                    /* game object registration */
.L_second_pass:
                                            ! --- Phase 7: third sprite + object pass ---
    mov.w   DAT_0601b38a, r6               ! r6 = 0x008C (obj flags C)
    mov r9, r5                              ! r5 = slot C (0x0103)
    mov r6, r4                              ! r4 = 0x008C
    jsr @r14                                ! obj_register(0x008C+0x7A, 0x0103, 0x008C)
    add #0x7A, r4                           ! r4 = 0x008C + 0x7A = 0x0106
    mov #0x78, r6                           ! r6 = 0x78 (sprite type A)
    mov r13, r5                             ! r5 = size param (0x0B40)
    mov.l @(12, r15), r7                    ! r7 = saved sprite A addr
    jsr @r12                                ! vdp1_sprite_render(0x0101, 0x0B40, 0x78, addr)
    mov r10, r4                             ! r4 = slot A (0x0101)
    mov.l @(4, r15), r7                     ! r7 = saved sprite B addr
    mov #0x7C, r6                           ! r6 = 0x7C (sprite type B)
    mov r13, r5
    jsr @r12                                ! vdp1_sprite_render(0x0102, 0x0B40, 0x7C, addr)
    mov r11, r4                             ! r4 = slot B (0x0102)
    mov r13, r5
    mov.l @(8, r15), r7                     ! r7 = saved sprite C addr
    mov.w   DAT_0601b38c, r6               ! r6 = 0x0080 (sprite type C)
    jsr @r12                                ! vdp1_sprite_render(0x0103, 0x0B40, 0x80, addr)
    mov r9, r4                              ! r4 = slot C (0x0103)
    mov.w   DAT_0601b38e, r6               ! r6 = 0x0084 (obj flags A)
    mov.w   DAT_0601b390, r4               ! r4 = 0x0104 (obj slot A)
    jsr @r14                                ! obj_register(0x0104, 0x0101, 0x0084)
    mov r10, r5                             ! r5 = slot A
    mov.w   DAT_0601b392, r6               ! r6 = 0x0088 (obj flags B)
    mov r11, r5                             ! r5 = slot B
    mov r6, r4
    jsr @r14                                ! obj_register(0x0105, 0x0102, 0x0088)
    add #0x7D, r4                           ! r4 = 0x0088 + 0x7D = 0x0105
    mov r9, r5                              ! r5 = slot C
    mov.w   DAT_0601b38a, r6               ! r6 = 0x008C (obj flags C)
    mov r6, r4
    jsr @r14                                ! obj_register(0x0106, 0x0103, 0x008C)
    add #0x7A, r4                           ! r4 = 0x008C + 0x7A = 0x0106
                                            ! --- Phase 8: DMA palettes + tile data ---
    mov r8, r3                              ! r3 = 0
    mov.l   .L_vdp2_scroll_word, r2
    mov.w r3, @r2                           ! *vdp2_scroll_word = 0 (clear scroll state)
    mov.l   .L_render_mode_flags, r13      ! r13 = &render_mode_flags (persistent)
    mov.l   .L_fp_min, r3                  ! r3 = 0x80000000 (sign bit)
    mov.l @r13, r2                          ! r2 = *render_mode_flags
    or r3, r2                               ! r2 |= 0x80000000 (set sign bit)
    mov.l   .L_fn_display_update, r3
    jsr @r3                                 ! display_update() — flush with new flags
    mov.l r2, @r13                          ! *render_mode_flags = r2 (store before call)
    mov.l   .L_fn_display_update, r3
    jsr @r3                                 ! display_update() — second flush
    nop
                                            ! --- DMA palette A into VDP2 CRAM +0x540 ---
    mov.l   .L_palette_src_a, r5           ! r5 = palette source A (WRAM)
    mov.l   .L_vdp2_cram_0x540, r4        ! r4 = 0x25F00540 (VDP2 CRAM destination)
    mov.l   .L_fn_dma_transfer, r3
    jsr @r3                                 ! dma_transfer(0x25F00540, src_a, 0x40)
    mov #0x40, r6                           ! r6 = 0x40 (64 bytes = 32 palette entries)
                                            ! --- DMA palette B into VDP2 CRAM +0x1A0 ---
    mov.l   .L_palette_src_b, r5           ! r5 = palette source B (WRAM)
    mov.l   .L_vdp2_cram_0x1A0, r4        ! r4 = 0x25F001A0 (VDP2 CRAM destination)
    mov.l   .L_fn_dma_transfer, r3
    jsr @r3                                 ! dma_transfer(0x25F001A0, src_b, 0x20)
    mov #0x20, r6                           ! r6 = 0x20 (32 bytes = 16 palette entries)
                                            ! --- Copy tile data to VDP2 VRAM ---
    mov #0x9, r7                            ! r7 = 0x9 (tile format/mode)
    mov.l   .L_tile_size_a, r5             ! r5 = 0x00017700 (tile data size: 96000 bytes)
    mov.l   .L_vdp2_vram_0x6F9C4, r4      ! r4 = 0x25E6F9C4 (VRAM destination)
    mov.l   .L_fn_vram_tile_copy, r3
    jsr @r3                                 ! vram_tile_copy(0x25E6F9C4, 0x17700, 0, 0x9)
    mov r8, r6                              ! r6 = 0
                                            ! --- DMA tilemap into VDP2 VRAM ---
    mov.l   .L_tilemap_src, r5             ! r5 = tilemap source data (WRAM)
    mov.l   .L_vdp2_vram_0x75DDC, r4      ! r4 = 0x25E75DDC (VRAM destination)
    mov.l   .L_fn_dma_mem_transfer, r3
    add r8, r5                              ! r5 += 0 (no-op, r8=0)
    jsr @r3                                 ! dma_memory_transfer(0x25E75DDC, src, ...)
    mov.l r5, @(4, r15)                     ! save src addr for later reuse
                                            ! --- Phase 9: display list + channel config ---
    mov r8, r6                              ! r6 = 0
    mov.l @(4, r15), r5                     ! r5 = tilemap src (from stack)
    mov.l   .L_dma_block_size, r7          ! r7 = 0xB000 (block size: 45056 bytes)
    mov.l   .L_fn_display_list_load, r3
    jsr @r3                                 ! display_list_load(0x4, src, 0, 0xB000)
    mov #0x4, r4                            ! r4 = channel 4
    mov r8, r6                              ! r6 = 0
    mov r8, r5                              ! r5 = 0
    mov.l   .L_fn_display_channel_b, r3
    jsr @r3                                 ! display_channel_b(0x10, 0, 0)
    mov #0x10, r4                           ! r4 = channel 0x10
    mov r8, r6
    mov r8, r5
    mov.l   .L_fn_display_channel_b, r3
    jsr @r3                                 ! display_channel_b(0x20, 0, 0)
    mov #0x20, r4                           ! r4 = channel 0x20
                                            ! --- Configure nibble priority for all channels ---
    mov.l   .L_fn_channel_nibble_cfg, r14  ! r14 = channel_nibble_config (persistent fn ptr)
    mov.w   .L_channel_id, r4             ! r4 = 0x0100 (channel group ID)
    jsr @r14                                ! channel_nibble_config(0x0100, 0x7)
    mov #0x7, r5                            ! r5 = priority 7
    mov r8, r5                              ! r5 = 0
    jsr @r14                                ! channel_nibble_config(0x4, 0)
    mov #0x4, r4
    mov #0x1, r5
    jsr @r14                                ! channel_nibble_config(0x8, 0x1)
    mov #0x8, r4
    mov #0x6, r5
    jsr @r14                                ! channel_nibble_config(0x10, 0x6)
    mov #0x10, r4
    mov #0x5, r5
    jsr @r14                                ! channel_nibble_config(0x20, 0x5)
    mov #0x20, r4
    mov r8, r5                              ! r5 = 0
    jsr @r14                                ! channel_nibble_config(0x1, 0)
    mov #0x1, r4
                                            ! --- Phase 10: display layer + render commit ---
    mov.l   .L_fn_display_layer_cfg, r3
    jsr @r3                                 ! display_layer_config(0xC)
    mov #0xC, r4
    mov.l   .L_fn_render_state_commit, r3
    jsr @r3                                 ! render_state_commit()
    nop
                                            ! --- Phase 11: set bit 30 in render flags, clear disc state ---
    mov.l   .L_fp_0x4000_0000, r2         ! r2 = 0x40000000 (bit 30)
    mov.l @r13, r3                          ! r3 = *render_mode_flags
    or r2, r3                               ! r3 |= 0x40000000 (set "ready" bit 30)
    mov.l r3, @r13                          ! *render_mode_flags = r3
    mov r8, r2                              ! r2 = 0
    mov.l   .L_disc_state_flag_b, r3
    mov.b r2, @r3                           ! *disc_state_flag_b = 0 (clear error code)
    bra     .L_cleanup_and_exit             ! jump to epilogue
    nop

    ! --- Inline data pool (word constants, second section) ---
    .global DAT_0601b38a
DAT_0601b38a:
    .2byte  0x008C                          /* object flags for slot C (second pass) */

    .global DAT_0601b38c
DAT_0601b38c:
    .2byte  0x0080                          /* sprite flags small (second pass) */

    .global DAT_0601b38e
DAT_0601b38e:
    .2byte  0x0084                          /* object flags for slot A (second pass) */

    .global DAT_0601b390
DAT_0601b390:
    .2byte  0x0104                          /* object slot ID A (second pass) */

    .global DAT_0601b392
DAT_0601b392:
    .2byte  0x0088                          /* object flags for slot B (second pass) */
.L_channel_id:
    .2byte  0x0100                          /* display channel group ID */
    .2byte  0xFFFF                          /* alignment padding */
    ! --- Long constant pool (second section) ---
.L_vdp2_scroll_word:
    .4byte  sym_0605AAA0                    /* VDP2 scroll position state (16-bit) */
.L_render_mode_flags:
    .4byte  sym_0605B6D8                    /* render mode flags (32-bit bitmask) */
.L_fp_min:
    .4byte  0x80000000                      /* sign bit (bit 31) */
.L_fn_display_update:
    .4byte  sym_06026CE0                    /* display update / camera state finalization */
.L_palette_src_a:
    .4byte  sym_0604842C                    /* palette data source A (WRAM) */
.L_vdp2_cram_0x540:
    .4byte  0x25F00540                      /* VDP2 color RAM +0x540 */
.L_fn_dma_transfer:
    .4byte  dma_transfer                    /* DMA transfer routine */
.L_palette_src_b:
    .4byte  sym_060487EC                    /* palette data source B (WRAM) */
.L_vdp2_cram_0x1A0:
    .4byte  0x25F001A0                      /* VDP2 color RAM +0x1A0 */
.L_tile_size_a:
    .4byte  0x00017700                      /* tile data size (96000 bytes) */
.L_vdp2_vram_0x6F9C4:
    .4byte  0x25E6F9C4                      /* VDP2 VRAM tile destination A */
.L_fn_vram_tile_copy:
    .4byte  sym_0600511E                    /* VRAM tile data copy routine */
.L_tilemap_src:
    .4byte  sym_06094FA8                    /* tilemap source data (WRAM) */
.L_vdp2_vram_0x75DDC:
    .4byte  0x25E75DDC                      /* VDP2 VRAM tilemap destination B */
.L_fn_dma_mem_transfer:
    .4byte  dma_memory_transfer             /* DMA memory-to-memory transfer */
.L_dma_block_size:
    .4byte  0x0000B000                      /* DMA block size (45056 bytes) */
.L_fn_display_list_load:
    .4byte  sym_06028400                    /* display list loader */
.L_fn_display_channel_b:
    .4byte  display_channel_b               /* display channel B setup */
.L_fn_channel_nibble_cfg:
    .4byte  channel_nibble_config           /* channel priority nibble configuration */
.L_fn_display_layer_cfg:
    .4byte  sym_0602853E                    /* display layer configuration */
.L_fn_render_state_commit:
    .4byte  sym_06028560                    /* render state commit / flush */
.L_fp_0x4000_0000:
    .4byte  0x40000000                      /* bit 30 — "ready" flag */
.L_disc_state_flag_b:
    .4byte  sym_0608600D                    /* disc error code (byte: 0=none) */
                                            ! --- Epilogue: clear remaining flags, tail call ---
.L_cleanup_and_exit:
    .byte   0xD3, 0x19    /* mov.l r3, sym_0608600C */  ! r3 = &disc_error_flag
    mov.b r2, @r3                           ! *disc_error_flag = 0
    .byte   0xD3, 0x19    /* mov.l r3, sym_0608600E */  ! r3 = &disc_type_flag
    mov.b r2, @r3                           ! *disc_type_flag = 0
    mov #0xF, r6                            ! r6 = 0xF (tail call arg)
    mov #0x4, r5                            ! r5 = 0x4
    mov r5, r4                              ! r4 = 0x4
    add #0x10, r15                          ! deallocate stack locals
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r8                         ! restore callee-saved registers
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    .byte   0xD3, 0x14    /* mov.l r3, handler_dispatch */  ! r3 = handler_dispatch (0x06018DDC)
    jmp @r3                                 ! tail call handler_dispatch(0x4, 0x4, 0xF)
    mov.l @r15+, r14                        ! restore r14 (delay slot)
