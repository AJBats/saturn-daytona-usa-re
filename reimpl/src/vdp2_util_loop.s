/* vdp2_util_loop -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601712C - 0x060171AC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ----------------------------------------------------------------
 * vdp2_util_loop
 * ----------------------------------------------------------------
 * Iterates through 18 VDP2/HUD slot entries (68-byte structs at
 * sym_06084FC8) and dispatches a handler for each active slot.
 *
 * The function copies a 22-entry function pointer table (sym_0605BC14)
 * onto the stack, then loops over slots 0..17. For each slot, it reads
 * the handler-type byte at offset 0 of the 68-byte struct. If non-zero,
 * the byte is used as a 1-based index into the local function table to
 * call the appropriate HUD/display handler.
 *
 * Handler table entries include: hud_layout_mgr, lap_counter_update,
 * speed_unit_display, position_suffix_ordinal, lap_progress_bar,
 * time_delta_format, time_digit_update, hud_anim_ctrl, etc.
 *
 * Arguments:
 *   (none)
 *
 * Returns:
 *   (nothing â€” side effects via handler calls)
 *
 * Calls (external):
 *   sym_06035168 = memcpy_long(r0=byte_count, r1=dst, r2=src)
 *   handler table functions (indirect via jsr @r3)
 */

    .section .text.FUN_0601712C


    .global vdp2_util_loop
    .type vdp2_util_loop, @function
vdp2_util_loop:
    mov.l r14, @-r15                    ! save r14 (loop counter)
    mov.l r13, @-r15                    ! save r13 (slot data base pointer)
    mov.l r12, @-r15                    ! save r12 (local fn table on stack)
    mov.l r11, @-r15                    ! save r11 (slot count limit)
    sts.l pr, @-r15                     ! save return address
    mov #0x12, r11                      ! r11 = 18 = number of slots to process
    add #-0x58, r15                     ! allocate 0x58 (88) bytes on stack for fn table copy
    mov r15, r12                        ! r12 = sp (base of local fn table on stack)
    mov.l   .L_pool_slot_data_base, r13 ! r13 = slot data array base (sym_06084FC8, 68-byte structs)
    mov r15, r1                         ! r1 = dst for memcpy (stack frame)
    mov.l   .L_pool_fn_table_src, r2    ! r2 = src for memcpy (sym_0605BC14, handler fn table)
    mov.l   .L_pool_memcpy_long, r3     ! r3 = memcpy_long function address
    jsr @r3                             ! call memcpy_long(r0=0x58, r1=stack, r2=fn_table)
    mov #0x58, r0                       ! (delay slot) r0 = 88 bytes to copy (22 fn pointers)
    mov #0x0, r14                       ! r14 = 0 (loop counter / slot index)
.L_slot_loop:
    extu.b r14, r2                      ! r2 = slot_index & 0xFF
    mov r2, r3                          ! r3 = slot_index (for 64x multiply)
    shll2 r2                            ! r2 = slot_index * 4
    shll2 r3                            ! r3 = slot_index * 4
    shll2 r3                            ! r3 = slot_index * 16
    shll2 r3                            ! r3 = slot_index * 64
    add r3, r2                          ! r2 = slot_index * 68 (struct stride)
    exts.w r2, r2                       ! sign-extend offset to 32-bit
    add r13, r2                         ! r2 = &slot_data[slot_index] (struct base)
    mov.b @r2, r2                       ! r2 = slot_data[slot_index].handler_type (byte at offset 0)
    extu.b r2, r2                       ! zero-extend handler_type to 32-bit
    tst r2, r2                          ! is handler_type == 0? (inactive slot)
    bt      .L_skip_slot                ! if inactive, skip this slot
    extu.b r14, r0                      ! r0 = slot_index & 0xFF
    mov r0, r3                          ! r3 = slot_index (for 64x multiply)
    shll2 r0                            ! r0 = slot_index * 4
    shll2 r3                            ! r3 = slot_index * 4
    shll2 r3                            ! r3 = slot_index * 16
    shll2 r3                            ! r3 = slot_index * 64
    add r3, r0                          ! r0 = slot_index * 68
    exts.w r0, r0                       ! sign-extend offset to 32-bit
    mov.b @(r0, r13), r0                ! r0 = slot_data[slot_index].handler_type (re-read byte)
    extu.b r0, r0                       ! zero-extend to 32-bit
    add #-0x1, r0                       ! r0 = handler_type - 1 (convert 1-based to 0-based index)
    shll2 r0                            ! r0 = (handler_type - 1) * 4 (byte offset into fn table)
    mov.l @(r0, r12), r3                ! r3 = fn_table[handler_type - 1] (handler fn pointer)
    jsr @r3                             ! call handler function
    mov r14, r4                         ! (delay slot) r4 = slot_index (arg to handler)
.L_skip_slot:
    add #0x1, r14                       ! slot_index++
    extu.b r14, r2                      ! r2 = slot_index & 0xFF
    cmp/ge r11, r2                      ! has slot_index reached 18?
    bf      .L_slot_loop                ! if not, continue loop
    add #0x58, r15                      ! deallocate fn table from stack
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay slot) restore r14
    .4byte  handler_dispatch
    .4byte  sym_06018E1E
.L_pool_slot_data_base:
    .4byte  sym_06084FC8                ! slot data array base (68-byte structs, byte[0] = handler type)
.L_pool_fn_table_src:
    .4byte  sym_0605BC14                ! source handler function pointer table (22 entries)
.L_pool_memcpy_long:
    .4byte  sym_06035168                ! memcpy_long(r0=count, r1=dst, r2=src)
