/* screen_flash_effect -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06028384 - 0x0602843A
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Screen flash/fill rendering functions for the VDP1 effects subsystem.
 * All three functions share a common entry pattern: they look up a VRAM
 * buffer base pointer from the VRAM pointer table (sym_06028614),
 * indexed by r4, then render pixel data into that buffer with a color
 * bias applied to each word.
 *
 * screen_flash_effect (FUN_06028384):
 *   Renders a fixed-length flash overlay into VRAM. Calls the VDP1
 *   command lookup function (0x060282C0) to obtain a source data
 *   pointer, then copies 12 bytes from the source into VRAM as words,
 *   adding a color offset (r6) to each byte before writing.
 *
 *   Entry registers:
 *     r4  = VRAM pointer table index (selects framebuffer)
 *     r5  = destination offset within VRAM buffer
 *     r6  = color bias (added to each source byte)
 *     r7  = parameter passed to VDP1 command lookup as r4
 *
 * sym_060283E0 (vram_write_nullterm):
 *   Writes pixel words to VRAM from a null-terminated byte array.
 *   Each byte from r7 is added to the color bias (r6) and written
 *   as a word. Stops when a null byte is encountered.
 *
 *   Entry registers:
 *     r4  = VRAM pointer table index (selects framebuffer)
 *     r5  = destination offset within VRAM buffer
 *     r6  = color bias (added to each source byte)
 *     r7  = pointer to null-terminated source byte array
 *
 * sym_06028400 (vram_rect_fill):
 *   Fills a rectangular region of VRAM with pixel words from a source
 *   array. Reads width and height from the first two words of the
 *   source (r5), then copies width*height words with color bias (r7).
 *   Pads each row to 64 words (128 bytes) to match VRAM stride.
 *
 *   Entry registers:
 *     r4  = VRAM pointer table index (selects framebuffer)
 *     r5  = pointer to source data: [width:16][height:16][pixels...]
 *     r6  = destination offset within VRAM buffer
 *     r7  = color bias (added to each source pixel word)
 *
 * sym_06028430 (prologue-only fragment):
 *   Saves callee-saved registers r8-r13. This is the entry point of
 *   a function whose body continues in the next TU (screen_fade_ctrl).
 */

    .section .text.FUN_06028384


    .global screen_flash_effect
    .type screen_flash_effect, @function
screen_flash_effect:
    sts.l pr, @-r15                       ! save return address
    mov.l   .L_pool_vram_ptr_tbl_a, r0    ! r0 = &vram_pointer_table (sym_06028614)
    mov.l @(r0, r4), r2                   ! r2 = vram_pointer_table[index] (ptr to VRAM base ptr)
    mov.l @r2, r2                         ! r2 = *vram_pointer_table[index] (VRAM base address)
    add r2, r5                            ! r5 = dest = VRAM_base + dest_offset
    .byte   0xBF, 0x97    /* bsr 0x060282C0 (external) */
    mov r7, r4                            ! (delay slot) r4 = lookup param for VDP1 cmd function
    mov r0, r1                            ! r1 = source data pointer (returned by VDP1 cmd lookup)
    mov #0x16, r7                         ! r7 = 0x16 = loop end threshold (12 words * 2 bytes - 2)
    mov #0x0, r0                          ! r0 = 0 = byte offset into destination (loop counter)
.copy_loop:
    mov.b @r1+, r3                        ! r3 = next source byte
    add r6, r3                            ! r3 += color_bias (apply flash tint)
    mov.w r3, @(r0, r5)                   ! write color word to dest[offset]
    cmp/eq r7, r0                         ! has offset reached 0x16? (12 words done)
    bf/s    .copy_loop                    ! loop if not finished
    add #0x2, r0                          ! (delay slot) advance dest offset by 2 bytes per word
    lds.l @r15+, pr                       ! restore return address
    rts                                   ! return
    nop                                   ! (delay slot)
    .2byte  0x0000                        /* alignment padding */
.L_pool_vram_ptr_tbl_a:
    .4byte  sym_06028614
    .4byte  0xA003E302
    .4byte  0xA001E306
    .4byte  0xE30ED008
    .4byte  0x024E6222
    .4byte  0x325CE50F
    .4byte  0x61736033
    .4byte  0x21594709
    .4byte  0x316C4709
    .4byte  0x02152338
    .4byte  0x8FF673FE
    .4byte  0x000B0009
    .4byte  sym_06028614

    .global sym_060283E0
sym_060283E0:
/* vram_write_nullterm -- write color-biased words from a null-terminated
 * byte array into VRAM. Stops on first null byte.
 */
    mov.l   .L_pool_vram_ptr_tbl_b, r0   ! r0 = &vram_pointer_table (sym_06028614)
    mov.l @(r0, r4), r2                   ! r2 = vram_pointer_table[index] (ptr to VRAM base ptr)
    mov.l @r2, r2                         ! r2 = *vram_pointer_table[index] (VRAM base address)
    add r5, r2                            ! r2 = dest = VRAM_base + dest_offset
.nullterm_loop:
    mov.b @r7+, r3                        ! r3 = next source byte from array
    tst r3, r3                            ! is it the null terminator?
    bt      .nullterm_done                ! if zero, we are done
    add r6, r3                            ! r3 += color_bias (apply tint)
    mov.w r3, @r2                         ! write color word to dest
    bra     .nullterm_loop                ! loop for next byte
    add #0x2, r2                          ! (delay slot) advance dest pointer by 2 bytes
    .2byte  0x0000                        /* alignment padding */
.L_pool_vram_ptr_tbl_b:
    .4byte  sym_06028614
.nullterm_done:
    rts                                   ! return
    nop                                   ! (delay slot)

    .global sym_06028400
sym_06028400:
/* vram_rect_fill -- copy a width*height block of pixel words into VRAM.
 * Source format: [width:16][height:16][pixel_data...].
 * Each source word gets color_bias (r7) added before writing.
 * Rows are padded to 64-word (128-byte) VRAM stride.
 */
    mov.l   .L_pool_vram_ptr_tbl_c, r0   ! r0 = &vram_pointer_table (sym_06028614)
    mov.l @(r0, r4), r4                   ! r4 = vram_pointer_table[index] (ptr to VRAM base ptr)
    mov.l @r4, r4                         ! r4 = *vram_pointer_table[index] (VRAM base address)
    add r4, r6                            ! r6 = dest = VRAM_base + dest_offset
    mov #-0x80, r4                        ! r4 = -128 (will become row padding stride)
    mov.w @r5+, r3                        ! r3 = width (words per row to copy)
    mov.w @r5+, r2                        ! r2 = height (number of rows)
    add r3, r4                            ! r4 += width (first add)
    add r3, r4                            ! r4 += width (second add; r4 = -128 + 2*width)
    neg r4, r4                            ! r4 = 128 - 2*width = bytes to skip per row
.row_loop:
    mov r3, r1                            ! r1 = width (column counter for this row)
.col_loop:
    mov.w @r5+, r0                        ! r0 = next source pixel word
    add r7, r0                            ! r0 += color_bias (apply tint)
    mov.w r0, @r6                         ! write tinted pixel to dest VRAM
    dt r1                                 ! decrement column counter
    bf/s    .col_loop                     ! loop if columns remain
    add #0x2, r6                          ! (delay slot) advance dest pointer by 2 bytes
    dt r2                                 ! decrement row counter
    bf/s    .row_loop                     ! loop if rows remain
    add r4, r6                            ! (delay slot) skip padding to next VRAM row
    rts                                   ! return
    nop                                   ! (delay slot)
.L_pool_vram_ptr_tbl_c:
    .4byte  sym_06028614

    .global sym_06028430
sym_06028430:
/* Prologue of screen_fade_ctrl â€” saves callee-saved registers.
 * Function body continues in the next TU.
 */
    mov.l r8, @-r15                       ! save r8
    mov.l r9, @-r15                       ! save r9
    mov.l r11, @-r15                      ! save r11
    mov.l r12, @-r15                      ! save r12
    mov.l r13, @-r15                      ! save r13
