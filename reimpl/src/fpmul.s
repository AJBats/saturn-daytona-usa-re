/* fpmul -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06027552 - 0x060276CC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Math utility library:
 *   fpmul(a, b)          — 16.16 fixed-point multiply: (a * b) >> 16
 *   fpdiv_setup(num, den) — 16.16 fixed-point divide via SH-2 hardware divider
 *   memcpy_byte_idx       — byte copy (index-based, forward only)
 *   memcpy_word_idx       — word copy (index-based, forward only)
 *   memcpy_long_idx       — long copy (index-based, forward only)
 *   dma_transfer(dst, src, count) — SCU DMA Level 0 transfer
 */

    .section .text.FUN_06027552
    .space 2    /* align to match original address 0x06027552 (mod 4 = 2) */


    .global fpmul
    .type fpmul, @function
/* fpmul(r4=a, r5=b) -> r0 = (a * b) >> 16
 * 16.16 fixed-point multiply using 32x32->64 hardware multiplier.
 * xtrct extracts middle 32 bits of MACH:MACL = (a*b) >> 16.
 */
fpmul:
    dmuls.l r4, r5              /* signed 32x32->64 multiply */
    sts mach, r4                /* r4 = high 32 bits */
    sts macl, r0                /* r0 = low 32 bits */
    rts
    xtrct r4, r0                /* r0 = (r4<<16)|(r0>>16) = middle 32 bits */

    .global fpdiv_setup
/* fpdiv_setup(r4=numerator, r5=denominator) -> r0 = (num << 16) / den
 * Writes to SH-2 hardware division unit at 0xFFFFFF00.
 * DVSR=den, DVDNTH:DVDNTL = num<<16 (64-bit dividend), result in DVDNT.
 */
fpdiv_setup:
    mov.w   .L_divu_base, r2   /* r2 = 0xFFFFFF00 (SH-2 DIVU base) */
    mov r4, r3
    mov.l r5, @(0, r2)         /* DVSR (0xFFFFFF00) = denominator */
    shlr16 r3
    exts.w r3, r3
    mov.l r3, @(16, r2)        /* DVDNTH (0xFFFFFF10) = num >> 16 (sign-ext) */
    shll16 r4
    mov.l r4, @(20, r2)        /* DVDNTL (0xFFFFFF14) = num << 16, triggers div */
    rts
    mov.l @(28, r2), r0        /* r0 = quotient from DVDNT (0xFFFFFF1C) */
.L_divu_base:
    .2byte  0xFF00              /* sign-extends to 0xFFFFFF00 = SH-2 DIVU base */
    .2byte  0x0000
    .4byte  0x3540890C
    .4byte  0xE7003670
    .4byte  0x89093546
    .4byte  0x8909356C
    .4byte  0x346C75FF
    .4byte  0x67504610
    .4byte  0x24748FFB
    .4byte  0x75FF000B
    .4byte  0x00096754
    .4byte  0x46102470
    .4byte  0x8FFB7401
    .4byte  0x000B0009
    .4byte  0x3540890E
    .4byte  0xE7003670
    .4byte  0x890B6763
    .4byte  0x35468D0A
    .4byte  0x4601357C
    .4byte  0x347C75FC
    .4byte  0x67514610
    .4byte  0x24758FFB
    .4byte  0x75FE000B
    .4byte  0x00096755
    .4byte  0x46102471
    .4byte  0x8FFB7402
    .4byte  0x000B0009
    .4byte  0x3540890E
    .4byte  0xE7003670
    .4byte  0x890B6763
    .4byte  0x35468D0A
    .4byte  0x4609357C
    .4byte  0x347C75FC
    .4byte  0x67524610
    .4byte  0x24768FFB
    .4byte  0x75FC000B
    .4byte  0x00096756
    .4byte  0x46102472
    .4byte  0x8FFB7404
    .4byte  0x000B0009

    .global memcpy_byte_idx
/* memcpy_byte_idx(r4=dst, r5=src, r6=count) — byte copy, forward, index-based */
memcpy_byte_idx:
    mov #0x0, r0                /* r0 = index */
    add #-0x1, r6              /* r6 = count - 1 (loop bound) */
.L_06027610:
    mov.b @(r0, r5), r1        /* r1 = src[i] */
    cmp/gt r0, r6
    mov.b r1, @(r0, r4)        /* dst[i] = r1 */
    bt/s    .L_06027610
    add #0x1, r0
    rts
    add #0x1, r6

    .global memcpy_word_idx
/* memcpy_word_idx(r4=dst, r5=src, r6=byte_count) — word copy, forward */
memcpy_word_idx:
    mov #0x0, r0
    add #-0x2, r6
.L_06027622:
    mov.w @(r0, r5), r1
    cmp/gt r0, r6
    mov.w r1, @(r0, r4)
    bt/s    .L_06027622
    add #0x2, r0
    rts
    add #0x2, r6

    .global memcpy_long_idx
/* memcpy_long_idx(r4=dst, r5=src, r6=byte_count) — long copy, forward */
memcpy_long_idx:
    mov #0x0, r0
    add #-0x4, r6
.L_06027634:
    mov.l @(r0, r5), r1
    cmp/gt r0, r6
    mov.l r1, @(r0, r4)
    bt/s    .L_06027634
    add #0x4, r0
    rts
    add #0x4, r6
    .2byte  0x6056
    .4byte  0x61566256
    .4byte  0x63561400
    .4byte  0x14111422
    .4byte  0x14336056
    .4byte  0x61566256
    .4byte  0x63561404
    .4byte  0x14151426
    .4byte  0x14374610
    .4byte  0x8FED7420
    .4byte  0x000B0009

    .global dma_transfer
/* dma_transfer(r4=dst, r5=src, r6=byte_count) — SCU DMA Level 0 transfer
 * Polls DSTA until DMA is idle, then programs Level 0 for immediate transfer.
 */
dma_transfer:
    mov.l   .L_scu_dsta, r0
    mov.l @r0, r0               /* read SCU DSTA (DMA status) */
    mov.l   .L_dma_busy_mask, r1
    tst r1, r0                  /* any DMA channel active? */
    bf      dma_transfer         /* spin until idle */
    mov.l   .L_scu_dma_l0, r1   /* r1 = 0x25FE0000 (Level 0 base) */
    mov.w   .L_dma_addr_inc, r2
    mov.l r4, @(4, r1)         /* D0W = dst (write address) */
    mov.l r5, @(0, r1)         /* D0R = src (read address) */
    mov.l r6, @(8, r1)         /* D0C = byte count */
    mov.l r2, @(12, r1)        /* D0AD = 0x0101 (read+4, write+4) */
    mov #0x7, r0
    mov.l r0, @(20, r1)        /* D0MD = 7 (direct, immediate start) */
    rts
    mov.l r2, @(16, r1)        /* D0EN = 0x0101 (enable + go) */
.L_dma_addr_inc:
    .2byte  0x0101              /* DMA address increment: src+4, dst+4 */
.L_scu_dsta:
    .4byte  0x25FE007C          /* SCU DSTA — DMA status register */
.L_dma_busy_mask:
    .4byte  0x0000272E          /* DMA busy check mask (L0+L1+L2 operating bits) */
.L_scu_dma_l0:
    .4byte  0x25FE0000          /* SCU DMA Level 0 register base */
    .4byte  0x00090000
    .4byte  0x91109014
    .4byte  0x52421104
    .4byte  0x1120E000
    .4byte  0x11055041
    .4byte  0x6242600B
    .4byte  0x5417342D
    .4byte  0x020A340D
    .4byte  0x2521000A
    .4byte  0x000B8151
    .4byte  0xFF000009
    .4byte  0x00010000
    .4byte  0xFF0000A0
