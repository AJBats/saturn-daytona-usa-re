/* scene_render_body -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600C010 - 0x0600C170
 *
 * Master Scene Rendering Orchestrator (body)
 * -------------------------------------------
 * The prologue (scene_master, 0x0600BFFC) pushes r14-r8 and sets up:
 *   r11 = 1 (LOD minimum threshold)
 *   r14 = 0x80 (bit 7 mask for hardware polling)
 * ...then falls through to this body function.
 *
 * This function coordinates the primary SH-2's per-frame scene rendering:
 *   1. Optionally dispatches secondary SH-2 work (vblank_handler)
 *   2. Conditional render dispatch based on game state bitmask:
 *      - If bit 25 (0x02000000) is SET: skip physics/render dispatch
 *      - Else if *render_mode_flag != 0: call render path A (sym_0600D336)
 *      - Else: call physics_calc_dispatch (render path B)
 *   3. Special state-17 rendering: if bitmask == 0x00020000 exactly
 *      and *state17_guard == 0, call sym_0602E610
 *   4. Allocate 48 bytes to render budget (*render_budget_ctr += 48)
 *   5. Copy render data via memcpy_long_idx
 *   6. Set object iteration count at *obj_iter_count:
 *      - If *obj_count_mode == 0: count = *total_obj_count >> 1
 *      - Else: count = LOD config byte from *lod_config_ptr
 *   7. CRITICAL: Store FUN_0600C170 -> *secondary_callback_ptr
 *      (this is the secondary SH-2 callback that the secondary reads
 *       via its main loop at FUN_06034F08)
 *   8. Write 0xFFFF -> 0x21000000 (MINIT - triggers secondary SH-2 interrupt)
 *   9. If state bits 3+19+25 are all clear: call per-frame update (FUN_060058FA)
 *  10. Call scene_post_render (scene grid rendering dispatch)
 *  11. BSR to CS0 object rendering loop (0x0600B6A0)
 *  12. If bitmask != state 25: call post-render dispatch (FUN_0601BDEC)
 *  13. Hardware polling: loop until bit 7 of *hw_status_byte is set (secondary done),
 *      then clear upper 4 bits to acknowledge
 *  14. LOD config adjustment: increment if budget available, decrement if exceeded
 *  15. Call render finalize (sym_0603C000)
 *  16. Deallocate 48 bytes from render budget (*render_budget_ctr -= 48)
 *
 * Register plan (set by prologue, persistent across body):
 *   r8  = &game_state_flags (sym_0607EBC4)
 *   r9  = LOD adjustment flag (0 = decrement path, nonzero = increment path)
 *   r10 = hw_status_byte ptr low bits (loaded as 0xFE11, used as byte ptr)
 *   r11 = 1 (LOD minimum, set by prologue)
 *   r12 = &render_budget_ctr (sym_0608A52C)
 *   r13 = &lod_config_byte (sym_0605A1DD)
 *   r14 = 0x80 (bit 7 mask, set by prologue)
 *
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0600C010


    .global scene_render_body
    .type scene_render_body, @function
scene_render_body:
    sts.l pr, @-r15                     ! save return address (PR) to stack
    mov.l   .L_pool_game_state_flags, r8 ! r8 = &game_state_flags (sym_0607EBC4)
    mov.w   .L_wpool_hw_status_mask, r10 ! r10 = 0xFE11 (hardware status address fragment)
    mov.l   .L_pool_render_budget_ctr, r12 ! r12 = &render_budget_ctr (sym_0608A52C)
    mov.l   .L_pool_lod_config_byte, r13 ! r13 = &lod_config_byte (sym_0605A1DD)
    mov.l   .L_pool_secondary_proc_flag, r0 ! r0 = &secondary_proc_flag (sym_06083255)
    mov.b @r0, r0                       ! r0 = *secondary_proc_flag (byte: 0 = no secondary work)
    tst r0, r0                          ! is secondary processing flag zero?
    bt/s    .L_skip_secondary_init      ! if zero, skip secondary SH-2 dispatch
    mov #0x0, r9                        ! (delay slot) r9 = 0 (LOD adjustment flag: decrement path)
    mov.l   .L_pool_secondary_arg_ptr, r4 ! r4 = &secondary_arg (sym_0607EB8C)
    mov.l   .L_pool_fn_vblank_handler, r3 ! r3 = vblank_handler (secondary dispatch function)
    jsr @r3                             ! call vblank_handler(*secondary_arg) -- dispatch secondary work
    mov.l @r4, r4                       ! (delay slot) r4 = *secondary_arg (dereference arg pointer)
.L_skip_secondary_init:
    mov.l @r8, r2                       ! r2 = *game_state_flags (current state bitmask)
    mov.l   .L_pool_state25_bit, r3     ! r3 = 0x02000000 (state 25 bitmask)
    and r3, r2                          ! r2 = flags & 0x02000000 (isolate state 25 bit)
    tst r2, r2                          ! is state 25 active?
    bf      .L_past_render_dispatch     ! if state 25 is set, skip render dispatch entirely
    mov.l   .L_pool_render_mode_flag, r0 ! r0 = &render_mode_flag (sym_06078635)
    mov.b @r0, r0                       ! r0 = *render_mode_flag (byte)
    extu.b r0, r0                       ! zero-extend byte to long
    tst r0, r0                          ! is render mode flag zero?
    bt      .L_render_path_b            ! if zero, take render path B (physics_calc_dispatch)
    mov.l   .L_pool_fn_render_path_a, r3 ! r3 = sym_0600D336 (render path A)
    jsr @r3                             ! call render path A
    nop                                 ! delay slot
    bra     .L_past_render_dispatch     ! skip render path B
    nop                                 ! delay slot
.L_render_path_b:
    mov.l   .L_pool_fn_physics_dispatch, r3 ! r3 = physics_calc_dispatch (render path B)
    jsr @r3                             ! call physics_calc_dispatch (render path B)
    nop                                 ! delay slot
.L_past_render_dispatch:
    mov.l @r8, r2                       ! r2 = *game_state_flags (reload bitmask)
    mov.l   .L_pool_state17_exact, r3   ! r3 = 0x00020000 (state 17 bitmask)
    cmp/eq r3, r2                       ! is bitmask EXACTLY state 17?
    bf      .L_past_state17_render      ! if not exactly state 17, skip special render
    mov.l   .L_pool_state17_guard, r0   ! r0 = &state17_guard (sym_0607EAE0)
    mov.l @r0, r0                       ! r0 = *state17_guard
    tst r0, r0                          ! is guard value zero?
    bf      .L_past_state17_render      ! if guard is non-zero, skip special render
    mov.l   .L_pool_fn_state17_render, r3 ! r3 = sym_0602E610 (state 17 special render)
    jsr @r3                             ! call state 17 special rendering function
    nop                                 ! delay slot
.L_past_state17_render:
    mov #0x30, r6                       ! r6 = 48 (budget allocation size in bytes)
    mov.l @r12, r2                      ! r2 = *render_budget_ctr (current budget offset)
    add #0x30, r2                       ! r2 += 48 (advance budget pointer)
    mov.l r2, @r12                      ! *render_budget_ctr = r2 (commit allocation)
    mov.l   .L_pool_render_src_data, r5 ! r5 = &render_src_data (sym_06089EDC)
    mov.l   .L_pool_fn_memcpy_long_idx, r3 ! r3 = memcpy_long_idx (indexed long copy)
    mov.l @r5, r5                       ! r5 = *render_src_data (source address)
    jsr @r3                             ! call memcpy_long_idx(dst=r4, src=r5, len=r6=48)
    mov r2, r4                          ! (delay slot) r4 = budget pointer (destination)
    mov.l   .L_pool_obj_iter_count, r4  ! r4 = &obj_iter_count (sym_06078664, halfword target)
    mov.l   .L_pool_obj_count_mode, r0  ! r0 = &obj_count_mode (sym_06059F30)
    mov.l @r0, r0                       ! r0 = *obj_count_mode (0 = compute from total, else use config)
    tst r0, r0                          ! is obj_count_mode zero?
    bf      .L_use_lod_config_count     ! if non-zero, use LOD config byte as iteration count
    mov.l   .L_pool_total_obj_count, r3 ! r3 = &total_obj_count (sym_0607EA98)
    mov.l @r3, r3                       ! r3 = *total_obj_count (total renderable objects)
    shar r3                             ! r3 >>= 1 (arithmetic: half the objects)
    exts.w r3, r3                       ! sign-extend halfword (clamp to 16-bit range)
    mov.w r3, @r4                       ! *obj_iter_count = total_objects / 2
    bra     .L_set_secondary_callback   ! jump to set secondary callback
    nop                                 ! delay slot
.L_wpool_hw_status_mask:
    .2byte  0xFE11                      /* hardware status address mask fragment */
    .2byte  0xFFFF                      /* padding / alignment */
.L_pool_game_state_flags:
    .4byte  sym_0607EBC4                /* game state bitmask (read by @r8) */
.L_pool_render_budget_ctr:
    .4byte  sym_0608A52C                /* render budget counter (frame alloc tracking) */
.L_pool_lod_config_byte:
    .4byte  sym_0605A1DD                /* LOD config byte (object detail level) */
.L_pool_secondary_proc_flag:
    .4byte  sym_06083255                /* secondary SH-2 processing flag (byte) */
.L_pool_secondary_arg_ptr:
    .4byte  sym_0607EB8C                /* argument pointer for secondary dispatch */
.L_pool_fn_vblank_handler:
    .4byte  vblank_handler              /* per-frame update / secondary dispatch */
.L_pool_state25_bit:
    .4byte  0x02000000                  /* state 25 bitmask (bit 25) */
.L_pool_render_mode_flag:
    .4byte  sym_06078635                /* render mode flag (byte: 0=path B, else=path A) */
.L_pool_fn_render_path_a:
    .4byte  sym_0600D336                /* render path A function */
.L_pool_fn_physics_dispatch:
    .4byte  physics_calc_dispatch       /* render path B / physics calc dispatch */
.L_pool_state17_exact:
    .4byte  0x00020000                  /* state 17 bitmask (0x20000) â€” 2.0 in 16.16 fixed-point */
.L_pool_state17_guard:
    .4byte  sym_0607EAE0                /* state 17 guard (long: 0 = allow special render) */
.L_pool_fn_state17_render:
    .4byte  sym_0602E610                /* state 17 special rendering function */
.L_pool_render_src_data:
    .4byte  sym_06089EDC                /* source data for render budget copy */
.L_pool_fn_memcpy_long_idx:
    .4byte  memcpy_long_idx             /* indexed long memory copy function */
.L_pool_obj_iter_count:
    .4byte  sym_06078664                /* object iteration count target (halfword) */
.L_pool_obj_count_mode:
    .4byte  sym_06059F30                /* object count mode (0=compute, else=use config) */
.L_pool_total_obj_count:
    .4byte  sym_0607EA98                /* total renderable object count */
.L_use_lod_config_count:
    mov.b @r13, r2                      ! r2 = *lod_config_byte (current LOD detail level)
    extu.b r2, r2                       ! zero-extend byte to long
    mov.w r2, @r4                       ! *obj_iter_count = LOD config value (use config directly)
.L_set_secondary_callback:
    .byte   0xD3, 0x29    /* mov.l .L_pool_secondary_callback_fn, r3 -- r3 = FUN_0600C170 (secondary rendering callback) */
    .byte   0xD2, 0x29    /* mov.l .L_pool_secondary_callback_ptr, r2 -- r2 = &secondary_callback_ptr (sym_06063574) */
    mov.l r3, @r2                       ! *secondary_callback_ptr = FUN_0600C170 (SET SECONDARY CALLBACK)
    .byte   0xD3, 0x29    /* mov.l .L_pool_minit_value, r3 -- r3 = 0x0000FFFF (MINIT trigger value) */
    .byte   0xD2, 0x2A    /* mov.l .L_pool_minit_register, r2 -- r2 = 0x21000000 (VDP/MINIT hardware register) */
    mov.w r3, @r2                       ! write 0xFFFF -> 0x21000000 (trigger MINIT: wake secondary SH-2)
    mov.l @r8, r3                       ! r3 = *game_state_flags (reload bitmask)
    .byte   0xD2, 0x29    /* mov.l .L_pool_skip_update_mask, r2 -- r2 = 0x02800008 (states 3+19+25 combined mask) */
    and r2, r3                          ! r3 = flags & 0x02800008 (test skip-update states)
    tst r3, r3                          ! are any skip-update state bits set?
    bf      .L_skip_per_frame_update    ! if any set, skip per-frame update chain
    .byte   0xD3, 0x28    /* mov.l .L_pool_fn_per_frame_update, r3 -- r3 = FUN_060058FA (per-frame update) */
    jsr @r3                             ! call per-frame update chain
    nop                                 ! delay slot
.L_skip_per_frame_update:
    .byte   0xD3, 0x28    /* mov.l .L_pool_fn_scene_post_render, r3 -- r3 = scene_post_render (FUN_06006868) */
    jsr @r3                             ! call scene_post_render (scene grid rendering dispatch)
    nop                                 ! delay slot
    .byte   0xBA, 0xCC    /* bsr 0x0600B6A0 (external) -- call CS0 object rendering loop */
    nop                                 ! delay slot
    mov.l @r8, r2                       ! r2 = *game_state_flags (reload bitmask)
    .byte   0xD3, 0x26    /* mov.l .L_pool_state25_bit_b, r3 -- r3 = 0x02000000 (state 25) */
    cmp/eq r3, r2                       ! is bitmask exactly state 25?
    bt      .L_begin_hw_poll            ! if exactly state 25, skip post-render dispatch
    .byte   0xD3, 0x25    /* mov.l .L_pool_fn_post_render_dispatch, r3 -- r3 = FUN_0601BDEC (post-render) */
    jsr @r3                             ! call post-render dispatch (additional render pass)
    nop                                 ! delay slot
    bra     .L_begin_hw_poll            ! jump past LOD-increment flag setter
    nop                                 ! delay slot
.L_set_lod_increment:
    mov r11, r9                         ! r9 = r11 = 1 (flag: LOD increment path after poll)
.L_begin_hw_poll:
    mov.b @r10, r2                      ! r2 = *hw_status_byte (read hardware status)
    extu.b r2, r2                       ! zero-extend byte to long
    and r14, r2                         ! r2 = status & 0x80 (isolate bit 7: busy flag)
    cmp/eq r14, r2                      ! is bit 7 set? (secondary SH-2 done signal?)
    bf      .L_set_lod_increment        ! if bit 7 NOT set, set increment flag and re-poll
    mov.b @r10, r0                      ! r0 = *hw_status_byte (re-read for cleanup)
    and #0xF, r0                        ! r0 &= 0x0F (clear upper 4 bits: reset busy flags)
    mov.b r0, @r10                      ! *hw_status_byte = cleaned value (acknowledge hardware)
    tst r9, r9                          ! is LOD adjustment flag zero? (0 = decrement, 1 = increment)
    bt      .L_lod_decrement_path       ! if zero, try to decrement LOD config
    mov.b @r13, r3                      ! r3 = *lod_config_byte (current LOD level)
    .byte   0xD2, 0x1E    /* mov.l .L_pool_total_obj_count_b, r2 -- r2 = &total_obj_count (sym_0607EA98) */
    extu.b r3, r3                       ! zero-extend LOD config byte
    mov.l @r2, r2                       ! r2 = *total_obj_count (maximum LOD value)
    cmp/ge r2, r3                       ! is config >= total? (already at maximum?)
    bt      .L_lod_adjustment_done      ! if at max, skip increment
    mov.b @r13, r2                      ! r2 = *lod_config_byte (reload for increment)
    add #0x1, r2                        ! r2++ (increment LOD detail level)
    bra     .L_lod_adjustment_done      ! jump to done
    mov.b r2, @r13                      ! (delay slot) *lod_config_byte = incremented value
.L_lod_decrement_path:
    mov.b @r13, r2                      ! r2 = *lod_config_byte (current LOD level)
    extu.b r2, r2                       ! zero-extend byte to long
    cmp/gt r11, r2                      ! is config > 1? (above minimum threshold?)
    bf      .L_lod_adjustment_done      ! if config <= 1, don't decrement (already at minimum)
    mov.b @r13, r2                      ! r2 = *lod_config_byte (reload for decrement)
    add #-0x1, r2                       ! r2-- (decrement LOD detail level)
    mov.b r2, @r13                      ! *lod_config_byte = decremented value
.L_lod_adjustment_done:
    .byte   0xD3, 0x17    /* mov.l .L_pool_fn_render_finalize, r3 -- r3 = sym_0603C000 (render finalize) */
    jsr @r3                             ! call render finalize (flush render state)
    nop                                 ! delay slot
    mov.l @r12, r2                      ! r2 = *render_budget_ctr (current budget offset)
    add #-0x30, r2                      ! r2 -= 48 (deallocate budget reserved earlier)
    mov.l r2, @r12                      ! *render_budget_ctr = r2 (commit deallocation)
    lds.l @r15+, pr                     ! restore return address (PR) from stack
    mov.l @r15+, r8                     ! restore r8 (game_state_flags ptr)
    mov.l @r15+, r9                     ! restore r9 (LOD adjustment flag)
    mov.l @r15+, r10                    ! restore r10 (hw_status address)
    mov.l @r15+, r11                    ! restore r11 (LOD minimum threshold)
    mov.l @r15+, r12                    ! restore r12 (render_budget_ctr ptr)
    mov.l @r15+, r13                    ! restore r13 (lod_config_byte ptr)
    rts                                 ! return to caller (scene_master epilogue)
    mov.l @r15+, r14                    ! (delay slot) restore r14 (bit 7 poll mask)
