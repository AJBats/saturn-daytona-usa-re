/* mat_rot_z -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06026F2A - 0x06026FFC
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06026F2A


    .global mat_rot_z
    .type mat_rot_z, @function
mat_rot_z:
    sts.l pr, @-r15                       ! save return address
    .byte   0xD6, 0x50    /* mov.l .L_pool_06027070, r6 — rotation buffer (0x0608A4E0) */
    mov #0x8, r5                          ! r5 = offset 8 (sin slot)
    .byte   0xB2, 0x12    /* bsr 0x06027358 — sincos_lookup(r4=angle) */
    add r6, r5                            ! r5 = &buf[2] (sin dest), r6 = &buf[0] (cos dest) [delay slot]
    lds.l @r15+, pr                       ! restore return address
    mov.l @r5, r1                         ! r1 = sin(angle)
    mov.l @r6, r2                         ! r2 = cos(angle)
    neg r1, r1                            ! r1 = -sin(angle)
    mov.l r1, @(4, r6)                    ! buf[1] = -sin
    .byte   0xD0, 0x4A    /* mov.l .L_pool_06027068, r0 — matrix stack A ptr (0x06089EDC) */
    mov.l r2, @(12, r6)                   ! buf[3] = cos  — rotation 2x2: [cos, -sin, sin, cos]
    mov.l @r0, r4                         ! r4 = current matrix base
    mov #0x3, r3                          ! r3 = 3 rows to process
.L_rot_z_row_loop:
    mov r4, r5                            ! r5 = matrix row ptr (col 0)
    mov r6, r7                            ! r7 = rotation buffer ptr
    clrmac                                ! clear MAC for dot product: new col0
    mac.l @r7+, @r5+                      ! acc += buf[0] * mat[row][0]  (cos * col0)
    mac.l @r7+, @r5+                      ! acc += buf[1] * mat[row][1]  (-sin * col1)
    mov r4, r5                            ! reset r5 to col 0 for second dot product
    sts mach, r0                          ! r0 = MAC high
    sts macl, r1                          ! r1 = MAC low
    xtrct r0, r1                          ! r1 = fixed-point result (new col0 value)
    clrmac                                ! clear MAC for dot product: new col1
    mac.l @r7+, @r5+                      ! acc += buf[2] * mat[row][0]  (sin * col0)
    mac.l @r7+, @r5+                      ! acc += buf[3] * mat[row][1]  (cos * col1)
    mov.l r1, @(0, r4)                    ! store new col0 for this row
    dt r3                                 ! decrement row counter
    sts mach, r0                          ! r0 = MAC high
    sts macl, r2                          ! r2 = MAC low
    xtrct r0, r2                          ! r2 = fixed-point result (new col1 value)
    mov.l r2, @(4, r4)                    ! store new col1 for this row
    bf/s    .L_rot_z_row_loop             ! loop until all 3 rows processed
    add #0xC, r4                          ! advance to next row (+12 bytes) [delay slot]
    rts                                   ! return
    nop                                   ! [delay slot]

    .global sym_06026F72
sym_06026F72:
    ! Full 3x3 matrix multiply: M_current = M_current * M_input
    ! r4 = input matrix ptr (3x3 + translation = 48 bytes)
    ! Uses temp buffer at 0x0608A4F0 to build result
    .byte   0xD0, 0x3D    /* mov.l .L_pool_06027068, r0 — matrix stack A ptr (0x06089EDC) */
    .byte   0xD6, 0x3F    /* mov.l .L_pool_06027074, r6 — temp buffer (0x0608A4F0) */
    mov.l @r0, r5                         ! r5 = current matrix base
    mov #0x3, r3                          ! r3 = 3 columns (outer loop)
    ! Phase 1: Transpose multiply — result[r][c] = dot(M_row[r], input_col[c])
.L_fullmul_col_loop:
    mov #0x3, r2                          ! r2 = 3 rows (inner loop)
.L_fullmul_row_loop:
    clrmac                                ! clear MAC for dot product
    mac.l @r4+, @r5+                      ! acc += input[c][0] * M[r][0]
    add #0x8, r4                          ! skip to next column element (+12 total stride)
    mac.l @r4+, @r5+                      ! acc += input[c][1] * M[r][1]
    add #0x8, r4                          ! skip to next column element
    dt r2                                 ! decrement row counter
    mac.l @r4+, @r5+                      ! acc += input[c][2] * M[r][2]
    add #-0x18, r4                        ! reset input ptr to column start (-24)
    add #-0xC, r5                         ! reset matrix row ptr (-12)
    sts mach, r0                          ! r0 = MAC high
    sts macl, r1                          ! r1 = MAC low
    xtrct r0, r1                          ! r1 = fixed-point dot product result
    mov.l r1, @r6                         ! store result element to temp buffer
    bf/s    .L_fullmul_row_loop           ! loop for all 3 rows of this column
    add #0x4, r6                          ! advance temp buffer write ptr [delay slot]
    add #-0xC, r4                         ! back to start of input column (-12)
    dt r3                                 ! decrement column counter
    bf/s    .L_fullmul_col_loop           ! loop for all 3 columns
    add #0xC, r5                          ! advance matrix to next row [delay slot]
    ! Phase 2: Translation update — new_trans[i] = dot(input_trans, M_row[i]) + old_trans[i]
    mov r5, r7                            ! r7 = M translation ptr (row 3 = offset +36)
    add #-0x24, r5                        ! r5 = back to matrix start (-36)
    add #0x24, r4                         ! r4 = input translation ptr (+36)
    mov #0x3, r3                          ! r3 = 3 components
.L_trans_update_loop:
    clrmac                                ! clear MAC for translation dot product
    mac.l @r4+, @r5+                      ! acc += input_trans[0] * M[row][0]
    mac.l @r4+, @r5+                      ! acc += input_trans[1] * M[row][1]
    dt r3                                 ! decrement component counter
    mac.l @r4+, @r5+                      ! acc += input_trans[2] * M[row][2]
    add #-0xC, r4                         ! reset input translation ptr
    sts mach, r0                          ! r0 = MAC high
    sts macl, r1                          ! r1 = MAC low
    xtrct r0, r1                          ! r1 = fixed-point dot product
    mov.l @r7+, r0                        ! r0 = old translation component
    add r0, r1                            ! r1 = new_trans = dot + old_trans
    mov.l r1, @r6                         ! store to temp buffer
    bf/s    .L_trans_update_loop          ! loop for all 3 translation components
    add #0x4, r6                          ! advance temp buffer write ptr [delay slot]
    ! Phase 3: Copy 48 bytes from temp buffer back to matrix — unrolled in 6-word chunks
    add #-0x30, r6                        ! r6 = temp buffer start (-48)
    add #-0x30, r7                        ! r7 = matrix translation start - 48 = matrix base
    mov.l @(0, r6), r0                    ! load temp[0]
    mov.l @(4, r6), r1                    ! load temp[1]
    mov.l @(8, r6), r2                    ! load temp[2]
    mov.l @(12, r6), r3                   ! load temp[3]
    mov.l @(16, r6), r4                   ! load temp[4]
    mov.l @(20, r6), r5                   ! load temp[5]
    mov.l r0, @(0, r7)                    ! store mat[0]
    mov.l r1, @(4, r7)                    ! store mat[1]
    mov.l r2, @(8, r7)                    ! store mat[2]
    mov.l r3, @(12, r7)                   ! store mat[3]
    mov.l r4, @(16, r7)                   ! store mat[4]
    mov.l r5, @(20, r7)                   ! store mat[5]
    mov.l @(24, r6), r0                   ! load temp[6]
    mov.l @(28, r6), r1                   ! load temp[7]
    mov.l @(32, r6), r2                   ! load temp[8]
    mov.l @(36, r6), r3                   ! load temp[9] (translation X)
    mov.l @(40, r6), r4                   ! load temp[10] (translation Y)
    mov.l @(44, r6), r5                   ! load temp[11] (translation Z)
    mov.l r0, @(24, r7)                   ! store mat[6]
    mov.l r1, @(28, r7)                   ! store mat[7]
    mov.l r2, @(32, r7)                   ! store mat[8]
    mov.l r3, @(36, r7)                   ! store mat[9] (translation X)
    mov.l r4, @(40, r7)                   ! store mat[10] (translation Y)
    rts                                   ! return
    mov.l r5, @(44, r7)                   ! store mat[11] (translation Z) [delay slot]
