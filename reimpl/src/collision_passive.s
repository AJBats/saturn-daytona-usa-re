/* collision_passive -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600D12C - 0x0600D31C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * This TU contains three functions:
 *
 * 1. collision_passive (FUN_0600D12C) — Passive Collision Response
 *    Checks separation distance between two cars in a combined X+Z
 *    diagonal metric. If the cars are close enough (below thresholds),
 *    falls through to the aggressive push handler. If they are far
 *    enough apart, returns immediately (no collision response needed).
 *
 *    Called from the collision response dispatcher (FUN_0600CF58) when
 *    a head-on or default collision is detected. r4 = collision partner
 *    car struct, r5 = current car struct (loaded from sym_0607E940).
 *
 *    Car struct offsets used:
 *      +0x10: X position (32-bit fixed-point)
 *      +0x18: Z position / bump offset (32-bit fixed-point)
 *      +0x0118: collision partner A pointer (or null)
 *      +0x0234: collision partner B pointer (or null)
 *
 * 2. [byte-encoded] Aggressive Collision Response (FUN_0600D1A4/D210)
 *    Speed-based push: compares speed fields of two colliding cars,
 *    applies a +/-16 push to the force field, clamps to [0, 0x0800],
 *    and sets a 64-frame collision timer. This is the fall-through
 *    target when collision_passive detects cars are too close.
 *    There are two copies — one reached from collision_passive's
 *    fall-through (0x0600D1A4) and one standalone (0x0600D210).
 *
 * 3. friction_stub (FUN_0600D266) — Unused stub, returns immediately.
 *
 * 4. sym_0600D280 — Car Pointer List Initialization
 *    Called once during car array init (from FUN_0600629C). Builds two
 *    sorted pointer arrays (car_ptr_list_a at sym_0607E94C, car_ptr_list_b
 *    at sym_0607E9EC) mapping car indices to car struct addresses. Also
 *    clears three words at sym_0607EA8C. Used by the race update loop
 *    to iterate cars by sorted position rather than array index.
 */

    .section .text.FUN_0600D12C


    .global collision_passive
    .type collision_passive, @function
collision_passive:
    mov.l r14, @-r15                    ! save r14 (will use as scratch)
    mov.l   .L_pool_cur_car_ptr, r5     ! r5 = &current_car_ptr (sym_0607E940)
    mov.w   DAT_0600d192, r0            ! r0 = 0x0118 (offset: collision partner A)
    mov.l   .L_pool_separation_thresh, r6 ! r6 = 0x000F0000 (diagonal separation threshold, 15.0 in 16.16 fixed-point)
    mov.l @r5, r5                       ! r5 = *cur_car_ptr = self car struct
    mov.l @(r0, r5), r4                 ! r4 = self_car[+0x118] = collision partner A
    mov.w   .L_wpool_partner_b_offset, r0 ! r0 = 0x0234 (offset: collision partner B)
    mov.l @(r0, r5), r14                ! r14 = self_car[+0x234] = collision partner B (or null)
    tst r14, r14                        ! is partner B null?
    bt      .L_no_partner_b             ! yes -> skip partner B distance check
    ! --- Partner B exists: check diagonal distance to partner B ---
    mov.l @(16, r14), r7               ! r7 = partner_B.x_pos (car[+0x10])
    mov.l @(16, r5), r3                ! r3 = self.x_pos (car[+0x10])
    mov.l @(24, r14), r2               ! r2 = partner_B.z_offset (car[+0x18])
    sub r3, r7                          ! r7 = partner_B.x - self.x
    add r2, r7                          ! r7 += partner_B.z_offset
    mov.l @(24, r5), r3                ! r3 = self.z_offset (car[+0x18])
    mov.l   .L_pool_close_thresh, r2   ! r2 = 0x00080000 (close proximity threshold, 8.0 in 16.16)
    sub r3, r7                          ! r7 = diagonal_dist = (B.x - self.x) + (B.z - self.z)
    cmp/ge r2, r7                       ! diagonal_dist >= 8.0?
    bt      .L_partner_b_far_enough     ! yes -> partner B is far enough, check partner A
    ! Partner B is too close — use partner B as collision target
    mov r14, r4                         ! r4 = partner B (override partner A)
    bra     .L_apply_push               ! fall through to aggressive push handler
    mov.l @r15+, r14                    ! (delay slot) restore r14
.L_partner_b_far_enough:
    ! --- Check diagonal distance to partner A ---
    mov.l @(16, r4), r2                ! r2 = partner_A.x_pos
    mov.l @(16, r5), r3                ! r3 = self.x_pos
    mov.l @(24, r4), r1                ! r1 = partner_A.z_offset
    sub r3, r2                          ! r2 = partner_A.x - self.x
    add r1, r2                          ! r2 += partner_A.z_offset
    mov.l @(24, r5), r3                ! r3 = self.z_offset
    mov r2, r5                          ! r5 = partial diagonal distance
    sub r3, r5                          ! r5 = full diagonal = (A.x - self.x) + (A.z - self.z)
    cmp/ge r6, r5                       ! diagonal >= 15.0 (separation threshold)?
    bt      .L_cars_separated           ! yes -> cars are separated, no push needed
    bra     .L_apply_push               ! no -> too close, apply aggressive push
    mov.l @r15+, r14                    ! (delay slot) restore r14
.L_cars_separated:
    bra     .L_return_no_push           ! cars far enough apart — return with no action
    nop
.L_no_partner_b:
    ! --- No partner B: check diagonal distance to partner A only ---
    mov.l @(16, r4), r2                ! r2 = partner_A.x_pos
    mov.l @(16, r5), r3                ! r3 = self.x_pos
    mov.l @(24, r4), r1                ! r1 = partner_A.z_offset
    sub r3, r2                          ! r2 = partner_A.x - self.x
    add r1, r2                          ! r2 += partner_A.z_offset
    mov.l @(24, r5), r3                ! r3 = self.z_offset
    mov r2, r5                          ! r5 = partial diagonal distance
    sub r3, r5                          ! r5 = full diagonal = (A.x - self.x) + (A.z - self.z)
    cmp/ge r6, r5                       ! diagonal >= 15.0 (separation threshold)?
    bt      .L_return_no_push           ! yes -> separated, no push needed
    bra     .L_apply_push               ! no -> too close, apply aggressive push
    mov.l @r15+, r14                    ! (delay slot) restore r14
.L_return_no_push:
    rts                                 ! return — cars are separated, no collision response
    mov.l @r15+, r14                    ! (delay slot) restore r14

    .global DAT_0600d192
DAT_0600d192:
    .2byte  0x0118                      /* car struct offset: collision partner A pointer */
.L_wpool_partner_b_offset:
    .2byte  0x0234                      /* car struct offset: collision partner B pointer */
    .2byte  0xFFFF                      /* alignment padding */
.L_pool_cur_car_ptr:
    .4byte  sym_0607E940                /* &current_car_ptr — points to active car struct */
.L_pool_separation_thresh:
    .4byte  0x000F0000                  /* 15.0 in 16.16 fixed-point — diagonal separation threshold */
.L_pool_close_thresh:
    .4byte  0x00080000                  /* 8.0 in 16.16 fixed-point — close proximity threshold */
.L_apply_push:
    ! =====================================================================
    ! Aggressive Collision Response (fall-through from collision_passive)
    ! Byte-encoded FUN_0600D1A4 — speed-based push with clamping.
    ! r4 = collision partner, r6 = self car (loaded fresh from pool).
    ! Compares speed fields (car[+0x01FC]), applies +/-0x300 push,
    ! clamps result to [0, 0x0800], stores to car[+0x01F8],
    ! sets 0x0100 (256) as collision timer at car[+0x0204],
    ! and stores partner pointer at car[+0x0234].
    ! =====================================================================
    mov.l   .L_pool_self_car_ptr_b, r6 ! r6 = &current_car_ptr (sym_0607E940)
    mov.w   DAT_0600d1fa, r0           ! r0 = 0x01FC (offset: speed/heading field)
    mov.l @r6, r6                       ! r6 = self car struct
    mov.l @(r0, r4), r5                ! r5 = partner.speed (car[+0x01FC])
    mov.l @(r0, r6), r3                ! r3 = self.speed (car[+0x01FC])
    mov r5, r7                          ! r7 = partner.speed (copy for delta calc)
    sub r3, r7                          ! r7 = speed_delta = partner.speed - self.speed
    mov.w   DAT_0600d1fc, r3           ! r3 = 0xFD00 = -768 (signed lower bound)
    cmp/ge r3, r7                       ! speed_delta >= -768?
    bf      .L_push_exit                ! no -> delta too negative, skip push
    mov.w   DAT_0600d1fe, r3           ! r3 = 0x0300 = 768 (upper bound)
    cmp/gt r3, r7                       ! speed_delta > 768?
    bt      .L_push_exit                ! yes -> delta too positive, skip push
    ! --- Delta is in range [-768, 768]: apply push ---
    mov.w   DAT_0600d1fe, r7           ! r7 = 0x0300 = push magnitude (768)
    mov.w   DAT_0600d200, r3           ! r3 = 0x0400 = direction threshold (1024)
    cmp/gt r3, r5                       ! partner.speed > 1024?
    bt      .L_push_subtract            ! yes -> partner faster, subtract push from self
    bra     .L_push_clamp               ! no -> partner slower, add push to self
    add r7, r5                          ! (delay slot) r5 = partner.speed + push
.L_push_subtract:
    sub r7, r5                          ! r5 = partner.speed - push
.L_push_clamp:
    cmp/pz r5                           ! result >= 0?
    bt      .L_push_check_max           ! yes -> check upper bound
    mov #0x0, r3                        ! clamp to zero
    mov.w   DAT_0600d202, r0           ! r0 = 0x01F8 (offset: force/push field)
    bra     .L_push_set_timer           ! store zero and set timer
    mov.l r3, @(r0, r6)                ! (delay slot) self_car[+0x01F8] = 0
.L_push_check_max:
    mov.w   DAT_0600d204, r3           ! r3 = 0x0800 = max push value (2048)
    cmp/gt r3, r5                       ! result > max?
    bf      .L_push_store_result        ! no -> store as-is
    mov.w   DAT_0600d204, r3           ! r3 = 0x0800 (max value, reload)
    mov.w   DAT_0600d202, r0           ! r0 = 0x01F8 (force field offset)
    mov.l r3, @(r0, r6)                ! self_car[+0x01F8] = max (2048)
    bra     .L_push_set_timer           ! jump to set collision timer
    nop
.L_push_store_result:
    mov.w   DAT_0600d202, r0           ! r0 = 0x01F8 (force field offset)
    mov.l r5, @(r0, r6)                ! self_car[+0x01F8] = clamped push value
.L_push_set_timer:
    mov.w   .L_wpool_collision_timer_val, r3 ! r3 = 0x0100 = 256 (collision timer duration)
    mov.w   .L_wpool_timer_offset, r0  ! r0 = 0x0204 (offset: collision timer field)
    mov.l r3, @(r0, r6)                ! self_car[+0x0204] = 256 (start collision timer)
    add #0x30, r0                       ! r0 = 0x0234 (offset: collision partner B field)
    mov.l r4, @(r0, r6)                ! self_car[+0x0234] = partner car pointer
.L_push_exit:
    rts                                 ! return
    nop

    .global DAT_0600d1fa
DAT_0600d1fa:
    .2byte  0x01FC                      /* car struct offset: speed/heading field */

    .global DAT_0600d1fc
DAT_0600d1fc:
    .2byte  0xFD00                      /* -768 (signed) — lower bound for speed delta */

    .global DAT_0600d1fe
DAT_0600d1fe:
    .2byte  0x0300                      /* 768 — upper bound for speed delta / push magnitude */

    .global DAT_0600d200
DAT_0600d200:
    .2byte  0x0400                      /* 1024 — direction threshold for push direction */

    .global DAT_0600d202
DAT_0600d202:
    .2byte  0x01F8                      /* car struct offset: force/push accumulator field */

    .global DAT_0600d204
DAT_0600d204:
    .2byte  0x0800                      /* 2048 — maximum push value (clamp ceiling) */
.L_wpool_collision_timer_val:
    .2byte  0x0100                      /* 256 — collision timer duration (frames) */
.L_wpool_timer_offset:
    .2byte  0x0204                      /* car struct offset: collision timer / steering countdown */
    .2byte  0xFFFF                      /* alignment padding */
.L_pool_self_car_ptr_b:
    .4byte  sym_0607E940                /* &current_car_ptr (duplicate for push handler reach) */
    ! === Byte-encoded FUN_0600D210 — standalone aggressive collision push ===
    ! Identical logic to the fall-through above, but called independently
    ! from the collision dispatcher for side-hit mode 2 collisions.
    ! Uses its own pool at the end (sym_0607E940, sym_0607E944).
    ! This block is byte-encoded because it contains BRA instructions.
    .4byte  0xD519D41A
    .4byte  0x90296552
    .4byte  0x6442035E
    .4byte  0x044E6643
    .4byte  0x36389323
    .4byte  0x36338B1C
    .4byte  0x93213637
    .4byte  0x8919901C
    .4byte  0x035E3347
    .4byte  0x8B01A001
    .4byte  0x74F07410
    .4byte  0x44118903
    .4byte  0xE3009015
    .4byte  0xA00A0536
    .4byte  0x93133437
    .4byte  0x8B049310
    .4byte  0x900E0536
    .4byte  0xA0020009
    .4byte  0x900A0546
    .4byte  0xE3409009
    .4byte  0x0536000B
    .2byte  0x0009

    .global friction_stub
friction_stub:
    rts                                 ! return immediately — unused stub
    nop

    .global DAT_0600d26a
DAT_0600d26a:
    .2byte  0x01FC                      /* car struct offset: speed field (for standalone push) */

    .global DAT_0600d26c
DAT_0600d26c:
    .2byte  0xFD00                      /* -768 (signed) — lower bound (standalone push pool) */

    .global DAT_0600d26e
DAT_0600d26e:
    .2byte  0x0300                      /* 768 — upper bound / push magnitude (standalone pool) */

    .global DAT_0600d270
DAT_0600d270:
    .2byte  0x01F8                      /* car struct offset: force field (standalone push pool) */

    .global DAT_0600d272
DAT_0600d272:
    .2byte  0x0800                      /* 2048 — max push value (standalone push pool) */
    .4byte  0x0204FFFF                  /* 0x0204 = timer offset, 0xFFFF = padding (standalone pool) */
    .4byte  sym_0607E940                /* &current_car_ptr (standalone push: self car) */
    .4byte  sym_0607E944                /* &car_base_ptr (standalone push: other car) */

    ! =====================================================================
    ! sym_0600D280 — Car Pointer List Initialization
    ! Called once during car array init (FUN_0600629C) to build sorted
    ! pointer arrays for race position tracking.
    !
    ! Clears two pointer arrays (20 entries each, 8 bytes per entry):
    !   car_ptr_list_a at sym_0607E94C — primary sorted car pointer list
    !   car_ptr_list_b at sym_0607E9EC — secondary sorted car pointer list
    ! Clears 3 longs at sym_0607EA8C (race position scratch state).
    ! Then populates both lists with car struct addresses computed as:
    !   car_array_base + (car_index - 1) * stride
    ! where stride = 0x0268 and car_index runs from 1 to car_count.
    !
    ! r12 = car_array_base (sym_06078900)
    ! r1  = car struct stride (0x0268)
    ! r5  = &car_count (sym_0607EA98)
    ! r7  = 0x28 = 40 = loop bound (20 entries * 2 bytes per iteration step)
    ! =====================================================================
    .global sym_0600D280
sym_0600D280:
    mov.l r12, @-r15                    ! save r12
    sts.l macl, @-r15                   ! save macl (will use mul.l)
    mov.l   .L_pool_car_array_base, r12 ! r12 = car_array_base (sym_06078900)
    mov.w   .L_wpool_car_stride, r1    ! r1 = 0x0268 (car struct stride)
    mov #0x28, r7                       ! r7 = 40 (loop bound: 20 entries * 2)
    mov.l   .L_pool_car_count_ptr, r5  ! r5 = &car_count (sym_0607EA98)
    mov #0x0, r4                        ! r4 = 0 (zero constant for clearing)
    mov.l   .L_pool_list_a_base, r6    ! r6 = car_ptr_list_a (sym_0607E94C)
    bra     .L_clear_list_a_test        ! jump to loop test
    mov r4, r0                          ! (delay slot) r0 = 0 (loop counter)
.L_clear_list_a_body:
    mov.l r4, @r6                       ! list_a[i].ptr = 0
    add #0x4, r6                        ! advance to list_a[i].sort_key
    mov.l r4, @r6                       ! list_a[i].sort_key = 0
    add #0x2, r0                        ! counter += 2
    add #0x4, r6                        ! advance to next entry
.L_clear_list_a_test:
    cmp/hs r7, r0                       ! counter >= 40?
    bf      .L_clear_list_a_body        ! no -> continue clearing
    ! --- Clear car_ptr_list_b (20 entries) ---
    mov.l   .L_pool_list_b_base, r6    ! r6 = car_ptr_list_b (sym_0607E9EC)
    bra     .L_clear_list_b_test        ! jump to loop test
    mov r4, r0                          ! (delay slot) r0 = 0 (loop counter)
.L_clear_list_b_body:
    mov.l r4, @r6                       ! list_b[i].ptr = 0
    add #0x4, r6                        ! advance to list_b[i].sort_key
    mov.l r4, @r6                       ! list_b[i].sort_key = 0
    add #0x2, r0                        ! counter += 2
    add #0x4, r6                        ! advance to next entry
.L_clear_list_b_test:
    cmp/hs r7, r0                       ! counter >= 40?
    bf      .L_clear_list_b_body        ! no -> continue clearing
    ! --- Clear 3 scratch longs at sym_0607EA8C ---
    mov.l   .L_pool_scratch_base, r6   ! r6 = &race_pos_scratch (sym_0607EA8C)
    mov.l r4, @r6                       ! scratch[0] = 0
    add #0x4, r6                        ! advance
    mov.l r4, @r6                       ! scratch[1] = 0
    add #0x4, r6                        ! advance
    mov.l r4, @r6                       ! scratch[2] = 0 (this is car_count location)
    ! --- Populate car_ptr_list_a with car struct addresses ---
    mov.l   .L_pool_list_a_base, r0    ! r0 = &car_ptr_list_a[0]
    bra     .L_fill_list_a_test         ! jump to loop test
    mov #0x1, r6                        ! (delay slot) r6 = 1 (car index, 1-based)
.L_fill_list_a_body:
    mov r0, r2                          ! r2 = current list_a slot address
    add #0x4, r0                        ! advance r0 to next slot
    mov.l @r5, r3                       ! r3 = car_count
    sub r6, r3                          ! r3 = car_count - car_index
    mul.l r1, r3                        ! macl = (car_count - car_index) * stride
    sts macl, r3                        ! r3 = byte offset into car array
    add r12, r3                         ! r3 = &car_array[car_count - car_index]
    mov.l r3, @r2                       ! list_a[slot] = car struct pointer
    add #0x1, r6                        ! car_index++
.L_fill_list_a_test:
    mov.l @r5, r2                       ! r2 = car_count
    cmp/hi r2, r6                       ! car_index > car_count?
    bf      .L_fill_list_a_body         ! no -> continue filling
    ! --- Populate car_ptr_list_b with car struct addresses ---
    mov.l   .L_pool_list_b_base, r0    ! r0 = &car_ptr_list_b[0]
    bra     .L_fill_list_b_test         ! jump to loop test
    mov #0x1, r6                        ! (delay slot) r6 = 1 (car index, 1-based)
.L_fill_list_b_body:
    mov r0, r2                          ! r2 = current list_b slot address
    add #0x4, r0                        ! advance r0 to next slot
    mov.l @r5, r3                       ! r3 = car_count
    sub r6, r3                          ! r3 = car_count - car_index
    mul.l r1, r3                        ! macl = (car_count - car_index) * stride
    sts macl, r3                        ! r3 = byte offset into car array
    add r12, r3                         ! r3 = &car_array[car_count - car_index]
    mov.l r3, @r2                       ! list_b[slot] = car struct pointer
    add #0x1, r6                        ! car_index++
.L_fill_list_b_test:
    mov.l @r5, r2                       ! r2 = car_count
    cmp/hi r2, r6                       ! car_index > car_count?
    bf      .L_fill_list_b_body         ! no -> continue filling
    lds.l @r15+, macl                   ! restore macl
    rts                                 ! return
    mov.l @r15+, r12                    ! (delay slot) restore r12
.L_wpool_car_stride:
    .2byte  0x0268                      /* car struct stride (616 bytes) */
    .2byte  0xFFFF                      /* alignment padding */
.L_pool_car_array_base:
    .4byte  sym_06078900                /* car struct array base address */
.L_pool_car_count_ptr:
    .4byte  sym_0607EA98                /* &total_car_count (long) */
.L_pool_list_a_base:
    .4byte  sym_0607E94C                /* car_ptr_list_a — primary sorted pointer array */
.L_pool_list_b_base:
    .4byte  sym_0607E9EC                /* car_ptr_list_b — secondary sorted pointer array */
.L_pool_scratch_base:
    .4byte  sym_0607EA8C                /* race position scratch state (3 longs) */
