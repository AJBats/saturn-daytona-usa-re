/* course2_physics_init -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06019FB2 - 0x0601A0F0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Course 2 (Expert / Seaside Street Galaxy) car physics initialization.
 * Called during the course loading sequence after course data is loaded
 * from ROM and course parameters are configured.
 *
 * Iterates over all cars on the course (up to r14 cars), and for each car:
 *   1. Determines a physics parameter set index based on whether this car
 *      is the player car (looked up from player_car_index at sym_0605AD04).
 *      - Player car gets index 0x6 (r11); other cars get index 0x5 (r14).
 *   2. Looks up the car's model ID from the car_model_table (sym_06049B2C),
 *      a word array indexed by car slot number.
 *   3. Uses the model ID to index into the physics_data_table (sym_06063750),
 *      an array of 8-byte records. Reads the record's +4 field as an offset
 *      and adds it to the parameter set base to get the source pointer.
 *   4. Reads two bytes from the course param offset table (sym_06049B22 + car*2)
 *      to compute a destination offset: byte[1]*64 + byte[0], doubled.
 *   5. Calls block_copy (sym_06028400) with r4=0xC (12 bytes), r5=source
 *      data pointer from the physics record, r6=destination offset, r7=dest base.
 *
 * Two paths exist based on the game config byte at sym_06085FF0:
 *   - If config == 2 (expert mode): uses the alternate path with a wrapping
 *     animation counter at sym_0605D242. When the counter is 8..16, player car
 *     gets index 0x7 instead of 0x6. Counter resets to 0 when it exceeds 16.
 *   - Otherwise: straightforward path where player gets 0x6, others get 0x5.
 *
 * Register allocation:
 *   r8  = car_model_table base (sym_06049B2C, word array)
 *   r9  = block_copy function pointer (sym_06028400)
 *   r10 = physics param set index for current car (computed per iteration)
 *   r11 = player car param index constant (0x6)
 *   r12 = pointer to animation counter byte (sym_0605D242)
 *   r13 = loop counter (car index, 0..r14-1)
 *   r14 = total car count for this course (0x5 normal, or from config)
 */

    .section .text.FUN_06019FB2


    .global course2_physics_init
    .type course2_physics_init, @function
course2_physics_init:
    /* === Prologue: save callee-saved registers === */
    mov.l r14, @-r15            ! save r14 (car count / loop limit)
    mov.l r13, @-r15            ! save r13 (loop counter)
    mov.l r12, @-r15            ! save r12 (anim counter ptr)
    mov.l r11, @-r15            ! save r11 (player param index constant)
    mov #0x6, r11               ! r11 = 0x6 (player car physics param index)
    mov.l r10, @-r15            ! save r10 (current car param index)
    mov.l r9, @-r15             ! save r9 (block_copy func ptr)
    mov.l r8, @-r15             ! save r8 (car model table base)
    sts.l pr, @-r15             ! save return address
    add #-0xC, r15              ! allocate 12 bytes of stack locals

    /* === Load constants from pool === */
    .byte   0xD8, 0x08    /* mov.l .L_pool_car_model_table, r8 */   ! r8 = &car_model_table (sym_06049B2C)
    .byte   0xD9, 0x08    /* mov.l .L_pool_block_copy, r9 */        ! r9 = &block_copy (sym_06028400)
    .byte   0xDC, 0x09    /* mov.l .L_pool_anim_counter, r12 */     ! r12 = &anim_counter_byte (sym_0605D242)
    .byte   0xD0, 0x09    /* mov.l .L_pool_game_config, r0 */       ! r0 = &game_config_byte (sym_06085FF0)
    mov.b @r0, r0               ! r0 = game_config_byte value
    cmp/eq #0x2, r0             ! is config == 2 (expert mode)?
    bt/s    .L_expert_path      ! if expert: take alternate path with anim counter
    mov #0x5, r14               ! r14 = 5 (car count for this course, in delay slot)

    /* ================================================================
     * NORMAL PATH (config != 2)
     * Simple iteration: player car gets param index 6, AI cars get 5.
     * ================================================================ */
    mov #0x0, r13               ! r13 = 0 (loop counter init)
.L_normal_loop:
    extu.b r13, r2              ! r2 = car_index (zero-extended)
    .byte   0xD3, 0x07    /* mov.l .L_pool_player_car_index, r3 */  ! r3 = &player_car_index (sym_0605AD04)
    mov.l @r3, r3               ! r3 = player_car_index value
    cmp/eq r3, r2               ! is this the player car?
    bf      .L_normal_not_player ! if not player: use default index
    bra     .L_normal_apply_index ! player car: use r11 (0x6)
    extu.b r11, r10             ! r10 = 0x6 (player param index, delay slot)
    .2byte  0xFFFF              ! padding (alignment)

    /* === Constant pool (first block) === */
.L_pool_car_model_table:
    .4byte  sym_06049B2C        /* car model index table (word array, course 2) */
.L_pool_block_copy:
    .4byte  sym_06028400        /* block_copy function */
.L_pool_anim_counter:
    .4byte  sym_0605D242        /* animation counter byte */
.L_pool_game_config:
    .4byte  sym_06085FF0        /* game config / course selection byte */
.L_pool_player_car_index:
    .4byte  sym_0605AD04        /* player car index (long) for course 2 */

.L_normal_not_player:
    extu.b r14, r10             ! r10 = 0x5 (AI car default param index)

    /* === Common body: compute physics data source and call block_copy === */
.L_normal_apply_index:
    extu.b r10, r7              ! r7 = param_set_index (zero-extended)
    extu.b r13, r0              ! r0 = car_index (zero-extended)
    shll8 r7                    ! r7 = param_set_index << 8
    shll r0                     ! r0 = car_index * 2 (word offset into model table)
    shll2 r7                    ! r7 = param_set_index << 10
    mov.l r0, @(8, r15)        ! sp[8] = car_index * 2 (save for later)
    shll2 r7                    ! r7 = param_set_index << 12 (param base = index * 4096)
    mov.w @(r0, r8), r3        ! r3 = car_model_table[car_index] (model ID, word)
    .byte   0xD2, 0x35    /* mov.l .L_pool_physics_data_table, r2 */ ! r2 = &physics_data_table (sym_06063750)
    extu.w r3, r3               ! r3 = model_id (zero-extended to 32-bit)
    shll2 r3                    ! r3 = model_id * 4
    shll r3                     ! r3 = model_id * 8 (each physics record is 8 bytes)
    add r3, r2                  ! r2 = &physics_data_table[model_id]
    mov.l r2, @(4, r15)        ! sp[4] = &physics_record (save for later)
    mov.l @(4, r2), r3         ! r3 = physics_record[model_id].offset (+4 field)
    mov.l @(8, r15), r6        ! r6 = car_index * 2 (restored)
    add r3, r7                  ! r7 = param_base + physics_record.offset (dest ptr)
    .byte   0xD3, 0x31    /* mov.l .L_pool_course_param_offsets, r3 */ ! r3 = &course_param_offsets (sym_06049B22)
    add r3, r6                  ! r6 = &course_param_offsets[car_index] (2 bytes per car)
    mov.l r6, @r15              ! sp[0] = &param_offset_entry (save for later)
    mov.b @(1, r6), r0         ! r0 = param_offset_entry.byte[1] (high component)
    mov.l @r15, r2              ! r2 = &param_offset_entry (restore)
    mov r0, r6                  ! r6 = high_component
    mov.b @r2, r2               ! r2 = param_offset_entry.byte[0] (low component)
    extu.b r6, r6               ! r6 = high_component (zero-extended)
    extu.b r2, r2               ! r2 = low_component (zero-extended)
    shll2 r6                    ! r6 = high * 4
    shll2 r6                    ! r6 = high * 16
    shll2 r6                    ! r6 = high * 64
    add r2, r6                  ! r6 = high * 64 + low (combined offset)
    shll r6                     ! r6 = (high * 64 + low) * 2 (final dest offset)
    mov.l @(4, r15), r5        ! r5 = &physics_record (restored)
    mov.l @r5, r5               ! r5 = physics_record[model_id].data_ptr (+0 field, source)
    jsr @r9                     ! call block_copy(r4=count, r5=src, r6=dest_offset, r7=dest_base)
    mov #0xC, r4                ! r4 = 0xC (12 bytes to copy, delay slot)

    /* === Loop increment and test === */
    add #0x1, r13               ! r13++ (next car)
    extu.b r13, r3              ! r3 = car_index (zero-extended)
    cmp/ge r14, r3              ! car_index >= car_count?
    bf      .L_normal_loop      ! if not done: loop back
    bra     .L_epilogue         ! all cars processed: exit
    nop                         ! delay slot (nop)

    /* ================================================================
     * EXPERT PATH (config == 2)
     * Uses animation counter at sym_0605D242 for player car.
     * When counter is in range [8..16], player gets param index 7.
     * When counter exceeds 16, it resets to 0.
     * AI cars always get param index 3 (not 5 as in normal path).
     * ================================================================ */
.L_expert_path:
    mov #0x0, r13               ! r13 = 0 (loop counter init)
.L_expert_loop:
    extu.b r13, r2              ! r2 = car_index (zero-extended)
    .byte   0xD3, 0x25    /* mov.l .L_pool_player_car_index_b, r3 */ ! r3 = &player_car_index (sym_0605AD04)
    mov.l @r3, r3               ! r3 = player_car_index value
    cmp/eq r3, r2               ! is this the player car?
    bf      .L_expert_not_player ! if not player: use AI index

    /* --- Player car in expert mode: check animation counter --- */
    mov #0x8, r2                ! r2 = 8 (lower threshold)
    mov.b @r12, r3              ! r3 = anim_counter value
    extu.b r3, r3               ! r3 = anim_counter (zero-extended)
    cmp/ge r2, r3               ! anim_counter >= 8?
    bt      .L_expert_counter_high ! if >= 8: check upper bound
    bra     .L_expert_apply_index  ! if < 8: use default player index (0x6)
    extu.b r11, r10             ! r10 = 0x6 (delay slot)

.L_expert_counter_high:
    mov #0x10, r3               ! r3 = 16 (upper threshold)
    mov.b @r12, r2              ! r2 = anim_counter (re-read)
    extu.b r2, r2               ! r2 = anim_counter (zero-extended)
    cmp/gt r3, r2               ! anim_counter > 16?
    bf/s    .L_expert_use_index_7  ! if <= 16: use index 7 (enhanced physics)
    mov #0x7, r10               ! r10 = 0x7 (enhanced param index, delay slot)
    /* Counter exceeded 16: reset to 0 */
    mov #0x0, r3                ! r3 = 0
    mov.b r3, @r12              ! anim_counter = 0 (reset)

.L_expert_use_index_7:
    bra     .L_expert_apply_index ! proceed with current r10
    nop                         ! delay slot (nop)

.L_expert_not_player:
    mov #0x3, r10               ! r10 = 0x3 (AI car param index in expert mode)

    /* === Common body for expert path: same physics lookup as normal === */
.L_expert_apply_index:
    extu.b r10, r7              ! r7 = param_set_index (zero-extended)
    extu.b r13, r0              ! r0 = car_index (zero-extended)
    shll8 r7                    ! r7 = param_set_index << 8
    shll r0                     ! r0 = car_index * 2 (word offset into model table)
    shll2 r7                    ! r7 = param_set_index << 10
    mov.l r0, @r15              ! sp[0] = car_index * 2 (save for later)
    shll2 r7                    ! r7 = param_set_index << 12 (param base = index * 4096)
    mov.w @(r0, r8), r3        ! r3 = car_model_table[car_index] (model ID, word)
    .byte   0xD2, 0x14    /* mov.l .L_pool_physics_data_table, r2 */ ! r2 = &physics_data_table (sym_06063750)
    extu.w r3, r3               ! r3 = model_id (zero-extended to 32-bit)
    shll2 r3                    ! r3 = model_id * 4
    shll r3                     ! r3 = model_id * 8 (each physics record is 8 bytes)
    add r3, r2                  ! r2 = &physics_data_table[model_id]
    mov.l r2, @(8, r15)        ! sp[8] = &physics_record (save for later)
    mov.l @(4, r2), r3         ! r3 = physics_record[model_id].offset (+4 field)
    mov.l @r15, r6              ! r6 = car_index * 2 (restored)
    add r3, r7                  ! r7 = param_base + physics_record.offset (dest ptr)
    .byte   0xD3, 0x11    /* mov.l .L_pool_course_param_offsets, r3 */ ! r3 = &course_param_offsets (sym_06049B22)
    add r3, r6                  ! r6 = &course_param_offsets[car_index] (2 bytes per car)
    mov.l r6, @(4, r15)        ! sp[4] = &param_offset_entry (save for later)
    mov.b @(1, r6), r0         ! r0 = param_offset_entry.byte[1] (high component)
    mov.l @(4, r15), r2        ! r2 = &param_offset_entry (restore)
    mov r0, r6                  ! r6 = high_component
    mov.b @r2, r2               ! r2 = param_offset_entry.byte[0] (low component)
    extu.b r6, r6               ! r6 = high_component (zero-extended)
    extu.b r2, r2               ! r2 = low_component (zero-extended)
    shll2 r6                    ! r6 = high * 4
    shll2 r6                    ! r6 = high * 16
    shll2 r6                    ! r6 = high * 64
    add r2, r6                  ! r6 = high * 64 + low (combined offset)
    shll r6                     ! r6 = (high * 64 + low) * 2 (final dest offset)
    mov.l @(8, r15), r5        ! r5 = &physics_record (restored)
    mov.l @r5, r5               ! r5 = physics_record[model_id].data_ptr (+0 field, source)
    jsr @r9                     ! call block_copy(r4=count, r5=src, r6=dest_offset, r7=dest_base)
    mov #0xC, r4                ! r4 = 0xC (12 bytes to copy, delay slot)

    /* === Loop increment and test (expert path) === */
    add #0x1, r13               ! r13++ (next car)
    extu.b r13, r3              ! r3 = car_index (zero-extended)
    cmp/ge r14, r3              ! car_index >= car_count?
    bf      .L_expert_loop      ! if not done: loop back

    /* === Epilogue: restore registers and return === */
.L_epilogue:
    add #0xC, r15               ! deallocate 12 bytes of stack locals
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r8             ! restore r8
    mov.l @r15+, r9             ! restore r9
    mov.l @r15+, r10            ! restore r10
    mov.l @r15+, r11            ! restore r11
    mov.l @r15+, r12            ! restore r12
    mov.l @r15+, r13            ! restore r13
    rts                         ! return to caller
    mov.l @r15+, r14            ! restore r14 (delay slot)
    .2byte  0xFFFF              ! padding (alignment)

    /* === Constant pool (second block) === */
.L_pool_physics_data_table:
    .4byte  sym_06063750        /* physics data table base (8-byte records per car model) */
.L_pool_course_param_offsets:
    .4byte  sym_06049B22        /* course 2 per-car parameter offset table */
.L_pool_player_car_index_b:
    .4byte  sym_0605AD04        /* player car index (long) for course 2 (expert path copy) */
