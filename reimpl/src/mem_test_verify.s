/* mem_test_verify -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0604053A - 0x060405B8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Verifies a memory region by acquiring an event boundary lock,
 * calling ai_section_check with the lock sequence, then checking
 * whether the event boundary is still active. If active, releases
 * the lock. Compares a validation counter from the state struct
 * against a local result to detect if the boundary was modified
 * during verification, and promotes the counter if so.
 *
 * Args:
 *   r4 = context pointer (field +24 = state descriptor)
 *   r5 = enable flag (0 = skip lock acquire, nonzero = acquire lock first)
 *
 * Calls:
 *   ai_section_check      0x0604134E  validate section with lock sequence
 *   sym_06041014           0x06041014  check if event boundary is active
 *   sym_06040FEA           0x06040FEA  release event boundary lock
 *   evt_validate_multi     0x060405B8  validate event params and get type (BSR)
 */

    .section .text.FUN_0604053A


    .global mem_test_verify
    .type mem_test_verify, @function
mem_test_verify:
    mov.l r14, @-r15                      ! save r14 (callee-saved)
    mov.l r13, @-r15                      ! save r13 (callee-saved)
    sts.l pr, @-r15                       ! save return address
    add #-0xC, r15                        ! allocate 12 bytes of stack locals
    .byte   0xDE, 0x19    /* mov.l .L_pool_state_ptr, r14 */  ! r14 = &sym_060A4D14 (global state pointer)
    tst r5, r5                            ! is enable flag zero?
    bt/s    .L_check_boundary             ! if zero, skip lock acquire
    mov.l @(24, r4), r13                  ! r13 = context->state_desc (+0x18) [delay slot]
    mov #0x0, r1                          ! r1 = 0 (clear value)
    mov.w   .L_wpool_060405A4, r0         ! r0 = 0x00B0 (offset to validation counter)
    mov r15, r4                           ! r4 = stack pointer (output buffer for section check)
    mov.l @r14, r3                        ! r3 = state struct base address
    mov r3, r2                            ! r2 = state struct base (copy)
    mov.l r1, @(r0, r2)                   ! state[0xB0] = 0 (clear validation counter)
    mov r1, r2                            ! r2 = 0 (unused, register cleanup)
    add #-0x4, r0                         ! r0 = 0x00AC (offset to previous counter field)
    mov #0x3, r2                          ! r2 = 3 (initial value for stack local)
    mov.l r1, @(r0, r3)                   ! state[0xAC] = 0 (clear previous counter)
    mov r15, r3                           ! r3 = stack pointer
    add #0x4, r3                          ! r3 = sp+4 (address of second stack local)
    mov.l r2, @r3                         ! stack[+4] = 3 (store initial value)
    mov.l @(40, r13), r5                  ! r5 = state_desc->lock_seq (+0x28, sequence handle)
    .byte   0xD3, 0x11    /* mov.l .L_fn_ai_section_check, r3 */  ! r3 = &ai_section_check
    jsr @r3                               ! ai_section_check(r4=&stack_buf, r5=lock_seq)
    add #0x4, r4                          ! r4 = sp+4 (adjusted buffer ptr) [delay slot]
.L_check_boundary:
    .byte   0xD3, 0x10    /* mov.l .L_fn_evt_boundary_active, r3 */  ! r3 = &sym_06041014 (boundary active check)
    jsr @r3                               ! sym_06041014(r4=lock_seq) -- is boundary still active?
    mov.l @(40, r13), r4                  ! r4 = state_desc->lock_seq (+0x28) [delay slot]
    tst r0, r0                            ! is boundary active? (0 = inactive)
    bt      .L_epilogue                   ! if inactive, skip release and return
    .byte   0xD3, 0x0F    /* mov.l .L_fn_evt_boundary_release, r3 */  ! r3 = &sym_06040FEA (release lock)
    jsr @r3                               ! sym_06040FEA(r4=lock_seq) -- release event boundary lock
    mov.l @(40, r13), r4                  ! r4 = state_desc->lock_seq (+0x28) [delay slot]
    mov #0x0, r5                          ! r5 = 0 (no output buffer for validate)
    .byte   0xB0, 0x1B    /* bsr 0x060405B8 (external) */  ! evt_validate_multi(r4=&stack_buf, r5=0)
    mov r15, r4                           ! r4 = stack pointer (input buffer) [delay slot]
    mov.l @r14, r2                        ! r2 = state struct base address
    mov.w   .L_wpool_060405A4, r0         ! r0 = 0x00B0 (offset to validation counter)
    mov.l @(r0, r2), r3                   ! r3 = state[0xB0] (current validation counter)
    mov.l @r15, r2                        ! r2 = stack[0] (local result from evt_validate_multi)
    cmp/gt r2, r3                         ! is validation counter > local result?
    bt      .L_epilogue                   ! if counter already higher, no update needed
    mov.l @r14, r2                        ! r2 = state struct base address
    mov r2, r3                            ! r3 = state struct base (copy)
    mov.w   .L_wpool_060405A4, r0         ! r0 = 0x00B0 (offset to validation counter)
    mov.l @(r0, r3), r1                   ! r1 = state[0xB0] (current counter value)
    add #-0x4, r0                         ! r0 = 0x00AC (offset to previous counter field)
    mov.l r1, @(r0, r2)                   ! state[0xAC] = state[0xB0] (promote counter to previous)
.L_epilogue:
    add #0xC, r15                         ! deallocate stack locals
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r13                      ! restore r13
    rts                                   ! return to caller
    mov.l @r15+, r14                      ! restore r14 [delay slot]
.L_wpool_060405A4:
    .2byte  0x00B0
    .2byte  0xFFFF
.L_pool_state_ptr:
    .4byte  sym_060A4D14
.L_fn_ai_section_check:
    .4byte  ai_section_check
.L_fn_evt_boundary_active:
    .4byte  sym_06041014
.L_fn_evt_boundary_release:
    .4byte  sym_06040FEA
