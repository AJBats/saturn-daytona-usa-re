/* ai_physics_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600E906 - 0x0600E99C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * AI car per-frame physics pipeline — runs the physics sub-steps for
 * each AI opponent car every frame:
 *
 *   1. friction_stub       — apply surface friction (cross-TU pool)
 *   2. ai_orchestrator     — AI decision making / steering (cross-TU pool)
 *   3. fpmul(car.Y, scale) — project Y coordinate for camera targeting
 *
 * After projection, copies car[+0x20] to car[+0x30], then calls
 * track_segment_advance to update track position tracking.
 *
 * Velocity integration:
 *   car[+0x1F4] = car[+0x1EC] + car[+0x228] * speed_coefficient
 *
 * If car[+0x1EC] == 0 (car inactive): clears car[+0x21C] and
 * sets car[+0x204] = 0x200 (timer reset).
 *
 * Early-exit: if race mode flag (sym_0607EAD8) is nonzero,
 * clears car[+0x0C] and returns immediately.
 */

    .section .text.FUN_0600E906


    .global ai_physics_main
    .type ai_physics_main, @function
ai_physics_main:
    mov.l r14, @-r15                   ! save r14 (will hold car struct base)
    sts.l pr, @-r15                    ! save return address
    sts.l macl, @-r15                  ! save multiply accumulator
    .byte   0xDE, 0x0C    /* mov.l .L_pool_car_state_ptr, r14 */  ! r14 = &car_state_ptr (sym_0607E940)
    .byte   0xD0, 0x0D    /* mov.l .L_pool_race_mode_flag, r0 */  ! r0 = &race_mode_flag (sym_0607EAD8)
    mov.l @r0, r0                      ! r0 = race mode flag value
    tst r0, r0                         ! test if race mode == 0
    bt/s    .L_physics_pipeline        ! flag == 0 → run physics pipeline
    mov.l @r14, r14                    ! (delay) r14 = car struct base pointer
    mov #0x0, r3                       ! r3 = 0 (clear value)
    bra     .L_epilogue                ! skip physics, jump to return
    mov.l r3, @(12, r14)              ! (delay) car[+0x0C] = 0 (clear Y position)
    .2byte  0x0228                     ! word pool: car offset for forward speed

    .global DAT_0600e920
DAT_0600e920:
    .word 0x01F8                       ! cross-TU word pool: car offset for surface type

    .global DAT_0600e922
DAT_0600e922:
    mov.b r14, @(r0, r0)              ! cross-TU word pool: 0x00E4 (projected coord A offset)
    .word 0x00E0                       ! cross-TU word pool: projected coord B offset
    .word 0xFFFF                       ! alignment padding
    .4byte  track_segment_advance      ! cross-TU long pool: track segment advance function
    .4byte  sym_0607EA9C               ! cross-TU long pool: speed coefficient / section count
    .4byte  sym_0607EBC4               ! cross-TU long pool: game state flags
    .4byte  0x00200000                 ! cross-TU long pool: fixed-point constant
    .4byte  0x066505B3                 ! cross-TU long pool: Y projection constant
    .4byte  fpmul                      ! cross-TU long pool: fixed-point multiply function
.L_pool_car_state_ptr:
    .4byte  sym_0607E940               ! pointer to current AI car state struct
.L_pool_race_mode_flag:
    .4byte  sym_0607EAD8               ! race mode flag (0 = active, nonzero = inactive)
.L_physics_pipeline:
    .byte   0xD3, 0x29    /* mov.l .L_pool_0600E9F0, r3 */  ! r3 = &friction_stub (cross-TU pool)
    jsr @r3                            ! step 1: apply surface friction
    nop                                ! (delay)
    .byte   0xD3, 0x29    /* mov.l .L_pool_0600E9F4, r3 */  ! r3 = &ai_orchestrator (cross-TU pool)
    jsr @r3                            ! step 2: AI decision / steering
    nop                                ! (delay)
    .byte   0xD5, 0x28    /* mov.l .L_pool_0600E9F8, r5 */  ! r5 = 0x00480000 (Y scale constant, cross-TU pool)
    .byte   0xD3, 0x29    /* mov.l .L_pool_0600E9FC, r3 */  ! r3 = &fpmul (cross-TU pool)
    jsr @r3                            ! step 3: fpmul(car.Y_pos, scale)
    mov.l @(12, r14), r4               ! (delay) r4 = car[+0x0C] (Y position)
    shlr16 r0                          ! result >> 16 (fixed-point to integer)
    exts.w r0, r0                      ! sign-extend 16→32 bits
    mov.l r0, @(8, r14)                ! car[+0x08] = projected Y coordinate
    mov.l @(32, r14), r2               ! r2 = car[+0x20] (position field A)
    .byte   0xD3, 0x26    /* mov.l .L_pool_0600EA00, r3 */  ! r3 = &track_segment_advance (cross-TU pool)
    jsr @r3                            ! step 4: advance track segment tracking
    mov.l r2, @(48, r14)               ! (delay) car[+0x30] = car[+0x20] (copy position)
    .byte   0x90, 0x3A    /* mov.w .L_wpool_0600E9E2, r0 */  ! r0 = 0x0228 (forward speed offset)
    .byte   0xD3, 0x25    /* mov.l .L_pool_0600EA04, r3 */  ! r3 = &speed_coefficient (sym_0607EA9C, cross-TU pool)
    mov.l @(r0, r14), r2               ! r2 = car[+0x228] (forward speed)
    mov.l @r3, r3                      ! r3 = speed coefficient value
    add #-0x3C, r0                     ! r0 = 0x01EC (position base offset)
    mul.l r3, r2                       ! speed * coefficient
    mov.l @(r0, r14), r3               ! r3 = car[+0x1EC] (position base)
    sts macl, r2                       ! r2 = product (low 32 bits)
    add #0x8, r0                       ! r0 = 0x01F4 (integrated position offset)
    add r3, r2                         ! r2 = position + speed*coeff
    mov.l r2, @(r0, r14)               ! car[+0x1F4] = integrated position
    add #-0x8, r0                      ! r0 = 0x01EC (position base offset)
    mov.l @(r0, r14), r0               ! r0 = car[+0x1EC] (check if car active)
    tst r0, r0                         ! test if position base == 0
    bf      .L_epilogue                ! nonzero → car active, skip cleanup
    mov #0x0, r3                       ! r3 = 0 (clear value)
    .byte   0x90, 0x2B    /* mov.w .L_wpool_0600E9E4, r0 */  ! r0 = 0x021C (speed field offset)
    mov.l r3, @(r0, r14)               ! car[+0x21C] = 0 (clear speed field)
    .byte   0x93, 0x2A    /* mov.w .L_wpool_0600E9E6, r3 */  ! r3 = 0x0200 (timer reset value)
    add #-0x18, r0                     ! r0 = 0x0204 (timer field offset)
    mov.l r3, @(r0, r14)               ! car[+0x204] = 0x200 (reset timer)
.L_epilogue:
    lds.l @r15+, macl                  ! restore multiply accumulator
    lds.l @r15+, pr                    ! restore return address
    rts                                ! return
    mov.l @r15+, r14                   ! (delay) restore r14
