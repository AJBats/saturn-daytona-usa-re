/* evt_boundary_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040F82 - 0x06041034
 * Auto-generated by tools/generate_l3_tu.py
 *
 * This TU contains event boundary locking primitives used by the
 * system boot sequence and timer overflow handler to serialise
 * access to shared event state.
 *
 * Functions:
 *   evt_boundary_check  -- query mesh boundary, return masked 24-bit result
 *   sym_06040FB8         -- acquire event boundary lock (returns seq or -5)
 *   sym_06040FEA         -- release event boundary lock (validates seq)
 *   sym_06041014         -- check if event boundary is active for given seq
 *
 * Lock structure at sym_060A5400 (pointer to struct):
 *   +48 (0x30): lock flag   (0 = free, 1 = held)
 *   +56 (0x38): sequence counter
 */

    .section .text.FUN_06040F82


/*----------------------------------------------------------------------
 * evt_boundary_check
 *
 * Queries mesh boundary twice: first with key=0 to get the initial
 * boundary byte, then with that byte as key. Returns the 32-bit
 * result masked to 24 bits (strips cache-through / upper address bits).
 *
 * Returns: r0 = boundary result & 0x00FFFFFF
 *----------------------------------------------------------------------*/
    .global evt_boundary_check
    .type evt_boundary_check, @function
evt_boundary_check:
    sts.l pr, @-r15                       ! save return address
    add #-0x4, r15                        ! allocate 4 bytes on stack (local buf)
    mov r15, r5                           ! r5 = &buf (output param)
    .byte   0xD3, 0x09    /* mov.l .L_fn_mesh_boundary, r3 */
    jsr @r3                               ! mesh_boundary_check(0, &buf)
    mov #0x0, r4                          ! r4 = 0 (initial key) [delay slot]
    mov r15, r5                           ! r5 = &buf (output param, reuse)
    mov r15, r4                           ! r4 = &buf (to read result byte)
    .byte   0xD3, 0x07    /* mov.l .L_fn_mesh_boundary, r3 */
    mov.b @r4, r4                         ! r4 = buf[0] (boundary byte from first call)
    jsr @r3                               ! mesh_boundary_check(boundary_byte, &buf)
    extu.b r4, r4                         ! r4 = zero-extend byte to word [delay slot]
    mov r15, r0                           ! r0 = &buf
    .byte   0xD3, 0x05    /* mov.l .L_mask_24bit, r3 */
    mov.l @r0, r0                         ! r0 = buf (32-bit result from second call)
    add #0x4, r15                         ! free stack local
    lds.l @r15+, pr                       ! restore return address
    rts                                   ! return r0 & 0x00FFFFFF
    and r3, r0                            ! r0 = result & 0x00FFFFFF [delay slot]
    .4byte  0x0000FFFF
    .4byte  0x00008000
.L_fn_mesh_boundary:
    .4byte  mesh_boundary_check           /* mesh boundary validator */
.L_mask_24bit:
    .4byte  0x00FFFFFF                  /* low 24-bit mask */

/*----------------------------------------------------------------------
 * sym_06040FB8 -- acquire event boundary lock
 *
 * Acquires the event boundary lock. If already held, returns -5
 * immediately. Otherwise sets the lock flag to 1, increments the
 * sequence counter (clamping to non-negative), and returns the
 * new sequence value.
 *
 * Returns: r0 = sequence counter, or -5 if already locked
 *----------------------------------------------------------------------*/
    .global sym_06040FB8
sym_06040FB8:
    .byte   0xD4, 0x15    /* mov.l .L_ptr_lock_state, r4 */
    mov.l @r4, r0                         ! r0 = lock_state (ptr to struct)
    mov.l @(48, r0), r0                   ! r0 = lock_state->lock_flag (+0x30)
    cmp/eq #0x1, r0                       ! already locked?
    bf      .L_not_locked                 ! branch if lock is free
    rts                                   ! return -5 (already locked)
    mov #-0x5, r0                         ! r0 = -5 error code [delay slot]
.L_not_locked:
    mov #0x1, r3                          ! r3 = 1 (lock value)
    mov.l @r4, r2                         ! r2 = lock_state
    mov.l r3, @(48, r2)                   ! lock_state->lock_flag = 1
    mov.l @r4, r2                         ! r2 = lock_state (reload)
    mov.l @(56, r2), r3                   ! r3 = lock_state->sequence (+0x38)
    add #0x1, r3                          ! r3 = sequence + 1
    mov.l r3, @(56, r2)                   ! lock_state->sequence = sequence + 1
    mov.l @r4, r2                         ! r2 = lock_state (reload)
    mov.l @(56, r2), r3                   ! r3 = lock_state->sequence (updated)
    cmp/pz r3                             ! sequence >= 0?
    bt      .L_seq_nonneg                 ! branch if non-negative
    mov.l @r4, r3                         ! r3 = lock_state
    mov #0x0, r2                          ! r2 = 0
    mov.l r2, @(56, r3)                   ! lock_state->sequence = 0 (clamp)
.L_seq_nonneg:
    mov.l @r4, r0                         ! r0 = lock_state
    mov.l @(56, r0), r0                   ! r0 = lock_state->sequence
    rts                                   ! return sequence counter
    nop                                   ! [delay slot]

/*----------------------------------------------------------------------
 * sym_06040FEA -- release event boundary lock
 *
 * Releases the event boundary lock. Validates that the lock is
 * currently held and that the caller's sequence handle (r4) matches
 * the current sequence counter. Returns 0 on success.
 *
 * r4 = expected sequence handle
 * Returns: r0 = 0 on success, -7 if not locked, -9 if seq mismatch
 *----------------------------------------------------------------------*/
    .global sym_06040FEA
sym_06040FEA:
    .byte   0xD5, 0x09    /* mov.l .L_ptr_lock_state, r5 */
    mov.l @r5, r3                         ! r3 = lock_state
    mov.l @(48, r3), r0                   ! r0 = lock_state->lock_flag
    tst r0, r0                            ! lock_flag == 0? (not locked)
    bf      .L_is_locked                  ! branch if lock IS held
    rts                                   ! return -7 (not locked)
    mov #-0x7, r0                         ! r0 = -7 error code [delay slot]
.L_is_locked:
    mov.l @r5, r3                         ! r3 = lock_state
    mov.l @(56, r3), r2                   ! r2 = lock_state->sequence
    cmp/eq r4, r2                         ! sequence == expected handle?
    bt      .L_seq_match                  ! branch if match
    rts                                   ! return -9 (sequence mismatch)
    mov #-0x9, r0                         ! r0 = -9 error code [delay slot]
.L_seq_match:
    mov #0x0, r4                          ! r4 = 0
    mov.l @r5, r2                         ! r2 = lock_state
    mov.l r4, @(48, r2)                   ! lock_state->lock_flag = 0 (release)
    mov r4, r0                            ! r0 = 0 (success)
    rts                                   ! return 0
    nop                                   ! [delay slot]
.L_ptr_lock_state:
    .4byte  sym_060A5400                  /* event boundary lock state */

/*----------------------------------------------------------------------
 * sym_06041014 -- check if event boundary is active
 *
 * Tests whether the event boundary lock is held AND the sequence
 * counter matches the given handle. Returns 1 if active, 0 if not.
 *
 * r4 = sequence handle to check
 * Returns: r0 = 1 if active and matching, 0 otherwise
 *----------------------------------------------------------------------*/
    .global sym_06041014
sym_06041014:
    .byte   0xD5, 0x11    /* mov.l .L_ptr_lock_state, r5 */
    mov.l @r5, r3                         ! r3 = lock_state
    mov.l @(48, r3), r0                   ! r0 = lock_state->lock_flag
    tst r0, r0                            ! lock_flag == 0? (not locked)
    bf      .L_check_active               ! branch if lock IS held
    rts                                   ! return 0 (not locked)
    mov #0x0, r0                          ! r0 = 0 [delay slot]
.L_check_active:
    mov.l @r5, r0                         ! r0 = lock_state
    mov.l @(56, r0), r3                   ! r3 = lock_state->sequence
    cmp/eq r4, r3                         ! sequence == expected handle?
    bf      .L_no_match                   ! branch if mismatch
    bra     .L_return                     ! branch to return
    mov #0x1, r0                          ! r0 = 1 (active) [delay slot]
.L_no_match:
    mov #0x0, r0                          ! r0 = 0 (not active / wrong seq)
.L_return:
    rts                                   ! return r0
    nop                                   ! [delay slot]
