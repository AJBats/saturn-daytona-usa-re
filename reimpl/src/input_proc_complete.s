/* input_proc_complete -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06035F44 - 0x06036144
 * Auto-generated by tools/generate_l3_tu.py
 *
 * This TU contains five C runtime library functions compiled into the game
 * binary by the Sega SDK toolchain (Hitachi SH-2 GCC / Cygnus).
 *
 * Functions:
 *   input_proc_complete   -- udiv_32: unsigned 32-bit division
 *                           Input:  r0 = divisor, r1 = dividend
 *                           Output: r0 = r1 / r0 (unsigned quotient)
 *                           On divide-by-zero: stores 0x44E to error flag
 *                           variable (sym_060A246C), returns 0.
 *                           Uses SH-2 div0u/div1 hardware division, 32 iterations.
 *
 *   sym_06035FEC          -- strcpy_unaligned: byte-by-byte string copy
 *                           Input:  r0 = dst, r1 = src
 *                           Output: r0 = dst (original pointer)
 *                           Checks alignment of both pointers; if both are
 *                           word-aligned, jumps to sym_06036CB0 (fast
 *                           word-aligned strcpy). Otherwise copies bytes
 *                           in groups of 4 until null terminator found.
 *
 *   sym_06036068          -- lshr_dispatch: variable-count logical shift right
 *                           Input:  r0 = value, r1 = shift count
 *                           Output: r0 = r0 >> r1 (logical, unsigned)
 *                           Uses a jump table (sym_0603603C) indexed by shift
 *                           count to dispatch to the right number of shlr/shlr2
 *                           instructions, avoiding the loop overhead of a
 *                           variable shift. Handles 0..31 bit shifts.
 *
 *   sym_06036086          -- lshr_targets: shift execution targets
 *                           (Not called directly — jumped into by lshr_dispatch.)
 *                           Multiple entry points, each performing a specific
 *                           number of right shifts via shlr/shlr2/and sequences.
 *
 *   sym_060360FC          -- memmove: safe overlapping memory copy
 *                           Input:  r4 = dst, r5 = src, r6 = count
 *                           Output: r0 = dst (original pointer)
 *                           If dst < src, copies forward byte-by-byte.
 *                           If dst > src, copies backward byte-by-byte.
 *                           If dst == src, returns immediately.
 *
 * sym_0603603C is the shift-offset jump table used by lshr_dispatch.
 */

    .section .text.FUN_06035F44


    .global input_proc_complete
    .type input_proc_complete, @function
input_proc_complete:                            ! udiv_32: unsigned 32-bit division
    tst r0, r0                                  ! test if divisor == 0
    mov.l r2, @-r15                             ! save r2
    bt      .L_udiv_by_zero                     ! divisor is zero → error path
    mov #0x0, r2                                ! r2 = 0 (accumulator for div1)
    div0u                                       ! clear M/Q/T flags for unsigned division
    rotcl r1                                    ! shift dividend bit 31 into T
    div1 r0, r2                                 ! division step  1
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  2
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  3
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  4
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  5
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  6
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  7
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  8
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step  9
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 10
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 11
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 12
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 13
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 14
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 15
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 16
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 17
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 18
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 19
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 20
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 21
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 22
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 23
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 24
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 25
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 26
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 27
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 28
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 29
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 30
    rotcl r1                                    ! shift next bit into T
    div1 r0, r2                                 ! division step 31
    rotcl r1                                    ! shift final bit into T
    div1 r0, r2                                 ! division step 32 (quotient now in r1)
    rotcl r1                                    ! final rotate: r1 = quotient
    mov r1, r0                                  ! r0 = quotient (return value)
    rts                                         ! return
    mov.l @r15+, r2                             ! restore r2 (delay slot)
.L_udiv_by_zero:                                ! --- divide-by-zero handler ---
    mov.l   .L_ptr_udiv_error, r2              ! r2 = ptr to error flag variable
    mov.l   .L_udiv_error_code, r1             ! r1 = error code 0x44E
    mov #0x0, r0                                ! return 0
    mov.l r1, @r2                               ! store error code to flag variable
    rts                                         ! return
    mov.l @r15+, r2                             ! restore r2 (delay slot)
    .2byte  0x0009                              ! alignment pad (nop encoding)
.L_ptr_udiv_error:
    .4byte  sym_060A246C
.L_udiv_error_code:
    .4byte  0x0000044E

    .global sym_06035FEC
sym_06035FEC:                                   ! strcpy_unaligned: byte-by-byte string copy
    mov.l r3, @-r15                             ! save r3
    mov.l r4, @-r15                             ! save r4
    mov #0x3, r3                                ! r3 = 0x3 (alignment mask)
    mov r0, r4                                  ! r4 = dst low bits
    and r3, r4                                  ! r4 = dst & 0x3 (alignment offset)
    and r1, r3                                  ! r3 = src & 0x3 (alignment offset)
    or r4, r3                                   ! r3 = combined alignment bits
    tst r3, r3                                  ! both word-aligned? (r3 == 0?)
    bt      .L_strcpy_both_aligned              ! yes → use fast word-aligned path
    mov r0, r4                                  ! r4 = dst (save original for return)
    mov.b @r1+, r0                              ! read first byte from src
    mov r4, r3                                  ! r3 = current dst write pointer
.L_strcpy_byte_loop:                            ! --- byte-by-byte copy loop (4 bytes per iter) ---
    cmp/eq #0x0, r0                             ! is byte null terminator?
    mov.b r0, @r3                               ! store byte to dst[0]
    bt      .L_strcpy_return                    ! yes → done
    mov.b @r1+, r0                              ! read next byte from src
    cmp/eq #0x0, r0                             ! null?
    mov.b r0, @(1, r3)                          ! store byte to dst[1]
    bt      .L_strcpy_return                    ! yes → done
    mov.b @r1+, r0                              ! read next byte from src
    cmp/eq #0x0, r0                             ! null?
    mov.b r0, @(2, r3)                          ! store byte to dst[2]
    bt      .L_strcpy_return                    ! yes → done
    mov.b @r1+, r0                              ! read next byte from src
    cmp/eq #0x0, r0                             ! null?
    mov.b r0, @(3, r3)                          ! store byte to dst[3]
    bt      .L_strcpy_return                    ! yes → done
    mov.b @r1+, r0                              ! read next byte from src
    bra     .L_strcpy_byte_loop                 ! loop back for next 4 bytes
    add #0x4, r3                                ! r3 += 4 (advance dst pointer, delay slot)
.L_strcpy_return:                               ! --- return original dst ---
    mov r4, r0                                  ! r0 = original dst (return value)
    mov.l @r15+, r4                             ! restore r4
    rts                                         ! return
    mov.l @r15+, r3                             ! restore r3 (delay slot)
.L_strcpy_both_aligned:                         ! --- both pointers word-aligned → fast path ---
    mov.l   .L_ptr_strcpy_fast, r3             ! r3 = ptr to sym_06036CB0 (word-aligned strcpy)
    jmp @r3                                     ! tail-call fast strcpy
    nop                                         ! delay slot
    .2byte  0x0009                              ! alignment pad (nop encoding)
.L_ptr_strcpy_fast:
    .4byte  sym_06036CB0

    .global sym_0603603C
sym_0603603C:                                   ! lshr_jump_table: byte offsets for shift dispatch
    mov.b @(r0, r0), r14                        ! (raw data — not executed as code)
    .word 0x0A08 /* UNKNOWN */
    .4byte  loc_06040200
    .4byte  0x201E1C1A
    .4byte  0x18161412
    .4byte  0x3432302E
    .4byte  0x2C2A2826
    .4byte  0x403E3C3A
    .4byte  0x4856626C
    .4byte  0x2F264111
    .4byte  0x8F18E220
    .4byte  0x3123890B

    .global sym_06036068
sym_06036068:                                   ! lshr_dispatch: variable-count logical shift right
    mov.l   .L_ptr_lshr_jump_table, r2        ! r2 = ptr to shift offset table
    add r1, r2                                  ! r2 = &table[shift_count]
    mov.b @r2, r2                               ! r2 = signed byte offset to shift target
    mov.l   .L_ptr_lshr_base, r1              ! r1 = base address (sym_06036086)
    add r2, r1                                  ! r1 = target address for this shift count
    jmp @r1                                     ! jump to shift target
    nop                                         ! delay slot
    .2byte  0x0009                              ! alignment pad (nop encoding)
.L_ptr_lshr_base:
    .4byte  sym_06036086
.L_ptr_lshr_jump_table:
    .4byte  sym_0603603C
    .4byte  0xE000000B                          ! (shift-0 case: mov #0, r0 / rts)
    .2byte  0x62F6                              ! (mov.l @r15+, r2 — restore r2)

    .global sym_06036086
sym_06036086:                                   ! lshr_targets: shift execution entry points
    shlr r0                                     ! shift right by 1 (bit 0 → T)
    shlr r0                                     ! shift right by 1
    shlr r0                                     ! shift right by 1
    shlr r0                                     ! shift right by 1
    shlr r0                                     ! shift right by 1
    shlr r0                                     ! shift right by 1
    shlr r0                                     ! shift right by 1 (total: 7 bits)
    rts                                         ! return (entry for shift-by-7)
    mov.l @r15+, r2                             ! restore r2 (delay slot)
    .4byte  0x40014001                          ! shlr r0 / shlr r0 (shift by 8, entry +0x12)
    .4byte  0x40014001                          ! shlr r0 / shlr r0
    .4byte  0x40014001                          ! shlr r0 / shlr r0
    .4byte  0x40014019                          ! shlr r0 / shlr8 r0 (total: 14 bits)
    .4byte  0x000B62F6                          ! rts / mov.l @r15+, r2
    .4byte  0x40014001                          ! shlr r0 / shlr r0 (shift by 15, entry +0x26)
    .4byte  0x40014001                          ! shlr r0 / shlr r0
    .4byte  0x40014001                          ! shlr r0 / shlr r0
    .4byte  0x40014029                          ! shlr r0 / shlr16 r0 (total: 22 bits)
    .4byte  0x000B62F6                          ! rts / mov.l @r15+, r2
    .4byte  0x40014001                          ! shlr r0 / shlr r0
    .4byte  0x40014019                          ! shlr r0 / shlr8 r0
    .4byte  0x4029000B                          ! shlr16 r0 / rts (total: 27 bits)
    .4byte  0x62F64004                          ! mov.l @r15+, r2 / shll r0
    .4byte  0x40044004                          ! shll r0 / shll r0
    .4byte  0x4004C90F                          ! shll r0 / and #0x0F, r0 (mask low 4 bits)
    .4byte  0x000B62F6                          ! rts / mov.l @r15+, r2
    .4byte  0x40044004                          ! shll r0 / shll r0
    .4byte  0x4004C907                          ! shll r0 / and #0x07, r0 (mask low 3 bits)
    .4byte  0x000B62F6                          ! rts / mov.l @r15+, r2
    .4byte  0x40044004                          ! shll r0 / shll r0
    .4byte  0xC903000B                          ! and #0x03, r0 / rts (mask low 2 bits)
    .4byte  0x62F64004                          ! mov.l @r15+, r2 / shll r0
    .4byte  0xC901000B                          ! and #0x01, r0 / rts (mask low 1 bit)
    .4byte  0x62F60000                          ! mov.l @r15+, r2 / padding

    .global sym_060360FC
sym_060360FC:                                   ! memmove: safe overlapping memory copy
    mov.l r13, @-r15                            ! save r13
    cmp/eq r5, r4                               ! dst == src?
    bt      .L_memmove_return                   ! yes → nothing to do, return
    cmp/hs r5, r4                               ! dst >= src? (unsigned)
    bt/s    .L_memmove_backward                 ! yes → copy backward to avoid overlap
    mov #0x0, r7                                ! r7 = 0 (byte counter, delay slot)
    mov r4, r13                                 ! r13 = dst (forward write pointer)
    mov r5, r0                                  ! r0 = src (forward read pointer)
    cmp/hs r6, r7                               ! counter >= count? (count == 0?)
    bt/s    .L_memmove_return                   ! yes → nothing to copy
    mov r7, r5                                  ! r5 = 0 (byte counter, delay slot)
.L_memmove_fwd_loop:                            ! --- forward copy loop (byte-by-byte) ---
    mov r13, r2                                 ! r2 = current dst address
    mov.b @r0+, r1                              ! r1 = *src++
    add #0x1, r5                                ! r5++ (byte counter)
    add #0x1, r13                               ! r13++ (advance dst pointer)
    cmp/hs r6, r5                               ! counter >= count?
    bf/s    .L_memmove_fwd_loop                 ! no → continue loop
    mov.b r1, @r2                               ! *dst = r1 (delay slot)
    bra     .L_memmove_return                   ! done → return
    nop                                         ! delay slot
.L_memmove_backward:                            ! --- backward copy (dst > src) ---
    mov r4, r13                                 ! r13 = dst
    mov r5, r0                                  ! r0 = src
    add r6, r13                                 ! r13 = dst + count (end of dst)
    add r6, r0                                  ! r0 = src + count (end of src)
    cmp/hs r6, r7                               ! counter >= count? (count == 0?)
    bt/s    .L_memmove_return                   ! yes → nothing to copy
    mov r7, r5                                  ! r5 = 0 (byte counter, delay slot)
.L_memmove_bwd_loop:                            ! --- backward copy loop (byte-by-byte) ---
    add #-0x1, r0                               ! r0-- (decrement src pointer)
    add #0x1, r5                                ! r5++ (byte counter)
    mov.b @r0, r3                               ! r3 = *src
    cmp/hs r6, r5                               ! counter >= count?
    bf/s    .L_memmove_bwd_loop                 ! no → continue loop
    mov.b r3, @-r13                             ! *--dst = r3 (delay slot)
.L_memmove_return:                              ! --- return original dst ---
    mov r4, r0                                  ! r0 = original dst (return value)
    rts                                         ! return
    mov.l @r15+, r13                            ! restore r13 (delay slot)
