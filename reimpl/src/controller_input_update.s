/* VERIFIED: controller input state updater — reads SMPC peripheral data,
 * NOT-inverts active-LOW encoding, writes processed button state to g_pad_state.
 * Method: watchpoint on g_pad_state at mode select screen
 *   DOWN:  word[+0]=0x2000, word[+2]=0x2000  (SMPC bit 13 = DOWN)
 *   UP:    word[+0]=0x1000, word[+2]=0x1000  (SMPC bit 12 = UP)
 *   LEFT:  word[+0]=0x4000, word[+2]=0x4000  (SMPC bit 14 = LEFT)
 *   RIGHT: word[+0]=0x8000, word[+2]=0x8000  (SMPC bit 15 = RIGHT)
 *   C:     word[+0]=0x0200, word[+2]=0x0200  (SMPC bit 9 = C)
 *   No button: no writes at all.
 *   All writes come from controller_input_update (PC +0x5E and +0x62).
 *   Static analysis confirms data source is SMPC OREGs via smpc_data_manage.
 * Date: 2026-02-28
 */
/* controller_input_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06005198 - 0x06005294
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06005198


/*
 * controller_input_update (FUN_06005198)
 *
 * Reads buffered SMPC peripheral data (active-LOW button bits), NOT-inverts
 * to active-HIGH, and writes the processed button state to g_pad_state.
 * This is the sole producer of the global pad state struct read by 30+
 * functions throughout the game (menus, racing, transitions).
 *
 * Called from the VBlank-OUT handler (vblank_out_handler) every frame.
 *
 * Process:
 *   1. Call smpc_data_manage(&stack_slot) to obtain a pointer to the
 *      current SMPC peripheral data buffer (returned via @r15).
 *   2. Read two sets of button data from the buffer:
 *        - Port 1: offsets 0x00, 0x08, 0x02 (button words, active-LOW)
 *        - Port 2: offsets 0x12, 0x1A, 0x14 (button words, active-LOW)
 *   3. Bitwise-invert each word (NOT) to convert active-LOW to active-HIGH.
 *   4. Read a status byte from each port (offset 0x10, 0x22).
 *   5. Check sym_06059F44:
 *        - If == 1 (first frame): write state directly to output struct.
 *        - Otherwise: OR into existing values (accumulate edge-triggered presses).
 *   6. If the status word (offset 6) == 0x20, clear all output words to zero
 *      (controller disconnected or reset condition).
 *
 * Output struct layout at g_pad_state (16 bytes):
 *   word[+0]: held buttons (port 1) — currently pressed, active-HIGH
 *   word[+2]: edge-triggered presses (port 1) — newly pressed this frame
 *   word[+4]: held buttons raw / status (port 1)
 *   word[+6]: status byte (port 1)
 *   word[+8..+14]: port 2 equivalent (unused in single-player)
 *
 * Button masks (standard Saturn SMPC, after NOT inversion):
 *   0x8000=R  0x4000=L  0x2000=D  0x1000=U
 *   0x0800=Start  0x0400=A  0x0200=C  0x0100=B
 *
 * Registers:
 *   r14 = &pad_state (g_pad_state, output structure)
 *   r13 = port 2 button word (inverted)
 *   r12 = port 1 edge-trigger word (inverted)
 *   r1  = port 1 held word (inverted)
 *   r5  = port 1 status word (inverted)
 *   r6  = port 2 held word (inverted)
 *   r7  = port 2 edge-trigger word (inverted)
 *
 * Pool constants:
 *   .L_pool_pad_state        -> g_pad_state (global pad state output)
 *   .L_pool_smpc_data_mgr    -> smpc_data_manage (SMPC buffer accessor)
 *   .L_pool_frame_flag       -> sym_06059F44 (frame/animation state flag)
 */

    .global controller_input_update
    .type controller_input_update, @function
controller_input_update:
    mov.l r14, @-r15                       ! save r14
    mov.l r13, @-r15                       ! save r13
    mov.l r12, @-r15                       ! save r12
    sts.l pr, @-r15                        ! save return address
    add #-0x4, r15                         ! allocate 4 bytes on stack for periph data ptr
    mov.l   .L_pool_pad_state, r14         ! r14 = &pad_state output struct (g_pad_state)
    mov.l   .L_pool_smpc_data_mgr, r3     ! r3 = &smpc_data_manage
    jsr @r3                                ! call smpc_data_manage(r4) — returns periph data ptr in @r15
    mov r15, r4                            ! [delay] r4 = &stack_slot (output param for periph data ptr)
    mov.l @r15, r1                         ! r1 = peripheral data buffer pointer (returned by smpc_data_manage)
    mov.w @r1, r1                          ! r1 = primary rect X1 word (offset 0x00)
    extu.w r1, r1                          ! zero-extend X1 to 32-bit
    not r1, r1                             ! invert X1 (complement decode)
    extu.w r1, r1                          ! mask to 16-bit: r1 = decoded X1
    mov.l @r15, r12                        ! r12 = display list entry pointer (reload)
    mov.w @(8, r12), r0                    ! r0 = primary rect Y1 word (offset 0x08)
    mov r0, r12                            ! r12 = raw Y1
    extu.w r12, r12                        ! zero-extend Y1
    not r12, r12                           ! invert Y1
    extu.w r12, r12                        ! mask to 16-bit: r12 = decoded Y1
    mov.l @r15, r5                         ! r5 = display list entry pointer (reload)
    mov.w @(2, r5), r0                     ! r0 = primary rect width word (offset 0x02)
    mov r0, r5                             ! r5 = raw width
    not r5, r5                             ! invert width
    extu.w r5, r5                          ! mask to 16-bit: r5 = decoded width1
    mov.l @r15, r4                         ! r4 = display list entry pointer (reload)
    add #0x12, r4                          ! r4 = &secondary rect base (entry + 0x12)
    mov.w @r4, r6                          ! r6 = secondary rect X2 word (offset 0x12)
    extu.w r6, r6                          ! zero-extend X2
    not r6, r6                             ! invert X2
    extu.w r6, r6                          ! mask to 16-bit: r6 = decoded X2
    mov.w @(8, r4), r0                     ! r0 = secondary rect Y2 word (offset 0x1A)
    mov r0, r7                             ! r7 = raw Y2
    extu.w r7, r7                          ! zero-extend Y2
    not r7, r7                             ! invert Y2
    extu.w r7, r7                          ! mask to 16-bit: r7 = decoded Y2
    mov.w @(2, r4), r0                     ! r0 = secondary rect width word (offset 0x14)
    mov r0, r13                            ! r13 = raw width2
    not r13, r13                           ! invert width2
    mov.l   .L_pool_frame_flag, r0         ! r0 = &frame_flag (sym_06059F44)
    mov.l @r0, r0                          ! r0 = current frame flag value
    cmp/eq #0x1, r0                        ! T = (frame_flag == 1)?
    bf/s    .L_accumulate_coords           ! if not first frame, OR into existing values
    extu.w r13, r13                        ! [delay] mask to 16-bit: r13 = decoded width2
    mov r14, r4                            ! r4 = &viewport_state[0] (output base)
    mov.w r1, @r4                          ! viewport[0] = decoded X1 (primary)
    mov r12, r0                            ! r0 = decoded Y1
    mov.w r0, @(2, r4)                     ! viewport[2] = decoded Y1 (primary)
    mov r5, r0                             ! r0 = decoded width1
    mov.w r0, @(4, r4)                     ! viewport[4] = decoded width1 (primary)
    mov.l @r15, r3                         ! r3 = display list entry pointer (reload)
    mov #0x10, r0                          ! r0 = 0x10 (priority byte offset in primary rect)
    mov.b @(r0, r3), r3                    ! r3 = primary rect priority/depth byte
    extu.b r3, r0                          ! zero-extend priority to 16-bit
    mov.w r0, @(6, r4)                     ! viewport[6] = priority byte (primary)
    add #0x8, r4                           ! r4 = &viewport_state[8] (secondary output base)
    mov.w r6, @r4                          ! viewport[8] = decoded X2 (secondary)
    mov r7, r0                             ! r0 = decoded Y2
    mov.w r0, @(2, r4)                     ! viewport[10] = decoded Y2 (secondary)
    mov r13, r0                            ! r0 = decoded width2
    mov.w r0, @(4, r4)                     ! viewport[12] = decoded width2 (secondary)
    mov.l @r15, r3                         ! r3 = display list entry pointer (reload)
    add #0x12, r3                          ! r3 = &secondary rect base (entry + 0x12)
    mov #0x10, r0                          ! r0 = 0x10 (priority byte offset in secondary rect)
    mov.b @(r0, r3), r3                    ! r3 = secondary rect priority/depth byte
    extu.b r3, r0                          ! zero-extend priority to 16-bit
    bra     .L_check_occluded              ! jump to occlusion check
    mov.w r0, @(6, r4)                     ! [delay] viewport[14] = priority byte (secondary)
.L_pool_pad_state:
    .4byte  g_pad_state
.L_pool_smpc_data_mgr:
    .4byte  smpc_data_manage
.L_pool_frame_flag:
    .4byte  sym_06059F44
.L_accumulate_coords:
    mov r14, r4                            ! r4 = &viewport_state[0] (output base)
    extu.w r1, r1                          ! re-mask X1 to 16-bit
    mov.w @r4, r2                          ! r2 = existing viewport[0]
    or r1, r2                              ! accumulate X1 via OR
    mov.w r2, @r4                          ! viewport[0] |= decoded X1
    extu.w r12, r12                        ! re-mask Y1 to 16-bit
    mov.w @(2, r4), r0                     ! r0 = existing viewport[2]
    mov r0, r3                             ! r3 = existing Y1
    or r12, r3                             ! accumulate Y1 via OR
    mov r3, r0                             ! r0 = accumulated Y1
    mov.w r0, @(2, r4)                     ! viewport[2] |= decoded Y1
    mov r5, r0                             ! r0 = decoded width1
    mov.w r0, @(4, r4)                     ! viewport[4] = decoded width1 (overwritten, not OR'd)
    add #0x8, r4                           ! r4 = &viewport_state[8] (secondary output base)
    extu.w r6, r6                          ! re-mask X2 to 16-bit
    mov.w @r4, r3                          ! r3 = existing viewport[8]
    or r6, r3                              ! accumulate X2 via OR
    mov.w r3, @r4                          ! viewport[8] |= decoded X2
    extu.w r7, r7                          ! re-mask Y2 to 16-bit
    mov.w @(2, r4), r0                     ! r0 = existing viewport[10]
    mov r0, r2                             ! r2 = existing Y2
    or r7, r2                              ! accumulate Y2 via OR
    mov r2, r0                             ! r0 = accumulated Y2
    mov.w r0, @(2, r4)                     ! viewport[10] |= decoded Y2
    mov r13, r0                            ! r0 = decoded width2
    mov.w r0, @(4, r4)                     ! viewport[12] = decoded width2 (overwritten, not OR'd)
.L_check_occluded:
    mov.w @(6, r14), r0                    ! r0 = viewport[6] (primary priority byte)
    extu.w r0, r0                          ! zero-extend to 32-bit
    cmp/eq #0x20, r0                       ! T = (priority == 0x20)?
    bf      .L_epilogue                    ! if not 0x20, keep coords and return
    mov #0x0, r4                           ! r4 = 0 (clear value)
    mov r14, r5                            ! r5 = &viewport_state[0]
    mov.w r4, @r5                          ! viewport[0] = 0 (clear X1)
    extu.w r4, r0                          ! r0 = 0
    mov.w r0, @(2, r5)                     ! viewport[2] = 0 (clear Y1)
    extu.w r4, r0                          ! r0 = 0
    mov.w r0, @(4, r5)                     ! viewport[4] = 0 (clear width1)
    add #0x8, r5                           ! r5 = &viewport_state[8]
    extu.w r4, r3                          ! r3 = 0
    mov.w r3, @r5                          ! viewport[8] = 0 (clear X2)
    extu.w r4, r2                          ! r2 = 0
    mov r2, r0                             ! r0 = 0
    mov.w r0, @(2, r5)                     ! viewport[10] = 0 (clear Y2)
    extu.w r4, r4                          ! r4 = 0
    mov r4, r0                             ! r0 = 0
    mov.w r0, @(4, r5)                     ! viewport[12] = 0 (clear width2)
.L_epilogue:
    add #0x4, r15                          ! free stack slot
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return
    mov.l @r15+, r14                       ! [delay] restore r14
