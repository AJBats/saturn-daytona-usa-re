/* vblank_color_apply -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603EDC4 - 0x0603EF64
 * Auto-generated by tools/generate_l3_tu.py
 *
 * vblank_color_apply:
 *   Applies per-channel color bit manipulation to an 8-byte color buffer.
 *   Called from color_transform_calc during VBlank to apply palette fades
 *   and color offset effects. Each of 8 channels (bits 0-7 in r5) maps to
 *   a byte in the buffer at r6. For each enabled channel, the corresponding
 *   byte is either OR'd with r7 (set bits) or AND'd with ~r7 (clear bits),
 *   controlled by the matching bit in r4.
 *
 *   Args:
 *     r4 = direction mask — bit=1 means OR (set), bit=0 means AND (clear)
 *     r5 = channel enable mask — which channels to process
 *     r6 = pointer to 8-byte color buffer
 *     r7 = OR value (bits to set, zero-extended to byte)
 *     @(3, r15) = AND mask (bits to preserve when clearing)
 *
 *   Buffer layout at r6:
 *     [0] = channel 3 (bit 3)    [4] = channel 5 (bit 5, via word pool 0x0100)
 *     [1] = channel 2 (bit 2)    [5] = channel 0 (bit 0)
 *     [2] = channel 5 (bit 5)    [6] = channel 7 (bit 17)
 *     [3] = channel 4 (bit 4)    [7] = channel 6 (bit 16)
 *
 * color_transform_init:
 *   Initializes a 24-byte color transform descriptor at r4.
 *   Sets callback pointer (r5), zeros all channels, sets mode to 1.
 *
 * color_transform_set_params:
 *   Writes RGB target values (r5, r6, r7) into a color transform descriptor
 *   at r4, and clears the progress/status fields.
 */

    .section .text.FUN_0603EDC4


    .global vblank_color_apply
    .type vblank_color_apply, @function
vblank_color_apply:
    mov.b @(3, r15), r0              ! r0 = AND mask from caller's stack frame
    mov #0x4, r3                     ! r3 = bit 2 mask (0x04)
    mov r0, r1                       ! r1 = AND mask (preserved for clear paths)
    and r5, r3                       ! r3 = channel_enable & 0x04 (channel 2)
    tst r3, r3                       ! test if channel 2 is enabled
    bf      .L_ch2_enabled           ! branch if channel 2 bit set in enable mask
    mov #0x2, r3                     ! r3 = bit 1 mask (0x02)
    and r5, r3                       ! r3 = channel_enable & 0x02 (channel 1)
    tst r3, r3                       ! test if channel 1 is enabled
    bt      .L_ch2_done              ! skip channel 2 processing entirely
.L_ch2_enabled:
    mov #0x4, r3                     ! r3 = bit 2 mask (0x04)
    and r4, r3                       ! r3 = direction & 0x04
    tst r3, r3                       ! test direction for channel 2
    bf      .L_ch2_set_bits          ! if bit set in direction, go to OR path
    mov #0x2, r3                     ! r3 = bit 1 mask (0x02)
    and r4, r3                       ! r3 = direction & 0x02
    tst r3, r3                       ! test direction for channel 1
    bt      .L_ch2_clear_bits        ! if bit clear in direction, go to AND path
.L_ch2_set_bits:
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @(1, r6), r0               ! r0 = current value of buffer[1]
    mov r0, r2                       ! r2 = copy of buffer[1]
    or r3, r2                        ! r2 = buffer[1] | OR_value (set bits)
    bra     .L_ch2_store             ! jump to store result
    mov r2, r0                       ! r0 = result (delay slot)
.L_ch2_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @(1, r6), r0               ! r0 = current value of buffer[1]
    mov r0, r3                       ! r3 = copy of buffer[1]
    and r2, r3                       ! r3 = buffer[1] & AND_mask (clear bits)
    mov r3, r0                       ! r0 = result
.L_ch2_store:
    mov.b r0, @(1, r6)              ! buffer[1] = updated channel 2 value
.L_ch2_done:
    mov #0x8, r3                     ! r3 = bit 3 mask (0x08)
    and r5, r3                       ! r3 = channel_enable & 0x08 (channel 3)
    tst r3, r3                       ! test if channel 3 is enabled
    bf      .L_ch3_enabled           ! branch if channel 3 bit set in enable mask
    mov.w   .L_wpool_bit7_mask, r3   ! r3 = 0x0080 (bit 7 mask)
    and r5, r3                       ! r3 = channel_enable & 0x80 (channel 7 alt)
    tst r3, r3                       ! test alternate enable
    bt      .L_ch3_done              ! skip channel 3 processing entirely
.L_ch3_enabled:
    mov #0x8, r3                     ! r3 = bit 3 mask (0x08)
    and r4, r3                       ! r3 = direction & 0x08
    tst r3, r3                       ! test direction for channel 3
    bf      .L_ch3_set_bits          ! if bit set in direction, go to OR path
    mov.w   .L_wpool_bit7_mask, r3   ! r3 = 0x0080 (bit 7 mask)
    and r4, r3                       ! r3 = direction & 0x80
    tst r3, r3                       ! test direction for channel 7 alt
    bt      .L_ch3_clear_bits        ! if bit clear, go to AND path
.L_ch3_set_bits:
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @r6, r2                    ! r2 = current value of buffer[0]
    or r3, r2                        ! r2 = buffer[0] | OR_value (set bits)
    bra     .L_ch3_done              ! jump past clear path
    mov.b r2, @r6                    ! buffer[0] = result (delay slot)
.L_ch3_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @r6, r3                    ! r3 = current value of buffer[0]
    and r2, r3                       ! r3 = buffer[0] & AND_mask (clear bits)
    mov.b r3, @r6                    ! buffer[0] = result
.L_ch3_done:
    mov #0x10, r2                    ! r2 = bit 4 mask (0x10)
    and r5, r2                       ! r2 = channel_enable & 0x10 (channel 4)
    tst r2, r2                       ! test if channel 4 is enabled
    bt      .L_ch4_done              ! skip if channel 4 not enabled
    mov #0x10, r3                    ! r3 = bit 4 mask (0x10)
    and r4, r3                       ! r3 = direction & 0x10
    tst r3, r3                       ! test direction for channel 4
    bt      .L_ch4_clear_bits        ! if bit clear in direction, go to AND path
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @(3, r6), r0               ! r0 = current value of buffer[3]
    mov r0, r2                       ! r2 = copy of buffer[3]
    or r3, r2                        ! r2 = buffer[3] | OR_value (set bits)
    bra     .L_ch4_store             ! jump to store result
    mov r2, r0                       ! r0 = result (delay slot)
.L_ch4_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @(3, r6), r0               ! r0 = current value of buffer[3]
    mov r0, r3                       ! r3 = copy of buffer[3]
    and r2, r3                       ! r3 = buffer[3] & AND_mask (clear bits)
    mov r3, r0                       ! r0 = result
.L_ch4_store:
    mov.b r0, @(3, r6)              ! buffer[3] = updated channel 4 value
.L_ch4_done:
    mov #0x20, r3                    ! r3 = bit 5 mask (0x20)
    and r5, r3                       ! r3 = channel_enable & 0x20 (channel 5)
    tst r3, r3                       ! test if channel 5 is enabled
    bt      .L_ch5_done              ! skip if channel 5 not enabled
    mov #0x20, r3                    ! r3 = bit 5 mask (0x20)
    and r4, r3                       ! r3 = direction & 0x20
    tst r3, r3                       ! test direction for channel 5
    bt      .L_ch5_clear_bits        ! if bit clear in direction, go to AND path
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @(2, r6), r0               ! r0 = current value of buffer[2]
    mov r0, r2                       ! r2 = copy of buffer[2]
    or r3, r2                        ! r2 = buffer[2] | OR_value (set bits)
    bra     .L_ch5_store             ! jump to store result
    mov r2, r0                       ! r0 = result (delay slot)
.L_wpool_bit7_mask:
    .2byte  0x0080
.L_ch5_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @(2, r6), r0               ! r0 = current value of buffer[2]
    mov r0, r3                       ! r3 = copy of buffer[2]
    and r2, r3                       ! r3 = buffer[2] & AND_mask (clear bits)
    mov r3, r0                       ! r0 = result
.L_ch5_store:
    mov.b r0, @(2, r6)              ! buffer[2] = updated channel 5 value
.L_ch5_done:
    mov #0x1, r3                     ! r3 = bit 0 mask (0x01)
    and r5, r3                       ! r3 = channel_enable & 0x01 (channel 0)
    tst r3, r3                       ! test if channel 0 is enabled
    bt      .L_ch0_done              ! skip if channel 0 not enabled
    mov #0x1, r3                     ! r3 = bit 0 mask (0x01)
    and r4, r3                       ! r3 = direction & 0x01
    tst r3, r3                       ! test direction for channel 0
    bt      .L_ch0_clear_bits        ! if bit clear in direction, go to AND path
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @(5, r6), r0               ! r0 = current value of buffer[5]
    mov r0, r2                       ! r2 = copy of buffer[5]
    or r3, r2                        ! r2 = buffer[5] | OR_value (set bits)
    bra     .L_ch0_store             ! jump to store result
    mov r2, r0                       ! r0 = result (delay slot)
.L_ch0_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @(5, r6), r0               ! r0 = current value of buffer[5]
    mov r0, r3                       ! r3 = copy of buffer[5]
    and r2, r3                       ! r3 = buffer[5] & AND_mask (clear bits)
    mov r3, r0                       ! r0 = result
.L_ch0_store:
    mov.b r0, @(5, r6)              ! buffer[5] = updated channel 0 value
.L_ch0_done:
    mov.w   .L_wpool_bit8_mask, r3   ! r3 = 0x0100 (bit 8 mask)
    and r5, r3                       ! r3 = channel_enable & 0x100 (channel 8)
    tst r3, r3                       ! test if channel 8 is enabled
    bt      .L_ch8_done              ! skip if channel 8 not enabled
    mov.w   .L_wpool_bit8_mask, r3   ! r3 = 0x0100 (bit 8 mask)
    and r4, r3                       ! r3 = direction & 0x100
    tst r3, r3                       ! test direction for channel 8
    bt      .L_ch8_clear_bits        ! if bit clear in direction, go to AND path
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @(4, r6), r0               ! r0 = current value of buffer[4]
    mov r0, r2                       ! r2 = copy of buffer[4]
    or r3, r2                        ! r2 = buffer[4] | OR_value (set bits)
    bra     .L_ch8_store             ! jump to store result
    mov r2, r0                       ! r0 = result (delay slot)
.L_ch8_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @(4, r6), r0               ! r0 = current value of buffer[4]
    mov r0, r3                       ! r3 = copy of buffer[4]
    and r2, r3                       ! r3 = buffer[4] & AND_mask (clear bits)
    mov r3, r0                       ! r0 = result
.L_ch8_store:
    mov.b r0, @(4, r6)              ! buffer[4] = updated channel 8 value
.L_ch8_done:
    mov.l   .L_pool_bit16_mask, r3   ! r3 = 0x00010000 (bit 16 mask)
    and r5, r3                       ! r3 = channel_enable & 0x10000 (channel 16)
    tst r3, r3                       ! test if channel 16 is enabled
    bt      .L_ch16_done             ! skip if channel 16 not enabled
    mov.l   .L_pool_bit16_mask, r3   ! r3 = 0x00010000 (bit 16 mask)
    and r4, r3                       ! r3 = direction & 0x10000
    tst r3, r3                       ! test direction for channel 16
    bt      .L_ch16_clear_bits       ! if bit clear in direction, go to AND path
    extu.b r7, r3                    ! r3 = OR value (zero-extended to byte)
    mov.b @(7, r6), r0               ! r0 = current value of buffer[7]
    mov r0, r2                       ! r2 = copy of buffer[7]
    or r3, r2                        ! r2 = buffer[7] | OR_value (set bits)
    bra     .L_ch16_store            ! jump to store result
    mov r2, r0                       ! r0 = result (delay slot)
.L_ch16_clear_bits:
    extu.b r1, r2                    ! r2 = AND mask (zero-extended to byte)
    mov.b @(7, r6), r0               ! r0 = current value of buffer[7]
    mov r0, r3                       ! r3 = copy of buffer[7]
    and r2, r3                       ! r3 = buffer[7] & AND_mask (clear bits)
    mov r3, r0                       ! r0 = result
.L_ch16_store:
    mov.b r0, @(7, r6)              ! buffer[7] = updated channel 16 value
.L_ch16_done:
    mov.l   .L_pool_bit17_mask, r3   ! r3 = 0x00020000 (bit 17 mask)
    and r3, r5                       ! r5 = channel_enable & 0x20000 (channel 17)
    tst r5, r5                       ! test if channel 17 is enabled
    bt      .L_ch17_done             ! skip if channel 17 not enabled
    mov.l   .L_pool_bit17_mask, r3   ! r3 = 0x00020000 (bit 17 mask)
    and r3, r4                       ! r4 = direction & 0x20000
    tst r4, r4                       ! test direction for channel 17
    bt      .L_ch17_clear_bits       ! if bit clear in direction, go to AND path
    extu.b r7, r7                    ! r7 = OR value (zero-extended to byte, final use)
    mov.b @(6, r6), r0               ! r0 = current value of buffer[6]
    mov r0, r3                       ! r3 = copy of buffer[6]
    or r7, r3                        ! r3 = buffer[6] | OR_value (set bits)
    mov r3, r0                       ! r0 = result
    bra     .L_ch17_store            ! jump to store result
    nop                              ! delay slot (no-op)
.L_ch17_clear_bits:
    extu.b r1, r1                    ! r1 = AND mask (zero-extended to byte, final use)
    mov.b @(6, r6), r0               ! r0 = current value of buffer[6]
    mov r0, r2                       ! r2 = copy of buffer[6]
    and r1, r2                       ! r2 = buffer[6] & AND_mask (clear bits)
    mov r2, r0                       ! r0 = result
.L_ch17_store:
    mov.b r0, @(6, r6)              ! buffer[6] = updated channel 17 value
.L_ch17_done:
    rts                              ! return to caller
    nop                              ! delay slot (no-op)
.L_wpool_bit8_mask:
    .2byte  0x0100
.L_pool_bit16_mask:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_pool_bit17_mask:
    .4byte  0x00020000                  /* 2.0 (16.16 fixed-point) */

/*
 * color_transform_init:
 *   Initializes a 24-byte color transform descriptor structure.
 *   Called from save_block_copy to set up a fresh color state.
 *
 *   Args:
 *     r4 = pointer to color transform descriptor (24 bytes)
 *     r5 = callback function pointer (stored at offset 0)
 *
 *   Descriptor layout:
 *     [0]  = callback pointer (r5)
 *     [4]  = zero (cleared)
 *     [8]  = zero (cleared)
 *     [12] = 1 (initial mode/state)
 *     [16] = zero (progress field, cleared)
 *     [20] = zero (status field, cleared)
 */
    .global sym_0603EF34
sym_0603EF34:
    add #-0x4, r15                   ! allocate 4 bytes on stack
    mov #0x0, r6                     ! r6 = 0 (zero constant)
    mov r4, r0                       ! r0 = descriptor base pointer (unused)
    mov r6, r7                       ! r7 = 0 (zero constant)
    mov.l r6, @r15                   ! store 0 on stack (temp for offset 8)
    mov r7, r2                       ! r2 = 0 (unused)
    mov.l r5, @r4                    ! desc[0] = callback pointer
    mov.l r7, @(4, r4)              ! desc[4] = 0 (zero)
    mov.l @r15, r3                   ! r3 = 0 (load from stack temp)
    mov.l r3, @(8, r4)              ! desc[8] = 0 (zero)
    mov #0x1, r3                     ! r3 = 1
    mov.l r3, @(12, r4)             ! desc[12] = 1 (initial mode)
    mov.l r7, @(20, r4)             ! desc[20] = 0 (status cleared)
    mov.l r7, @(16, r4)             ! desc[16] = 0 (progress cleared)
    rts                              ! return to caller
    add #0x4, r15                    ! deallocate stack (delay slot)

/*
 * color_transform_set_params:
 *   Sets the RGB target values in a color transform descriptor and
 *   resets its progress/status fields to zero. Called from
 *   menu_list_scroll and menu_toggle_switch to configure fade targets.
 *
 *   Args:
 *     r4 = pointer to color transform descriptor
 *     r5 = target R value (stored at offset 4)
 *     r6 = target G value (stored at offset 8)
 *     r7 = target B value (stored at offset 12)
 */
    .global sym_0603EF54
sym_0603EF54:
    mov.l r5, @(4, r4)              ! desc[4] = target R value
    mov #0x0, r3                     ! r3 = 0 (zero constant)
    mov.l r6, @(8, r4)              ! desc[8] = target G value
    mov r3, r2                       ! r2 = 0 (unused)
    mov.l r7, @(12, r4)             ! desc[12] = target B value
    mov.l r3, @(20, r4)             ! desc[20] = 0 (status cleared)
    rts                              ! return to caller
    mov.l r3, @(16, r4)             ! desc[16] = 0 (progress cleared, delay slot)
