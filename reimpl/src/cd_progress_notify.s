/* cd_progress_notify -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06012CF4 - 0x06012D7C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Polls the CD subsystem for read progress by repeatedly calling
 * cmd_validate_exec (command ID 5) until the return value exceeds 2,
 * indicating the CD read has completed successfully.
 *
 * Before entering the poll loop, initializes the CD command struct at
 * sym_06084360 with:
 *   [+0x00] = 1            (command type / init flag)
 *   [+0x04] = 0x50         (sector count: 80 sectors)
 *   [+0x08] = sym_0608436C (data destination pointer)
 * and clears the CD status flag byte at sym_06084AEC to 0.
 *
 * Every 5 iterations, calls the BIOS service function (via indirect
 * pointer at sym_0600026C) to reset the CD subsystem. This acts as a
 * watchdog to recover from stalls.
 *
 * Arguments: none
 *
 * Register allocation:
 *   r9  = cmd_validate_exec (function pointer)
 *   r10 = iteration counter (0..N, reset never — grows until success)
 *   r11 = sym_06083274      (sector data buffer, passed as r5)
 *   r12 = last cmd_validate_exec return value
 *   r13 = sym_0600026C      (indirect pointer to BIOS service function)
 *   r14 = 2                 (success threshold: status must be > 2)
 *   @(0,r15) = sentinel value (-1, never read — stack alignment padding)
 */

    .section .text.FUN_06012CF4


    .global cd_progress_notify
    .type cd_progress_notify, @function
cd_progress_notify:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r13, @-r15                    ! save r13 (callee-saved)
    mov.l r12, @-r15                    ! save r12 (callee-saved)
    mov.l r11, @-r15                    ! save r11 (callee-saved)
    mov.l r10, @-r15                    ! save r10 (callee-saved)
    mov.l r9, @-r15                     ! save r9  (callee-saved)
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes of stack locals
    mov.l   .L_pool_cmd_validate_exec, r9   ! r9 = &cmd_validate_exec (poll-based CD command executor)
    mov.l   .L_pool_bios_service_ptr, r13   ! r13 = &sym_0600026C (indirect ptr to BIOS service fn)
    mov #0x2, r14                       ! r14 = 2 (success threshold: result must be > 2)
    mov #-0x1, r3                       ! r3 = -1 (sentinel value)
    mov.l r3, @r15                      ! local[0] = -1 (sentinel, unused)
    mov #0x0, r4                        ! r4 = 0 (initial value for status flag clear)
    mov r4, r10                         ! r10 = 0 (iteration counter)
    exts.b r4, r4                       ! sign-extend r4 to longword (r4 = 0, for byte write)
    mov.l   .L_pool_cd_status_flag, r3  ! r3 = &sym_06084AEC (CD status flag byte)
    mov.b r4, @r3                       ! sym_06084AEC = 0 (clear CD status flag: mark as ready)
    mov.l   .L_pool_cd_cmd_struct, r2   ! r2 = &sym_06084360 (CD command struct base)
    mov #0x1, r3                        ! r3 = 1 (command type / init flag)
    mov.l r3, @r2                       ! cmd_struct[+0x00] = 1 (command type)
    mov.l   .L_pool_cd_data_dest, r3    ! r3 = &sym_0608436C (CD data destination ptr)
    mov.l r3, @(8, r2)                  ! cmd_struct[+0x08] = sym_0608436C (data dest)
    mov #0x50, r3                       ! r3 = 0x50 = 80 (sector count)
    mov.l r3, @(4, r2)                  ! cmd_struct[+0x04] = 80 (sectors to read)
    mov.l   .L_pool_cd_sector_buf, r11  ! r11 = &sym_06083274 (sector data buffer, r5 arg)
.L_poll_loop:
    mov.l   .L_pool_cd_cmd_struct, r6   ! r6 = &sym_06084360 (cmd struct ptr, 3rd arg)
    mov r11, r5                         ! r5 = sym_06083274 (sector buffer, 2nd arg)
    jsr @r9                             ! call cmd_validate_exec(r4=5, r5=sector_buf, r6=cmd_struct)
    mov #0x5, r4                        ! r4 = 5 (command ID, delay slot)
    add #0x1, r10                       ! ++iteration_counter
    mov #0x5, r2                        ! r2 = 5 (BIOS reset interval)
    cmp/ge r2, r10                      ! T = (iteration_counter >= 5)?
    bf/s    .L_check_result             ! if fewer than 5 iters, skip BIOS reset
    mov r0, r12                         ! r12 = cmd_validate_exec return value (delay slot)
    mov.l @r13, r2                      ! r2 = *sym_0600026C (BIOS service function ptr)
    jsr @r2                             ! call BIOS service (reset CD subsystem)
    nop                                 ! delay slot
.L_check_result:
    cmp/gt r14, r12                     ! T = (last result > 2)?
    bf      .L_poll_loop                ! if result <= 2 (not done), loop back to poll again
    add #0x4, r15                       ! deallocate 4 bytes of stack locals
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .2byte  0x000B                      ! padding (rts opcode echo, aligns pool)
    .4byte  0x0009FFFF                  ! padding data
.L_pool_cmd_validate_exec:
    .4byte  cmd_validate_exec           ! fn ptr: poll-based CD command executor
.L_pool_bios_service_ptr:
    .4byte  sym_0600026C                ! indirect ptr to BIOS service/reset function
.L_pool_cd_status_flag:
    .4byte  sym_06084AEC                ! byte flag: 0 = CD ready, 1 = CD busy/error
.L_pool_cd_cmd_struct:
    .4byte  sym_06084360                ! CD command request struct base address
.L_pool_cd_data_dest:
    .4byte  sym_0608436C                ! CD data destination pointer (stored into cmd struct)
.L_pool_cd_sector_buf:
    .4byte  sym_06083274                ! sector data buffer address (passed as r5)
    .4byte  0x000B0009                  ! padding data
    .4byte  0x000B0009                  ! padding data
