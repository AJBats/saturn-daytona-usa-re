/* track_texture_map -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602F7F2 - 0x0602F99C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Per-frame track sound trigger processor. Runs once per frame during
 * racing to dispatch sound commands based on car position, speed, and
 * state flags. Uses segment lookup tables to detect when the car enters
 * sound trigger zones (e.g., tunnel echo, surface change). Computes a
 * speed-proportional volume via hw_divide, clamps it to [1..127], and
 * dispatches it on channel 1. Also handles course-specific surface
 * sound selection (channel 0), road-type ambient sounds (channel 0),
 * tire screech triggers (channel 3), and lateral-velocity engine pitch
 * (channel 2).
 *
 * Calling convention for sound_cmd_dispatch (r12):
 *   r4 = channel number, r5 = sound command (0xAE..FF format)
 *
 * Key car struct offsets (base in r14):
 *   +0x00  flags word (bit 14 = zone sound active)
 *   +0x0C  speed/direction
 *   +0x5C  lateral velocity (signed, used for engine pitch)
 *   +0x84  secondary speed metric
 *   +0x14  Y position (height)
 *   +0xB8  collision timer A
 *   +0xE4  scaled speed
 *   +0x166 course/surface type word
 *   +0x1BC collision timer B
 *   +0x1EC track position (segment index)
 */

    .section .text.FUN_0602F7F2


    .global track_texture_map
    .type track_texture_map, @function
track_texture_map:
    sts.l pr, @-r15
    mov.l @r14, r14                     ! r14 = car state base pointer
    .byte   0xDC, 0x15    /* mov.l .L_fn_sound_cmd_dispatch, r12 */  ! r12 = sound_cmd_dispatch (persists)
    mov r14, r0
    .byte   0xD5, 0x15    /* mov.l .L_player_mode_ptr, r5 */  ! r5 = &player_mode (0x0607EAD8)
    mov.w   DAT_0602f842, r4           ! r4 = 0x01EC (track position offset)
    mov.l @r5, r0                       ! r0 = player_mode value (course index)
    add r14, r4                         ! r4 = &car[+0x1EC]
    .byte   0xD1, 0x14    /* mov.l .L_seg_range_table, r1 */  ! r1 = seg_range_table base
    mov.l @r4, r4                       ! r4 = car track position (segment)
    shll2 r0                            ! r0 = course_idx * 4
    add r0, r1                          ! r1 = &seg_range_table[course_idx]
    mov.w @r1, r5                       ! r5 = entry count for this course
    tst r5, r5                          ! any trigger zones defined?
    bt      .L_volume_calc              ! no zones -> skip to volume calc
    .byte   0xD3, 0x11    /* mov.l .L_seg_entry_table, r3 */  ! r3 = seg_entry_table base
    mov.w @(2, r1), r0                  ! r0 = byte offset into entry table
    add r0, r3                          ! r3 = &first entry for this course
.L_zone_scan_loop:                      ! -- scan each trigger zone entry --
    mov.w @r3, r1                       ! r1 = zone start segment
    cmp/gt r4, r1                       ! car_pos > zone_start? (not yet in zone)
    bt      .L_zone_next_entry          ! skip this entry
    mov.w @(2, r3), r0                  ! r0 = zone end segment
    cmp/gt r0, r4                       ! car_pos > zone_end? (past zone)
    bt      .L_zone_next_entry          ! skip this entry
    ! -- car is within this zone --
    mov #0x10, r0                       ! r0 = 0x10
    mov.l @(20, r14), r1               ! r1 = car[+0x14] (Y position / height)
    shll16 r0                           ! r0 = 0x100000 (height threshold)
    cmp/ge r1, r0                       ! Y < threshold? (too high = airborne)
    bt      .L_volume_calc              ! airborne -> skip zone sound
    mov.l @(0, r14), r1                 ! r1 = car flags word
    mov.w   DAT_0602f844, r3           ! r3 = 0x4000 (zone-sound-active bit)
    tst r3, r1                          ! already playing zone sound?
    bf      .L_volume_calc              ! yes -> don't re-trigger
    or r3, r1                           ! set zone-sound-active flag
    mov.l r1, @(0, r14)                 ! store updated flags
    .byte   0xD5, 0x08    /* mov.l .L_snd_zone_enter, r5 */  ! r5 = 0xAE0601FF (BGM zone enter)
    jsr @r12                            ! sound_cmd_dispatch(ch=4, snd)
    mov #0x4, r4                        ! r4 = channel 4 (delay slot)
    bra     .L_volume_calc
    nop

    .global DAT_0602f842
DAT_0602f842:
    .2byte  0x01EC                      ! car struct offset: track position

    .global DAT_0602f844
DAT_0602f844:
    .2byte  0x4000                      ! bit 14: zone-sound-active flag
    .2byte  0x0000                      ! padding
    .4byte  sym_0607E944                ! current car pointer (primary)
.L_fn_sound_cmd_dispatch:
    .4byte  sound_cmd_dispatch          ! fn ptr: sound command dispatcher
.L_player_mode_ptr:
    .4byte  sym_0607EAD8               ! player mode / car count
.L_seg_range_table:
    .4byte  sym_0602FD3C               ! per-course zone count + offset table
.L_seg_entry_table:
    .4byte  sym_0602FD48               ! zone entries: start/end segment pairs
.L_snd_zone_enter:
    .4byte  0xAE0601FF                 ! sound: BGM zone enter (group 06, ch 01)
.L_zone_next_entry:                     ! -- advance to next zone entry --
    add #-0x1, r5                       ! decrement remaining entry count
    tst r5, r5                          ! all entries checked?
    add #0x4, r3                        ! r3 += 4 (next entry: 2 words)
    bf      .L_zone_scan_loop           ! more entries -> continue scan
    ! -- fell through: car not in any zone --
    mov.l @(0, r14), r1                 ! r1 = car flags word
    mov.w   DAT_0602f890, r3           ! r3 = 0x4000 (zone-sound-active bit)
    tst r3, r1                          ! was zone sound active?
    bt      .L_volume_calc              ! no -> nothing to clear
    not r3, r3                          ! r3 = ~0x4000 (clear mask)
    and r3, r1                          ! clear zone-sound-active flag
    mov.l r1, @(0, r14)                 ! store updated flags
    .byte   0xD5, 0x08    /* mov.l .L_snd_zone_exit, r5 */  ! r5 = 0xAE0600FF (BGM start/zone exit)
    jsr @r12                            ! sound_cmd_dispatch(ch=4, snd)
    mov #0x4, r4                        ! r4 = channel 4 (delay slot)
.L_volume_calc:                         ! -- compute speed-proportional volume --
    mov.w   .L_off_scaled_speed, r5    ! r5 = 0xE4 (scaled speed offset)
    add r14, r5                         ! r5 = &car[+0xE4]
    mov.w   .L_speed_range_min, r3     ! r3 = 0x0708 (1800 = min speed for sound)
    mov.l @r5, r1                       ! r1 = car scaled speed
    mov.w   .L_speed_range_max, r4     ! r4 = 0x2134 (8500 = max speed clamp)
    cmp/gt r3, r1                       ! speed > min?
    bt      .L_clamp_speed_high         ! yes -> check upper bound
    mov r3, r1                          ! clamp to min
    bra     .L_speed_clamped
    nop

    .global DAT_0602f890
DAT_0602f890:
    .2byte  0x4000                      ! bit 14: zone-sound-active flag (dup)
.L_off_scaled_speed:
    .2byte  0x00E4                      ! car struct offset: scaled speed
.L_speed_range_min:
    .2byte  0x0708                      ! 1800: minimum speed for volume
.L_speed_range_max:
    .2byte  0x2134                      ! 8500: maximum speed clamp
.L_snd_zone_exit:
    .4byte  0xAE0600FF                 ! sound: BGM start / zone exit (group 06)
.L_clamp_speed_high:                    ! speed is above minimum
    cmp/gt r1, r4                       ! max > speed?
    bt      .L_speed_clamped            ! yes -> speed within range
    mov r4, r1                          ! clamp to max
.L_speed_clamped:                       ! r1 = clamped speed in [min..max]
    sub r3, r1                          ! r1 = speed - min (normalize to 0-based)
    shll8 r1                            ! r1 <<= 8 (scale up for fixed-point)
    mov.w   .L_divisor_speed_range, r0 ! r0 = 0x14B4 (5300 = speed range width)
    .byte   0xBA, 0x10    /* bsr 0x0602ECCC (external) */  ! hw_divide(r0=divisor, r1=dividend)
    shlr r1                             ! r1 >>= 1 (adjust before divide, delay slot)
    mov #0x7F, r4                       ! r4 = 127 (max volume)
    mov #0x1, r3                        ! r3 = 1 (min volume)
    cmp/gt r3, r0                       ! quotient > 1?
    bt      .L_vol_above_min            ! yes -> check upper bound
    mov r3, r0                          ! clamp to min volume
    bra     .L_vol_clamped
    nop
.L_divisor_speed_range:
    .2byte  0x14B4                      ! 5300: speed range divisor (max - min)
.L_vol_above_min:                       ! volume is above minimum
    cmp/gt r0, r4                       ! 127 > volume?
    bt      .L_vol_clamped              ! yes -> volume within range
    mov r4, r0                          ! clamp to 127
.L_vol_clamped:                         ! r0 = clamped volume in [1..127]
    mov r0, r5                          ! r5 = volume (sound command arg)
    jsr @r12                            ! sound_cmd_dispatch(ch=1, volume)
    mov #0x1, r4                        ! r4 = channel 1 (delay slot)
    ! -- surface sound selection (channel 0) --
    .byte   0xD4, 0x0A    /* mov.l .L_course_type_byte, r4 */  ! r4 = &course_type_byte
    mov.b @r4, r4                       ! r4 = course type (0 or nonzero)
    mov.w   DAT_0602f8f0, r1           ! r1 = 0x01BC (collision timer B offset)
    add r14, r1                         ! r1 = &car[+0x1BC]
    mov.l @r1, r0                       ! r0 = collision timer B
    tst r0, r0                          ! timer active?
    bf      .L_check_road_type          ! yes -> skip surface sound
    mov.w   DAT_0602f8f2, r1           ! r1 = 0x0166 (surface type offset)
    add r14, r1                         ! r1 = &car[+0x166]
    mov.w @r1, r0                       ! r0 = surface type value
    tst r0, r0                          ! zero?
    bt      .L_check_road_type          ! yes -> no surface sound
    cmp/eq #0xA, r0                     ! surface type == 10? (type A)
    bf      .L_check_surface_b          ! no -> try type B
    .byte   0xD5, 0x04    /* mov.l .L_snd_surface_a_default, r5 */  ! r5 = 0xAE111EFF
    tst r4, r4                          ! course type == 0?
    bt      .L_dispatch_surface_snd     ! yes -> use default sound
    .byte   0xD5, 0x04    /* mov.l .L_snd_surface_a_alt, r5 */  ! r5 = 0xAE1142FF (alt course)
    bra     .L_dispatch_surface_snd
    nop

    .global DAT_0602f8f0
DAT_0602f8f0:
    .2byte  0x01BC                      ! car struct offset: collision timer B

    .global DAT_0602f8f2
DAT_0602f8f2:
    .2byte  0x0166                      ! car struct offset: surface type
.L_course_type_byte:
    .4byte  sym_0605D241               ! course type byte (0=beginner, etc.)
.L_snd_surface_a_default:
    .4byte  0xAE111EFF                 ! sound: surface A, default course (SFX 1E)
.L_snd_surface_a_alt:
    .4byte  0xAE1142FF                 ! sound: surface A, alt course (SFX 42)
.L_check_surface_b:                     ! -- check surface type B --
    cmp/eq #0x3, r0                     ! surface type == 3? (type B)
    .byte   0xD5, 0x20    /* mov.l .L_snd_surface_b_default, r5 */  ! r5 = 0xAE111CFF (preload)
    bf      .L_check_road_type          ! neither A nor B -> skip
    tst r4, r4                          ! course type == 0?
    bt      .L_dispatch_surface_snd     ! yes -> use default sound
    .byte   0xD5, 0x1F    /* mov.l .L_snd_surface_b_alt, r5 */  ! r5 = 0xAE1140FF (alt course)
.L_dispatch_surface_snd:                ! -- dispatch surface SFX --
    jsr @r12                            ! sound_cmd_dispatch(ch=0, snd)
    mov #0x0, r4                        ! r4 = channel 0 (delay slot)
.L_check_road_type:                     ! -- road type ambient sound --
    .byte   0xD4, 0x1E    /* mov.l .L_course_type_byte_2, r4 */  ! r4 = &course_type_byte
    mov.b @r4, r1                       ! r1 = course type
    mov.w   .L_off_collision_timer, r3 ! r3 = 0xB8 (collision timer A offset)
    add r14, r3                         ! r3 = &car[+0xB8]
    mov #0x2C, r5                       ! r5 = 44 (road type ID for trigger)
    mov.l @r3, r4                       ! r4 = collision timer A value
    cmp/eq r4, r5                       ! timer == 44? (specific road type)
    bf      .L_check_screech            ! no match -> skip road sound
    tst r1, r1                          ! course type == 0?
    .byte   0xD5, 0x1B    /* mov.l .L_snd_road_type_default, r5 */  ! r5 = 0xAE111BFF
    bt      .L_dispatch_road_snd        ! yes -> use default
    .byte   0xD5, 0x1B    /* mov.l .L_snd_road_type_alt, r5 */  ! r5 = 0xAE113FFF (alt course)
.L_dispatch_road_snd:                   ! -- dispatch road type SFX --
    jsr @r12                            ! sound_cmd_dispatch(ch=0, snd)
    mov #0x0, r4                        ! r4 = channel 0 (delay slot)
.L_check_screech:                       ! -- tire screech sound (channel 3) --
    .byte   0xD3, 0x1A    /* mov.l .L_screech_countdown_ptr, r3 */  ! r3 = &screech_countdown
    mov.b @r3, r0                       ! r0 = screech countdown timer
    tst r0, r0                          ! timer == 0?
    bt      .L_no_active_screech        ! yes -> check if new screech needed
    cmp/eq #0x1, r0                     ! timer == 1? (last tick)
    add #-0x1, r0                       ! decrement timer
    mov #0x0, r5                        ! r5 = 0 (stop sound on last tick)
    bt/s    .L_dispatch_screech_snd     ! if was 1, dispatch stop command
    mov.b r0, @r3                       ! store decremented timer (delay slot)
.L_no_active_screech:                   ! -- check conditions for new screech --
    mov.l @(12, r14), r0               ! r0 = car[+0x0C] (speed/direction)
    tst r0, r0                          ! car stationary?
    bt      .L_engine_pitch_calc        ! yes -> no screech
    mov.w   DAT_0602f980, r0           ! r0 = 0x84 (secondary speed offset)
    mov #-0x38, r4                      ! r4 = 0xC8 after extu.b (200)
    mov.l @(r0, r14), r5               ! r5 = car[+0x84] (secondary speed)
    extu.b r4, r4                       ! r4 = 200 (speed threshold)
    cmp/ge r5, r4                       ! threshold >= speed?
    bt      .L_engine_pitch_calc        ! speed too low -> no screech
    mov #0xA, r4                        ! r4 = 10 (countdown frames)
    mov.b r4, @r3                       ! set screech countdown = 10
    mov #0x1, r5                        ! r5 = 1 (start screech sound)
.L_dispatch_screech_snd:                ! -- dispatch screech SFX --
    jsr @r12                            ! sound_cmd_dispatch(ch=3, snd)
    mov #0x3, r4                        ! r4 = channel 3 (delay slot)
.L_engine_pitch_calc:                   ! -- engine pitch from lateral velocity (channel 2) --
    mov.w   DAT_0602f982, r0          ! r0 = 0x5C (lateral velocity offset)
    mov.l @(r0, r14), r5               ! r5 = car[+0x5C] (lateral velocity, signed)
    cmp/pz r5                           ! positive?
    bt      .L_lat_vel_positive         ! yes -> use as-is
    neg r5, r5                          ! r5 = abs(lateral_velocity)
.L_lat_vel_positive:                    ! r5 = |lateral_velocity|
    shlr8 r5                            ! r5 >>= 8
    mov #0x7, r3                        ! r3 = 7 (max pitch level)
    shlr2 r5                            ! r5 >>= 2 (total: >>10)
    cmp/ge r5, r3                       ! max >= pitch?
    bt      .L_pitch_clamped            ! yes -> within range
    mov #0x7, r5                        ! clamp to 7
.L_pitch_clamped:                       ! r5 = pitch level [0..7]
    jsr @r12                            ! sound_cmd_dispatch(ch=2, pitch)
    mov #0x2, r4                        ! r4 = channel 2 (delay slot)
    ! -- epilogue --
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_off_collision_timer:
    .2byte  0x00B8                      ! car struct offset: collision timer A

    .global DAT_0602f980
DAT_0602f980:
    .2byte  0x0084                      ! car struct offset: secondary speed

    .global DAT_0602f982
DAT_0602f982:
    .2byte  0x005C                      ! car struct offset: lateral velocity
.L_snd_surface_b_default:
    .4byte  0xAE111CFF                 ! sound: surface B, default course (SFX 1C)
.L_snd_surface_b_alt:
    .4byte  0xAE1140FF                 ! sound: surface B, alt course (SFX 40)
.L_course_type_byte_2:
    .4byte  sym_0605D241               ! course type byte (same as above, 2nd ref)
.L_snd_road_type_default:
    .4byte  0xAE111BFF                 ! sound: road type, default (SFX 1B)
.L_snd_road_type_alt:
    .4byte  0xAE113FFF                 ! sound: road type, alt course (SFX 3F)
.L_screech_countdown_ptr:
    .4byte  sym_0602FD9F               ! screech countdown byte in data tables
