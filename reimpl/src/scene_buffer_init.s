/* scene_buffer_init -- Scene rendering buffer initialization
 * Translation unit: 0x06038120 - 0x06038300
 *
 * Initializes the scene rendering pipeline buffers from a pattern config
 * structure. Called during engine init and per-frame render setup to
 * configure the two scene channels (A and B) for the VDP2 rendering
 * pipeline.
 *
 * The config struct (passed via r4 = pattern_config_base, sym_06087C84)
 * has the following layout:
 *   +0x00: byte  channel_flag_A   (enables scene A source copy per entry)
 *   +0x01: byte  channel_flag_B   (enables scene B X copy per entry)
 *   +0x02: byte  channel_flag_C   (enables scene A Y copy per entry)
 *   +0x03: byte  channel_flag_D   (enables scene B Z copy per entry)
 *   +0x04: byte  viewport_mode    (0..3 = viewport count / screen mode)
 *   +0x08: long  scene_a_size     (scene A buffer size in words)
 *   +0x0C: long  scene_b_size     (scene B buffer size in words)
 *   +0x10: array of 12-byte records (3 longwords each) = source data entries
 *
 * The function:
 *  1. Checks the command slot (sym_060635A8) for modes 4 or 8 to decide
 *     whether to proceed or bail out early.
 *  2. Builds a channel bitmask from config bytes 0-4, packing each flag
 *     into a specific bit position, and writes it to the scene transform
 *     struct (sym_060A3DF8) at offset +0x2A.
 *  3. Configures scene A and B source/size pointers (sym_060A3D70/78).
 *  4. Computes half-sizes (shlr) masked to 19 bits for viewport dimensions.
 *  5. Maps viewport_mode (0-3) to a stride value (1/2/4/8) for the
 *     entry copy loops.
 *  6. Loop 1: copies up to 512 entries from the config record array into
 *     the scene A output buffer (sym_060A2470), using flags C/B/A to
 *     select which of the 3 longwords per record to copy.
 *  7. Loop 2: copies up to 64 entries from the config's coord array
 *     (offset +0x1810 from config base) into the scene B output buffer
 *     (sym_060A3C70), gated by flag D.
 *  8. Writes entry counts to sym_060635A0 and sym_060635A2, then sets
 *     the ready flag at sym_060635AC to 2.
 *
 * Args:
 *   r4 = pointer to pattern config struct (sym_06087C84)
 *
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06038120


    .global scene_buffer_init
    .type scene_buffer_init, @function
scene_buffer_init:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    mov #0x0, r13                       ! r13 = 0 (used as zero constant)
    mov.l r11, @-r15                    ! save r11
    mov.l r10, @-r15                    ! save r10
    mov.l r9, @-r15                     ! save r9
    mov #0x40, r9                       ! r9 = 64 (loop 2 iteration limit)
    mov.l r8, @-r15                     ! save r8
    add #-0x4, r15                      ! allocate 4 bytes scratch on stack
    mov.w   .L_wpool_entry_limit, r10   ! r10 = 0x0200 = 512 (loop 1 iteration limit)
    mov.l   .L_pool_scene_transform, r11 ! r11 = &scene_transform_struct (sym_060A3DF8)
    mov.l   .L_pool_scene_buf_b, r12    ! r12 = &scene_buf_b (sym_060A3C70) — output for loop 2
    mov.l   .L_pool_scene_buf_a, r6     ! r6 = &scene_buf_a (sym_060A2470) — output for loop 1
    mov.l   .L_pool_cmd_slot, r8        ! r8 = &cmd_slot (sym_060635A8, scene mode selector)
    mov.l @r8, r0                       ! r0 = current scene mode value
    cmp/eq #0x8, r0                     ! is mode == 8? (sets T bit)
    .word 0x0129 /* movt r1 */          ! r1 = T (1 if mode==8, else 0)
    add #-0x1, r1                       ! r1 = r1 - 1 (0 if was 8, -1 otherwise)
    neg r1, r1                          ! r1 = -r1 (0 if was 8, 1 otherwise)
    cmp/eq #0x4, r0                     ! is mode == 4? (sets T bit)
    .word 0x0029 /* movt r0 */          ! r0 = T (1 if mode==4, else 0)
    xor #0x1, r0                        ! r0 = !r0 (0 if mode==4, 1 otherwise)
    and r1, r0                          ! r0 = (!is_mode4) & (!is_mode8)
    tst r0, r0                          ! test: is result zero? (i.e., mode IS 4 or 8)
    bt/s    .L_mode_accepted            ! if zero (mode 4 or 8) -> proceed with init
    extu.w r13, r14                     ! r14 = 0 (zero-extend r13; delay slot)
    bra     .L_epilogue                 ! mode is neither 4 nor 8 -> skip init, return
    nop
.L_wpool_entry_limit:
    .2byte  0x0200                      /* 512 = max entries for scene A loop */
.L_pool_scene_transform:
    .4byte  sym_060A3DF8                /* scene transform struct (64 bytes) */
.L_pool_scene_buf_b:
    .4byte  sym_060A3C70                /* scene buffer B output (for loop 2) */
.L_pool_scene_buf_a:
    .4byte  sym_060A2470                /* scene buffer A output (for loop 1) */
.L_pool_cmd_slot:
    .4byte  sym_060635A8                /* scene mode / command slot selector */
.L_mode_accepted:
    mov.b @(3, r4), r0                  ! r0 = config.channel_flag_D (byte 3)
    extu.b r0, r0                       ! zero-extend to 32 bits
    and #0x1, r0                        ! isolate bit 0
    extu.w r0, r5                       ! r5 = flag_D in bit 0 of channel bitmask
    mov.b @(2, r4), r0                  ! r0 = config.channel_flag_C (byte 2)
    extu.b r0, r0                       ! zero-extend to 32 bits
    shll r0                             ! shift left by 1 (bit position 1)
    and #0x2, r0                        ! isolate bit 1
    or r0, r5                           ! r5 |= flag_C << 1
    mov.b @(1, r4), r0                  ! r0 = config.channel_flag_B (byte 1)
    extu.b r0, r0                       ! zero-extend to 32 bits
    shll2 r0                            ! shift left by 2 (bit position 2)
    and #0x4, r0                        ! isolate bit 2
    or r0, r5                           ! r5 |= flag_B << 2
    mov.b @r4, r0                       ! r0 = config.channel_flag_A (byte 0)
    extu.b r0, r0                       ! zero-extend to 32 bits
    shll2 r0                            ! shift left by 2
    shll r0                             ! shift left by 1 more (total shift 3, bit position 3)
    and #0x8, r0                        ! isolate bit 3
    or r0, r5                           ! r5 |= flag_A << 3
    mov.b @(4, r4), r0                  ! r0 = config.viewport_mode (byte 4, 0..3)
    extu.b r0, r0                       ! zero-extend to 32 bits
    shll2 r0                            ! shift left by 2
    shll2 r0                            ! shift left by 2 more (total shift 4, bits 4-5)
    and #0x30, r0                       ! isolate bits 4-5
    or r0, r5                           ! r5 |= viewport_mode << 4; r5 = full channel bitmask
    mov r11, r7                         ! r7 = &scene_transform (for half-size A write)
    mov r11, r3                         ! r3 = &scene_transform
    add #0x2C, r3                       ! r3 = &scene_transform[0x2C] (half-size B field)
    mov.l r3, @r15                      ! save half-size B pointer to stack scratch
    mov.l @r8, r0                       ! r0 = current scene mode
    cmp/eq #0x8, r0                     ! is mode == 8?
    bf/s    .L_mode_is_4                ! if not mode 8 -> skip mode-8 shift, go to mode 4 path
    add #0x30, r7                       ! r7 = &scene_transform[0x30] (half-size A, mode 4 offset; delay slot)
    extu.w r5, r3                       ! r3 = channel bitmask (16-bit clean)
    shll8 r3                            ! r3 <<= 8 (shift bitmask to upper byte of word)
    mov.l   .L_mask_byte1, r2           ! r2 = 0x0000FF00
    and r2, r3                          ! mask to byte 1 only (bits 8-15)
    extu.w r3, r5                       ! r5 = shifted bitmask for mode 8
    mov r11, r7                         ! r7 = &scene_transform (reset base)
    add #0x34, r7                       ! r7 = &scene_transform[0x34] (half-size A, mode 8 offset)
.L_mode_is_4:
    mov #0x2A, r0                       ! r0 = 0x2A (offset for channel bitmask word in transform)
    mov r6, r2                          ! r2 = &scene_buf_a (unused assignment, overwritten below)
    mov.w r5, @(r0, r11)               ! scene_transform[0x2A] = channel bitmask (16-bit write)
    mov r12, r2                         ! r2 = &scene_buf_b (unused assignment, overwritten below)
    mov.l   .L_pool_scene_a_cfg, r5    ! r5 = &scene_a_config (sym_060A3D70, source/size pair)
    mov.l @(8, r4), r3                  ! r3 = config.scene_a_size (longword at +8)
    mov.l r3, @r5                       ! scene_a_config.size = config.scene_a_size
    mov.l r6, @(4, r5)                  ! scene_a_config.dest = &scene_buf_a
    mov.l   .L_pool_scene_b_cfg, r5    ! r5 = &scene_b_config (sym_060A3D78, source/size pair)
    mov.l @(12, r4), r3                 ! r3 = config.scene_b_size (longword at +12)
    mov.l r3, @r5                       ! scene_b_config.size = config.scene_b_size
    mov.l r12, @(4, r5)                 ! scene_b_config.dest = &scene_buf_b
    mov.l   .L_pool_half_size_mask, r5 ! r5 = 0x0007FFFF (19-bit mask for half-size)
    mov.l @(8, r4), r3                  ! r3 = config.scene_a_size
    shlr r3                             ! r3 >>= 1 (half the size)
    and r5, r3                          ! r3 &= 0x0007FFFF (mask to 19 bits)
    mov.l r3, @r7                       ! scene_transform[half_size_a_offset] = half_a_size
    mov.l @r15, r2                      ! r2 = &scene_transform[0x2C] (half-size B ptr from stack)
    mov.l @(12, r4), r3                 ! r3 = config.scene_b_size
    shlr r3                             ! r3 >>= 1 (half the size)
    and r5, r3                          ! r3 &= 0x0007FFFF (mask to 19 bits)
    mov.l r3, @r2                       ! scene_transform[0x2C] = half_b_size
    mov.b @(4, r4), r0                  ! r0 = config.viewport_mode
    mov r0, r2                          ! r2 = viewport_mode
    extu.b r2, r2                       ! zero-extend to 32 bits
    tst r2, r2                          ! is viewport_mode == 0?
    bf      .L_check_mode_1             ! if nonzero -> check for mode 1
    mov #0x1, r14                       ! mode 0: stride = 1 entry per iteration
.L_check_mode_1:
    mov.b @(4, r4), r0                  ! r0 = config.viewport_mode
    extu.b r0, r0                       ! zero-extend to 32 bits
    cmp/eq #0x1, r0                     ! is viewport_mode == 1?
    bf      .L_check_mode_2             ! if not -> check mode 2
    mov #0x2, r14                       ! mode 1: stride = 2 entries per iteration
.L_check_mode_2:
    mov.b @(4, r4), r0                  ! r0 = config.viewport_mode
    extu.b r0, r0                       ! zero-extend to 32 bits
    cmp/eq #0x2, r0                     ! is viewport_mode == 2?
    bf      .L_check_mode_3             ! if not -> check mode 3
    mov #0x4, r14                       ! mode 2: stride = 4 entries per iteration
.L_check_mode_3:
    mov.b @(4, r4), r0                  ! r0 = config.viewport_mode
    extu.b r0, r0                       ! zero-extend to 32 bits
    cmp/eq #0x3, r0                     ! is viewport_mode == 3?
    bf      .L_loop1_setup              ! if not -> start loop 1 with current stride
    mov #0x8, r14                       ! mode 3: stride = 8 entries per iteration
.L_loop1_setup:
    extu.w r13, r7                      ! r7 = 0 (output index for scene_buf_a)
    extu.w r13, r5                      ! r5 = 0 (source record index)
.L_loop1_top:
    mov.b @(2, r4), r0                  ! r0 = config.channel_flag_C (controls Y copy)
    extu.b r0, r0                       ! zero-extend
    tst r0, r0                          ! is flag_C zero?
    bt      .L_loop1_skip_y             ! if zero -> skip Y component copy
    extu.w r7, r0                       ! r0 = output index (zero-extended)
    mov r5, r3                          ! r3 = source record index
    mov r5, r2                          ! r2 = source record index
    shll2 r0                            ! r0 = output_idx * 4 (byte offset into scene_buf_a)
    add #0x1, r7                        ! output index++
    shll2 r3                            ! r3 = src_idx * 4
    shll2 r2                            ! r2 = src_idx * 4
    shll r2                             ! r2 = src_idx * 8
    add r2, r3                          ! r3 = src_idx * 12 (12-byte record stride)
    exts.w r3, r3                       ! sign-extend to 32 bits (handles large indices)
    mov r4, r1                          ! r1 = config base pointer
    add #0x10, r1                       ! r1 = &config.records[0] (record array at +0x10)
    add r1, r3                          ! r3 = &config.records[src_idx] (first longword = Y)
    mov.l @r3, r3                       ! r3 = record[src_idx].field_0 (Y component)
    mov.l r3, @(r0, r6)                 ! scene_buf_a[output_idx] = Y component
.L_loop1_skip_y:
    mov.b @(1, r4), r0                  ! r0 = config.channel_flag_B (controls X copy)
    extu.b r0, r0                       ! zero-extend
    tst r0, r0                          ! is flag_B zero?
    bt      .L_loop1_skip_x             ! if zero -> skip X component copy
    extu.w r7, r0                       ! r0 = output index (zero-extended)
    mov r5, r3                          ! r3 = source record index
    mov r5, r2                          ! r2 = source record index
    shll2 r0                            ! r0 = output_idx * 4 (byte offset)
    add #0x1, r7                        ! output index++
    shll2 r3                            ! r3 = src_idx * 4
    shll2 r2                            ! r2 = src_idx * 4
    shll r2                             ! r2 = src_idx * 8
    add r2, r3                          ! r3 = src_idx * 12 (record stride)
    exts.w r3, r3                       ! sign-extend to 32 bits
    mov r4, r1                          ! r1 = config base pointer
    add #0x10, r1                       ! r1 = &config.records[0]
    add r1, r3                          ! r3 = &config.records[src_idx]
    mov.l @(4, r3), r3                  ! r3 = record[src_idx].field_1 (X component)
    mov.l r3, @(r0, r6)                 ! scene_buf_a[output_idx] = X component
.L_loop1_skip_x:
    mov.b @r4, r0                       ! r0 = config.channel_flag_A (controls Z copy)
    extu.b r0, r0                       ! zero-extend
    tst r0, r0                          ! is flag_A zero?
    bt      .L_loop1_skip_z             ! if zero -> skip Z component copy
    extu.w r7, r0                       ! r0 = output index (zero-extended)
    mov r5, r3                          ! r3 = source record index
    mov r5, r2                          ! r2 = source record index
    shll2 r0                            ! r0 = output_idx * 4 (byte offset)
    add #0x1, r7                        ! output index++
    shll2 r3                            ! r3 = src_idx * 4
    shll2 r2                            ! r2 = src_idx * 4
    shll r2                             ! r2 = src_idx * 8
    add r2, r3                          ! r3 = src_idx * 12 (record stride)
    exts.w r3, r3                       ! sign-extend to 32 bits
    mov r4, r1                          ! r1 = config base pointer
    add #0x10, r1                       ! r1 = &config.records[0]
    add r1, r3                          ! r3 = &config.records[src_idx]
    mov.l @(8, r3), r3                  ! r3 = record[src_idx].field_2 (Z component)
    mov.l r3, @(r0, r6)                 ! scene_buf_a[output_idx] = Z component
.L_loop1_skip_z:
    extu.w r14, r2                      ! r2 = stride (1/2/4/8 depending on viewport_mode)
    add r2, r5                          ! src_idx += stride
    extu.w r5, r3                       ! r3 = src_idx (zero-extended for comparison)
    cmp/ge r10, r3                      ! has src_idx reached 512 (entry limit)?
    bf      .L_loop1_top                ! if not -> continue loop 1
    mov.l   .L_pool_entry_count_a, r3  ! r3 = &entry_count_a (sym_060635A0)
    mov.w r7, @r3                       ! entry_count_a = output index (number of entries written)
    extu.w r13, r7                      ! r7 = 0 (reset output index for loop 2)
    extu.w r13, r5                      ! r5 = 0 (reset source index for loop 2)
.L_loop2_pre:
    bra     .L_loop2_top                ! jump to loop 2 body
    nop
.L_mask_byte1:
    .4byte  0x0000FF00                  /* byte 1 mask (for mode 8 bitmask shift) */
.L_pool_scene_a_cfg:
    .4byte  sym_060A3D70                /* scene A config: size + dest pointer pair */
.L_pool_scene_b_cfg:
    .4byte  sym_060A3D78                /* scene B config: size + dest pointer pair */
.L_pool_half_size_mask:
    .4byte  0x0007FFFF                  /* 19-bit mask for half-size viewport dimension */
.L_pool_entry_count_a:
    .4byte  sym_060635A0                /* scene A entry count (word) */
.L_loop2_top:
    mov.b @(3, r4), r0                  ! r0 = config.channel_flag_D (controls loop 2 copy)
    extu.b r0, r0                       ! zero-extend
    tst r0, r0                          ! is flag_D zero?
    bt      .L_loop2_skip               ! if zero -> skip this entry
    extu.w r7, r0                       ! r0 = output index (zero-extended)
    shll2 r0                            ! r0 = output_idx * 4 (byte offset into scene_buf_b)
    add #0x1, r7                        ! output index++
    extu.w r5, r3                       ! r3 = source index (zero-extended)
    shll2 r3                            ! r3 = src_idx * 4 (byte offset)
    mov.w   .L_wpool_coord_offset, r2  ! r2 = 0x1810 (offset to coord array in config)
    add r4, r2                          ! r2 = &config + 0x1810 (coord array base)
    add r2, r3                          ! r3 = &config.coords[src_idx]
    mov.l @r3, r3                       ! r3 = coords[src_idx] (longword value)
    mov.l r3, @(r0, r12)               ! scene_buf_b[output_idx] = coords[src_idx]
.L_loop2_skip:
    add #0x1, r5                        ! source index++
    extu.w r5, r2                       ! r2 = src_idx (zero-extended for comparison)
    cmp/ge r9, r2                       ! has src_idx reached 64 (loop 2 limit)?
    bf      .L_loop2_pre                ! if not -> continue loop 2
    mov.l   .L_pool_entry_count_b, r3  ! r3 = &entry_count_b (sym_060635A2)
    mov.w r7, @r3                       ! entry_count_b = output index (entries written to buf B)
    mov #0x2, r2                        ! r2 = 2 (ready flag value)
    mov.l   .L_pool_ready_flag, r3     ! r3 = &ready_flag (sym_060635AC)
    mov.w r2, @r3                       ! ready_flag = 2 (signal scene data ready for dispatch)
.L_epilogue:
    add #0x4, r15                       ! free stack scratch space
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_wpool_coord_offset:
    .2byte  0x1810                      /* offset from config base to coord array */
    .2byte  0xFFFF                      /* padding */
.L_pool_entry_count_b:
    .4byte  sym_060635A2                /* scene B entry count (word) */
.L_pool_ready_flag:
    .4byte  sym_060635AC                /* scene ready flag (2 = data ready for dispatch) */
