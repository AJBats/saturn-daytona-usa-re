/* course_selector_hl -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06033738 - 0x060337AE
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Computes the 4 corner vertices of the course selector highlight quad.
 * Handles mirrored (reverse) courses by negating angle and position,
 * then looks up a rotation table to orient the highlight.
 */

    .section .text.FUN_06033738


    .global course_selector_hl
    .type course_selector_hl, @function
course_selector_hl:
    sts.l pr, @-r15              ! save return address
    jsr @r1                      ! call display callback (r1 = fn ptr)
    nop                          ! delay slot
    lds.l @r15+, pr              ! restore return address
    swap.w r0, r1                ! r1 = high 16 bits of callback result
    exts.w r1, r14               ! r14 = sign-extended position offset
    mov.l @r15+, r1              ! r1 = course data table index (from stack)
    .byte   0xD4, 0x26    /* mov.l .L_pool_060337E0, r4 */  ! r4 = 0xFFFFC800 (default angular offset, negative)
    .byte   0xD3, 0x4E    /* mov.l .L_pool_06033884, r3 */  ! r3 = &mirror_flag
    mov.b @r3, r3                ! r3 = mirror flag byte
    cmp/pl r3                    ! is course mirrored? (flag > 0)
    bf      .L_normal_direction  ! branch if not mirrored
    neg r12, r12                 ! negate angle for reverse course
    neg r14, r14                 ! negate position offset for reverse
    .byte   0xD4, 0x23    /* mov.l .L_pool_060337E4, r4 */  ! r4 = 0x00004800 (mirrored angular offset, positive)
.L_normal_direction:
    .byte   0xD0, 0x20    /* mov.l .L_pool_060337D8, r0 */  ! r0 = course geometry table base
    add r1, r0                   ! r0 = &table[index]
    mov.w @r0+, r1               ! r1 = base X from table
    mov.w @r0+, r2               ! r2 = base Y from table
    sub r14, r1                  ! r1 = adjusted X (subtract position offset)
    sub r13, r2                  ! r2 = adjusted Y (subtract center Y)
    mov r1, r14                  ! r14 = highlight center X
    mov r2, r13                  ! r13 = highlight center Y
    cmp/pl r3                    ! is course mirrored?
    bf      .L_skip_mirror_adjust ! branch if not mirrored
    mov.w @r0+, r1               ! r1 = mirror X adjustment
    mov.w @r0, r2                ! r2 = mirror Y adjustment
    add r1, r14                  ! apply mirror X offset to center
    add r2, r13                  ! apply mirror Y offset to center
.L_skip_mirror_adjust:
    add r4, r12                  ! add angular offset to rotation angle
    .byte   0xD0, 0x1C    /* mov.l .L_pool_060337E8, r0 */  ! r0 = 0x0000FFFF (16-bit mask)
    and r0, r12                  ! mask angle to 16 bits
    shlr8 r12                    ! shift right 8 (angle >> 8)
    shlr2 r12                    ! shift right 2 (angle >> 10)
    shlr2 r12                    ! shift right 2 (angle >> 12, total = 16 -> 4-bit index)
    shll r12                     ! shift left 1 (index * 2, each entry is 2 bytes)
    .byte   0xD1, 0x1A    /* mov.l .L_pool_060337EC, r1 */  ! r1 = rotation lookup table base
    add r12, r1                  ! r1 = &rot_table[angle_index]
    mov.b @r1+, r2               ! r2 = rotation X component (signed byte)
    add r11, r2                  ! r2 += base Y offset (combined adjustment)
    mov.b @r1, r0                ! r0 = rotation Y component (signed byte)
    mov r10, r4                  ! r4 = half_size (for corner offsets)
    mov r14, r5                  ! r5 = center X (corner 0 X)
    mov r13, r6                  ! r6 = center Y (corner 0 Y)
    mov r14, r7                  ! r7 = center X (corner 1 X)
    mov r13, r8                  ! r8 = center Y (corner 1 Y)
    mov r14, r9                  ! r9 = center X (corner 2 X)
    mov r13, r10                 ! r10 = center Y (corner 2 Y)
    mov r14, r11                 ! r11 = center X (corner 3 X)
    mov r13, r12                 ! r12 = center Y (corner 3 Y)
    add r4, r7                   ! corner 1 X += half_size (right)
    add r4, r9                   ! corner 2 X += half_size (right)
    add r4, r10                  ! corner 2 Y += half_size (bottom)
    add r4, r12                  ! corner 3 Y += half_size (bottom)
    neg r4, r4                   ! r4 = -half_size
    add r4, r5                   ! corner 0 X -= half_size (left)
    add r4, r11                  ! corner 3 X -= half_size (left)
    add r4, r6                   ! corner 0 Y -= half_size (top)
    add r4, r8                   ! corner 1 Y -= half_size (top)
