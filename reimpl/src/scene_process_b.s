/* scene_process_b -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06025478 - 0x060256CC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Scene geometry / text rendering for car select variant B (up to 8 slots).
 * Near-twin of scene_process_a (variant A handles 10 slots).
 *
 * Checks game state byte (render_phase) to decide text overlay:
 *   State 4: "PRESS START TO EXIT" + two geometry layers
 *   State 5: "PRESS A OR C TO DECIDE  B TO CANCEL" + two geometry layers
 *   Other:   "PRESS A OR C..." (alt text) + two geometry layers
 *
 * After text/geometry setup, iterates up to 8 car slots:
 *   - Calls car_physics_final(slot_idx, render_param) per slot
 *   - For slots matching sentinel (0xB4), reads direction byte pairs
 *     from lookup tables and dispatches layer_setup with computed indices
 *   - Skips sentinel slots only if game state is neither 4 nor 5
 *
 * Parameters:
 *   r4 = slot table index (saved to stack)
 *
 * Persistent registers:
 *   r8  = render_param constant (0x00A8)
 *   r10 = slot_data_ptr (render_base + 0x0590 offset)
 *   r11 = sentinel value (0x00A8 + 0xC = 0x00B4)
 *   r12 = render_base_table (sym_06063750)
 *   r13 = loop counter (0..7)
 *   r14 = fn_layer_setup (sym_06028400)
 */

    .section .text.FUN_06025478


    .global scene_process_b
    .type scene_process_b, @function
scene_process_b:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x18, r15                       ! allocate 24 bytes of locals
    mov.w   DAT_060254de, r8            ! r8 = 0x00A8 (render param constant)
    mov.l   .L_render_base_table, r12   ! r12 = render base table ptr
    mov.l   .L_fn_layer_setup, r14      ! r14 = layer_setup fn (persistent)
    mov r8, r11                         ! r11 = 0x00A8 (will become sentinel)
    mov.l r4, @(4, r15)                 ! save slot_table_index to stack[4]
    mov.l   .L_game_state_byte, r4      ! r4 = &game_state (byte)
    mov.w   .L_text_pos_offset, r13     ! r13 = 0x0C08 (text screen position)
    mov.w   .L_slot_data_offset, r10    ! r10 = 0x0590 (slot data offset into base)
    mov.b @r4, r0                       ! r0 = game_state
    extu.b r0, r0
    cmp/eq #0x4, r0                     ! state == 4? ("PRESS START TO EXIT")
    bf/s    .L_not_state4
    add #0xC, r11                       ! r11 = 0x00B4 (sentinel, in delay slot)
    mov.l   .L_str_press_start, r7      ! === State 4: show "PRESS START TO EXIT" ===
    mov r13, r5                         ! r5 = text position
    mov.l   .L_fn_text_render, r3
    mov.w   .L_text_len, r6             ! r6 = text length (0x0090)
    jsr @r3                             ! text_render(8, pos, len, str_ptr)
    mov #0x8, r4
    mov r12, r7                         ! r7 = render_base + slot_data_offset
    add r10, r7
    mov.l r7, @r15                      ! save slot_data_ptr to stack[0]
    mov.l @(4, r7), r7                  ! r7 = slot_data[1] (frame data ptr)
    mov.w   DAT_060254e6, r6            ! r6 = 0x0C3E (layer param)
    mov.l @r15, r5
    mov.l @r5, r5                       ! r5 = slot_data[0] (render fn ptr)
    jsr @r14                            ! layer_setup(8, render_fn, layer_param, frame_data)
    mov #0x8, r4
    bra     .L_after_text_layers
    nop
.L_not_state4:                              ! --- game_state != 4 ---
    mov.b @r4, r0
    extu.b r0, r0
    cmp/eq #0x5, r0                     ! state == 5? ("PRESS A OR C TO DECIDE...")
    bf      .L_default_text
    mov.l   .L_str_press_ac_decide, r7  ! === State 5: show "PRESS A OR C TO DECIDE  B TO CANCEL" ===
    mov r13, r5
    mov.l   .L_fn_text_render, r3
    mov.w   .L_text_len, r6
    jsr @r3                             ! text_render(8, pos, len, str_ptr)
    mov #0x8, r4
    bra     .L_render_two_layers
    nop

    .global DAT_060254de
DAT_060254de:
    .2byte  0x00A8                       /* render param (variant B) */
.L_text_pos_offset:
    .2byte  0x0C08                       /* text screen position */
.L_slot_data_offset:
    .2byte  0x0590                       /* offset into render_base for slot data */
.L_text_len:
    .2byte  0x0090                       /* text string length param */

    .global DAT_060254e6
DAT_060254e6:
    .2byte  0x0C3E                       /* layer param for state-4 geometry */
.L_render_base_table:
    .4byte  sym_06063750                 /* render base table (8-byte stride) */
.L_fn_layer_setup:
    .4byte  sym_06028400                 /* layer setup / geometry dispatch */
.L_game_state_byte:
    .4byte  sym_06061198                 /* game state byte (render phase) */
.L_str_press_start:
    .4byte  sym_060590B8                 /* "PRESS START TO EXIT" */
.L_fn_text_render:
    .4byte  sym_060284AE                 /* text renderer / geometry dispatch */
.L_str_press_ac_decide:
    .4byte  sym_060590E0                 /* "PRESS A OR C TO DECIDE  B TO CANCEL" */
.L_default_text:                            ! === Default state: show alt "PRESS A OR C..." text ===
    mov.l   .L_str_press_ac_alt, r7
    mov r13, r5
    mov.l   .L_fn_text_render_2, r3
    mov.w   .L_text_len_2, r6
    jsr @r3                             ! text_render(8, pos, len, str_ptr)
    mov #0x8, r4
.L_render_two_layers:                       ! === Render two geometry layers (states 5 & default) ===
    mov r12, r13                        ! r13 = render_base
    mov.w   DAT_060255ce, r6            ! r6 = 0x0C34 (layer A param)
    add r10, r13                        ! r13 = render_base + slot_data_offset
    mov.l @(4, r13), r7                 ! r7 = slot_data[1] (frame data)
    mov.l @r13, r5                      ! r5 = slot_data[0] (render fn)
    jsr @r14                            ! layer_setup(8, render_fn, 0x0C34, frame_data)
    mov #0x8, r4
    mov.l @(4, r13), r7                 ! r7 = slot_data[1] again
    mov.w   DAT_060255d0, r6            ! r6 = 0x0C4E (layer B param)
    mov.l @r13, r5                      ! r5 = slot_data[0] again
    jsr @r14                            ! layer_setup(8, render_fn, 0x0C4E, frame_data)
    mov #0x8, r4
.L_after_text_layers:                       ! === Common path: render type name + 3 geometry layers ===
    mov.l @(4, r15), r7                 ! r7 = slot_table_index
    mov.l   .L_type_name_table, r3      ! r3 = type name string table (" TYPE A"/" TYPE B"/...)
    mov.w   .L_text_len_2, r6           ! r6 = 0x0090 (text length)
    mov.w   DAT_060255d2, r5            ! r5 = 0x02A4 (text screen position)
    mov.l   .L_fn_text_render_2, r2
    shll2 r7                            ! r7 = slot_table_index * 8 (8-byte string stride)
    shll r7
    add r3, r7                          ! r7 = &type_name_table[slot_table_index]
    jsr @r2                             ! text_render(8, 0x02A4, 0x0090, type_name_str)
    mov #0x8, r4
    mov.w   DAT_060255d4, r7            ! r7 = 0x0428 (render_base offset for layer C)
    mov #0x10, r6                       ! r6 = 0x10 (layer C param)
    add r12, r7                         ! r7 = &render_base[0x0428]
    mov.l r7, @r15
    mov.l @(4, r7), r7                  ! r7 = render_base[0x0428].frame_data
    mov.w   DAT_060255d6, r3            ! r3 = 0x6000 (frame data offset)
    mov.l @r15, r5
    add r3, r7                          ! r7 = frame_data + 0x6000
    mov.l @r5, r5                       ! r5 = render_base[0x0428].render_fn
    jsr @r14                            ! layer_setup(8, render_fn, 0x10, frame_data+0x6000)
    mov #0x8, r4
    mov.w   DAT_060255d8, r7            ! r7 = 0x0430 (render_base offset for layer D)
    add r12, r7
    mov.l r7, @r15
    mov.l @(4, r7), r7                  ! r7 = render_base[0x0430].frame_data
    mov.w   DAT_060255da, r3            ! r3 = 0x7000 (frame data offset)
    mov.w   .L_geom_param_a, r6         ! r6 = 0x02A0 (layer D param)
    mov.l @r15, r5
    add r3, r7                          ! r7 = frame_data + 0x7000
    mov.l @r5, r5                       ! r5 = render_fn
    jsr @r14                            ! layer_setup(8, render_fn, 0x02A0, frame_data+0x7000)
    mov #0x8, r4
    mov.w   DAT_060255de, r7            ! r7 = 0x0438 (render_base offset for layer E)
    add r12, r7
    mov.l r7, @r15
    mov.l @(4, r7), r7                  ! r7 = render_base[0x0438].frame_data
    mov.w   DAT_060255da, r3            ! r3 = 0x7000 (frame data offset)
    mov.w   .L_geom_param_b, r6         ! r6 = 0x02B4 (layer E param)
    mov.l @r15, r5
    add r3, r7                          ! r7 = frame_data + 0x7000
    mov.l @r5, r5                       ! r5 = render_fn
    jsr @r14                            ! layer_setup(8, render_fn, 0x02B4, frame_data+0x7000)
    mov #0x8, r4
    mov #0x0, r13                       ! r13 = 0 (loop counter init)
    mov.l @(4, r15), r10                ! r10 = slot_table_index
    shll2 r10                           ! r10 = slot_table_index * 4 (dword stride)
    mov.l   .L_render_record_table, r3  ! r3 = render_record_table base
    add r3, r10                         ! r10 = &render_record_table[slot_table_index]
.L_slot_loop_top:                           ! === Per-slot physics + geometry loop (0..7) ===
    extu.w r8, r5                       ! r5 = render_param (0x00A8)
    mov.l   .L_fn_car_physics_final, r3
    jsr @r3                             ! car_physics_final(slot_idx=r13, render_param=0x00A8)
    extu.w r13, r4                      ! r4 = slot_idx (in delay slot)
    mov r13, r2                         ! r2 = slot_idx
    mov.l @r10, r3                      ! r3 = *render_record_ptr (slot record base)
    shll2 r2                            ! r2 = slot_idx * 8 (8-byte record stride)
    shll r2
    add r3, r2                          ! r2 = &record[slot_idx]
    mov.w @(6, r2), r0                  ! r0 = record[slot_idx].type_id (offset +6)
    mov r0, r2
    extu.w r2, r2
    cmp/eq r11, r2                      ! type_id == sentinel (0xB4)?
    bf      .L_process_slot             ! no → always process this slot
    mov.l   .L_game_state_byte_2, r0    ! yes → check if state allows sentinel skip
    mov.b @r0, r0
    extu.b r0, r0
    cmp/eq #0x4, r0                     ! state == 4? (still process sentinel slots)
    bt      .L_process_slot
    mov.l   .L_game_state_byte_2, r0
    mov.b @r0, r0
    extu.b r0, r0
    cmp/eq #0x5, r0                     ! state == 5? (still process sentinel slots)
    bf      .L_next_slot                ! neither 4 nor 5 → skip sentinel slot
.L_process_slot:                            ! === Render geometry for this slot ===
    mov r13, r9                         ! r9 = slot_idx
    mov.l @r10, r3                      ! r3 = slot record base
    shll2 r9                            ! r9 = slot_idx * 8 (record stride)
    shll r9
    add r9, r3                          ! r3 = &record[slot_idx]
    mov.w @(6, r3), r0                  ! r0 = record.type_id
    mov r0, r2
    extu.w r2, r2
    cmp/eq r11, r2                      ! type_id == sentinel?
    bt      .L_sentinel_match           ! yes → render_class = 9
    bra     .L_dispatch_render          ! no → render_class = 8
    mov #0x8, r2                        ! r2 = 8 (in delay slot)
.L_text_len_2:
    .2byte  0x0090                       /* text length param (duplicate) */

    .global DAT_060255ce
DAT_060255ce:
    .2byte  0x0C34                       /* layer A geometry param */

    .global DAT_060255d0
DAT_060255d0:
    .2byte  0x0C4E                       /* layer B geometry param */

    .global DAT_060255d2
DAT_060255d2:
    .2byte  0x02A4                       /* type name text screen position */

    .global DAT_060255d4
DAT_060255d4:
    .2byte  0x0428                       /* render_base offset: layer C entry */

    .global DAT_060255d6
DAT_060255d6:
    .2byte  0x6000                       /* frame data offset for layer C */

    .global DAT_060255d8
DAT_060255d8:
    .2byte  0x0430                       /* render_base offset: layer D entry */

    .global DAT_060255da
DAT_060255da:
    .2byte  0x7000                       /* frame data offset for layers D/E */
.L_geom_param_a:
    .2byte  0x02A0                       /* layer D geometry param */

    .global DAT_060255de
DAT_060255de:
    .2byte  0x0438                       /* render_base offset: layer E entry */
.L_geom_param_b:
    .2byte  0x02B4                       /* layer E geometry param */
    .2byte  0xFFFF                       /* padding */
.L_str_press_ac_alt:
    .4byte  sym_06059104                 /* "PRESS A OR C..." (alt/truncated) */
.L_fn_text_render_2:
    .4byte  sym_060284AE                 /* text renderer (duplicate ref) */
.L_type_name_table:
    .4byte  sym_06058F94                 /* " TYPE A"/" TYPE B"/..." string table */
.L_render_record_table:
    .4byte  sym_06061184                 /* render record ptr table (variant B) */
.L_fn_car_physics_final:
    .4byte  car_physics_final            /* per-car geometry dispatch */
.L_game_state_byte_2:
    .4byte  sym_06061198                 /* game state byte (duplicate ref) */
.L_sentinel_match:                          ! sentinel slot → render_class = 9
    mov #0x9, r2                        ! r2 = 9
.L_dispatch_render:                         ! === Dispatch two geometry layers per slot ===
    extu.w r2, r2                       ! r2 = render_class (8 or 9)
    mov r13, r6                         ! r6 = slot_idx
    mov r2, r0
    shll r6                             ! r6 = slot_idx * 2 (dir_table byte-pair stride)
    mov.w r0, @(16, r15)               ! save render_class to stack[16]
    mov.l   .L_slot_index_table, r7     ! r7 = &slot_index_table
    add r9, r7                          ! r7 = &slot_index_table[slot_idx*8]
    mov.l r7, @r15                      ! save to stack[0]
    mov.l @r7, r7                       ! r7 = slot_index_table[slot_idx*8] (render base index)
    shll2 r7                            ! r7 = render_base_index * 8 (8-byte stride)
    shll r7
    add r12, r7                         ! r7 = &render_base[render_base_index]
    mov.l r7, @(8, r15)                ! save render_entry_ptr to stack[8]
    mov.l @(4, r7), r7                  ! r7 = render_entry.frame_data
    mov.l   .L_fp_half, r3             ! r3 = 0x8000 (0.5 fixed-point)
    mov.l r6, @(4, r15)                ! save slot_idx*2 to stack[4]
    add r3, r7                          ! r7 = frame_data + 0x8000 (half offset)
    mov.l   .L_dir_table_a, r3         ! --- First layer: direction table A ---
    add r3, r6                          ! r6 = &dir_table_a[slot_idx*2]
    mov.l r6, @(12, r15)              ! save dir_ptr to stack[12]
    mov.b @(1, r6), r0                  ! r0 = dir_high byte
    mov.l @(12, r15), r2
    mov r0, r6
    mov.b @r2, r2                       ! r2 = dir_low byte
    extu.b r6, r6
    extu.b r2, r2
    shll2 r6                            ! r6 = dir_high << 6
    shll2 r6
    shll2 r6
    add r2, r6                          ! r6 = (dir_high << 6) | dir_low
    shll r6                             ! r6 = index * 2
    mov.l @(8, r15), r5                ! r5 = render_entry_ptr
    mov.l @r15, r4                      ! r4 = &slot_index_table[slot_idx*8]
    mov.l @r5, r5                       ! r5 = render_entry.render_fn
    add #0x4, r4                        ! r4 = &slot_index_table[slot_idx*8 + 4]
    mov.l r4, @(20, r15)              ! save to stack[20]
    mov.l @r4, r4                       ! r4 = slot_index_table[slot_idx*8 + 4]
    jsr @r14                            ! layer_setup(class*4, render_fn, index*2, frame_data+0x8000)
    shll2 r4                            ! r4 *= 4 (in delay slot)
    mov.w @(16, r15), r0               ! --- Second layer: use record type_id to select render_base entry ---
    mov.l @r10, r3                      ! r3 = slot record base
    mov r0, r7                          ! r7 = render_class
    add r9, r3                          ! r3 = &record[slot_idx]
    extu.w r7, r7
    mov.w @(6, r3), r0                  ! r0 = record.type_id
    shll8 r7                            ! r7 = render_class << 12 (combined offset)
    mov r0, r2
    shll2 r7
    extu.w r2, r3                       ! r3 = type_id (zero-extended)
    shll2 r7
    shll2 r3                            ! r3 = type_id * 8 (8-byte stride)
    shll r3
    mov r12, r2                         ! r2 = render_base
    add r3, r2                          ! r2 = &render_base[type_id]
    mov.l r2, @(8, r15)               ! save to stack[8]
    mov.l @(4, r2), r3                  ! r3 = render_base[type_id].frame_data
    add r3, r7                          ! r7 = frame_data + (render_class << 12)
    mov.l @(4, r15), r6                ! r6 = slot_idx * 2
    mov.l   .L_dir_table_b, r3         ! --- Second layer: direction table B ---
    add r3, r6                          ! r6 = &dir_table_b[slot_idx*2]
    mov.l r6, @r15                     ! save dir_ptr to stack[0]
    mov.b @(1, r6), r0                  ! r0 = dir_high byte
    mov r0, r6
    extu.b r6, r6
    shll2 r6                            ! r6 = dir_high << 6
    shll2 r6
    shll2 r6
    mov.l @r15, r2
    mov.b @r2, r2                       ! r2 = dir_low byte
    extu.b r2, r2
    add r2, r6                          ! r6 = (dir_high << 6) | dir_low
    shll r6                             ! r6 = index * 2
    mov.l @(8, r15), r5                ! r5 = &render_base[type_id]
    mov.l @(20, r15), r4               ! r4 = slot_index+4 value
    mov.l @r5, r5                       ! r5 = render_base[type_id].render_fn
    mov.l @r4, r4                       ! r4 = slot_index+4 deref
    jsr @r14                            ! layer_setup(class*4, render_fn, index*2, frame_data)
    shll2 r4                            ! r4 *= 4 (in delay slot)
.L_next_slot:                               ! === Advance to next slot ===
    add #0x1, r13                       ! r13++ (next slot)
    mov #0x8, r3                        ! max 8 slots for variant B
    cmp/ge r3, r13                      ! r13 >= 8?
    bt      .L_epilogue                 ! yes → done
    bra     .L_slot_loop_top            ! no → next iteration
    nop
.L_epilogue:                                ! === Restore registers and return ===
    add #0x18, r15                      ! deallocate 24 bytes of locals
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
    .2byte  0xFFFF                       /* padding */
.L_slot_index_table:
    .4byte  sym_0605900C                 /* per-slot render base index table */
.L_fp_half:
    .4byte  0x00008000                   /* 0.5 (16.16 fixed-point) */
.L_dir_table_a:
    .4byte  sym_06059074                 /* direction byte-pair table A (2-byte stride) */
.L_dir_table_b:
    .4byte  sym_06059084                 /* direction byte-pair table B (2-byte stride) */
