/* attract_cleanup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603FF3A - 0x0603FF9C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * attract_cleanup(r4=unused, r5=dst_base, r6=dst_stride, r7=src_base,
 *                 sp[8]=src_stride, sp[12]=total_bytes):
 *   Block-copies longwords from src array to dst array with configurable
 *   strides. If dst_base (r5) is zero, returns immediately (nothing to
 *   clean). Otherwise copies total_bytes/4 longwords, then tail-calls
 *   FUN_0603FFE6 to handle any trailing bytes (total_bytes & 3).
 *
 * loc_0603FF8A:
 *   Null handler stub — returns 0. Referenced from function pointer table
 *   in binary_final_func (sym_0606367C area).
 */

    .section .text.FUN_0603FF3A


    .global attract_cleanup
    .type attract_cleanup, @function
attract_cleanup:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov r7, r13                         ! r13 = src_base
    tst r5, r5                          ! test if dst_base is NULL
    bf/s    .L_dst_valid                ! branch if dst_base != 0
    mov r5, r14                         ! r14 = dst_base (delay slot)
    bra     .L_early_return             ! dst is NULL — skip cleanup
    nop
    .2byte  0x0101                      ! (unreachable padding / data)
    .4byte  0x25FE000C                  ! (unreachable data)
    .4byte  sym_06000340                ! (unreachable pointer)
.L_dst_valid:
    mov #0x0, r4                        ! r4 = loop counter = 0
    shll2 r6                            ! r6 = dst_stride * 4 (bytes)
    mov.l @(8, r15), r7                 ! r7 = src_stride (from stack)
    mov.l @(12, r15), r5                ! r5 = total_bytes (from stack)
    mov r4, r3                          ! r3 = 0 (copy of counter for compare)
    shlr2 r5                            ! r5 = total_bytes / 4 = longword count
    cmp/hs r5, r3                       ! if counter >= longword_count already
    bt/s    .L_copy_done                ! skip loop (nothing to copy)
    shll2 r7                            ! r7 = src_stride * 4 (bytes, delay slot)
.L_copy_loop:
    add #0x1, r4                        ! counter++
    mov.l @r13, r3                      ! r3 = *src
    mov.l r3, @r14                      ! *dst = r3 (copy one longword)
    add r6, r14                         ! dst += dst_stride
    cmp/hs r5, r4                       ! if counter >= longword_count
    bf/s    .L_copy_loop                ! loop if counter < longword_count
    add r7, r13                         ! src += src_stride (delay slot)
.L_copy_done:
    mov r13, r6                         ! r6 = final src ptr (arg for tail call)
    mov r14, r5                         ! r5 = final dst ptr (arg for tail call)
    mov.l @(12, r15), r0                ! r0 = total_bytes (reload from stack)
    and #0x3, r0                        ! r0 = remaining bytes (total_bytes & 3)
    mov r0, r4                          ! r4 = remaining byte count (arg)
    mov.l @r15+, r13                    ! restore r13
    .byte   0xA0, 0x31    /* bra 0x0603FFE6 (external) */ ! tail-call: copy remaining bytes
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_early_return:
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return (no cleanup needed)
    mov.l @r15+, r14                    ! restore r14 (delay slot)

    .global loc_0603FF8A
loc_0603FF8A:
    rts                                 ! return immediately (null handler)
    mov #0x0, r0                        ! r0 = 0 (return value, delay slot)
    .2byte  0x7FFC                      ! (next TU preamble — not part of this function)
    .4byte  0x2F426043                  ! (next TU code)
    .4byte  0x50095448                  ! (next TU code)
    .4byte  0x402B7F04                  ! (next TU code)
