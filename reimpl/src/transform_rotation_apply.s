/* transform_rotation_apply -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06026362 - 0x060263EC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Iterates over 10 rotation data slots (sym_06060F2C, 8-byte stride) and
 * reads each slot's rotation type word at offset +6.  After subtracting the
 * base value 0x8A, the adjusted index dispatches through a 12-entry jump
 * table to write one of two values (zero or 0.5 fixed-point) into one of
 * two output channels (rotation_out_a at sym_06060D2A, rotation_out_b at
 * sym_06060D34).
 *
 * Jump table (12 entries, rotation_adjusted 0..11):
 *   0,1    -> rotation_out_a = 0          (clear channel A)
 *   2,3    -> rotation_out_b = 0          (clear channel B)
 *   4,5,6,7  -> rotation_out_a = 0x8000   (set channel A to 0.5 fp16.16)
 *   8,9,10,11 -> rotation_out_b = 0x8000  (set channel B to 0.5 fp16.16)
 *   >=12   -> skip slot (out of range)
 *
 * Called by sprite_pair_render (variant A) when mode == 4.
 *
 * Persistent registers:
 *   r12 = rotation_data_table base (sym_06060F2C, 8-byte stride)
 *   r13 = 10 (slot count limit)
 *   r14 = &rotation_out_a (sym_06060D2A, written as word)
 *   r7  = &rotation_out_b (sym_06060D34, written as word)
 *   r5  = 0x8000 (0.5 in 16.16 fixed-point, "half" constant)
 *   r4  = 0 (zero constant)
 *   r6  = current slot index (loop variable, 0..9)
 */

    .section .text.FUN_06026362


    .global transform_rotation_apply
    .type transform_rotation_apply, @function
transform_rotation_apply:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    mov.l r13, @-r15                        ! save r13 (callee-saved)
    mov.l r12, @-r15                        ! save r12 (callee-saved)
    .byte   0xDC, 0x0C    /* mov.l .L_pool_rotation_data_table, r12 */
    mov #0xA, r13                           ! r13 = 10 (slot count limit)
    .byte   0xDE, 0x0C    /* mov.l .L_pool_rotation_out_a, r14 */
    .byte   0xD7, 0x0D    /* mov.l .L_pool_rotation_out_b, r7 */
    .byte   0xD5, 0x0D    /* mov.l .L_fp_half, r5 */
    mov #0x0, r4                            ! r4 = 0 (zero constant)
    extu.w r4, r6                           ! r6 = 0 (slot index, loop start)
.L_loop_body:                              ! === Per-slot rotation dispatch ===
    extu.w r6, r0                           ! r0 = slot_idx (zero-extended)
    shll2 r0                                ! r0 = slot_idx * 4
    shll r0                                 ! r0 = slot_idx * 8 (8-byte stride)
    add r12, r0                             ! r0 -> rotation_data_table[slot_idx]
    mov.w @(6, r0), r0                      ! r0 = rotation type word (slot[i]+6)
    bra     .L_dispatch_rotation            ! jump to switch dispatch
    extu.w r0, r0                           ! [delay] r0 = rotation type (zero-extended)
    /* --- Inline switch case bodies (encoded as raw bytes due to BRA) ---
     *
     * Case A (index 0,1): entry at 0x06026384
     *   bra +2 / extu.w r4, r2  → r2 = 0 (skip fp_half load)
     *   bra loop_next / mov.w r2, @r14  → rotation_out_a = 0
     *
     * Case C (index 4-7): entry at 0x06026388
     *   extu.w r5, r2  → r2 = fp_half (0x8000)
     *   bra loop_next / mov.w r2, @r14  → rotation_out_a = 0x8000
     *
     * Case B (index 2,3): entry at 0x0602638E
     *   bra +2 / extu.w r4, r2  → r2 = 0 (skip fp_half load)
     *   bra loop_next / mov.w r2, @r7   → rotation_out_b = 0
     *
     * Case D (index 8-11): entry at 0x06026392
     *   extu.w r5, r2  → r2 = fp_half (0x8000)
     *   bra loop_next / mov.w r2, @r7   → rotation_out_b = 0x8000
     */
    .4byte  0xA001624D                      /* bra +2 / extu.w r4, r2 (case A entry) */
    .4byte  0x625DA027                      /* extu.w r5, r2 / bra loop_next (case C entry) */
    .4byte  0x2E21A001                      /* mov.w r2, @r14 [delay] / bra +2 (case B entry) */
    .4byte  0x624D625D                      /* extu.w r4, r2 [delay] / extu.w r5, r2 (case D entry) */
    .4byte  0xA0222721                      /* bra loop_next / mov.w r2, @r7 [delay] */
.L_out_of_range:                           ! rotation type out of jump table bounds
    bra     .L_loop_next                    ! skip this slot, continue loop
    nop                                     ! (delay slot)
.L_pool_rotation_data_table:
    .4byte  sym_06060F2C                    /* rotation data table base (8-byte stride, 10 slots) */
.L_pool_rotation_out_a:
    .4byte  sym_06060D2A                    /* &rotation_out_a (word output) */
.L_pool_rotation_out_b:
    .4byte  sym_06060D34                    /* &rotation_out_b (word output) */
.L_fp_half:
    .4byte  0x00008000                      /* 0.5 (16.16 fixed-point) */
.L_dispatch_rotation:                      ! === Switch: rotation_adjusted -> channel write ===
    mov.w   .L_wpool_060263C2, r1           ! r1 = 0x008A (rotation base offset)
    sub r1, r0                              ! r0 = rotation_type - 0x8A (adjusted index)
    mov #0xC, r1                            ! r1 = 12 (jump table entry count)
    cmp/hs r1, r0                           ! adjusted_index >= 12? (unsigned)
    bt      .L_out_of_range                 ! yes -> out of range, skip slot
    shll r0                                 ! r0 = adjusted_index * 2 (word offset)
    mov r0, r1                              ! r1 = adjusted_index * 2 (copy for indexed access)
    .word 0xC702 /* UNKNOWN */              /* mova @(0x8,PC), r0 -> r0 = jump offset table base */
    mov.w @(r0, r1), r0                     ! r0 = signed jump offset from table[adjusted_index]
    braf r0                                 ! PC-relative indirect branch -> dispatch case
    nop                                     ! (delay slot)
.L_wpool_060263C2:
    .2byte  0x008A                          /* rotation base value to subtract */
    .4byte  0xFFC2FFC2                      /* index 0,1: offset -62 -> case A (rotation_out_a = 0) */
    .4byte  0xFFCCFFCC                      /* index 2,3: offset -52 -> case B (rotation_out_b = 0) */
    .4byte  0xFFC6FFC6                      /* index 4,5: offset -58 -> case C (rotation_out_a = fp_half) */
    .4byte  0xFFC6FFC6                      /* index 6,7: offset -58 -> case C (rotation_out_a = fp_half) */
    .4byte  0xFFD0FFD0                      /* index 8,9: offset -48 -> case D (rotation_out_b = fp_half) */
    .4byte  0xFFD0FFD0                      /* index 10,11: offset -48 -> case D (rotation_out_b = fp_half) */
.L_loop_next:                              ! === Loop increment ===
    add #0x1, r6                            ! slot_idx++
    extu.w r6, r2                           ! r2 = slot_idx (zero-extended)
    cmp/ge r13, r2                          ! slot_idx >= 10 (slot_limit)?
    bf      .L_loop_body                    ! no -> process next slot
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! [delay] restore r14
