/* obj_state_serialize -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06020D50 - 0x06020DD0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * obj_state_serialize — dispatch per-object handler for each active object
 *
 * Copies the object handler function table (sym_0605F5A8, 9 entries = 0x24 bytes)
 * onto the stack, then iterates over objects 0..r11-1. For each object whose
 * type byte (at slot[0]) is non-zero, calls handler_table[type-1](obj_index).
 *
 * Object slot stride is 0x44 (68 bytes): index*4 + index*64 = index*68.
 * Slot byte 0 holds the object type.
 *
 * Args:
 *   r11 = object count (max index, exclusive)
 *   (r13, r14 saved by caller — callee-saved registers restored on exit)
 *
 * Returns: nothing (void)
 *
 * Calls:
 *   memcpy_long (sym_06035168) — copy handler table to stack
 *   handler_table[type-1]      — per-object dispatch
 */

    .section .text.FUN_06020D50


    .global obj_state_serialize
    .type obj_state_serialize, @function
obj_state_serialize:
    sts.l pr, @-r15                         ! save return address
    add #-0x24, r15                         ! allocate 0x24 (36) bytes on stack for handler table copy
    mov r15, r12                            ! r12 = stack handler table base (for indexed lookup)
    mov r15, r1                             ! r1  = dst for memcpy_long (stack buffer)
    mov.l   .L_pool_handler_table, r2            ! r2  = src for memcpy_long (sym_0605F5A8 = handler table)
    mov.l   .L_pool_slot_array_base, r13           ! r13 = object slot array base (sym_0608782C)
    mov.l   .L_pool_memcpy_long, r3            ! r3  = memcpy_long function address (sym_06035168)
    jsr @r3                                 ! call memcpy_long(r0=count, r1=dst, r2=src)
    mov #0x24, r0                           ! (delay slot) r0 = 0x24 (36 bytes to copy — 9 function ptrs)
    mov #0x0, r14                           ! r14 = loop counter (object index), starts at 0
.L_obj_loop:
    extu.b r14, r2                          ! r2 = obj_index (zero-extended to 32-bit)
    mov r2, r3                              ! r3 = obj_index (copy for 64x multiply)
    shll2 r2                                ! r2 = obj_index * 4
    shll2 r3                                ! r3 = obj_index * 4
    shll2 r3                                ! r3 = obj_index * 16
    shll2 r3                                ! r3 = obj_index * 64
    add r3, r2                              ! r2 = obj_index*4 + obj_index*64 = obj_index*68 (slot offset)
    exts.w r2, r2                           ! r2 = sign-extend slot offset to 32-bit
    add r13, r2                             ! r2 = &slot_array[obj_index] (pointer to slot)
    mov.b @r2, r2                           ! r2 = slot[0] — object type byte
    extu.b r2, r2                           ! r2 = zero-extend type byte
    tst r2, r2                              ! test: type == 0 (empty/inactive slot)?
    bt      .L_skip_dispatch                ! if type is 0, skip this object
    extu.b r14, r0                          ! r0 = obj_index (zero-extended)
    mov r0, r3                              ! r3 = obj_index (copy for 64x multiply)
    shll2 r0                                ! r0 = obj_index * 4
    shll2 r3                                ! r3 = obj_index * 4
    shll2 r3                                ! r3 = obj_index * 16
    shll2 r3                                ! r3 = obj_index * 64
    add r3, r0                              ! r0 = obj_index*68 (slot offset, recomputed)
    exts.w r0, r0                           ! r0 = sign-extend slot offset
    mov.b @(r0, r13), r0                    ! r0 = slot[0] — reload type byte from slot array
    extu.b r0, r0                           ! r0 = zero-extend type byte
    add #-0x1, r0                           ! r0 = type - 1 (0-based handler index)
    shll2 r0                                ! r0 = (type-1) * 4 (byte offset into handler table)
    mov.l @(r0, r12), r3                    ! r3 = handler_table[type-1] (function pointer from stack)
    jsr @r3                                 ! call handler(r4 = obj_index)
    mov r14, r4                             ! (delay slot) r4 = obj_index (argument to handler)
.L_skip_dispatch:
    add #0x1, r14                           ! r14++ (advance to next object)
    extu.b r14, r2                          ! r2 = next obj_index (zero-extended)
    cmp/ge r11, r2                          ! test: obj_index >= object_count?
    bf      .L_obj_loop                     ! if not done, continue loop
    add #0x24, r15                          ! deallocate stack buffer (36 bytes)
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r11                        ! restore r11 (callee-saved)
    mov.l @r15+, r12                        ! restore r12 (callee-saved)
    mov.l @r15+, r13                        ! restore r13 (callee-saved)
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! (delay slot) restore r14 (callee-saved)

    .global DAT_06020db2
DAT_06020db2:
    mov.b @(r0, r2), r1
    .4byte  sym_06087C6C
    .4byte  sym_060785FC
    .4byte  sym_060280F8
    .4byte  sym_0605A008
.L_pool_slot_array_base:
    .4byte  sym_0608782C                /* object slot array base */
.L_pool_handler_table:
    .4byte  sym_0605F5A8                /* handler function pointer table */
.L_pool_memcpy_long:
    .4byte  sym_06035168                /* memcpy_long utility */
