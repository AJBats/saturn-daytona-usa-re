/* sprite_anim_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060266CC - 0x06027552
 * Auto-generated by tools/generate_l3_tu.py
 *
 * This is one of the largest and most important TUs in the game. It contains
 * the sprite animation sequencer, the entire 3D matrix transform pipeline
 * (two independent matrix stacks A and B), and the core trig/math library.
 *
 * Functions:
 *   sprite_anim_update()      — sprite animation sequencer (frame counter + state machine)
 *   menu_overlay_render()     — menu/overlay rendering with timer-based transitions
 *   vdp2_reg_block_setup()    — VDP2 register block write helper
 *   sym_06026CE0              — delay spin counter (NOP sled timing loop)
 *
 * Matrix Stack A (world/camera transforms):
 *   sym_06026DBC  mat_push_a         — push 48-byte matrix, advance stack pointer
 *   sym_06026DF8  mat_pop_a          — pop matrix, retreat stack pointer
 *   sym_06026E02  mat_identity_reset_a — reset stack to base + write identity
 *   sym_06026E0C  mat_identity_a     — write identity to current top
 *   sym_06026E2E  mat_translate_a    — apply translation via MAC unit
 *   transform_matrix()               — apply X-Z rotation to current matrix
 *   mat_rot_y()                      — apply Y rotation to current matrix
 *   mat_rot_z()                      — apply Z rotation to current matrix (XY plane)
 *   sym_06026F72  mat_mul_a          — full 3x3 matrix multiply + translation
 *   mat_vec_transform()              — transform vec3 through current matrix
 *
 * Matrix Stack B (object/model transforms):
 *   sym_06027080  mat_push_b         — push 48-byte matrix (stack B)
 *   sym_060270C6  mat_identity_reset_b
 *   sym_060270D0  mat_identity_b
 *   sym_060270F2  mat_translate_b
 *   mat_rot_xz_b()                   — X-Z rotation (stack B)
 *   mat_rot_xy_b()                   — X-Y rotation (stack B)
 *   mat_rot_yz_b()                   — Y-Z rotation (stack B)
 *   mat_vec_transform_b()            — transform vec3 (stack B)
 *
 * Trigonometry & Math:
 *   cos_lookup(angle)         — cos via 4096-entry table at 0x002F2F20
 *   sin_lookup(angle)         — sin via same table
 *   sincos_pair(angle, &sin, &cos) — both sin and cos in one call
 *   atan_piecewise(value)     — 10-segment piecewise linear atan
 *   atan2(x, y)               — full quadrant atan2
 *   atan2_full(x, y)          — atan2 inner (non-degenerate case)
 *   isqrt(value)              — integer square root via binary search
 *   vec3_normalize(vec*)      — normalize 3D vector to unit length
 *   swap_sign_ext(value)      — swap.w + sign-extend helper
 *
 * Number representations (used throughout):
 *   16.16 fixed-point: 0x00010000 = 1.0, 0x00008000 = 0.5
 *   Angles: 0x10000 = 360 deg, 0x4000 = 90 deg, 0x8000 = 180 deg
 *
 * Matrix format: 48 bytes = 3x3 rotation (9 longs) + translation (3 longs)
 *   Offsets: [0..8]=rot row0, [12..20]=rot row1, [24..32]=rot row2, [36..44]=translation
 *
 * Key data symbols:
 *   mat_stack_ptr_a    — current stack A top pointer (48 bytes per entry)
 *   mat_stack_base_a   — stack A base address
 *   mat_temp_a         — rotation setup scratch (16 bytes)
 *   mat_vec_result_a   — vec transform output (12 bytes)
 *   mat_stack_ptr_b    — current stack B top pointer
 *   mat_stack_base_b   — stack B base address
 *   mat_temp_b         — rotation setup scratch (16 bytes)
 *   mat_vec_result_b   — vec transform output (12 bytes)
 */

    .section .text.FUN_060266CC


    .global sprite_anim_update
    .type sprite_anim_update, @function
/* sprite_anim_update() — sprite animation sequencer.
 * Reads animation command word from sym_06063D9A, dispatches animation state.
 * Uses bit-field commands (0x0E00, 0x0100, 0x1000, 0x2000) to control
 * frame advance, reverse, and overlay rendering. Clamps frame counter
 * between 0x12 and 0x14. Falls through to tail-call sym_06028400 in
 * some paths.
 */
sprite_anim_update:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x4, r15
    mov.l   .L_sym_06059128, r10
    mov.l   .L_sym_060284AE, r12
    mov.w   .L_wpool_06026728, r13
    mov.l   .L_sym_06089EDA, r14
    mov.w   DAT_0602672a, r8
    mov.l   .L_sym_0605912C, r7
    mov r13, r6
    mov r8, r5
    jsr @r12
    mov #0x8, r4
    mov r13, r6
    mov.w   DAT_0602672c, r9
    mov.l   .L_sym_06059134, r7
    mov r9, r5
    jsr @r12
    mov #0x8, r4
    mov.l   .L_sym_06063D9A, r11
    mov.w @r11, r11
    extu.w r11, r3
    tst r3, r3
    bf      .L_0602670C
    bra     .L_06026824
    nop
.L_0602670C:
    mov.l   .L_sym_06061198, r6
    extu.w r11, r3
    mov.w   DAT_0602672e, r2
    mov.l   .L_sym_06089ED8, r4
    and r2, r3
    tst r3, r3
    bt/s    .L_06026784
    mov #0x6, r5
    mov.w @r14, r0
    extu.w r0, r0
    cmp/eq #0x12, r0
    bf      .L_06026750
    bra     .L_06026752
    mov #0x1, r3
.L_wpool_06026728:
    .2byte  0x0090

    .global DAT_0602672a
DAT_0602672a:
    .2byte  0x0926

    .global DAT_0602672c
DAT_0602672c:
    .2byte  0x0A26

    .global DAT_0602672e
DAT_0602672e:
    .2byte  0x0E00
.L_sym_06059128:
    .4byte  sym_06059128
.L_sym_060284AE:
    .4byte  sym_060284AE
.L_sym_06089EDA:
    .4byte  sym_06089EDA
.L_sym_0605912C:
    .4byte  sym_0605912C
.L_sym_06059134:
    .4byte  sym_06059134
.L_sym_06063D9A:
    .4byte  sym_06063D9A
.L_sym_06061198:
    .4byte  sym_06061198
.L_sym_06089ED8:
    .4byte  sym_06089ED8
.L_06026750:
    mov #0x0, r3
.L_06026752:
    mov r10, r7
    mov.w r3, @r4
    mov.b r5, @r6
    mov r13, r6
    mov.w @r14, r5
    extu.w r5, r5
    shll2 r5
    shll2 r5
    shll2 r5
    add #0x11, r5
    shll r5
    jsr @r12
    mov #0x8, r4
    mov.l   .L_sym_0605913C, r7
    mov r13, r6
    mov r8, r5
    jsr @r12
    mov #0x8, r4
    mov r13, r6
    mov r9, r5
    mov.l   .L_sym_06059144, r7
    jsr @r12
    mov #0x8, r4
    bra     .L_06026892
    nop
.L_06026784:
    extu.w r11, r3
    mov.w   .L_wpool_06026848, r2
    cmp/eq r2, r3
    bf      .L_060267C0
    mov #0x0, r2
    mov r10, r7
    mov.w r2, @r4
    mov.b r5, @r6
    mov r13, r6
    mov.w @r14, r5
    extu.w r5, r5
    shll2 r5
    shll2 r5
    shll2 r5
    add #0x11, r5
    shll r5
    jsr @r12
    mov #0x8, r4
    mov r13, r6
    mov r8, r5
    mov.l   .L_sym_0605913C, r7
    jsr @r12
    mov #0x8, r4
    mov.l   .L_sym_06059144, r7
    mov r13, r6
    mov r9, r5
    jsr @r12
    mov #0x8, r4
    bra     .L_06026892
    nop
.L_060267C0:
    extu.w r11, r3
    mov.w   DAT_0602684a, r2
    cmp/eq r2, r3
    bf      .L_060267E4
    mov r10, r7
    mov r13, r6
    mov.w @r14, r5
    extu.w r5, r5
    shll2 r5
    shll2 r5
    shll2 r5
    add #0x11, r5
    shll r5
    jsr @r12
    mov #0x8, r4
    mov.w @r14, r3
    add #-0x2, r3
    mov.w r3, @r14
.L_060267E4:
    extu.w r11, r11
    mov.w   .L_wpool_0602684C, r2
    cmp/eq r2, r11
    bf      .L_06026808
    mov r10, r7
    mov r13, r6
    mov.w @r14, r5
    extu.w r5, r5
    shll2 r5
    shll2 r5
    shll2 r5
    add #0x11, r5
    shll r5
    jsr @r12
    mov #0x8, r4
    mov.w @r14, r3
    add #0x2, r3
    mov.w r3, @r14
.L_06026808:
    mov.w @r14, r2
    mov #0x14, r3
    extu.w r2, r2
    cmp/gt r3, r2
    bf      .L_06026816
    mov #0x12, r3
    mov.w r3, @r14
.L_06026816:
    mov #0x12, r3
    mov.w @r14, r2
    extu.w r2, r2
    cmp/ge r3, r2
    bt      .L_06026824
    mov #0x14, r3
    mov.w r3, @r14
.L_06026824:
    mov.l   .L_sym_06089EC6, r0
    mov.w @r0, r0
    extu.w r0, r0
    tst #0x4, r0
    bt      .L_0602685C
    mov r10, r7
    mov r13, r6
    mov.w @r14, r5
    extu.w r5, r5
    shll2 r5
    shll2 r5
    shll2 r5
    add #0x11, r5
    shll r5
    jsr @r12
    mov #0x8, r4
    bra     .L_06026892
    nop
.L_wpool_06026848:
    .2byte  0x0100

    .global DAT_0602684a
DAT_0602684a:
    .2byte  0x1000
.L_wpool_0602684C:
    .2byte  0x2000
    .2byte  0xFFFF
.L_sym_0605913C:
    .4byte  sym_0605913C
.L_sym_06059144:
    .4byte  sym_06059144
.L_sym_06089EC6:
    .4byte  sym_06089EC6
.L_0602685C:
    mov.l   .L_sym_06063B88, r2
    mov.l r2, @r15
    mov r2, r7
    mov.w   DAT_060268a6, r3
    mov.w @r14, r6
    mov.l @(4, r7), r7
    extu.w r6, r6
    add r3, r7
    shll2 r6
    shll2 r6
    shll2 r6
    add #0x11, r6
    shll r6
    mov r2, r5
    mov.l @r5, r5
    mov #0x8, r4
    add #0x4, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    mov.l   .L_sym_06028400, r3
    jmp @r3
    mov.l @r15+, r14
.L_06026892:
    add #0x4, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14

    .global DAT_060268a6
DAT_060268a6:
    .2byte  0x7000
.L_sym_06063B88:
    .4byte  sym_06063B88
.L_sym_06028400:
    .4byte  sym_06028400

    .global menu_overlay_render
    .type menu_overlay_render, @function
/* menu_overlay_render(r4=mode) — menu/overlay rendering with timer-based transitions.
 * mode=0: reset all overlay state. mode!=0: run overlay animation state machine.
 * Uses frame timer at sym_0607864C, reads transition table at sym_060597B8,
 * dispatches VDP2 register block writes via sym_060283E0.
 */
menu_overlay_render:
    mov.l r14, @-r15
    exts.w r4, r4
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    mov.w   DAT_06026922, r8
    mov.l   .L_sym_060283E0, r9
    mov.l   .L_sym_0606123C, r10
    mov.l   .L_sym_0607864C, r11
    mov.l   .L_sym_0606123A, r13
    mov.l   .L_sym_06061238, r14
    tst r4, r4
    bt/s    .L_060268E6
    mov #0x0, r12
    mov.w r12, @r10
    exts.w r12, r2
    mov.w r2, @r13
    mov.w r2, @r14
    mov.l   .L_sym_0606123E, r2
    mov.w r12, @r2
    bra     .L_06026C70
    mov.l r12, @r11
.L_060268E6:
    mov.l   .L_sym_0607EAD8, r0
    bra     .L_06026C48
    mov.l @r0, r0
.L_060268EC:
    mov.w @r14, r2
    mov #0x36, r3
    cmp/ge r3, r2
    bt      .L_0602694C
    mov.w @r14, r3
    mov.l   .L_sym_060597B8, r2
    mov.l @r11, r0
    shll r3
    add r2, r3
    mov.w @r3, r3
    mov r3, r1
    shll r3
    add r1, r3
    cmp/hs r3, r0
    bf      .L_06026982
    mov r8, r5
    mov.w @r14, r2
    add #0x1, r2
    mov.w r2, @r14
    mov.w r12, @r13
    mov.l   .L_sym_06059826, r7
    mov.l   .L_pool_06026948, r6
    jsr @r9
    mov #0xC, r4
    mov #0x1, r2
    bra     .L_06026982
    mov.w r2, @r10

    .global DAT_06026922
DAT_06026922:
    .2byte  0x0C04
.L_sym_060283E0:
    .4byte  sym_060283E0
.L_sym_0606123C:
    .4byte  sym_0606123C
.L_sym_0607864C:
    .4byte  sym_0607864C
.L_sym_0606123A:
    .4byte  sym_0606123A
.L_sym_06061238:
    .4byte  sym_06061238
.L_sym_0606123E:
    .4byte  sym_0606123E
.L_sym_0607EAD8:
    .4byte  sym_0607EAD8
.L_sym_060597B8:
    .4byte  sym_060597B8
.L_sym_06059826:
    .4byte  sym_06059826
.L_pool_06026948:
    .4byte  0x0000F000
.L_0602694C:
    mov.w @r14, r0
    cmp/eq #0x36, r0
    bf      .L_06026982
    mov.w @r14, r2
    mov.l   .L_sym_060597B8_2, r3
    mov.l   .L_sym_0607864C_2, r0
    shll r2
    mov.l @r0, r0
    add r3, r2
    mov.w @r2, r2
    mov r2, r1
    shll r2
    add r1, r2
    cmp/hs r2, r0
    bf      .L_06026982
    mov r8, r5
    mov.l   .L_sym_06059826_2, r7
    mov.l   .L_pool_06026B28, r6
    jsr @r9
    mov #0xC, r4
    exts.w r12, r3
    mov.w r3, @r14
    exts.w r12, r2
    mov.w r2, @r13
    mov #0x1, r3
    mov.l   .L_sym_0606123E_2, r2
    mov.w r3, @r2
.L_06026982:
    mov.w @r10, r0
    tst r0, r0
    bt      .L_060269A2
    mov r8, r5
    mov.w @r14, r7
    mov.l   .L_sym_060591BA, r3
    mov.l   .L_sym_060611FC, r2
    mov.l   .L_pool_06026B28, r6
    add #-0x1, r7
    add r3, r7
    mov.b @r7, r7
    shll2 r7
    add r2, r7
    mov.l @r7, r7
    jsr @r9
    mov #0xC, r4
.L_060269A2:
    exts.w r12, r3
    mov.w r3, @r10
    mov.w @r14, r2
    cmp/pl r2
    bt      .L_060269B0
    bra     .L_06026C60
    nop
.L_060269B0:
    bra     .L_060269DC
    nop
.L_060269B4:
    mov.w @r13, r2
    mov #0x20, r3
    cmp/ge r3, r2
    bf      .L_060269C0
    bra     .L_06026A10
    nop
.L_060269C0:
    mov.w @r13, r5
    mov.w @r14, r4
    mov.l   .L_sym_060591BA, r3
    mov.l   .L_sym_060611FC, r2
    add #-0x1, r4
    add r3, r4
    mov.b @r4, r4
    shll2 r4
    add r2, r4
    bsr     vdp2_reg_block_setup
    mov.l @r4, r4
    mov.w @r13, r3
    add #0x1, r3
    mov.w r3, @r13
.L_060269DC:
    mov.w @r14, r0
    mov.l   .L_sym_060591BA, r3
    mov.l   .L_sym_060595D8, r2
    mov.w @r13, r4
    mov.w @r14, r1
    add #-0x1, r0
    add #-0x1, r1
    mov.b @(r0, r3), r0
    shll r1
    shll2 r0
    shll2 r0
    shll r0
    add r2, r0
    mov.b @(r0, r4), r4
    mov.l   .L_sym_060597B8_2, r0
    mov.w @(r0, r1), r3
    add r4, r3
    mov r3, r1
    shll r3
    add r1, r3
    mov.l @r11, r1
    cmp/hs r3, r1
    bf      .L_06026A10
    mov r4, r0
    cmp/eq #-0x1, r0
    bf      .L_060269B4
.L_06026A10:
    bra     .L_06026C60
    nop
.L_06026A14:
    mov.w @r14, r2
    mov #0x3A, r3
    cmp/ge r3, r2
    bt      .L_06026A4A
    mov.w @r14, r3
    mov.l   .L_sym_060591F0, r2
    mov.l @r11, r0
    shll r3
    add r2, r3
    mov.w @r3, r3
    mov r3, r1
    shll r3
    add r1, r3
    cmp/hs r3, r0
    bf      .L_06026A80
    mov r8, r5
    mov.w @r14, r2
    add #0x1, r2
    mov.w r2, @r14
    mov.w r12, @r13
    mov.l   .L_sym_06059826_2, r7
    mov.l   .L_pool_06026B28, r6
    jsr @r9
    mov #0xC, r4
    mov #0x1, r2
    bra     .L_06026A80
    mov.w r2, @r10
.L_06026A4A:
    mov.w @r14, r0
    cmp/eq #0x3A, r0
    bf      .L_06026A80
    mov.w @r14, r2
    mov.l   .L_sym_060591F0, r3
    mov.l   .L_sym_0607864C_2, r0
    shll r2
    mov.l @r0, r0
    add r3, r2
    mov.w @r2, r2
    mov r2, r1
    shll r2
    add r1, r2
    cmp/hs r2, r0
    bf      .L_06026A80
    mov.l   .L_sym_06059826_2, r7
    mov r8, r5
    mov.l   .L_pool_06026B28, r6
    jsr @r9
    mov #0xC, r4
    exts.w r12, r3
    mov.w r3, @r14
    exts.w r12, r2
    mov.w r2, @r13
    mov #0x1, r3
    mov.l   .L_sym_0606123E_2, r2
    mov.w r3, @r2
.L_06026A80:
    mov.w @r10, r0
    tst r0, r0
    bt      .L_06026AA0
    mov.w @r14, r7
    mov r8, r5
    mov.l   .L_sym_0605914C, r3
    mov.l   .L_sym_0606119C, r2
    mov.l   .L_pool_06026B28, r6
    add #-0x1, r7
    add r3, r7
    mov.b @r7, r7
    shll2 r7
    add r2, r7
    mov.l @r7, r7
    jsr @r9
    mov #0xC, r4
.L_06026AA0:
    exts.w r12, r3
    mov.w r3, @r10
    mov.w @r14, r2
    cmp/pl r2
    bt      .L_06026AAE
    bra     .L_06026C60
    nop
.L_06026AAE:
    bra     .L_06026ADA
    nop
.L_06026AB2:
    mov #0x24, r3
    mov.w @r13, r2
    cmp/ge r3, r2
    bf      .L_06026ABE
    bra     .L_06026B16
    nop
.L_06026ABE:
    mov.w @r13, r5
    mov.w @r14, r4
    mov.l   .L_sym_0605914C, r3
    mov.l   .L_sym_0606119C, r2
    add #-0x1, r4
    add r3, r4
    mov.b @r4, r4
    shll2 r4
    add r2, r4
    bsr     vdp2_reg_block_setup
    mov.l @r4, r4
    mov.w @r13, r3
    add #0x1, r3
    mov.w r3, @r13
.L_06026ADA:
    mov.w @r14, r0
    mov.l   .L_sym_0605914C, r3
    mov.l   .L_sym_06059266, r1
    mov.w @r13, r4
    add #-0x1, r0
    mov.b @(r0, r3), r0
    mov r0, r2
    shll2 r0
    shll2 r2
    shll2 r2
    shll r2
    add r2, r0
    exts.w r0, r0
    mov.w @r14, r2
    add r1, r0
    add #-0x1, r2
    mov.b @(r0, r4), r4
    shll r2
    mov.l   .L_sym_060591F0, r0
    mov.w @(r0, r2), r3
    add r4, r3
    mov r3, r2
    shll r3
    add r2, r3
    mov.l @r11, r2
    cmp/hs r3, r2
    bf      .L_06026B16
    mov r4, r0
    cmp/eq #-0x1, r0
    bf      .L_06026AB2
.L_06026B16:
    bra     .L_06026C60
    nop
    .2byte  0xFFFF
.L_sym_060597B8_2:
    .4byte  sym_060597B8
.L_sym_0607864C_2:
    .4byte  sym_0607864C
.L_sym_06059826_2:
    .4byte  sym_06059826
.L_pool_06026B28:
    .4byte  0x0000F000
.L_sym_0606123E_2:
    .4byte  sym_0606123E
.L_sym_060591BA:
    .4byte  sym_060591BA
.L_sym_060611FC:
    .4byte  sym_060611FC
.L_sym_060595D8:
    .4byte  sym_060595D8
.L_sym_060591F0:
    .4byte  sym_060591F0
.L_sym_0605914C:
    .4byte  sym_0605914C
.L_sym_0606119C:
    .4byte  sym_0606119C
.L_sym_06059266:
    .4byte  sym_06059266
.L_06026B4C:
    mov.w @r14, r2
    mov #0x34, r3
    cmp/ge r3, r2
    bt      .L_06026B82
    mov.w @r14, r3
    mov.l   .L_sym_0605956E, r2
    mov.l @r11, r0
    shll r3
    add r2, r3
    mov.w @r3, r3
    mov r3, r1
    shll r3
    add r1, r3
    cmp/hs r3, r0
    bf      .L_06026BB8
    mov r8, r5
    mov.w @r14, r2
    add #0x1, r2
    mov.w r2, @r14
    mov.w r12, @r13
    mov.l   .L_sym_06059826_3, r7
    mov.l   .L_pool_06026C8C, r6
    jsr @r9
    mov #0xC, r4
    mov #0x1, r2
    bra     .L_06026BB8
    mov.w r2, @r10
.L_06026B82:
    mov.w @r14, r0
    cmp/eq #0x34, r0
    bf      .L_06026BB8
    mov.w @r14, r2
    mov.l   .L_sym_0605956E, r3
    mov.l   .L_sym_0607864C_3, r0
    shll r2
    mov.l @r0, r0
    add r3, r2
    mov.w @r2, r2
    mov r2, r1
    shll r2
    add r1, r2
    cmp/hs r2, r0
    bf      .L_06026BB8
    mov.l   .L_sym_06059826_3, r7
    mov r8, r5
    mov.l   .L_pool_06026C8C, r6
    jsr @r9
    mov #0xC, r4
    exts.w r12, r3
    mov.w r3, @r14
    exts.w r12, r2
    mov.w r2, @r13
    mov #0x1, r3
    mov.l   .L_sym_0606123E_3, r2
    mov.w r3, @r2
.L_06026BB8:
    mov.w @r10, r0
    tst r0, r0
    bt      .L_06026BD8
    mov.w @r14, r7
    mov r8, r5
    mov.l   .L_sym_06059186, r3
    mov.l   .L_sym_060611DC, r2
    mov.l   .L_pool_06026C8C, r6
    add #-0x1, r7
    add r3, r7
    mov.b @r7, r7
    shll2 r7
    add r2, r7
    mov.l @r7, r7
    jsr @r9
    mov #0xC, r4
.L_06026BD8:
    exts.w r12, r3
    mov.w r3, @r10
    mov.w @r14, r2
    cmp/pl r2
    bf      .L_06026C60
    bra     .L_06026C0E
    nop
.L_06026BE6:
    mov #0x19, r3
    mov.w @r13, r2
    cmp/ge r3, r2
    bf      .L_06026BF2
    bra     .L_06026C44
    nop
.L_06026BF2:
    mov.w @r13, r5
    mov.w @r14, r4
    mov.l   .L_sym_06059186, r3
    mov.l   .L_sym_060611DC, r2
    add #-0x1, r4
    add r3, r4
    mov.b @r4, r4
    shll2 r4
    add r2, r4
    bsr     vdp2_reg_block_setup
    mov.l @r4, r4
    mov.w @r13, r3
    add #0x1, r3
    mov.w r3, @r13
.L_06026C0E:
    mov #0x19, r2
    mov.l   .L_sym_060594A6, r1
    mov.w @r14, r0
    mov.l   .L_sym_06059186, r3
    mov.w @r13, r4
    add #-0x1, r0
    mov.b @(r0, r3), r0
    mulu.w r2, r0
    mov.w @r14, r2
    sts macl, r0
    add #-0x1, r2
    extu.b r0, r0
    shll r2
    add r1, r0
    mov.b @(r0, r4), r4
    mov.l   .L_sym_0605956E, r0
    mov.w @(r0, r2), r3
    add r4, r3
    mov r3, r2
    shll r3
    add r2, r3
    mov.l @r11, r2
    cmp/hs r3, r2
    bf      .L_06026C44
    mov r4, r0
    cmp/eq #-0x1, r0
    bf      .L_06026BE6
.L_06026C44:
    bra     .L_06026C60
    nop
.L_06026C48:
    cmp/eq #0x0, r0
    bf      .L_06026C50
    bra     .L_060268EC
    nop
.L_06026C50:
    cmp/eq #0x1, r0
    bf      .L_06026C58
    bra     .L_06026A14
    nop
.L_06026C58:
    cmp/eq #0x2, r0
    bf      .L_06026C60
    bra     .L_06026B4C
    nop
.L_06026C60:
    mov.l   .L_sym_0606123E_3, r0
    mov.w @r0, r0
    tst r0, r0
    bt      .L_06026C70
    mov.l r12, @r11
    exts.w r12, r3
    mov.l   .L_sym_0606123E_3, r2
    mov.w r3, @r2
.L_06026C70:
    lds.l @r15+, macl
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_sym_0605956E:
    .4byte  sym_0605956E
.L_sym_06059826_3:
    .4byte  sym_06059826
.L_pool_06026C8C:
    .4byte  0x0000F000
.L_sym_0607864C_3:
    .4byte  sym_0607864C
.L_sym_0606123E_3:
    .4byte  sym_0606123E
.L_sym_06059186:
    .4byte  sym_06059186
.L_sym_060611DC:
    .4byte  sym_060611DC
.L_sym_060594A6:
    .4byte  sym_060594A6

    .global vdp2_reg_block_setup
    .type vdp2_reg_block_setup, @function
/* vdp2_reg_block_setup(r4=table_base, r5=index) — VDP2 register block write.
 * Reads byte from table[index], packs into 2-byte command buffer on stack,
 * then calls sym_060283E0 to apply the VDP2 register settings.
 */
vdp2_reg_block_setup:
    mov.l r14, @-r15
    sts.l pr, @-r15
    add #-0x8, r15
    mov r15, r14
    mov.w r5, @r15
    add #0x4, r14
    mov.w @r15, r0
    mov r14, r7
    mov.b @(r0, r4), r3
    mov #0x0, r0
    mov.b r3, @r14
    mov.b r0, @(1, r14)
    mov.l   .L_pool_06026CD8, r6
    mov.w @r15, r5
    mov.w   .L_wpool_06026CD4, r3
    add r3, r5
    shll r5
    mov.l   .L_sym_060283E0_2, r3
    jsr @r3
    mov #0xC, r4
    add #0x8, r15
    lds.l @r15+, pr
    rts
    mov.l @r15+, r14
.L_wpool_06026CD4:
    .2byte  0x0602
    .2byte  0xFFFF
.L_pool_06026CD8:
    .4byte  0x0000E000
.L_sym_060283E0_2:
    .4byte  sym_060283E0

    .global sym_06026CE0
/* delay_spin_counter — busy-wait timing loop with NOP sled.
 * Reads iteration count from sym_060635C4, decrements with 20 NOPs per
 * iteration (~21 cycles/iter). Stores total iteration count to sym_0605A010.
 * Used for timing calibration — measures CPU speed by counting loop passes.
 */
sym_06026CE0:
    mov.l   .L_sym_060635C4, r1
    mov #0x1, r2               /* initial count = 1 */
    mov.l   .L_sym_0605A010, r3
    mov #0x0, r4               /* r4 = total iterations */
    mov.l r2, @r1              /* store count to poll address */
    nop
.L_06026CEC:
    mov.l @r1, r0
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    dt r0                      /* count-- ; T = (count == 0) */
    bt/s    .L_06026CEC        /* loop while count > 0 */
    add #0x1, r4               /* delay: total++ */
    rts
    mov.l r4, @r3              /* delay: store total iterations */
    .2byte  0x0009
.L_sym_060635C4:
    .4byte  sym_060635C4
.L_sym_0605A010:
    .4byte  sym_0605A010
    .4byte  0xD217E000
    .4byte  0xE1010215
    .4byte  0xE002E100
    .4byte  0x0215E006
    .4byte  0xE1000215
    .4byte  0xE00CE100
    .4byte  0x0215E00E
    .4byte  0x911C0215
    .4byte  0xE020E100
    .4byte  0x0215E028
    .4byte  0xE1000215
    .4byte  0xE02A9114
    .4byte  0x0215E030
    .4byte  0x91120215
    .4byte  0xE032910F
    .4byte  0x0215E034
    .4byte  0x910C0215
    .4byte  0xE0369109
    .4byte  0x0215E038
    .4byte  0xE1000215
    .4byte  0xE03AE100
    .4byte  0x000B0215
    .4byte  0x13631022
    .4byte  0xC0000000
    .4byte  0x25F80000
    .4byte  0xE100D006
    .4byte  0xD2064010
    .4byte  0x8FFD2216
    .4byte  0xD005D206
    .4byte  0x40108FFD
    .4byte  0x2216000B
    .4byte  0x00090000
    .4byte  0x00060000
    .4byte  0x25F80000
    .4byte  0x00030000
    .4byte  0x25CC0000

/* mat_push_a — push current matrix onto stack A, copy current → new top
 * Advances stack pointer by 48 bytes (0x30), copies all 12 longs.
 * Matrix format: [0..32] = 3x3 rotation, [36..44] = translation
 */
    .global sym_06026DBC
sym_06026DBC:
    mov.l   .L_mat_stack_ptr_a, r3
    mov.l @r3, r0               /* r0 = current stack top */
    mov #0x30, r1               /* 48 bytes per matrix entry */
    add r0, r1                  /* r1 = new stack top */
    mov.l r1, @r3               /* advance stack pointer */
    mov.l @(0, r0), r2          /* copy 48 bytes: current → new top */
    mov.l @(4, r0), r3
    mov.l r2, @(0, r1)
    mov.l r3, @(4, r1)
    mov.l @(8, r0), r2
    mov.l @(12, r0), r3
    mov.l r2, @(8, r1)
    mov.l r3, @(12, r1)
    mov.l @(16, r0), r2
    mov.l @(20, r0), r3
    mov.l r2, @(16, r1)
    mov.l r3, @(20, r1)
    mov.l @(24, r0), r2
    mov.l @(28, r0), r3
    mov.l r2, @(24, r1)
    mov.l r3, @(28, r1)
    mov.l @(32, r0), r2
    mov.l @(36, r0), r3
    mov.l r2, @(32, r1)
    mov.l r3, @(36, r1)
    mov.l @(40, r0), r2
    mov.l @(44, r0), r3
    mov.l r2, @(40, r1)
    rts
    mov.l r3, @(44, r1)

/* mat_pop_a — pop matrix stack A (retreat pointer by 48 bytes) */
    .global sym_06026DF8
sym_06026DF8:
    mov.l   .L_mat_stack_ptr_a, r1
    mov.l @r1, r0
    add #-0x30, r0              /* retreat by one 48-byte entry */
    rts
    mov.l r0, @r1               /* store new stack top */

/* mat_identity_reset_a — reset stack A to base address + write identity matrix */
    .global sym_06026E02
sym_06026E02:
    mov.l   .L_mat_stack_base_a, r0 /* r0 = stack base address */
    mov.l   .L_mat_stack_ptr_a, r1
    mov #0x0, r2
    bra     .L_06026E12
    mov.l r0, @r1               /* reset stack pointer to base */

/* mat_identity_a — write identity matrix to current stack A top
 * Identity: diagonal = 1.0 (0x00010000), all other elements = 0
 * Layout: [0]=1.0 [4]=0 [8]=0 [12]=0 [16]=1.0 [20]=0 [24]=0 [28]=0 [32]=1.0 [36..44]=0
 */
    .global sym_06026E0C
sym_06026E0C:
    mov.l   .L_mat_stack_ptr_a, r0
    mov #0x0, r2                /* r2 = 0 (off-diagonal + translation) */
    mov.l @r0, r0               /* r0 = current stack top */
.L_06026E12:
    mov.l   .L_fp_one_a, r1 /* r1 = 0x00010000 = 1.0 in 16.16 */
    mov.l r2, @(4, r0)         /* [4]  = 0 */
    mov.l r1, @(0, r0)         /* [0]  = 1.0  (rotation M[0][0]) */
    mov.l r2, @(8, r0)         /* [8]  = 0 */
    mov.l r2, @(12, r0)        /* [12] = 0 */
    mov.l r1, @(16, r0)        /* [16] = 1.0  (rotation M[1][1]) */
    mov.l r2, @(20, r0)        /* [20] = 0 */
    mov.l r2, @(24, r0)        /* [24] = 0 */
    mov.l r2, @(28, r0)        /* [28] = 0 */
    mov.l r1, @(32, r0)        /* [32] = 1.0  (rotation M[2][2]) */
    mov.l r2, @(36, r0)        /* [36] = 0  (translation X) */
    mov.l r2, @(40, r0)        /* [40] = 0  (translation Y) */
    rts
    mov.l r2, @(44, r0)        /* [44] = 0  (translation Z) */

/* mat_translate_a(r4=dx, r5=dy, r6=dz) — apply translation to stack A
 * Stores translation vector in temp buffer, then for each row of the
 * 3x3 rotation matrix: translation[i] += dot(rotation_row[i], delta)
 * Uses MAC unit for the dot products (3x mac.l + xtrct for 16.16 result).
 */
    .global sym_06026E2E
sym_06026E2E:
    mov.l   .L_mat_temp_a, r0 /* r0 = mat_temp_a (scratch buffer) */
    mov.l   .L_mat_stack_ptr_a, r1
    mov.l r4, @(0, r0)         /* temp[0] = dx */
    mov.l r5, @(4, r0)         /* temp[1] = dy */
    mov.l r6, @(8, r0)         /* temp[2] = dz */
    mov.l @r1, r4              /* r4 = current matrix (rotation start) */
    mov #0x3, r3               /* 3 translation components */
    mov r4, r5
    add #0x24, r5              /* r5 = translation vector (offset 0x24 = 36) */
.L_06026E40:
    clrmac                     /* clear MAC accumulator */
    mac.l @r4+, @r0+          /* acc += rot[i][0] * dx */
    mac.l @r4+, @r0+          /* acc += rot[i][1] * dy */
    mac.l @r4+, @r0+          /* acc += rot[i][2] * dz */
    mov.l @r5, r6             /* r6 = current translation[i] */
    add #-0xC, r0             /* reset temp pointer */
    dt r3                      /* loop counter-- */
    sts mach, r1
    sts macl, r2
    xtrct r1, r2              /* r2 = dot product (16.16) */
    add r6, r2                /* r2 = translation[i] + dot */
    mov.l r2, @r5             /* store updated translation[i] */
    bf/s    .L_06026E40
    add #0x4, r5              /* next translation component */
    rts
    nop
    .4byte  0x00000000         /* 52 bytes zero padding (alignment / reserved) */
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000

    .global transform_matrix
    .type transform_matrix, @function
/* transform_matrix(r4=angle) — apply X-Z plane rotation to stack A
 * Builds 2x2 rotation submatrix from sincos_pair, then multiplies each
 * row of the current matrix by the rotation. Operates on columns 1,2
 * (the XZ plane). Uses MAC unit for the 2x2 multiply.
 *
 * Setup: temp = [cos, -sin, 0, sin, cos, 0] → 2x2 rotation padded to 4 entries
 * For each of 3 rows: new[col1,col2] = old[col1,col2] * rot_2x2
 */
transform_matrix:
    sts.l pr, @-r15
    mov.l   .L_mat_temp_a, r6 /* r6 = mat_temp_a (rotation scratch) */
    mov #0x8, r5               /* sin output at temp+8 */
    bsr     sincos_pair        /* sincos_pair(angle, temp+8, temp+0) */
    add r6, r5                 /* delay: r5 = &temp[2] (sin dest) */
    lds.l @r15+, pr
    mov.l @r5, r1              /* r1 = sin(angle) */
    mov.l @r6, r2              /* r2 = cos(angle) */
    neg r1, r1
    mov.l r1, @(4, r6)        /* temp[1] = -sin(angle) */
    mov.l   .L_mat_stack_ptr_a, r0
    mov.l r2, @(12, r6)       /* temp[3] = cos(angle) */
    mov.l @r0, r4             /* r4 = matrix row pointer (skip M[0][0]) */
    mov #0x3, r3              /* 3 rows */
    add #0x4, r4              /* start at column 1 */
.L_06026EB2:
    mov r4, r5                /* r5 = current row cols 1,2 */
    mov r6, r7                /* r7 = rotation 2x2 */
    clrmac
    mac.l @r7+, @r5+          /* acc = old_col1 * cos */
    mac.l @r7+, @r5+          /* acc += old_col2 * (-sin) */
    add #-0x8, r5             /* reset to cols 1,2 */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1              /* r1 = new_col1 (16.16) */
    clrmac
    mac.l @r7+, @r5+          /* acc = old_col1 * sin */
    mac.l @r7+, @r5+          /* acc += old_col2 * cos */
    mov.l r1, @(0, r4)        /* store new col1 */
    dt r3
    sts mach, r0
    sts macl, r2
    xtrct r0, r2              /* r2 = new_col2 (16.16) */
    mov.l r2, @(4, r4)        /* store new col2 */
    bf/s    .L_06026EB2
    add #0xC, r4              /* next row (+12 bytes) */
    rts
    nop

    .global mat_rot_y
    .type mat_rot_y, @function
/* mat_rot_y(r4=angle) — apply Y-axis rotation to stack A
 * Operates on columns 0 and 2 (the XZ plane from Y perspective).
 * Setup: temp = [cos, 0, -sin, 0, sin, 0, cos] at offsets [0],[4],[8],[12]
 * For each of 3 rows: new[col0,col2] = old[col0,col2] * rot_2x2
 */
mat_rot_y:
    sts.l pr, @-r15
    mov.l   .L_mat_temp_a, r6 /* r6 = mat_temp_a */
    mov #0x4, r5               /* sin output at temp+4 */
    bsr     sincos_pair
    add r6, r5                 /* delay: r5 = &temp[1] */
    lds.l @r15+, pr
    mov.l @r5, r1              /* r1 = sin(angle) */
    mov.l @r6, r2              /* r2 = cos(angle) */
    neg r1, r1
    mov.l r1, @(8, r6)        /* temp[2] = -sin(angle) */
    mov.l   .L_mat_stack_ptr_a, r0
    mov.l r2, @(12, r6)       /* temp[3] = cos(angle) */
    mov.l @r0, r4             /* r4 = matrix start */
    mov #0x3, r3              /* 3 rows */
.L_06026EFA:
    mov r4, r5                /* col0 */
    mov r6, r7                /* rotation data */
    clrmac
    mac.l @r7+, @r5+          /* acc = col0 * cos */
    add #0x4, r5              /* skip col1 → point to col2 */
    mac.l @r7+, @r5+          /* acc += col2 * (-sin) */
    add #-0xC, r5             /* back to col0 */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1              /* r1 = new col0 */
    clrmac
    mac.l @r7+, @r5+          /* acc = col0 * sin */
    add #0x4, r5              /* skip col1 */
    mac.l @r7+, @r5+          /* acc += col2 * cos */
    mov.l r1, @(0, r4)        /* store new col0 */
    dt r3
    sts mach, r0
    sts macl, r2
    xtrct r0, r2              /* r2 = new col2 */
    mov.l r2, @(8, r4)        /* store new col2 */
    bf/s    .L_06026EFA
    add #0xC, r4              /* next row */
    rts
    nop

    .global mat_rot_z
    .type mat_rot_z, @function
/* mat_rot_z(r4=angle) — apply Z-axis rotation to stack A (XY plane)
 * Operates on columns 0 and 1.
 * For each of 3 rows: new[col0,col1] = old[col0,col1] * rot_2x2
 */
mat_rot_z:
    sts.l pr, @-r15
    mov.l   .L_mat_temp_a, r6 /* r6 = mat_temp_a */
    mov #0x8, r5
    bsr     sincos_pair
    add r6, r5
    lds.l @r15+, pr
    mov.l @r5, r1              /* r1 = sin(angle) */
    mov.l @r6, r2              /* r2 = cos(angle) */
    neg r1, r1
    mov.l r1, @(4, r6)        /* temp[1] = -sin(angle) */
    mov.l   .L_mat_stack_ptr_a, r0
    mov.l r2, @(12, r6)       /* temp[3] = cos(angle) */
    mov.l @r0, r4             /* r4 = matrix start */
    mov #0x3, r3              /* 3 rows */
.L_06026F46:
    mov r4, r5                /* col0 */
    mov r6, r7                /* rotation data */
    clrmac
    mac.l @r7+, @r5+          /* acc = col0 * cos */
    mac.l @r7+, @r5+          /* acc += col1 * (-sin) */
    mov r4, r5                /* reset to col0 */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1              /* r1 = new col0 */
    clrmac
    mac.l @r7+, @r5+          /* acc = col0 * sin */
    mac.l @r7+, @r5+          /* acc += col1 * cos */
    mov.l r1, @(0, r4)        /* store new col0 */
    dt r3
    sts mach, r0
    sts macl, r2
    xtrct r0, r2              /* r2 = new col1 */
    mov.l r2, @(4, r4)        /* store new col1 */
    bf/s    .L_06026F46
    add #0xC, r4              /* next row */
    rts
    nop

/* mat_mul_a(r4=input_matrix) — multiply stack A top by input matrix
 * result = input * current_stack_top (rotation), then adds translation.
 * Uses mat_temp2_a (mat_scratch_a) as scratch for the 48-byte result,
 * then copies result back to the stack top.
 *
 * Phase 1: Compute 3x3 rotation product
 *   For each element result[row][col]:
 *     dot product of input row with current matrix column
 *     (stride-3 access: skip 8 bytes between column elements)
 *
 * Phase 2: Compute new translation
 *   For each translation component:
 *     new_trans[i] = dot(input_translation, current_rotation_col[i]) + current_trans[i]
 *
 * Phase 3: Copy 48-byte result from scratch back to stack top
 */
    .global sym_06026F72
sym_06026F72:
    mov.l   .L_mat_stack_ptr_a, r0
    mov.l   .L_mat_scratch_a, r6 /* r6 = mat_temp2_a (scratch output) */
    mov.l @r0, r5              /* r5 = current matrix (stack A top) */
    mov #0x3, r3               /* 3 rows in input */
.L_06026F7A:
    mov #0x3, r2               /* 3 columns per row */
.L_06026F7C:
    clrmac
    mac.l @r4+, @r5+          /* acc += input[row][0] * cur[0][col] */
    add #0x8, r4               /* skip to input[row][1] */
    mac.l @r4+, @r5+          /* acc += input[row][1] * cur[1][col] */
    add #0x8, r4               /* skip to input[row][2] */
    dt r2
    mac.l @r4+, @r5+          /* acc += input[row][2] * cur[2][col] */
    add #-0x18, r4             /* reset input to row start */
    add #-0xC, r5             /* reset current to column start */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1              /* r1 = dot product (16.16) */
    mov.l r1, @r6             /* scratch[row][col] = result */
    bf/s    .L_06026F7C
    add #0x4, r6              /* next output element */
    add #-0xC, r4             /* back to input row start (already advanced by inner) */
    dt r3
    bf/s    .L_06026F7A
    add #0xC, r5              /* next column group */
    mov r5, r7                /* r7 = current translation (offset 0x24) */
    add #-0x24, r5            /* r5 = current rotation start */
    add #0x24, r4             /* r4 = input translation */
    mov #0x3, r3              /* 3 translation components */
.L_06026FAA:
    clrmac
    mac.l @r4+, @r5+          /* acc += input_trans[0] * cur_rot[i][0] */
    mac.l @r4+, @r5+          /* acc += input_trans[1] * cur_rot[i][1] */
    dt r3
    mac.l @r4+, @r5+          /* acc += input_trans[2] * cur_rot[i][2] */
    add #-0xC, r4             /* reset input translation */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1              /* r1 = rotated translation component */
    mov.l @r7+, r0            /* r0 = existing translation[i] */
    add r0, r1                /* add to existing */
    mov.l r1, @r6             /* scratch_trans[i] = result */
    bf/s    .L_06026FAA
    add #0x4, r6
    add #-0x30, r6            /* r6 = scratch start */
    add #-0x30, r7            /* r7 = stack matrix start */
    mov.l @(0, r6), r0        /* copy 48 bytes: scratch → stack top */
    mov.l @(4, r6), r1
    mov.l @(8, r6), r2
    mov.l @(12, r6), r3
    mov.l @(16, r6), r4
    mov.l @(20, r6), r5
    mov.l r0, @(0, r7)
    mov.l r1, @(4, r7)
    mov.l r2, @(8, r7)
    mov.l r3, @(12, r7)
    mov.l r4, @(16, r7)
    mov.l r5, @(20, r7)
    mov.l @(24, r6), r0
    mov.l @(28, r6), r1
    mov.l @(32, r6), r2
    mov.l @(36, r6), r3
    mov.l @(40, r6), r4
    mov.l @(44, r6), r5
    mov.l r0, @(24, r7)
    mov.l r1, @(28, r7)
    mov.l r2, @(32, r7)
    mov.l r3, @(36, r7)
    mov.l r4, @(40, r7)
    rts
    mov.l r5, @(44, r7)

    .global mat_vec_transform
    .type mat_vec_transform, @function
/* mat_vec_transform(r4=input_vec3, r5=output_vec3) — transform vector by stack A matrix
 * output[i] = dot(rotation_row[i], input) + translation[i]
 * Uses MAC unit for 3-element dot products. Result goes through
 * mat_vec_result_a scratch buffer then copies to output pointer.
 */
mat_vec_transform:
    mov.l r14, @-r15
    mov.l   .L_mat_stack_ptr_a, r0
    mov #0x24, r7              /* offset to translation vector */
    mov.l @r0, r6             /* r6 = rotation matrix start */
    mov.l   .L_mat_vec_result_a, r14 /* r14 = mat_vec_result_a (scratch) */
    add r6, r7                /* r7 = translation vector */
    mov #0x3, r3              /* 3 output components */
.L_0602700A:
    clrmac
    mac.l @r4+, @r6+          /* acc += input[0] * rot[row][0] */
    mac.l @r4+, @r6+          /* acc += input[1] * rot[row][1] */
    mov.l @r7+, r2            /* r2 = translation[i] */
    mac.l @r4+, @r6+          /* acc += input[2] * rot[row][2] */
    dt r3
    add #-0xC, r4             /* reset input pointer */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1              /* r1 = dot product (16.16) */
    add r2, r1                /* r1 += translation[i] */
    mov.l r1, @r14            /* scratch[i] = result */
    bf/s    .L_0602700A
    add #0x4, r14
    add #-0xC, r14            /* reset scratch pointer */
    mov.l @r14+, r0           /* copy scratch → output */
    mov.l @r14+, r1
    mov.l @r14+, r2
    mov.l r0, @r5             /* output[0] = X */
    mov.l r1, @(4, r5)        /* output[1] = Y */
    mov.l r2, @(8, r5)        /* output[2] = Z */
    rts
    mov.l @r15+, r14
    .4byte  0xD00BD60F
    .4byte  0x6202E303
    .4byte  0x0028024F
    .4byte  0x024F024F
    .4byte  0x431074F4
    .4byte  0x000A011A
    .4byte  0x210D2612
    .4byte  0x8FF47604
    .4byte  0x76F46062
    .4byte  0x51615262
    .4byte  0x25021511
    .4byte  0x000B1522
.L_mat_stack_ptr_a:
    .4byte  mat_stack_ptr_a
.L_mat_stack_base_a:
    .4byte  mat_stack_base_a
.L_mat_temp_a:
    .4byte  mat_temp_a
.L_mat_scratch_a:
    .4byte  mat_scratch_a
.L_mat_vec_result_a:
    .4byte  mat_vec_result_a
.L_fp_one_a:
    .4byte  0x00010000

    .global sym_06027080
/* mat_push_b — duplicate current top-of-stack B, advance pointer by 48 bytes.
 * Identical to mat_push_a but operates on stack B.
 */
sym_06027080:
    mov.l   .L_mat_stack_ptr_b, r3
    mov.l @r3, r0               /* r0 = current top */
    mov #0x30, r1               /* 48 bytes per matrix entry */
    add r0, r1                  /* r1 = new top */
    mov.l r1, @r3               /* advance stack pointer */
    mov.l @(0, r0), r2          /* copy 48 bytes: old → new */
    mov.l @(4, r0), r3
    mov.l r2, @(0, r1)
    mov.l r3, @(4, r1)
    mov.l @(8, r0), r2
    mov.l @(12, r0), r3
    mov.l r2, @(8, r1)
    mov.l r3, @(12, r1)
    mov.l @(16, r0), r2
    mov.l @(20, r0), r3
    mov.l r2, @(16, r1)
    mov.l r3, @(20, r1)
    mov.l @(24, r0), r2
    mov.l @(28, r0), r3
    mov.l r2, @(24, r1)
    mov.l r3, @(28, r1)
    mov.l @(32, r0), r2
    mov.l @(36, r0), r3
    mov.l r2, @(32, r1)
    mov.l r3, @(36, r1)
    mov.l @(40, r0), r2
    mov.l @(44, r0), r3
    mov.l r2, @(40, r1)
    rts
    mov.l r3, @(44, r1)         /* delay: last long of copy */
    .4byte  0xD19B6012
    .4byte  0x70D0000B
    .2byte  0x2102

    .global sym_060270C6
/* mat_identity_reset_b — reset stack B to base + write 3x3 identity matrix.
 * Sets stack pointer to base, then falls through to mat_identity_b.
 */
sym_060270C6:
    mov.l   .L_mat_stack_base_b, r0
    mov.l   .L_mat_stack_ptr_b, r1
    mov #0x0, r2                /* r2 = 0 (for zeroing off-diagonal) */
    bra     .L_060270D6         /* jump to identity write */
    mov.l r0, @r1               /* delay: reset stack ptr to base */

    .global sym_060270D0
/* mat_identity_b — write 3x3 identity matrix + zero translation to stack B top.
 * Diagonal = 0x00010000 (1.0 in 16.16), all others = 0.
 */
sym_060270D0:
    mov.l   .L_mat_stack_ptr_b, r0
    mov #0x0, r2                /* r2 = 0 */
    mov.l @r0, r0               /* r0 = current stack B top */
.L_060270D6:
    mov.l   .L_fp_one_b, r1    /* r1 = 0x00010000 (1.0) */
    mov.l r2, @(4, r0)         /* M[0][1] = 0 */
    mov.l r1, @(0, r0)         /* M[0][0] = 1.0 */
    mov.l r2, @(8, r0)         /* M[0][2] = 0 */
    mov.l r2, @(12, r0)        /* M[1][0] = 0 */
    mov.l r1, @(16, r0)        /* M[1][1] = 1.0 */
    mov.l r2, @(20, r0)        /* M[1][2] = 0 */
    mov.l r2, @(24, r0)        /* M[2][0] = 0 */
    mov.l r2, @(28, r0)        /* M[2][1] = 0 */
    mov.l r1, @(32, r0)        /* M[2][2] = 1.0 */
    mov.l r2, @(36, r0)        /* tx = 0 */
    mov.l r2, @(40, r0)        /* ty = 0 */
    rts
    mov.l r2, @(44, r0)        /* delay: tz = 0 */

    .global sym_060270F2
/* mat_translate_b(r4=dx, r5=dy, r6=dz) — apply translation to stack B top.
 * For each translation axis: dot(rotation_row, delta) + current_translation.
 * Uses MAC unit: clrmac + 3x mac.l for dot product, xtrct for 16.16 result.
 */
sym_060270F2:
    mov.l   .L_mat_temp_b, r0
    mov.l   .L_mat_stack_ptr_b, r1
    mov.l r4, @(0, r0)         /* store dx */
    mov.l r5, @(4, r0)         /* store dy */
    mov.l r6, @(8, r0)         /* store dz */
    mov.l @r1, r4              /* r4 = matrix base (rotation rows) */
    mov #0x3, r3               /* 3 iterations (tx, ty, tz) */
    mov r4, r5
    add #0x24, r5              /* r5 = &translation[0] (offset 0x24=36) */
.L_06027104:
    clrmac                     /* clear MAC for dot product */
    mac.l @r4+, @r0+          /* acc += rot[row][0] * dx */
    mac.l @r4+, @r0+          /* acc += rot[row][1] * dy */
    mac.l @r4+, @r0+          /* acc += rot[row][2] * dz */
    mov.l @r5, r6              /* r6 = current translation component */
    add #-0xC, r0              /* rewind delta pointer */
    dt r3                      /* decrement loop counter */
    sts mach, r1
    sts macl, r2
    xtrct r1, r2               /* r2 = dot product (16.16) */
    add r6, r2                 /* add to existing translation */
    mov.l r2, @r5              /* store updated translation */
    bf/s    .L_06027104
    add #0x4, r5               /* delay: advance to next translation component */
    rts
    nop
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000
    .4byte  0x00000000

    .global mat_rot_xz_b
    .type mat_rot_xz_b, @function
mat_rot_xz_b:
    sts.l pr, @-r15
    mov.l   .L_mat_temp_b, r6
    mov #0x8, r5
    bsr     sincos_pair         /* sincos_pair(angle, &temp[2]=sin, &temp[0]=cos) */
    add r6, r5                  /* delay: r5 = &temp[2] (sin output) */
    lds.l @r15+, pr
    mov.l @r5, r1               /* r1 = sin */
    mov.l @r6, r2               /* r2 = cos */
    neg r1, r1                  /* build 2x2 rotation: [cos, -sin; sin, cos] */
    mov.l r1, @(4, r6)          /* temp[1] = -sin */
    mov.l   .L_mat_stack_ptr_b, r0
    mov.l r2, @(12, r6)         /* temp[3] = cos */
    mov.l @r0, r4
    mov #0x3, r3                /* 3 rows */
    add #0x4, r4                /* skip column 0, rotate columns 1+2 */
.L_06027176:
    mov r4, r5
    mov r6, r7
    clrmac                      /* new_col1 = col1*cos + col2*(-sin) */
    mac.l @r7+, @r5+
    mac.l @r7+, @r5+
    add #-0x8, r5               /* rewind to col1 */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    clrmac                      /* new_col2 = col1*sin + col2*cos */
    mac.l @r7+, @r5+
    mac.l @r7+, @r5+
    mov.l r1, @(0, r4)          /* store new col1 */
    dt r3
    sts mach, r0
    sts macl, r2
    xtrct r0, r2
    mov.l r2, @(4, r4)          /* store new col2 */
    bf/s    .L_06027176
    add #0xC, r4                /* delay: advance to next row */
    rts
    nop

    .global mat_rot_xy_b
    .type mat_rot_xy_b, @function
mat_rot_xy_b:
    sts.l pr, @-r15
    mov.l   .L_mat_temp_b, r6
    mov #0x4, r5
    bsr     sincos_pair         /* sincos_pair(angle, &temp[1]=sin, &temp[0]=cos) */
    add r6, r5                  /* delay: r5 = &temp[1] */
    lds.l @r15+, pr
    mov.l @r5, r1               /* r1 = sin */
    mov.l @r6, r2               /* r2 = cos */
    neg r1, r1                  /* build 2x2: [cos, -sin; sin, cos] */
    mov.l r1, @(8, r6)          /* temp[2] = -sin */
    mov.l   .L_mat_stack_ptr_b, r0
    mov.l r2, @(12, r6)         /* temp[3] = cos */
    mov.l @r0, r4
    mov #0x3, r3                /* 3 rows */
.L_060271BE:
    mov r4, r5
    mov r6, r7
    clrmac                      /* new_col0 = col0*cos + col2*sin */
    mac.l @r7+, @r5+
    add #0x4, r5                /* skip col1 */
    mac.l @r7+, @r5+
    add #-0xC, r5               /* rewind to col0 */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    clrmac                      /* new_col2 = col0*(-sin) + col2*cos */
    mac.l @r7+, @r5+
    add #0x4, r5                /* skip col1 */
    mac.l @r7+, @r5+
    mov.l r1, @(0, r4)          /* store new col0 */
    dt r3
    sts mach, r0
    sts macl, r2
    xtrct r0, r2
    mov.l r2, @(8, r4)          /* store new col2 */
    bf/s    .L_060271BE
    add #0xC, r4                /* delay: advance to next row */
    rts
    nop

    .global mat_rot_yz_b
    .type mat_rot_yz_b, @function
mat_rot_yz_b:
    sts.l pr, @-r15
    mov.l   .L_mat_temp_b, r6
    mov #0x8, r5
    bsr     sincos_pair         /* sincos_pair(angle, &temp[2]=sin, &temp[0]=cos) */
    add r6, r5                  /* delay: r5 = &temp[2] */
    lds.l @r15+, pr
    mov.l @r5, r1               /* r1 = sin */
    mov.l @r6, r2               /* r2 = cos */
    neg r1, r1                  /* build 2x2: [cos, -sin; sin, cos] */
    mov.l r1, @(4, r6)          /* temp[1] = -sin */
    mov.l   .L_mat_stack_ptr_b, r0
    mov.l r2, @(12, r6)         /* temp[3] = cos */
    mov.l @r0, r4
    mov #0x3, r3                /* 3 rows */
.L_0602720A:
    mov r4, r5
    mov r6, r7
    clrmac                      /* new_col0 = col0*cos + col1*(-sin) */
    mac.l @r7+, @r5+
    mac.l @r7+, @r5+
    mov r4, r5                  /* rewind to col0 */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1
    clrmac                      /* new_col1 = col0*sin + col1*cos */
    mac.l @r7+, @r5+
    mac.l @r7+, @r5+
    mov.l r1, @(0, r4)          /* store new col0 */
    dt r3
    sts mach, r0
    sts macl, r2
    xtrct r0, r2
    mov.l r2, @(4, r4)          /* store new col1 */
    bf/s    .L_0602720A
    add #0xC, r4                /* delay: advance to next row */
    rts
    nop
    .2byte  0xD03D
    .4byte  0xD63F6502
    .4byte  0xE303E203
    .4byte  0x0028054F
    .4byte  0x7408054F
    .4byte  0x74084210
    .4byte  0x054F74E8
    .4byte  0x75F4000A
    .4byte  0x011A210D
    .4byte  0x26128FF1
    .4byte  0x760474F4
    .4byte  0x43108FEC
    .4byte  0x750C6753
    .4byte  0x75DC7424
    .4byte  0xE3030028
    .4byte  0x054F054F
    .4byte  0x4310054F
    .4byte  0x74F4000A
    .4byte  0x011A210D
    .4byte  0x6076310C
    .4byte  0x26128FF2
    .4byte  0x760476D0
    .4byte  0x77D05060
    .4byte  0x51615262
    .4byte  0x53635464
    .4byte  0x55651700
    .4byte  0x17111722
    .4byte  0x17331744
    .4byte  0x17555066
    .4byte  0x51675268
    .4byte  0x5369546A
    .4byte  0x556B1706
    .4byte  0x17171728
    .4byte  0x1739174A
    .4byte  0x000B175B

    .global mat_vec_transform_b
    .type mat_vec_transform_b, @function
/* mat_vec_transform_b(r4=vec_in, r5=vec_out) — transform vec3 through stack B top.
 * result[i] = dot(rotation_row[i], vec_in) + translation[i]
 * Uses MAC unit for 16.16 fixed-point dot products.
 */
mat_vec_transform_b:
    mov.l r14, @-r15            /* save r14 (callee-saved) */
    mov.l   .L_mat_stack_ptr_b, r0
    mov #0x24, r7               /* 0x24 = offset to translation (36) */
    mov.l @r0, r6               /* r6 = rotation matrix pointer */
    mov.l   .L_mat_vec_result_b, r14 /* r14 = scratch output buffer */
    add r6, r7                  /* r7 = &translation[0] */
    mov #0x3, r3                /* 3 components (x, y, z) */
.L_060272CE:
    clrmac                      /* clear MAC for dot product */
    mac.l @r4+, @r6+           /* acc += rot[row][0] * vec[0] */
    mac.l @r4+, @r6+           /* acc += rot[row][1] * vec[1] */
    mov.l @r7+, r2              /* r2 = translation[i] */
    mac.l @r4+, @r6+           /* acc += rot[row][2] * vec[2] */
    dt r3
    add #-0xC, r4               /* rewind input vector pointer */
    sts mach, r0
    sts macl, r1
    xtrct r0, r1                /* r1 = dot product (16.16) */
    add r2, r1                  /* add translation */
    mov.l r1, @r14              /* store to scratch buffer */
    bf/s    .L_060272CE
    add #0x4, r14               /* delay: advance output pointer */
    add #-0xC, r14              /* rewind to start of result */
    mov.l @r14+, r0             /* load result x */
    mov.l @r14+, r1             /* load result y */
    mov.l @r14+, r2             /* load result z */
    mov.l r0, @r5               /* vec_out[0] = x */
    mov.l r1, @(4, r5)          /* vec_out[1] = y */
    mov.l r2, @(8, r5)          /* vec_out[2] = z */
    rts
    mov.l @r15+, r14            /* delay: restore r14 */
    .4byte  0xD00BD60F
    .4byte  0x6202E303
    .4byte  0x0028024F
    .4byte  0x024F024F
    .4byte  0x431074F4
    .4byte  0x000A011A
    .4byte  0x210D2612
    .4byte  0x8FF47604
    .4byte  0x76F46062
    .4byte  0x51615262
    .4byte  0x25021511
    .4byte  0x000B1522
.L_mat_stack_ptr_b:
    .4byte  mat_stack_ptr_b
.L_mat_stack_base_b:
    .4byte  mat_stack_base_b
.L_mat_temp_b:
    .4byte  mat_temp_b
    .4byte  sym_0608A6C0
.L_mat_vec_result_b:
    .4byte  mat_vec_result_b
.L_fp_one_b:
    .4byte  0x00010000

/* cos_lookup(r4=angle) -> r0 = cos(angle) in 16.16 fixed-point
 * Adds 0x4000 (90 deg) phase offset then falls through to sin_lookup.
 */
    .global cos_lookup
cos_lookup:
    mov.w   .L_cos_phase, r0  /* r0 = 0x4000 (90 deg phase offset) */
    add r0, r4                 /* angle += 90 deg (cos = sin + 90) */

/* sin_lookup(r4=angle) -> r0 = sin(angle) in 16.16 fixed-point
 * Table has 4096 entries of 4 bytes each at 0x002F2F20 (Work RAM Low).
 * angle >>= 2 to get table index, masked to 0x3FFC (4096 * 4 bytes).
 */
    .global sin_lookup
sin_lookup:
    mov.w   .L_table_mask, r0 /* r0 = 0x3FFC (table index mask) */
    shlr2 r4                   /* angle /= 4 → table index */
    add #0x2, r4               /* skip 2-byte header */
    and r0, r4                 /* wrap to table size */
    mov.l   .L_sin_table_base, r0 /* r0 = 0x002F2F20 (table base) */
    rts
    mov.l @(r0, r4), r0       /* return table[index] */
    .2byte  0x0009

/* sincos_pair(r4=angle, r5=sin_out_ptr, r6=cos_out_ptr)
 * Computes both sin and cos from the same table lookup.
 * cos index = (angle + 0x4000) >> 2, sin index = angle >> 2, both masked.
 * *r5 = sin(angle), *r6 = cos(angle)
 */
    .global sincos_pair
sincos_pair:
    mov.w   .L_cos_phase, r3  /* r3 = 0x4000 (cos phase offset) */
    add #0x8, r4              /* rounding adjustment */
    mov.w   .L_table_mask, r1 /* r1 = 0x3FFC (index mask) */
    add r4, r3                /* r3 = angle + 0x4000 (cos angle) */
    mov.l   .L_sin_table_base, r0 /* r0 = table base */
    shlr2 r4                  /* sin table index */
    and r1, r4                /* mask sin index */
    shlr2 r3                  /* cos table index */
    mov.l @(r0, r4), r2      /* r2 = sin(angle) */
    and r1, r3                /* mask cos index */
    mov.l r2, @r5             /* *sin_out = sin(angle) */
    nop
    mov.l @(r0, r3), r1      /* r1 = cos(angle) */
    rts
    mov.l r1, @r6             /* *cos_out = cos(angle) */
    .2byte  0x0009

/* atan_piecewise(r4=value) -> r0 = atan(value) as angle
 * 10-segment piecewise linear arctangent approximation.
 * Small values (<0x100000) use direct table lookup at 0x002F0000.
 * Large values use piecewise interpolation with slope/intercept pairs.
 * Output range: 0 to 0x4000 (0 to 90 degrees).
 */
    .global atan_piecewise
atan_piecewise:
    cmp/pz r4                  /* value >= 0? */
    bt/s    .L_06027380
    movt r6                    /* r6 = sign (1=pos, 0=neg) */
    neg r4, r4                 /* abs(value) */
.L_06027380:
    mov #0x10, r0
    shll16 r0
    add #0x40, r4
    add #0x40, r4
    cmp/hi r4, r0
    bf      .L_0602739C
    mov.l   .L_atan_table_base, r0
    shlr8 r4
    shll r4
    tst r6, r6
    mov.w @(r0, r4), r0
    bf      .L_0602743E
    rts
    neg r0, r0
.L_0602739C:
    mov.w   .L_wpool_06027516, r0
    swap.w r4, r5
    extu.w r5, r5
    cmp/hi r5, r0
    bf      .L_06027442
    mov.w   .L_wpool_06027520, r0
    cmp/hi r5, r0
    bt      .L_060273E6
    mov.w   .L_wpool_06027524, r0
    cmp/hi r5, r0
    bt      .L_060273CC
    mov.w   .L_wpool_06027526, r0
    cmp/hi r5, r0
    bt      .L_060273C2
    mov.w   .L_wpool_06027526, r3
    mov.l   .L_pool_06027528, r1
    mov.w   .L_wpool_06027504, r2
    bra     .L_0602742E
    swap.w r3, r3
.L_060273C2:
    mov.w   .L_wpool_06027524, r3
    mov.l   .L_pool_0602752C, r1
    mov.w   .L_wpool_06027506, r2
    bra     .L_0602742E
    swap.w r3, r3
.L_060273CC:
    mov.w   .L_wpool_06027522, r0
    cmp/hi r5, r0
    bt      .L_060273DC
    mov.w   .L_wpool_06027522, r3
    mov.l   .L_pool_06027530, r1
    mov.w   .L_wpool_06027508, r2
    bra     .L_0602742E
    swap.w r3, r3
.L_060273DC:
    mov.l   .L_pool_06027534, r1
    mov.w   .L_wpool_0602750A, r2
    mov #0x64, r3
    bra     .L_0602742E
    swap.w r3, r3
.L_060273E6:
    mov.w   .L_wpool_0602751C, r0
    cmp/hi r5, r0
    bt      .L_06027406
    mov.w   .L_wpool_0602751E, r0
    cmp/hi r5, r0
    bt      .L_060273FC
    mov.l   .L_pool_06027538, r1
    mov.w   .L_wpool_0602750C, r2
    mov #0x46, r3
    bra     .L_0602742E
    swap.w r3, r3
.L_060273FC:
    mov.l   .L_pool_0602753C, r1
    mov.w   .L_wpool_0602750E, r2
    mov #0x32, r3
    bra     .L_0602742E
    swap.w r3, r3
.L_06027406:
    mov.w   .L_wpool_06027518, r0
    cmp/hi r5, r0
    bt      .L_06027426
    mov.w   .L_wpool_0602751A, r0
    cmp/hi r5, r0
    bt      .L_0602741C
    mov.l   .L_pool_06027540, r1
    mov.w   .L_wpool_06027510, r2
    mov #0x28, r3
    bra     .L_0602742E
    swap.w r3, r3
.L_0602741C:
    mov.l   .L_pool_06027544, r1
    mov.w   .L_wpool_06027512, r2
    mov #0x1E, r3
    bra     .L_0602742E
    swap.w r3, r3
.L_06027426:
    mov.l   .L_pool_06027548, r1
    mov.w   .L_wpool_06027514, r2
    mov #0x10, r3
    swap.w r3, r3
.L_0602742E:
    sub r3, r4
    dmuls.l r4, r1
    sts mach, r0
    exts.w r0, r0
    tst r6, r6
    bf/s    .L_0602743E
    add r2, r0
    neg r0, r0
.L_0602743E:
    rts
    nop
.L_06027442:
    mov.w   .L_cos_phase, r0
    tst r6, r6
    bf      .L_0602743E
    rts
    neg r0, r0

/* atan2(r4=x, r5=y) -> r0 = atan2(y,x) as angle (0-0xFFFF = 0-360 deg)
 * Special case: y==0 returns +/-0x4000 (90 deg) based on sign of x.
 */
    .global atan2
atan2:
    tst r5, r5                 /* y == 0? */
    bf      atan2_full         /* y != 0 → full computation */
    mov.w   .L_cos_phase, r0  /* r0 = 0x4000 (90 degrees) */
    cmp/pz r4                 /* x >= 0? */
    bt      .L_06027458
    neg r0, r0                 /* x < 0 → return -90 deg */
.L_06027458:
    rts
    nop

/* atan2_full(r4=x, r5=y) -> r0 = atan2(y,x) (y guaranteed non-zero)
 * 1. Save sign of y via cmp/pz + movt
 * 2. Call fpdiv_setup to compute x/y ratio
 * 3. Call atan_piecewise for base angle
 * 4. If y was negative: add 0x8000 (180 deg) for quadrant adjustment
 */
    .global atan2_full
    .type atan2_full, @function
atan2_full:
    sts.l pr, @-r15
    cmp/pz r5                 /* y >= 0? */
    .byte   0xB0, 0x7C    /* bsr fpdiv_setup (external: 0x0602755C) */
    movt r7                    /* r7 = sign of y (1=pos, 0=neg) */
    bsr     atan_piecewise    /* atan(x/y ratio) */
    mov r0, r4                 /* delay: r4 = ratio from fpdiv */
    lds.l @r15+, pr
    tst r7, r7                /* y was negative? */
    bf      .L_06027472       /* no → skip adjustment */
    mov.l   .L_half_circle, r2 /* r2 = 0x8000 (180 degrees) */
    add r2, r0                /* add 180 deg for quadrant 3/4 */
.L_06027472:
    rts
    exts.w r0, r0             /* sign-extend result */

/* isqrt(r4=value) -> r0 = floor(sqrt(value)) << 8
 * Integer square root via binary search (bit-by-bit refinement).
 * Initial bit = 0x8000, tests each bit from MSB to LSB.
 * Final shll8 scales for 16.16 fixed-point compatibility (~8 fractional bits).
 */
    .global isqrt
isqrt:
    cmp/pl r4                  /* value > 0? */
    bf/s    .L_06027494        /* zero/negative → return 0 */
    mov #0x0, r0               /* guess = 0 */
    mov.l   .L_half_circle, r2 /* r2 = 0x8000 (initial test bit) */
.L_0602747E:
    add r2, r0                /* trial = guess + bit */
    mul.l r0, r0              /* trial^2 */
    sts macl, r3
    cmp/eq r4, r3             /* exact match? */
    bt      .L_06027494        /* perfect square → done */
    cmp/hi r4, r3             /* trial^2 > value? */
    bf      .L_0602748E        /* no → keep the bit */
    sub r2, r0                /* yes → remove the bit */
.L_0602748E:
    shlr r2                   /* bit >>= 1 */
    cmp/pl r2                 /* more bits? */
    bt      .L_0602747E
.L_06027494:
    rts
    shll8 r0                  /* scale result << 8 */

/* vec3_normalize(r4=vec_ptr) — normalize 3D vector to unit length in-place
 * Algorithm:
 *   mag_sq = vec3_dot(vec, vec)
 *   mag = isqrt(mag_sq)
 *   if (mag > 0): inv_mag = fpdiv(1.0, mag), scale each component
 */
    .global vec3_normalize
    .type vec3_normalize, @function
vec3_normalize:
    mov.l r14, @-r15
    sts.l pr, @-r15
    mov r4, r14                /* r14 = vec pointer (callee-saved) */
    bsr     .L_060274DA       /* vec3_dot(vec, vec) → magnitude squared */
    mov r4, r5                 /* delay: r5 = r4 (dot with self) */
    bsr     isqrt             /* isqrt(mag_sq) → magnitude */
    mov r0, r4                 /* delay: r4 = mag_sq */
    cmp/pl r0                 /* magnitude > 0? */
    bf      .L_060274D4        /* zero vector → skip */
    mov.l   .L_fp_one, r4    /* r4 = 0x00010000 (1.0 in 16.16) */
    .byte   0xB0, 0x56    /* bsr fpdiv_setup (external: 0x0602755C) → 1.0/mag */
    mov r0, r5                 /* delay: r5 = magnitude */
    mov.l @(0, r14), r1      /* r1 = vec.X */
    mov.l @(4, r14), r2      /* r2 = vec.Y */
    dmuls.l r0, r1            /* X * inv_mag (64-bit) */
    mov.l @(8, r14), r3      /* r3 = vec.Z */
    sts mach, r4
    sts macl, r1
    xtrct r4, r1              /* r1 = (X * inv_mag) >> 16 */
    dmuls.l r0, r2            /* Y * inv_mag */
    mov.l r1, @(0, r14)      /* store normalized X */
    sts mach, r4
    sts macl, r2
    xtrct r4, r2              /* r2 = (Y * inv_mag) >> 16 */
    dmuls.l r0, r3            /* Z * inv_mag */
    mov.l r2, @(4, r14)      /* store normalized Y */
    sts mach, r4
    sts macl, r3
    xtrct r4, r3              /* r3 = (Z * inv_mag) >> 16 */
    mov.l r3, @(8, r14)      /* store normalized Z */
.L_060274D4:
    lds.l @r15+, pr
    rts
    mov.l @r15+, r14
/* vec3_dot(r4=a_ptr, r5=b_ptr) -> r0 = a.x*b.x + a.y*b.y + a.z*b.z (16.16)
 * Leaf function using MAC unit. 7 instructions total.
 */
.L_060274DA:
    clrmac                    /* clear accumulator */
    mac.l @r4+, @r5+         /* acc += a.x * b.x */
    mac.l @r4+, @r5+         /* acc += a.y * b.y */
    mac.l @r4+, @r5+         /* acc += a.z * b.z */
    sts mach, r1              /* high 32 bits */
    sts macl, r0              /* low 32 bits */
    rts
    xtrct r1, r0             /* r0 = (mach<<16)|(macl>>16) = result */
    .2byte  0x0009
.L_sin_table_base:
    .4byte  0x002F2F20         /* sin/cos lookup table base (4096 entries, Work RAM Low) */
.L_atan_table_base:
    .4byte  0x002F0000         /* atan lookup table base (Work RAM Low) */
.L_half_circle:
    .4byte  0x00008000         /* 0.5 in 16.16 OR 180 degrees in angle units */
.L_fp_one:
    .4byte  0x00010000         /* 1.0 in 16.16 fixed-point */
.L_cos_phase:
    .2byte  0x4000             /* cos phase offset = 90 degrees */
.L_table_mask:
    .2byte  0x3FFC             /* table index mask (4096 entries * 4 bytes) */
    .4byte  0x0FFC4000         /* combined: 0x0FFC (atan mask), 0x4000 (phase) */
/* atan piecewise intercepts (angle values at segment boundaries) */
.L_wpool_06027504:
    .2byte  0x3FEB             /* intercept for segment >500 */
.L_wpool_06027506:
    .2byte  0x3FD6             /* intercept for segment >250 */
.L_wpool_06027508:
    .2byte  0x3FBA             /* intercept for segment >150 */
.L_wpool_0602750A:
    .2byte  0x3F97             /* intercept for segment >100 */
.L_wpool_0602750C:
    .2byte  0x3F6A             /* intercept for segment >70 */
.L_wpool_0602750E:
    .2byte  0x3F2F             /* intercept for segment >50 */
.L_wpool_06027510:
    .2byte  0x3EFB             /* intercept for segment >40 */
.L_wpool_06027512:
    .2byte  0x3EA4             /* intercept for segment >30 */
.L_wpool_06027514:
    .2byte  0x3D74             /* intercept for segment >16 */
/* atan piecewise thresholds (integer part of input value) */
.L_wpool_06027516:
    .2byte  0x03E8             /* threshold = 1000 */
.L_wpool_06027518:
    .2byte  0x001E             /* threshold = 30 */
.L_wpool_0602751A:
    .2byte  0x0028             /* threshold = 40 */
.L_wpool_0602751C:
    .2byte  0x0032             /* threshold = 50 */
.L_wpool_0602751E:
    .2byte  0x0046             /* threshold = 70 */
.L_wpool_06027520:
    .2byte  0x0064             /* threshold = 100 */
.L_wpool_06027522:
    .2byte  0x0096             /* threshold = 150 */
.L_wpool_06027524:
    .2byte  0x00FA             /* threshold = 250 */
.L_wpool_06027526:
    .2byte  0x01F4             /* threshold = 500 */
/* atan piecewise slopes (derivatives at each segment) */
.L_pool_06027528:
    .4byte  0x00000AC0         /* slope for >500 (smallest: atan flattening) */
.L_pool_0602752C:
    .4byte  0x00001581         /* slope for >250 */
.L_pool_06027530:
    .4byte  0x000047AE         /* slope for >150 */
.L_pool_06027534:
    .4byte  0x0000B333         /* slope for >100 */
.L_pool_06027538:
    .4byte  0x00018000         /* slope for >70 */
.L_pool_0602753C:
    .4byte  0x0002F333         /* slope for >50 */
.L_pool_06027540:
    .4byte  0x00053333         /* slope for >40 */
.L_pool_06027544:
    .4byte  0x0008B333         /* slope for >30 */
.L_pool_06027548:
    .4byte  0x0015B6DB         /* slope for >16 (steepest: near origin) */

/* swap_sign_ext(r4) -> r0 = sign_extend(swap_words(r4)) */
    .global swap_sign_ext
swap_sign_ext:
    swap.w r4, r0             /* swap upper/lower 16 bits */
    rts
    exts.w r0, r0             /* sign-extend low 16 bits */
