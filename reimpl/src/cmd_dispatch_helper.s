/* cmd_dispatch_helper -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603ADAC - 0x0603AE08
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Command slot initializer / writer.
 *
 * If r4 is zero (no command), clears the active command slot fields
 * (offsets +4, +8, +12) and reports success via save_checksum_calc(0).
 * If the slot is already occupied (active count at struct[0xA0] != 0),
 * reports error -7 (slot busy) via tail-call to save_checksum_calc.
 *
 * If r4 is nonzero (command pointer), copies 12 bytes from the
 * command source (r4) into the slot (r14), then calls
 * sys_timer_config (element flag search) to find the first matching
 * display element, storing the result at slot+12.  Reports success
 * via save_checksum_calc(0).
 *
 * Args:
 *   r4 = command pointer (nonzero) or 0 to clear the slot
 *
 * Returns:
 *   r0 = result from save_checksum_calc tail-call
 *
 * Calls (external):
 *   save_checksum_calc    0x0603B93C  set status/error code and return
 *   sys_timer_config      0x0603B7C0  element flag search
 *   sym_06035168                      memcpy_long(r0=count, r1=dst, r2=src)
 */

    .section .text.FUN_0603ADAC


    .global cmd_dispatch_helper
    .type cmd_dispatch_helper, @function
cmd_dispatch_helper:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    sts.l pr, @-r15                         ! save return address
    mov.l   .L_pool_state_ptr, r5           ! r5 = &sym_060A4D14 (global state pointer)
    mov.w   .L_woff_cmd_slot_base, r3       ! r3 = 0x0098 (offset to command slot sub-struct)
    mov.l @r5, r14                          ! r14 = state struct base
    tst r4, r4                              ! is command pointer null?
    bf/s    .L_copy_command                 ! if nonzero: branch to copy path
    add r3, r14                             ! r14 = base + 0x0098 = command slot pointer (delay slot)
    mov.l @r5, r3                           ! r3 = state struct base (reload)
    mov.w   .L_woff_active_count, r0        ! r0 = 0x00A0 (offset to active count field)
    mov.l @(r0, r3), r0                     ! r0 = struct[0xA0] (active queue count)
    tst r0, r0                              ! is active count zero?
    bt      .L_clear_slot                   ! if zero: safe to clear the slot
    mov #-0x7, r4                           ! r4 = -7 (error: slot busy)
    lds.l @r15+, pr                         ! restore return address
    .byte   0xA5, 0xB7    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(-7)
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_clear_slot:
    mov #0x0, r4                            ! r4 = 0 (clear value)
    mov.l r4, @(8, r14)                     ! slot[+8] = 0 (clear field 2)
    mov.l r4, @(12, r14)                    ! slot[+12] = 0 (clear field 3 / search result)
    mov r4, r2                              ! r2 = 0 (unused, kept for binary compat)
    bra     .L_report_success               ! jump to success epilogue
    mov.l r4, @(4, r14)                     ! slot[+4] = 0 (clear field 1, delay slot)
.L_woff_cmd_slot_base:
    .2byte  0x0098                          ! offset: command slot sub-struct within state
.L_woff_active_count:
    .2byte  0x00A0                          ! offset: active queue count within state
    .2byte  0x00F4                          ! (unused pool padding / adjacent TU data)
    .4byte  sym_0603F1E0                    ! index_mul12: idx*12 + base (used by adjacent TUs)
    .4byte  sym_0603F1F0                    ! index_mul24: idx*24 + base (used by adjacent TUs)
    .4byte  scene_frame_render              ! scene_frame_render (used by adjacent TUs)
.L_pool_state_ptr:
    .4byte  sym_060A4D14                    ! global state base pointer
.L_copy_command:
    mov r14, r1                             ! r1 = dst (command slot pointer)
    mov r4, r2                              ! r2 = src (command data pointer from caller)
    .byte   0xD3, 0x1C    /* mov.l pool_memcpy_long@0x0603AE68, r3 */  ! r3 = memcpy_long (sym_06035168)
    jsr @r3                                 ! call memcpy_long(r0=12, r1=slot, r2=cmd_src)
    mov #0xC, r0                            ! r0 = 12 (byte count, delay slot)
    .byte   0xB4, 0xE1    /* bsr 0x0603B7C0 (external) */  ! call sys_timer_config (element flag search)
    nop                                     ! delay slot
    mov.l r0, @(12, r14)                    ! slot[+12] = search result (1-based index or 0)
.L_report_success:
    mov #0x0, r4                            ! r4 = 0 (success status)
    lds.l @r15+, pr                         ! restore return address
    .byte   0xA5, 0x9A    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(0)
    mov.l @r15+, r14                        ! restore r14 (delay slot)
