/* geom_computation -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06017784 - 0x06017814
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Vertex Index Grid Builder
 * ========================
 * Populates a 2D grid of vertex indices into the display element table
 * (sym_06085640, stride 0x36 = 54 bytes per element entry).
 *
 * Reads vertex indices from a segment descriptor array organized as
 * rows x columns. Each index is offset by a vertex base value (r5)
 * before being stored into the element table at the position determined
 * by the element slot (r6) and row slot (r7).
 *
 * Arguments:
 *   r4  = segment data pointer (header: 2 words = row_count, col_count;
 *         followed by row_count * col_count vertex index words starting at +4)
 *   r5  = vertex base offset (added to each index before storing)
 *   r6  = starting element slot index (low byte used, incremented per vertex)
 *   r7  = starting row slot index (low byte used, incremented per column)
 *
 * Returns: nothing (writes directly into display element table)
 *
 * Called from: geom_pipeline_coord (BSR, multiple call sites for different
 *   segment groups â€” primary segments, secondary segments, demo variants)
 *
 * Data written:
 *   For each column c (0..col_count-1) and row r (0..row_count-1):
 *     element_table[(r6+r)*0x36 + (r7+c)*2] = seg_data[4 + (c*row_count+r)*2] + r5
 */

    .section .text.FUN_06017784


    .global geom_computation
    .type geom_computation, @function
geom_computation:
    mov.l r14, @-r15                     ! save r14 (inner loop counter)
    mov.l r13, @-r15                     ! save r13 (row_count from segment header)
    mov.l r12, @-r15                     ! save r12 (outer loop counter / column index)
    mov.l r11, @-r15                     ! save r11 (initial zero for counters)
    mov.l r10, @-r15                     ! save r10 (row slot offset, shifted)
    mov.l r8, @-r15                      ! save r8  (element table base)
    sts.l macl, @-r15                    ! save MACL (used by mulu/muls)
    add #-0x4, r15                       ! allocate 4 bytes on stack for col_count
    mov.l   .L_pool_elem_table, r8       ! r8 = display element table base (sym_06085640)
    mov #0x0, r11                        ! r11 = 0 (initial column counter)
    mov.w @r4, r13                       ! r13 = row_count (first word of segment data)
    mov.w @(2, r4), r0                   ! r0 = col_count (second word of segment data)
    mov r0, r3                           ! r3 = col_count (working copy)
    mov.w r3, @r15                       ! sp[0] = col_count (save for loop bound)
    add #0x2, r7                         ! r7 += 2 (skip 2-word header, advance row slot)
    bra     .L_outer_loop_test           ! jump to outer loop condition test
    extu.w r11, r12                      ! r12 = 0 (column index, zero-extended) [delay]
    .2byte  0xFFFF                       ! padding (unreachable)
    .4byte  sym_06028400                 ! pool: display_list_loader (unused by this func)
.L_pool_elem_table:
    .4byte  sym_06085640                 ! pool: display element table base (stride 0x36)
.L_outer_loop_body:
    extu.b r7, r10                       ! r10 = row_slot & 0xFF (current row slot index)
    mulu.w r13, r12                      ! MACL = row_count * column_index (source offset)
    extu.w r13, r3                       ! r3 = row_count (zero-extended for comparison)
    shll r10                             ! r10 <<= 1 (word offset for row slot in table)
    sts macl, r1                         ! r1 = row_count * column_index
    shll r1                              ! r1 <<= 1 (convert to byte offset, 2 bytes/word)
    cmp/pl r3                            ! T = (row_count > 0)?
    bf/s    .L_inner_loop_done           ! if row_count <= 0, skip inner loop
    extu.w r11, r14                      ! r14 = 0 (inner row counter) [delay]
.L_inner_loop_body:
    extu.b r6, r0                        ! r0 = elem_slot & 0xFF (current element index)
    mov #0x36, r3                        ! r3 = 0x36 (54 = element table stride)
    extu.w r14, r2                       ! r2 = row_counter (zero-extended)
    muls.w r3, r0                        ! MACL = elem_index * 54 (byte offset into table)
    shll r2                              ! r2 <<= 1 (row_counter * 2 = word offset)
    add #0x1, r14                        ! r14++ (advance inner row counter)
    sts macl, r0                         ! r0 = elem_index * 54 (element table offset)
    mov #0x4, r3                         ! r3 = 4 (skip 2-word header in segment data)
    add r1, r2                           ! r2 += col_offset (source word offset into grid)
    exts.w r0, r0                        ! sign-extend element table offset (for indexing)
    add r4, r2                           ! r2 += seg_data_base (absolute source address)
    add r8, r0                           ! r0 += elem_table_base (absolute dest element)
    add r2, r3                           ! r3 = seg_data + 4 + source_offset (vertex ptr)
    mov.w @r3, r3                        ! r3 = source vertex index (from segment data)
    extu.w r5, r2                        ! r2 = vertex_base_offset & 0xFFFF
    extu.w r3, r3                        ! r3 = vertex_index (zero-extended)
    add r2, r3                           ! r3 = vertex_index + vertex_base_offset
    mov.w r3, @(r0, r10)                 ! elem_table[elem*54 + row_slot*2] = final index
    extu.w r13, r2                       ! r2 = row_count (loop bound)
    extu.w r14, r3                       ! r3 = current row counter
    cmp/ge r2, r3                        ! T = (row_counter >= row_count)?
    bf/s    .L_inner_loop_body           ! if not done, continue inner loop
    add #0x1, r6                         ! r6++ (advance element slot index) [delay]
.L_inner_loop_done:
    extu.w r13, r2                       ! r2 = row_count
    sub r2, r6                           ! r6 -= row_count (reset elem slot for next col)
    add #0x1, r7                         ! r7++ (advance row slot index)
    add #0x1, r12                        ! r12++ (advance column index)
.L_outer_loop_test:
    extu.w r12, r3                       ! r3 = column_index (zero-extended)
    mov.w @r15, r2                       ! r2 = col_count (from stack)
    extu.w r2, r2                        ! r2 = col_count (zero-extended)
    cmp/ge r2, r3                        ! T = (column_index >= col_count)?
    bf      .L_outer_loop_body           ! if not done, process next column
    add #0x4, r15                        ! deallocate stack local (col_count)
    lds.l @r15+, macl                    ! restore MACL
    mov.l @r15+, r8                      ! restore r8
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return to caller
    mov.l @r15+, r14                     ! restore r14 [delay]
