/* menu_sound_trigger -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603AE74 - 0x0603AEE8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Looks up a sound entry from the global command/display state queue
 * by index, validates it, and returns an offset pointer for the caller
 * to use.  Requires the queue to be in wide mode (24-byte stride) with
 * at least one active entry.  Calls save_checksum_calc to set the
 * status/error code on every path.
 *
 * Args:
 *   r4 = sound entry index into the queue
 *
 * Returns:
 *   r0 = computed byte offset + 0xC on success
 *        0 on error (queue inactive, wrong mode, or index out of range)
 *
 * Error codes (via save_checksum_calc r4):
 *   -0x8  = queue inactive or not in wide mode
 *   -0x9  = index out of range (negative or >= capacity)
 *    0x0  = success
 *
 * Calls:
 *   sym_0603F1F0 = index_mul24(idx, base) -> idx*24 + base
 *   0x0603B93C   = save_checksum_calc (set status/error code)
 *
 * State struct fields (base = *sym_060A4D14):
 *   [0x00A0] = active entry count
 *   [0x0098] = queue mode flag (0 = 12-byte narrow, 1 = 24-byte wide)
 *   [0x00A4] = entry capacity (max valid index)
 */

    .section .text.FUN_0603AE74


    .global menu_sound_trigger
    .type menu_sound_trigger, @function
menu_sound_trigger:
    mov.l r14, @-r15                        ! save r14
    sts.l pr, @-r15                         ! save return address
    add #-0x4, r15                          ! reserve one stack slot (for spill)
    mov.l   .L_pool_state_ptr, r14          ! r14 = &sym_060A4D14 (global state pointer)
    mov.w   .L_wpool_0603AED8, r0           ! r0 = 0x00A0 (offset to active entry count)
    mov.l @r14, r3                          ! r3 = state struct base pointer
    mov.l @(r0, r3), r0                     ! r0 = struct[0xA0] (active entry count)
    tst r0, r0                              ! is active count zero?
    bt      .L_inactive_error               ! if no active entries, report error -0x8
    mov.l @r14, r0                          ! r0 = state struct base pointer
    mov.w   .L_wpool_0603AEDA, r1           ! r1 = 0x0098 (offset to queue mode flag)
    mov.l @(r0, r1), r0                     ! r0 = struct[0x98] (mode: 0=narrow, 1=wide)
    cmp/eq #0x1, r0                         ! is mode flag == 1 (wide / 24-byte stride)?
    bt      .L_mode_valid                   ! if wide mode, proceed to index validation
.L_inactive_error:
    .byte   0xB5, 0x54    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=-0x8)
    mov #-0x8, r4                           ! r4 = -0x8 error code (delay slot)
    mov #0x0, r0                            ! r0 = 0 (return value: failure)
    add #0x4, r15                           ! discard spilled stack slot
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_mode_valid:
    cmp/pz r4                               ! is entry index >= 0?
    bf      .L_range_error                  ! if negative index, report error -0x9
    mov.l   .L_pool_state_ptr, r3           ! r3 = &sym_060A4D14 (global state pointer)
    mov.w   .L_wpool_0603AEDC, r0           ! r0 = 0x00A4 (offset to entry capacity)
    mov.l @r3, r3                           ! r3 = state struct base pointer
    mov.l @(r0, r3), r2                     ! r2 = struct[0xA4] (entry capacity)
    cmp/gt r4, r2                           ! is capacity > index? (i.e. index < capacity)
    bt      .L_index_valid                  ! if index in range, proceed to lookup
.L_range_error:
    .byte   0xB5, 0x45    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=-0x9)
    mov #-0x9, r4                           ! r4 = -0x9 error code (delay slot)
    mov #0x0, r0                            ! r0 = 0 (return value: failure)
    add #0x4, r15                           ! discard spilled stack slot
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_index_valid:
    mov.l @r14, r5                          ! r5 = state struct base pointer
    mov.w   .L_wpool_0603AED8, r0           ! r0 = 0x00A0 (offset to active entry count)
    mov.l   .L_pool_index_mul24, r3         ! r3 = &index_mul24 function
    jsr @r3                                 ! call index_mul24(r4=index, r5=active_count)
    mov.l @(r0, r5), r5                     ! r5 = struct[0xA0] (active count; delay slot)
    mov.l r0, @r15                          ! spill index_mul24 result to stack
    .byte   0xB5, 0x38    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0)
    mov #0x0, r4                            ! r4 = 0 success status code (delay slot)
    mov.l @r15, r0                          ! r0 = index_mul24 result (reload from stack)
    add #0xC, r0                            ! r0 += 0xC (offset past 12-byte header to payload)
    add #0x4, r15                           ! discard spilled stack slot
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return r0 = byte offset + 0xC
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_wpool_0603AED8:
    .2byte  0x00A0
.L_wpool_0603AEDA:
    .2byte  0x0098
.L_wpool_0603AEDC:
    .2byte  0x00A4
    .2byte  0xFFFF
.L_pool_state_ptr:
    .4byte  sym_060A4D14                    ! pointer to global command/display state struct
.L_pool_index_mul24:
    .4byte  sym_0603F1F0                    ! index_mul24: idx*24 + base
