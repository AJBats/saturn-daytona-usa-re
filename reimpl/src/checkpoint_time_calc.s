/* checkpoint_time_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600DCC8 - 0x0600DD88
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Checkpoint elapsed time calculation — computes how much race time has
 * elapsed based on per-car track position data and a reference frame.
 *
 * Called from lap_time_record (0x0600D92C) after a lap/checkpoint crossing.
 *
 * Algorithm:
 *   1. Index into per-car timing array (24 bytes per car) using car_index
 *   2. Read current position fields (X, Z) from timing array entry
 *   3. Read reference position fields (X, Z) from car struct (+0x10, +0x18)
 *   4. Compute total_distance = |posX - refX| + |posZ - refZ|
 *   5. Divide by car_struct[+0x0C] (segment scale factor) using SH-2 HW divider
 *   6. Store elapsed time to checkpoint_elapsed (sym_0607869C)
 *   7. Compute remaining = frame_counter * 5 - elapsed → checkpoint_remaining
 *   8. If race_state != 0: compute delta from previous remaining time
 *
 * Data layout:
 *   car_struct[+0x0C]  = segment scale factor (divisor)
 *   car_struct[+0x10]  = reference X position
 *   car_struct[+0x18]  = reference Z position
 *   car_struct[+0x1E0] = pointer to per-car timing data array
 *   timing_entry[+0]   = current X position (24 bytes per entry)
 *   timing_entry[+4]   = current Z position
 *
 * Outputs:
 *   sym_0607869C = checkpoint elapsed time
 *   sym_060786B0 = checkpoint remaining time (frame_count*5 - elapsed)
 *   sym_060786A0 = delta from previous remaining time (when race_state != 0)
 */

    .section .text.FUN_0600DCC8


    .global checkpoint_time_calc
    .type checkpoint_time_calc, @function
checkpoint_time_calc:
    sts.l pr, @-r15                      ! save return address
    add #-0x10, r15                      ! allocate 16 bytes of stack frame
    mov.l   .L_p_car_struct, r4          ! r4 = &car_struct_ptr
    mov.l   .L_p_car_index, r5           ! r5 = &car_index
    mov.w   .L_off_timing_data, r0       ! r0 = 0x01E0 (car timing data ptr offset)
    mov.l @r4, r4                        ! r4 = car_struct (dereference)
    mov.l @r5, r5                        ! r5 = car_index (dereference)
    mov.l @(r0, r4), r2                  ! r2 = car_struct[+0x1E0] = timing_data_base
    mov r5, r3                           ! r3 = car_index (copy for multiply)
    shll2 r5                             ! r5 = car_index * 4
    shll2 r3                             ! r3 = car_index * 4
    shll r5                              ! r5 = car_index * 8
    shll2 r3                             ! r3 = car_index * 16
    add r3, r5                           ! r5 = car_index * 24 (stride per entry)
    add r2, r5                           ! r5 = &timing_data[car_index] (entry pointer)
    mov.l @r5, r2                        ! r2 = entry.posX (current X position)
    mov.l r2, @r15                       ! sp[0] = posX (save for abs calc)
    mov r2, r7                           ! r7 = posX
    mov.l @(16, r4), r6                  ! r6 = car_struct[+0x10] = refX (reference X)
    sub r6, r7                           ! r7 = posX - refX (signed diff)
    cmp/pz r7                            ! is diff >= 0?
    bt      .L_x_diff_positive           ! yes → use positive diff directly
    mov.l @r15, r2                       ! r2 = posX (reload from stack)
    mov r6, r3                           ! r3 = refX
    sub r2, r3                           ! r3 = refX - posX = |posX - refX|
    bra     .L_x_abs_done                ! skip positive path
    nop
.L_x_diff_positive:
    mov r7, r3                           ! r3 = posX - refX (already positive)
.L_x_abs_done:
    mov.l @(4, r5), r2                   ! r2 = entry.posZ (current Z position)
    mov.l r2, @(8, r15)                  ! sp[8] = posZ (save for abs calc)
    mov.l @(24, r4), r2                  ! r2 = car_struct[+0x18] = refZ (reference Z)
    mov.l r2, @(12, r15)                 ! sp[12] = refZ
    mov.l @(8, r15), r2                  ! r2 = posZ (reload)
    mov.l @(12, r15), r1                 ! r1 = refZ (reload)
    sub r1, r2                           ! r2 = posZ - refZ (signed diff)
    cmp/pz r2                            ! is diff >= 0?
    bt/s    .L_z_diff_positive           ! yes → use positive diff directly
    mov.l r2, @(4, r15)                  ! sp[4] = posZ - refZ (delay slot)
    mov.l @(12, r15), r1                 ! r1 = refZ (reload)
    mov.l @(8, r15), r2                  ! r2 = posZ (reload)
    sub r2, r1                           ! r1 = refZ - posZ = |posZ - refZ|
    bra     .L_z_abs_done                ! skip positive path
    nop
.L_z_diff_positive:
    mov.l @(4, r15), r1                  ! r1 = posZ - refZ (already positive)
.L_z_abs_done:
    mov r3, r5                           ! r5 = |posX - refX|
    mov.l   .L_p_checkpoint_elapsed, r6  ! r6 = &checkpoint_elapsed
    add r1, r5                           ! r5 = |posX - refX| + |posZ - refZ| = total_dist
    mov.l   .L_fn_hw_divide, r3          ! r3 = &hw_divide function
    mov r5, r1                           ! r1 = total_dist (dividend for hw_divide)
    jsr @r3                              ! call hw_divide: r0 = r1 / r0
    mov.l @(12, r4), r0                  ! r0 = car_struct[+0x0C] = scale_factor (divisor, delay slot)
    mov r0, r1                           ! r1 = elapsed (division result)
    mov.l r0, @r6                        ! checkpoint_elapsed = elapsed
    mov.l   .L_p_checkpoint_remaining, r4 ! r4 = &checkpoint_remaining
    mov.l   .L_p_frame_counter, r2       ! r2 = &frame_counter
    mov.l @r2, r2                        ! r2 = frame_counter (current frame count)
    mov r2, r3                           ! r3 = frame_counter (copy)
    shll2 r2                             ! r2 = frame_counter * 4
    add r3, r2                           ! r2 = frame_counter * 5
    sub r1, r2                           ! r2 = frame_counter * 5 - elapsed = remaining
    mov.l r2, @r4                        ! checkpoint_remaining = remaining
    mov.l   .L_p_race_state, r0          ! r0 = &race_state
    mov.l @r0, r0                        ! r0 = race_state
    tst r0, r0                           ! race_state == 0?
    bt      .L_epilogue                  ! yes → skip delta calculation
    mov.l   .L_p_prev_remaining, r5      ! r5 = &prev_remaining
    mov.l @r4, r3                        ! r3 = checkpoint_remaining (current)
    mov.l @r5, r2                        ! r2 = prev_remaining
    sub r2, r3                           ! r3 = remaining - prev_remaining = delta
    mov.l   .L_p_remaining_delta, r2     ! r2 = &remaining_delta
    mov.l r3, @r2                        ! remaining_delta = delta
    mov.l @r4, r3                        ! r3 = checkpoint_remaining (reload)
    mov.l r3, @r5                        ! prev_remaining = checkpoint_remaining (update)
.L_epilogue:
    add #0x10, r15                       ! deallocate stack frame
    lds.l @r15+, pr                      ! restore return address
    rts                                  ! return
    nop

    .global DAT_0600dd62
.L_off_timing_data:
DAT_0600dd62:
    .2byte  0x01E0
.L_p_car_struct:
    .4byte  sym_0607E940
.L_p_car_index:
    .4byte  sym_0607EA9C
.L_p_checkpoint_elapsed:
    .4byte  sym_0607869C
.L_fn_hw_divide:
    .4byte  sym_06034FE0
.L_p_checkpoint_remaining:
    .4byte  sym_060786B0
.L_p_frame_counter:
    .4byte  sym_0607EBD0
.L_p_race_state:
    .4byte  sym_0607EAD8
.L_p_prev_remaining:
    .4byte  sym_0605A21C
.L_p_remaining_delta:
    .4byte  sym_060786A0
