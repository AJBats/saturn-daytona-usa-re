/* heading_correct -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CC38 - 0x0600CD40
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Heading correction with stronger step size (+-8).
 *
 * Smooths the car's current heading toward its target heading
 * by stepping +-8 per frame, then looks up sin/cos direction vectors
 * from the course segment data table to compute the car's forward
 * direction for position integration.
 *
 * If the heading delta is within the +-8 deadzone, snaps current
 * heading to target (no overshoot). Otherwise nudges current heading
 * by +8 or -8 toward the target.
 *
 * After heading adjustment, the function extracts the heading's
 * integer index and interpolation fraction, then performs a weighted
 * blend between two adjacent direction vector entries (X and Z)
 * from the course segment table. The interpolated direction vector
 * is written to the output buffer along with angle data.
 *
 * r4 = input segment pointer (source of angle data)
 * r5 = output buffer (receives direction vectors + angles)
 * Uses: car struct from [sym_0607E940]
 *       course segment data table from [sym_0607EB88]
 *
 * Car struct offsets:
 *   +0x01F8 = target heading (heading_A)
 *   +0x01FC = current heading (heading_B, corrected toward A)
 *   +0x01EC = track position index (selects sin/cos table row)
 *
 * Output buffer layout (written to r5):
 *   +0x00 = X direction vector (32-bit, interpolated)
 *   +0x08 = Z direction vector (32-bit, interpolated)
 *   +0x0C = heading angle A (16-bit, from segment)
 *   +0x0E = heading angle B x4 (16-bit, scaled)
 *   +0x10 = heading angle C (16-bit, from segment)
 *   +0x12 = zero padding (16-bit)
 *
 * Companion function: FUN_0600CA96 (course_correct) uses the same
 * algorithm but with +-4 step size and heading pair at +0x01FC/+0x200.
 */

    .section .text.FUN_0600CC38


    .global heading_correct
    .type heading_correct, @function
/* ----------------------------------------------------------------
 * heading_correct
 * Heading correction (stronger +-8 step) + direction vector lookup.
 * Called from collision response and speed/position integration when
 * no active collision timer is running.
 * ---------------------------------------------------------------- */
heading_correct:
    mov.l r14, @-r15                   ! save r14 (callee-saved)
    mov.l r11, @-r15                   ! save r11 (callee-saved)
    sts.l macl, @-r15                  ! save MACL (used by mul.l)
    add #-0x4, r15                     ! allocate 4 bytes of stack (temp storage)
    mov.l   .L_p_car_struct, r6        ! r6 = &car_struct_ptr (sym_0607E940)
    mov.w   DAT_0600ccf6, r0          ! r0 = 0x01F8 (offset to target heading)
    mov.l @r6, r6                      ! r6 = car struct base (dereference pointer)
    mov.l @(r0, r6), r7               ! r7 = car[+0x01F8] (target heading)
    add #0x4, r0                       ! r0 = 0x01FC (offset to current heading)
    mov.l @(r0, r6), r3               ! r3 = car[+0x01FC] (current heading)
    sub r3, r7                         ! r7 = delta = target - current
    mov #0x8, r3                       ! r3 = 8 (positive deadzone threshold)
    cmp/ge r3, r7                      ! delta >= 8?
    bt      .L_outside_deadzone        ! yes -> delta outside deadzone, needs correction
    mov #-0x8, r3                      ! r3 = -8 (negative deadzone threshold)
    cmp/gt r3, r7                      ! delta > -8?
    bf      .L_outside_deadzone        ! no (delta <= -8) -> outside deadzone, needs correction

    ! Within deadzone (|delta| < 8): snap current heading to target
    mov.w   DAT_0600ccf6, r0          ! r0 = 0x01F8 (offset to target heading)
    mov.l @(r0, r6), r3               ! r3 = car[+0x01F8] (target heading value)
    add #0x4, r0                       ! r0 = 0x01FC (offset to current heading)
    mov.l r3, @(r0, r6)               ! car[+0x01FC] = target (snap current to target)
    bra     .L_do_lookup               ! proceed to direction vector lookup
    nop                                ! (delay slot)

.L_outside_deadzone:
    ! Delta is outside deadzone: nudge heading by +8 or -8
    cmp/pl r7                          ! delta > 0? (target is ahead of current)
    bf      .L_adjust_negative         ! no -> delta negative, adjust heading downward

    ! Delta positive: add +8 to current heading (steer toward target)
    mov.w   DAT_0600ccf8, r0          ! r0 = 0x01FC (offset to current heading)
    mov.l @(r0, r6), r3               ! r3 = car[+0x01FC] (current heading)
    add #0x8, r3                       ! r3 += 8 (step heading toward target)
    mov.l r3, @(r0, r6)               ! car[+0x01FC] = updated heading
    bra     .L_do_lookup               ! proceed to direction vector lookup
    nop                                ! (delay slot)

.L_adjust_negative:
    ! Delta negative: subtract 8 from current heading (steer toward target)
    mov.w   DAT_0600ccf8, r0          ! r0 = 0x01FC (offset to current heading)
    mov.l @(r0, r6), r2               ! r2 = car[+0x01FC] (current heading)
    add #-0x8, r2                      ! r2 -= 8 (step heading toward target)
    mov.l r2, @(r0, r6)               ! car[+0x01FC] = updated heading

.L_do_lookup:
    ! === Heading -> Direction Vector Lookup ===
    ! Reads the (now corrected) heading from the input segment pointer,
    ! extracts an integer table index and interpolation fraction,
    ! then looks up direction vectors from the course segment table.
    mov.w @(20, r4), r0               ! r0 = segment[+0x14] (heading value, 16-bit)
    mov r0, r3                         ! r3 = heading (copy)
    mov.w   DAT_0600ccf6, r0          ! r0 = 0x01F8 (offset to target heading field)
    mov.l r3, @(r0, r6)               ! car[+0x01F8] = heading from segment (update target)
    mov.w @(20, r4), r0               ! r0 = segment[+0x14] (re-read heading, 16-bit)
    mov r0, r3                         ! r3 = heading (copy for decomposition)
    mov.w r3, @r15                     ! store heading word to stack temp
    mov.w @r15, r7                     ! r7 = heading (reload from stack, ensures sign extension)
    mov.w @r15, r0                     ! r0 = heading (reload again for low-byte extraction)
    mov.l   .L_p_seg_data_table, r11   ! r11 = &seg_data_table_ptr (sym_0607EB88)
    extu.w r7, r7                      ! r7 = heading zero-extended to 32 bits
    and #0xFF, r0                      ! r0 = heading low byte (fraction component)
    extu.w r0, r14                     ! r14 = low byte zero-extended
    shlr2 r14                          ! r14 >>= 2 (divide fraction by 4)
    shlr2 r14                          ! r14 >>= 4 total
    shlr2 r14                          ! r14 >>= 6 total -> interp fraction (0-3)
    tst r14, r14                       ! fraction == 0?
    bt/s    .L_direct_lookup           ! yes -> no interpolation needed, direct lookup
    shlr8 r7                           ! (delay slot) r7 = heading >> 8 = integer table index

    ! Fraction is nonzero: check if index is within interpolatable range
    mov #0x7, r3                       ! r3 = 7 (max interpolatable index)
    cmp/ge r3, r7                      ! index >= 7?
    bt      .L_direct_lookup           ! yes -> clamp to direct lookup (can't read index+1)

    ! === Interpolated Lookup ===
    ! Blends direction vectors from table[index] and table[index+1]
    ! using weights: w1 = (4 - fraction), w2 = fraction
    mov #0x4, r1                       ! r1 = 4 (total weight)
    mov.w   DAT_0600ccfa, r0          ! r0 = 0x01EC (offset to track position index)
    sub r14, r1                        ! r1 = 4 - fraction (weight for current entry)
    mov.l @(r0, r6), r3               ! r3 = car[+0x01EC] (track position index)
    shll2 r3                           ! r3 *= 4 }
    shll r3                            ! r3 *= 2 } total: r3 *= 8 (row stride factor)
    add r3, r7                         ! r7 = table_index + (track_pos * 8) = final row
    mov r7, r0                         ! r0 = final row index (for current entry address)
    mov.l @r11, r3                     ! r3 = seg_data_table base (dereference pointer)
    mov r7, r6                         ! r6 = final row index (for next entry address)
    shll2 r0                           ! r0 *= 4 }
    add #0x1, r6                       ! r6 = row + 1 (next entry for interpolation)
    shll2 r0                           ! r0 *= 4 } total: r0 = row * 16 (byte offset)
    shll2 r6                           ! r6 *= 4 }
    add r3, r0                         ! r0 = &table[row] (absolute address)
    shll2 r6                           ! r6 *= 4 } total: r6 = (row+1) * 16
    mov.l @r0, r2                      ! r2 = table[row].x_dir (X direction vector)
    add r3, r6                         ! r6 = &table[row+1] (absolute address)

    ! Interpolate X direction: result = (X[row]*w1 + X[row+1]*w2) >> 2
    mul.l r1, r2                       ! MACL = X[row] * (4 - fraction)
    mov.l @r6, r3                      ! r3 = table[row+1].x_dir
    sts macl, r2                       ! r2 = X[row] * w1
    mul.l r14, r3                      ! MACL = X[row+1] * fraction
    sts macl, r3                       ! r3 = X[row+1] * w2
    add r3, r2                         ! r2 = weighted sum
    shar r2                            ! r2 >>= 1 (arithmetic shift)
    shar r2                            ! r2 >>= 2 total (divide by 4, total weight)
    mov.l r2, @r5                      ! output[+0x00] = interpolated X direction

    ! Interpolate Z direction: result = (Z[row]*w1 + Z[row+1]*w2) >> 2
    mov.l @(4, r0), r2                ! r2 = table[row].z_dir (Z direction vector)
    mul.l r1, r2                       ! MACL = Z[row] * (4 - fraction)
    sts macl, r1                       ! r1 = Z[row] * w1
    mov.l @(4, r6), r3                ! r3 = table[row+1].z_dir
    mul.l r14, r3                      ! MACL = Z[row+1] * fraction
    sts macl, r14                      ! r14 = Z[row+1] * w2
    add r14, r1                        ! r1 = weighted sum
    shar r1                            ! r1 >>= 1 (arithmetic shift)
    shar r1                            ! r1 >>= 2 total (divide by 4, total weight)
    bra     .L_copy_angles             ! jump to shared angle copy code
    mov.l r1, @(8, r5)                ! (delay slot) output[+0x08] = interpolated Z direction

    .global DAT_0600ccf6
DAT_0600ccf6:
    .2byte  0x01F8

    .global DAT_0600ccf8
DAT_0600ccf8:
    .2byte  0x01FC

    .global DAT_0600ccfa
DAT_0600ccfa:
    .2byte  0x01EC
.L_p_car_struct:
    .4byte  sym_0607E940
.L_p_seg_data_table:
    .4byte  sym_0607EB88

/* ----------------------------------------------------------------
 * Direct lookup (no interpolation)
 * When the heading fraction is zero or the index is at/beyond
 * the interpolation limit, read direction vectors directly from
 * a single table entry without blending.
 * ---------------------------------------------------------------- */
.L_direct_lookup:
    .byte   0x90, 0x5A    /* mov.w .L_wpool_0600CDBC, r0 */
    mov.l @(r0, r6), r2               ! r2 = car[+0x01EC] (track position index)
    shll2 r2                           ! r2 *= 4 }
    shll r2                            ! r2 *= 2 } total: r2 *= 8 (row stride factor)
    add r2, r7                         ! r7 = table_index + (track_pos * 8) = final row
    mov r7, r6                         ! r6 = final row index
    shll2 r6                           ! r6 *= 4 }
    shll2 r6                           ! r6 *= 4 } total: r6 = row * 16 (byte offset)
    mov.l @r11, r3                     ! r3 = seg_data_table base (dereference pointer)
    add r3, r6                         ! r6 = &table[row] (absolute address)
    mov.l @r6, r2                      ! r2 = table[row].x_dir (X direction vector)
    mov.l r2, @r5                      ! output[+0x00] = X direction (direct copy)
    mov.l @(4, r6), r3                ! r3 = table[row].z_dir (Z direction vector)
    mov.l r3, @(8, r5)                ! output[+0x08] = Z direction (direct copy)

/* ----------------------------------------------------------------
 * Copy angle fields from input segment to output buffer.
 * Shared epilogue for both interpolated and direct lookup paths.
 * ---------------------------------------------------------------- */
.L_copy_angles:
    mov.w @(12, r4), r0               ! r0 = segment[+0x0C] (heading angle A, 16-bit)
    mov.w r0, @(12, r5)               ! output[+0x0C] = heading angle A
    mov.w @(14, r4), r0               ! r0 = segment[+0x0E] (heading angle B, 16-bit)
    mov r0, r3                         ! r3 = angle B (copy for scaling)
    shll2 r3                           ! r3 = angle B * 4 (scale factor)
    exts.w r3, r0                      ! r0 = sign-extend scaled angle B to 32 bits
    mov.w r0, @(14, r5)               ! output[+0x0E] = heading angle B * 4
    mov.w @(16, r4), r0               ! r0 = segment[+0x10] (heading angle C, 16-bit)
    mov.w r0, @(16, r5)               ! output[+0x10] = heading angle C
    mov.w @(18, r4), r0               ! r0 = segment[+0x12] (zero padding, 16-bit)
    mov.w r0, @(18, r5)               ! output[+0x12] = copied padding field
    add #0x4, r15                      ! deallocate 4 bytes of stack temp
    lds.l @r15+, macl                  ! restore MACL
    mov.l @r15+, r11                   ! restore r11
    rts                                ! return to caller
    mov.l @r15+, r14                   ! (delay slot) restore r14
