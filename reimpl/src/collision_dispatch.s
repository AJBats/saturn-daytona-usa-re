/* collision_dispatch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CF58 - 0x0600D12C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Collision response dispatcher — evaluates collision severity and
 * dispatches to appropriate response handlers. Contains a sub-function
 * for speed limit clamping during collision.
 *
 * Arguments: r4 = collision result struct pointer (from collision detect)
 *
 * Persistent registers:
 *   r11 = stack frame pointer (byte flags at @r11)
 *   r12 = 0x0080 (speed limit reset constant)
 *   r13 = collision params struct (from car_array_base)
 *   r14 = car struct (from car_struct_ptr)
 *
 * Collision evaluation:
 *   1. Check car[+4] != 0 (collision active)
 *   2. Check car[+8] > 0x96 (150) — minimum speed for response
 *   3. Check car flags bits 23:22 (0x00C00000) — collision capable
 *   4. Copy 4 bytes of collision data to stack
 *   5. Check car[+0x210] (collision state):
 *      a. If state==0: call speed_limit_clamp sub-function
 *      b. If state!=0: evaluate severity via flags and distance
 *
 * Speed thresholds (state dispatch):
 *   - State 2 + speed > 0x0AF0: check counter < 10 → BSR external handler
 *   - State 1: compare speed limits (shift-right ×8), set surface constants
 *   - Low speeds (< 0x0300): set surface_type = 0x0300, cooldown = 0x0080
 *   - High speeds (> 0x0500): set surface_type = 0x0400, cooldown = 0x0080
 *
 * Sub-function speed_limit_clamp (0x0600D0B8):
 *   Reads speed limits from car and collision params structs,
 *   adjusts toward target by ±0x200 per frame, clamps to [0, 0x0800].
 *   Sets cooldown at car[+0x204] = 0x0200.
 *
 * Car struct offsets:
 *   +0x01B4 = collision cooldown check
 *   +0x01EC = track position
 *   +0x01F8 = surface type (written with speed constants)
 *   +0x01FC = speed limit (clamped value)
 *   +0x0204 = collision cooldown (written with 0x0080 or 0x0200)
 *   +0x0210 = collision state (0/1/2)
 *   +0x0224 = collision event counter
 */

    .section .text.FUN_0600CF58


    .global collision_dispatch
    .type collision_dispatch, @function
collision_dispatch:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    sts.l pr, @-r15
    add #-0x4, r15
    mov r15, r11                      /* r11 = stack frame (flag byte storage) */
    mov.w   .L_cooldown_const, r12   /* r12 = 0x0080 (cooldown value) */
    mov.l   .L_car_array_base, r13
    mov.l   .L_car_struct_ptr, r4
    mov.l @r4, r14                    /* r14 = car struct */
    mov.l @(4, r14), r0              /* car[+4] = collision active flag */
    tst r0, r0
    bf/s    .L_0600CF7A              /* collision active → evaluate */
    mov.l @r13, r13                   /* r13 = collision params struct */
    bra     .L_0600D092              /* no collision → check fallback */
    nop
.L_0600CF7A:
    mov.l @(8, r14), r3              /* car[+8] = impact speed */
    mov.w   DAT_0600cfe4, r2         /* 0x0096 (150) = minimum speed threshold */
    cmp/gt r2, r3
    bt      .L_0600CF86              /* speed > 150 → process collision */
    bra     .L_0600D092              /* too slow → fallback */
    nop
.L_0600CF86:
    mov.l @r4, r2                     /* reload car struct ptr */
    mov.l @r2, r3                     /* car[0] = flags word */
    mov.l   .L_collision_capable_mask, r2
    and r2, r3                        /* check bits 23:22 */
    tst r3, r3
    bf      .L_0600CF96              /* collision capable → proceed */
    bra     .L_0600D09C              /* not capable → exit */
    nop
.L_0600CF96:
    mov r11, r1                       /* dest = stack frame */
    mov r14, r2                       /* src = car struct */
    mov.l   .L_fn_data_copy, r3
    jsr @r3                            /* copy 4 bytes of collision data */
    mov #0x4, r0
    mov.w   DAT_0600cfe6, r0         /* +0x210 = collision state */
    mov.l @(r0, r14), r0
    tst r0, r0
    bf      .L_0600CFB0              /* state != 0 → severity evaluation */
    bsr     .L_0600D0B8              /* state == 0 → speed limit clamp */
    nop
    bra     .L_0600D09C
    nop
.L_0600CFB0:                              /* --- collision severity evaluation --- */
    mov r11, r0
    mov.b @r0, r0                     /* read collision flags from stack */
    tst #0x2, r0                      /* bit 1 = secondary collision? */
    bt      .L_0600CFD6              /* no → skip speed comparison */
    mov.l @(8, r13), r3              /* params speed reference */
    mov.l @(8, r14), r2              /* car impact speed */
    cmp/ge r2, r3
    bt      .L_0600CFC8              /* params >= car speed → copy speed limit */
    .byte   0xB0, 0xB4    /* bsr 0x0600D12C (external) — speed response handler */
    nop
    bra     .L_0600CFD6
    nop
.L_0600CFC8:                              /* speed limit copy path */
    mov.w   .L_off_speed_limit, r0   /* +0x1FC */
    mov.l @(r0, r14), r2
    add #-0x4, r0                     /* +0x1F8 = surface type */
    mov.l r2, @(r0, r14)             /* surface_type = speed_limit */
    add #0xC, r0                      /* +0x204 = cooldown */
    bra     .L_0600D09C
    mov.l r12, @(r0, r14)            /* cooldown = 0x0080 */
.L_0600CFD6:                              /* --- primary collision: distance check --- */
    mov.l @(8, r13), r3              /* params speed ref */
    mov.l @(8, r14), r2              /* car impact speed */
    cmp/ge r2, r3
    bt      .L_0600CFFC              /* params >= car → detailed dispatch */
    bra     .L_0600D09C              /* otherwise → exit */
    nop
.L_cooldown_const:
    .2byte  0x0080                        /* collision cooldown constant */

    .global DAT_0600cfe4
DAT_0600cfe4:
    .2byte  0x0096                        /* minimum speed for collision (150) */

    .global DAT_0600cfe6
DAT_0600cfe6:
    .2byte  0x0210                        /* car offset: collision state */
.L_off_speed_limit:
    .2byte  0x01FC                        /* car offset: speed limit */
    .2byte  0xFFFF
.L_car_array_base:
    .4byte  sym_0607E944               /* car array base / collision params */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_collision_capable_mask:
    .4byte  0x00C00000                  /* bits 23:22: collision capability flags */
.L_fn_data_copy:
    .4byte  sym_06035168               /* byte/word data copy function */
.L_0600CFFC:                              /* --- detailed collision state dispatch --- */
    mov r11, r0
    mov.b @r0, r0                     /* collision flags */
    tst #0x1, r0                      /* bit 0 = primary collision? */
    bt      .L_0600D08E              /* no → default handler */
    mov.w   .L_off_collision_state, r0 /* +0x210 */
    mov.l @(r0, r14), r0
    cmp/eq #0x2, r0
    bf      .L_0600D02E              /* state != 2 → check state 1 */
    mov.l @(8, r13), r2              /* --- state 2: high-speed collision --- */
    mov.w   .L_high_speed_threshold, r3 /* 0x0AF0 (2800) */
    cmp/gt r3, r2
    bf      .L_0600D026              /* speed <= 2800 → normal response */
    mov #0xA, r2
    mov.w   .L_off_event_counter, r0 /* +0x224 = event counter */
    mov.l @(r0, r14), r3
    cmp/ge r2, r3
    bt      .L_0600D026              /* counter >= 10 → normal response */
    .byte   0xB0, 0xF7    /* bsr 0x0600D210 (external) — severe collision handler */
    nop
    bra     .L_0600D08A
    nop
.L_0600D026:
    .byte   0xB0, 0x81    /* bsr 0x0600D12C (external) — normal collision handler */
    nop
    bra     .L_0600D08A
    nop
.L_0600D02E:                              /* --- state 1: speed limit comparison --- */
    mov.w   .L_off_collision_state, r0
    mov.l @(r0, r14), r0
    cmp/eq #0x1, r0
    bf      .L_0600D08A              /* state != 1 → exit */
    mov.w   .L_off_speed_limit_2, r0 /* +0x01FC */
    mov #0x2, r3
    mov.l @(r0, r13), r4             /* params speed limit */
    mov.l @(r0, r14), r5             /* car speed limit */
    shar r4                           /* shift right ×8 for comparison */
    shar r5
    shar r4
    shar r5
    shar r4
    shar r5
    shar r4
    shar r5
    shar r4
    shar r5
    shar r4
    shar r5
    shar r4
    shar r5
    shar r4
    shar r5
    cmp/hs r3, r4                     /* params >> 8 >= 2? */
    bt      .L_0600D074              /* yes → check high range */
    mov #0x3, r3
    cmp/hs r3, r5                     /* car >> 8 >= 3? */
    bt      .L_0600D074              /* yes → check high range */
    mov.w   .L_low_speed_const, r3   /* 0x0300 (low speed) */
    mov.w   .L_off_surface_type, r0  /* +0x01F8 */
    mov.l r3, @(r0, r14)             /* surface_type = 0x0300 */
    add #0xC, r0                      /* +0x204 = cooldown */
    bra     .L_0600D08A
    mov.l r12, @(r0, r14)            /* cooldown = 0x0080 */
.L_0600D074:                              /* --- high speed range check --- */
    mov #0x5, r2
    cmp/hi r2, r4                     /* params >> 8 > 5? */
    bf      .L_0600D08A              /* no → exit */
    mov #0x4, r2
    cmp/hi r2, r5                     /* car >> 8 > 4? */
    bf      .L_0600D08A              /* no → exit */
    mov.w   .L_high_speed_const, r2  /* 0x0400 (high speed) */
    mov.w   .L_off_surface_type, r0  /* +0x01F8 */
    mov.l r2, @(r0, r14)             /* surface_type = 0x0400 */
    add #0xC, r0                      /* +0x204 = cooldown */
    mov.l r12, @(r0, r14)            /* cooldown = 0x0080 */
.L_0600D08A:
    bra     .L_0600D09C
    nop
.L_0600D08E:                              /* --- default collision handler --- */
    .byte   0xB0, 0x4D    /* bsr 0x0600D12C (external) — default response */
    nop
.L_0600D092:                              /* --- fallback: check if collision just ended --- */
    mov.l @(4, r14), r0
    tst r0, r0
    bf      .L_0600D09C              /* still active → exit */
    .byte   0xB0, 0x48    /* bsr 0x0600D12C (external) — cleanup on end */
    nop
.L_0600D09C:
    add #0x4, r15
    lds.l @r15+, pr
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_off_collision_state:
    .2byte  0x0210                        /* car offset: collision state */
.L_high_speed_threshold:
    .2byte  0x0AF0                        /* high-speed collision threshold (2800) */
.L_off_event_counter:
    .2byte  0x0224                        /* car offset: collision event counter */
.L_off_speed_limit_2:
    .2byte  0x01FC                        /* car offset: speed limit (dup for reach) */
.L_low_speed_const:
    .2byte  0x0300                        /* low-speed surface type (768) */
.L_off_surface_type:
    .2byte  0x01F8                        /* car offset: surface type */
.L_high_speed_const:
    .2byte  0x0400                        /* high-speed surface type (1024) */
.L_0600D0B8:                              /* === speed_limit_clamp sub-function === */
    mov.w   .L_speed_increment, r7   /* 0x0200 = adjustment step */
    mov.l   .L_car_array_base_2, r5
    mov.l   .L_car_struct_ptr_2, r4
    mov.l @r4, r6                     /* r6 = car struct */
    mov r6, r3
    mov.l @r3, r2                     /* car[0] = flags */
    mov.l   .L_collision_capable_mask_2, r3
    and r3, r2
    tst r2, r2
    bt/s    .L_0600D10E              /* not collision-capable → return */
    mov.l @r5, r5                     /* r5 = collision params struct */
    mov.w   DAT_0600d114, r0         /* +0x1FC = speed limit */
    mov.l @(r0, r5), r3              /* params speed limit */
    mov.l @(r0, r6), r2              /* car speed limit */
    cmp/ge r2, r3
    bt      .L_0600D0E0              /* params >= car → decrement */
    mov.w   DAT_0600d114, r0         /* params < car → increment toward target */
    mov.l @(r0, r5), r4
    bra     .L_0600D0E8
    add r7, r4                        /* target = params + 0x200 */
.L_0600D0E0:
    mov.w   DAT_0600d114, r0         /* params >= car → decrement toward target */
    mov.l @(r0, r5), r4
    mov.w   .L_speed_decrement, r2
    add r2, r4                        /* target = params - 0x200 */
.L_0600D0E8:
    cmp/pz r4
    bt      .L_0600D0F6              /* target >= 0 → check upper bound */
    mov #0x0, r2                      /* clamp to 0 */
    mov.w   .L_off_surface_type_2, r0
    mov.l r2, @(r0, r6)
    bra     .L_0600D10A
    nop
.L_0600D0F6:
    mov.w   DAT_0600d11a, r3         /* 0x0800 = speed max */
    cmp/gt r3, r4
    bf      .L_0600D106              /* target <= max → store */
    mov.w   DAT_0600d11a, r3         /* clamp to max */
    mov.w   .L_off_surface_type_2, r0
    mov.l r3, @(r0, r6)
    bra     .L_0600D10A
    nop
.L_0600D106:
    mov.w   .L_off_surface_type_2, r0
    mov.l r4, @(r0, r6)              /* store clamped speed */
.L_0600D10A:
    mov.w   .L_off_cooldown, r0      /* +0x204 */
    mov.l r7, @(r0, r6)              /* cooldown = 0x0200 */
.L_0600D10E:
    rts
    nop
.L_speed_increment:
    .2byte  0x0200                        /* speed adjustment step (+512) */

    .global DAT_0600d114
DAT_0600d114:
    .2byte  0x01FC                        /* car offset: speed limit */
.L_speed_decrement:
    .2byte  0xFE00                        /* speed adjustment step (-512) */
.L_off_surface_type_2:
    .2byte  0x01F8                        /* car offset: surface type */

    .global DAT_0600d11a
DAT_0600d11a:
    .2byte  0x0800                        /* speed limit maximum (2048) */
.L_off_cooldown:
    .2byte  0x0204                        /* car offset: collision cooldown */
    .2byte  0xFFFF
.L_car_array_base_2:
    .4byte  sym_0607E944               /* car array base (dup for sub-fn) */
.L_car_struct_ptr_2:
    .4byte  sym_0607E940               /* car struct pointer (dup for sub-fn) */
.L_collision_capable_mask_2:
    .4byte  0x00C00000                  /* collision capability mask (dup) */
