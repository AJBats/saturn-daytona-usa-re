/* collision_dispatch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CF58 - 0x0600D12C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Collision response dispatcher -- evaluates collision severity and
 * dispatches to appropriate response handlers for car-to-car collisions.
 * Contains a sub-function (speed_limit_clamp) for clamping the car's
 * speed limit toward a target value during active collision state.
 *
 * Entry: Called each frame per car to process collision results.
 *
 * Persistent registers:
 *   r11 = stack frame pointer (byte flags at @r11)
 *   r12 = 0x0080 (speed limit reset / cooldown constant)
 *   r13 = collision params struct (from car_array_base)
 *   r14 = car struct pointer (from car_struct_ptr)
 *
 * Collision evaluation flow:
 *   1. Check car[+4] != 0 (collision active flag)
 *   2. Check car[+8] > 0x96 (150) -- minimum impact speed for response
 *   3. Check car flags bits 23:22 (0x00C00000) -- collision capable
 *   4. Copy 4 bytes of collision data to stack frame
 *   5. Check car[+0x210] (collision state):
 *      a. If state==0: call speed_limit_clamp sub-function
 *      b. If state!=0: evaluate severity via flags and distance
 *
 * Speed thresholds (state dispatch):
 *   - State 2 + speed > 0x0AF0: check counter < 10 -> BSR severe handler
 *   - State 1: compare speed limits (shift-right x8), set surface constants
 *   - Low speeds (< 0x0300): set surface_type = 0x0300, cooldown = 0x0080
 *   - High speeds (> 0x0500): set surface_type = 0x0400, cooldown = 0x0080
 *
 * Sub-function speed_limit_clamp (0x0600D0B8):
 *   Reads speed limits from car and collision params structs,
 *   adjusts toward target by +/-0x200 per frame, clamps to [0, 0x0800].
 *   Sets cooldown at car[+0x204] = 0x0200.
 *
 * Car struct offsets used:
 *   +0x004 = collision active flag
 *   +0x008 = impact speed
 *   +0x01F8 = surface type (written with speed constants)
 *   +0x01FC = speed limit (clamped value)
 *   +0x0204 = collision cooldown (written with 0x0080 or 0x0200)
 *   +0x0210 = collision state (0/1/2)
 *   +0x0224 = collision event counter
 */

    .section .text.FUN_0600CF58


    .global collision_dispatch
    .type collision_dispatch, @function
collision_dispatch:
    mov.l r14, @-r15                      ! save r14 (car struct ptr) to stack
    mov.l r13, @-r15                      ! save r13 (collision params) to stack
    mov.l r12, @-r15                      ! save r12 (cooldown constant) to stack
    mov.l r11, @-r15                      ! save r11 (stack frame ptr) to stack
    sts.l pr, @-r15                       ! save return address to stack
    add #-0x4, r15                        ! allocate 4 bytes for local collision flags
    mov r15, r11                          ! r11 = stack frame base (flag byte storage)
    mov.w   .L_wpool_cooldown_const, r12  ! r12 = 0x0080 (cooldown reset value)
    mov.l   .L_pool_car_array_base, r13   ! r13 = &car_array_base (collision params ptr)
    mov.l   .L_pool_car_struct_ptr, r4    ! r4 = &car_struct_ptr
    mov.l @r4, r14                        ! r14 = car struct (dereference ptr-to-ptr)
    mov.l @(4, r14), r0                   ! r0 = car[+4] (collision active flag)
    tst r0, r0                            ! test if collision is active
    bf/s    .L_collision_active           ! if collision active (nonzero) -> evaluate it
    mov.l @r13, r13                       ! r13 = collision params struct (delay slot)
    bra     .L_check_collision_ended      ! no active collision -> check if one just ended
    nop                                   ! (delay slot)
.L_collision_active:
    mov.l @(8, r14), r3                   ! r3 = car[+8] (impact speed)
    mov.w   DAT_0600cfe4, r2              ! r2 = 0x0096 (150 = minimum speed threshold)
    cmp/gt r2, r3                         ! compare: impact_speed > 150?
    bt      .L_speed_sufficient           ! if speed > 150 -> process the collision
    bra     .L_check_collision_ended      ! too slow for response -> check fallback
    nop                                   ! (delay slot)
.L_speed_sufficient:
    mov.l @r4, r2                         ! r2 = car struct ptr (reload from global)
    mov.l @r2, r3                         ! r3 = car[0] (car flags word)
    mov.l   .L_pool_coll_capable_mask, r2 ! r2 = 0x00C00000 (collision capability bits 23:22)
    and r2, r3                            ! r3 = flags & capability_mask
    tst r3, r3                            ! test if car is collision-capable
    bf      .L_car_is_capable             ! if capable (bits set) -> proceed with collision
    bra     .L_epilogue                   ! not capable -> exit immediately
    nop                                   ! (delay slot)
.L_car_is_capable:
    mov r11, r1                           ! r1 = dest address (stack frame for flags)
    mov r14, r2                           ! r2 = src address (car struct)
    mov.l   .L_pool_fn_data_copy, r3      ! r3 = address of byte/word copy function
    jsr @r3                               ! call data_copy(dest=r1, src=r2, len=r0)
    mov #0x4, r0                          ! r0 = 4 bytes to copy (delay slot)
    mov.w   DAT_0600cfe6, r0              ! r0 = 0x0210 (offset to collision state)
    mov.l @(r0, r14), r0                  ! r0 = car[+0x210] (collision state: 0/1/2)
    tst r0, r0                            ! test if state == 0
    bf      .L_severity_eval              ! if state != 0 -> evaluate collision severity
    bsr     .L_speed_limit_clamp          ! if state == 0 -> call speed_limit_clamp subroutine
    nop                                   ! (delay slot)
    bra     .L_epilogue                   ! after clamping, exit
    nop                                   ! (delay slot)
.L_severity_eval:                             ! --- collision severity evaluation ---
    mov r11, r0                           ! r0 = stack frame address
    mov.b @r0, r0                         ! r0 = collision flags byte from stack
    tst #0x2, r0                          ! test bit 1 (secondary/side collision flag)
    bt      .L_primary_distance_check     ! if bit 1 clear -> skip to primary distance check
    mov.l @(8, r13), r3                   ! r3 = params[+8] (reference speed from params)
    mov.l @(8, r14), r2                   ! r2 = car[+8] (car impact speed)
    cmp/ge r2, r3                         ! compare: params_speed >= car_speed?
    bt      .L_copy_speed_limit           ! if params >= car -> copy speed limit directly
    .byte   0xB0, 0xB4    /* bsr 0x0600D12C (external) -- speed response handler */
    nop                                   ! (delay slot)
    bra     .L_primary_distance_check     ! after handler, continue to primary check
    nop                                   ! (delay slot)
.L_copy_speed_limit:                          ! --- copy existing speed limit as surface type ---
    mov.w   .L_wpool_off_speed_limit, r0  ! r0 = 0x01FC (offset to speed limit)
    mov.l @(r0, r14), r2                  ! r2 = car[+0x1FC] (current speed limit)
    add #-0x4, r0                         ! r0 = 0x01F8 (offset to surface type)
    mov.l r2, @(r0, r14)                  ! car[+0x1F8] = speed_limit (copy as surface type)
    add #0xC, r0                          ! r0 = 0x0204 (offset to collision cooldown)
    bra     .L_epilogue                   ! exit after setting cooldown
    mov.l r12, @(r0, r14)                 ! car[+0x204] = 0x0080 (cooldown, delay slot)
.L_primary_distance_check:                    ! --- primary collision: speed comparison ---
    mov.l @(8, r13), r3                   ! r3 = params[+8] (reference speed)
    mov.l @(8, r14), r2                   ! r2 = car[+8] (impact speed)
    cmp/ge r2, r3                         ! compare: params_speed >= car_speed?
    bt      .L_detailed_state_dispatch    ! if params >= car -> do detailed state dispatch
    bra     .L_epilogue                   ! otherwise -> exit (car is faster, no response)
    nop                                   ! (delay slot)
.L_wpool_cooldown_const:
    .2byte  0x0080                        ! collision cooldown constant (128)

    .global DAT_0600cfe4
DAT_0600cfe4:
    .2byte  0x0096                        ! minimum impact speed for collision response (150)

    .global DAT_0600cfe6
DAT_0600cfe6:
    .2byte  0x0210                        ! car struct offset: collision state field
.L_wpool_off_speed_limit:
    .2byte  0x01FC                        ! car struct offset: speed limit
    .2byte  0xFFFF                        ! padding
.L_pool_car_array_base:
    .4byte  sym_0607E944                  ! car array base / collision params struct pointer
.L_pool_car_struct_ptr:
    .4byte  sym_0607E940                  ! current car struct pointer (ptr-to-ptr)
.L_pool_coll_capable_mask:
    .4byte  0x00C00000                    ! bits 23:22: collision capability flags
.L_pool_fn_data_copy:
    .4byte  sym_06035168                  ! byte/word data copy function
.L_detailed_state_dispatch:                   ! --- detailed collision state dispatch ---
    mov r11, r0                           ! r0 = stack frame address
    mov.b @r0, r0                         ! r0 = collision flags byte
    tst #0x1, r0                          ! test bit 0 (primary collision flag)
    bt      .L_default_handler            ! if bit 0 clear -> use default handler
    mov.w   .L_wpool_off_coll_state, r0   ! r0 = 0x0210 (collision state offset)
    mov.l @(r0, r14), r0                  ! r0 = car[+0x210] (collision state)
    cmp/eq #0x2, r0                       ! is state == 2 (severe)?
    bf      .L_check_state_1              ! if state != 2 -> check for state 1
    mov.l @(8, r13), r2                   ! --- state 2: high-speed collision path ---
    mov.w   .L_wpool_high_speed_thresh, r3 ! r3 = 0x0AF0 (2800 = high-speed threshold)
    cmp/gt r3, r2                         ! compare: params_speed > 2800?
    bf      .L_normal_collision           ! if speed <= 2800 -> use normal response
    mov #0xA, r2                          ! r2 = 10 (max event counter before downgrade)
    mov.w   .L_wpool_off_event_counter, r0 ! r0 = 0x0224 (event counter offset)
    mov.l @(r0, r14), r3                  ! r3 = car[+0x224] (collision event counter)
    cmp/ge r2, r3                         ! compare: counter >= 10?
    bt      .L_normal_collision           ! if counter >= 10 -> downgrade to normal
    .byte   0xB0, 0xF7    /* bsr 0x0600D210 (external) -- severe collision handler */
    nop                                   ! (delay slot)
    bra     .L_state_dispatch_done        ! after severe handler, jump to cleanup
    nop                                   ! (delay slot)
.L_normal_collision:
    .byte   0xB0, 0x81    /* bsr 0x0600D12C (external) -- normal collision handler */
    nop                                   ! (delay slot)
    bra     .L_state_dispatch_done        ! after normal handler, jump to cleanup
    nop                                   ! (delay slot)
.L_check_state_1:                             ! --- state 1: speed limit comparison ---
    mov.w   .L_wpool_off_coll_state, r0   ! r0 = 0x0210 (collision state offset)
    mov.l @(r0, r14), r0                  ! r0 = car[+0x210] (collision state)
    cmp/eq #0x1, r0                       ! is state == 1 (moderate)?
    bf      .L_state_dispatch_done        ! if state != 1 -> nothing to do, exit
    mov.w   .L_wpool_off_speed_limit_2, r0 ! r0 = 0x01FC (speed limit offset)
    mov #0x2, r3                          ! r3 = 2 (low threshold for params >> 8)
    mov.l @(r0, r13), r4                  ! r4 = params[+0x1FC] (params speed limit)
    mov.l @(r0, r14), r5                  ! r5 = car[+0x1FC] (car speed limit)
    shar r4                               ! r4 >>= 1 (arithmetic shift right, step 1/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 2/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 3/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 4/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 5/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 6/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 7/8)
    shar r5                               ! r5 >>= 1
    shar r4                               ! r4 >>= 1 (step 8/8, total: params_limit >> 8)
    shar r5                               ! r5 >>= 1 (total: car_limit >> 8)
    cmp/hs r3, r4                         ! compare unsigned: (params >> 8) >= 2?
    bt      .L_check_high_range           ! if yes -> check high-speed range
    mov #0x3, r3                          ! r3 = 3 (low threshold for car >> 8)
    cmp/hs r3, r5                         ! compare unsigned: (car >> 8) >= 3?
    bt      .L_check_high_range           ! if yes -> check high-speed range
    mov.w   .L_wpool_low_speed_const, r3  ! r3 = 0x0300 (low-speed surface type = 768)
    mov.w   .L_wpool_off_surface_type, r0 ! r0 = 0x01F8 (surface type offset)
    mov.l r3, @(r0, r14)                  ! car[+0x1F8] = 0x0300 (set low-speed surface)
    add #0xC, r0                          ! r0 = 0x0204 (cooldown offset)
    bra     .L_state_dispatch_done        ! exit after writing cooldown
    mov.l r12, @(r0, r14)                 ! car[+0x204] = 0x0080 (cooldown, delay slot)
.L_check_high_range:                          ! --- high speed range check ---
    mov #0x5, r2                          ! r2 = 5 (high threshold for params >> 8)
    cmp/hi r2, r4                         ! compare unsigned: (params >> 8) > 5?
    bf      .L_state_dispatch_done        ! if no -> exit without writing
    mov #0x4, r2                          ! r2 = 4 (high threshold for car >> 8)
    cmp/hi r2, r5                         ! compare unsigned: (car >> 8) > 4?
    bf      .L_state_dispatch_done        ! if no -> exit without writing
    mov.w   .L_wpool_high_speed_const, r2 ! r2 = 0x0400 (high-speed surface type = 1024)
    mov.w   .L_wpool_off_surface_type, r0 ! r0 = 0x01F8 (surface type offset)
    mov.l r2, @(r0, r14)                  ! car[+0x1F8] = 0x0400 (set high-speed surface)
    add #0xC, r0                          ! r0 = 0x0204 (cooldown offset)
    mov.l r12, @(r0, r14)                 ! car[+0x204] = 0x0080 (write cooldown constant)
.L_state_dispatch_done:
    bra     .L_epilogue                   ! jump to function epilogue
    nop                                   ! (delay slot)
.L_default_handler:                           ! --- default collision handler (bit 0 not set) ---
    .byte   0xB0, 0x4D    /* bsr 0x0600D12C (external) -- default collision response */
    nop                                   ! (delay slot)
.L_check_collision_ended:                     ! --- fallback: check if collision just ended ---
    mov.l @(4, r14), r0                   ! r0 = car[+4] (collision active flag, re-read)
    tst r0, r0                            ! test if collision is still active
    bf      .L_epilogue                   ! if still active -> exit normally
    .byte   0xB0, 0x48    /* bsr 0x0600D12C (external) -- cleanup on collision end */
    nop                                   ! (delay slot)
.L_epilogue:
    add #0x4, r15                         ! deallocate 4-byte local frame
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r11                      ! restore r11 (stack frame ptr)
    mov.l @r15+, r12                      ! restore r12 (cooldown constant)
    mov.l @r15+, r13                      ! restore r13 (collision params)
    rts                                   ! return to caller
    mov.l @r15+, r14                      ! restore r14 (car struct ptr, delay slot)
.L_wpool_off_coll_state:
    .2byte  0x0210                        ! car struct offset: collision state (0/1/2)
.L_wpool_high_speed_thresh:
    .2byte  0x0AF0                        ! high-speed collision threshold (2800)
.L_wpool_off_event_counter:
    .2byte  0x0224                        ! car struct offset: collision event counter
.L_wpool_off_speed_limit_2:
    .2byte  0x01FC                        ! car struct offset: speed limit (dup for reach)
.L_wpool_low_speed_const:
    .2byte  0x0300                        ! low-speed surface type constant (768)
.L_wpool_off_surface_type:
    .2byte  0x01F8                        ! car struct offset: surface type
.L_wpool_high_speed_const:
    .2byte  0x0400                        ! high-speed surface type constant (1024)
.L_speed_limit_clamp:                         ! === speed_limit_clamp sub-function ===
    mov.w   .L_wpool_speed_increment, r7  ! r7 = 0x0200 (speed adjustment step = +512)
    mov.l   .L_pool_car_array_base_2, r5  ! r5 = &car_array_base (for sub-fn)
    mov.l   .L_pool_car_struct_ptr_2, r4  ! r4 = &car_struct_ptr (for sub-fn)
    mov.l @r4, r6                         ! r6 = car struct (dereference)
    mov r6, r3                            ! r3 = car struct (temp copy)
    mov.l @r3, r2                         ! r2 = car[0] (car flags word)
    mov.l   .L_pool_coll_capable_mask_2, r3 ! r3 = 0x00C00000 (capability mask)
    and r3, r2                            ! r2 = flags & capability_mask
    tst r2, r2                            ! test if car is collision-capable
    bt/s    .L_clamp_return               ! if not capable -> return immediately
    mov.l @r5, r5                         ! r5 = collision params struct (delay slot)
    mov.w   DAT_0600d114, r0              ! r0 = 0x01FC (speed limit offset)
    mov.l @(r0, r5), r3                   ! r3 = params[+0x1FC] (params speed limit)
    mov.l @(r0, r6), r2                   ! r2 = car[+0x1FC] (car speed limit)
    cmp/ge r2, r3                         ! compare: params_limit >= car_limit?
    bt      .L_clamp_decrement            ! if params >= car -> decrement toward target
    mov.w   DAT_0600d114, r0              ! r0 = 0x01FC (reload offset for increment path)
    mov.l @(r0, r5), r4                   ! r4 = params[+0x1FC] (base for target calc)
    bra     .L_clamp_check_bounds         ! jump to bounds checking
    add r7, r4                            ! r4 = params_limit + 0x200 (target, delay slot)
.L_clamp_decrement:
    mov.w   DAT_0600d114, r0              ! r0 = 0x01FC (speed limit offset)
    mov.l @(r0, r5), r4                   ! r4 = params[+0x1FC] (base for target calc)
    mov.w   .L_wpool_speed_decrement, r2  ! r2 = 0xFE00 (-512 = negative adjustment)
    add r2, r4                            ! r4 = params_limit - 0x200 (target)
.L_clamp_check_bounds:
    cmp/pz r4                             ! test: target >= 0?
    bt      .L_clamp_check_upper          ! if non-negative -> check upper bound
    mov #0x0, r2                          ! r2 = 0 (clamp floor)
    mov.w   .L_wpool_off_surface_type_2, r0 ! r0 = 0x01F8 (surface type offset)
    mov.l r2, @(r0, r6)                   ! car[+0x1F8] = 0 (surface type = zero/clamped)
    bra     .L_clamp_write_cooldown       ! jump to write cooldown
    nop                                   ! (delay slot)
.L_clamp_check_upper:
    mov.w   DAT_0600d11a, r3              ! r3 = 0x0800 (speed limit maximum = 2048)
    cmp/gt r3, r4                         ! compare: target > max?
    bf      .L_clamp_store_target         ! if target <= max -> store directly
    mov.w   DAT_0600d11a, r3              ! r3 = 0x0800 (reload max for clamping)
    mov.w   .L_wpool_off_surface_type_2, r0 ! r0 = 0x01F8 (surface type offset)
    mov.l r3, @(r0, r6)                   ! car[+0x1F8] = 0x0800 (clamp to max)
    bra     .L_clamp_write_cooldown       ! jump to write cooldown
    nop                                   ! (delay slot)
.L_clamp_store_target:
    mov.w   .L_wpool_off_surface_type_2, r0 ! r0 = 0x01F8 (surface type offset)
    mov.l r4, @(r0, r6)                   ! car[+0x1F8] = target (store clamped speed)
.L_clamp_write_cooldown:
    mov.w   .L_wpool_off_cooldown, r0     ! r0 = 0x0204 (cooldown offset)
    mov.l r7, @(r0, r6)                   ! car[+0x204] = 0x0200 (set clamp cooldown)
.L_clamp_return:
    rts                                   ! return from speed_limit_clamp
    nop                                   ! (delay slot)
.L_wpool_speed_increment:
    .2byte  0x0200                        ! speed adjustment step (+512 per frame)

    .global DAT_0600d114
DAT_0600d114:
    .2byte  0x01FC                        ! car struct offset: speed limit
.L_wpool_speed_decrement:
    .2byte  0xFE00                        ! speed adjustment step (-512 per frame)
.L_wpool_off_surface_type_2:
    .2byte  0x01F8                        ! car struct offset: surface type (dup for sub-fn)

    .global DAT_0600d11a
DAT_0600d11a:
    .2byte  0x0800                        ! speed limit maximum (2048)
.L_wpool_off_cooldown:
    .2byte  0x0204                        ! car struct offset: collision cooldown
    .2byte  0xFFFF                        ! padding
.L_pool_car_array_base_2:
    .4byte  sym_0607E944                  ! car array base (dup for sub-fn reach)
.L_pool_car_struct_ptr_2:
    .4byte  sym_0607E940                  ! car struct pointer (dup for sub-fn reach)
.L_pool_coll_capable_mask_2:
    .4byte  0x00C00000                    ! collision capability mask (dup for sub-fn)
