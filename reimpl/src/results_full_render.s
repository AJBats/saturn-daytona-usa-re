/* results_full_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06033240 - 0x06033338
 * Auto-generated by tools/generate_l3_tu.py
 *
 * results_full_render: Outer entry — drives the result element rendering loop.
 *   Calls the inner helper (place_result_cell) to stamp one element, then
 *   advances both the X coordinate (r1) and loop counters (r6, r7).
 *   On return from the inner call the position is bumped by 1.0 (16.16) and
 *   external branch-back targets (in the caller) are used to iterate over
 *   all elements to display.
 *
 * place_result_cell: Inner helper (BSR target).
 *   Given a 16.16 fixed-point screen position (r1 = x, r2 = y) and a
 *   colour/rank nibble in r5, this routine:
 *     1. Adds tile-grid origin offsets (+36.0, +28.0) to convert from
 *        element-relative coords to screen coords.
 *     2. Bounds-checks the position against the visible results grid
 *        (x in [4.0, 70.0], y in [4.0, 54.0]).  Out-of-bounds → early return.
 *     3. Rounds the fractional halves up to the nearest integer (0.5 bias).
 *     4. Converts the integer pixel position to a packed-nibble byte offset
 *        into the results cell colour table (sym_060629AC).
 *     5. Reads the existing byte, merges the new nibble (high or low depending
 *        on whether r1 is odd), and writes the byte back.
 *
 * Register conventions (place_result_cell):
 *   r1 = x position (16.16)    r2 = y position (16.16)
 *   r5 = colour/rank nibble    r4 = scratch / cell base ptr
 *   r3 = byte index accumulator
 */

    .section .text.FUN_06033240


    .global results_full_render
    .type results_full_render, @function
results_full_render:
    sts.l pr, @-r15                      ! save return address (PR) — nested BSR follows
    bsr     place_result_cell            ! call inner cell-stamp helper
    nop                                  ! (branch delay slot)
    lds.l @r15+, pr                      ! restore return address
    mov.l   .L_fp_one, r4               ! r4 = 1.0 (16.16) — X step amount
    add r4, r1                           ! r1 += 1.0 — advance X position by one element
    add #-0x1, r7                        ! r7-- — outer loop counter
    cmp/pl r7                            ! is outer counter still positive?
    .byte   0x89, 0xEA    /* bt 0x06033228 (external) */ ! if yes, branch back to outer loop in caller
    mov.l   .L_pool_neg_eighth, r0      ! r0 = 0xFFF80000 (-8.0 16.16) — X reset delta
    add r0, r1                           ! r1 -= 8.0 — reset X to start of next row
    mov.l   .L_fp_one, r0              ! r0 = 1.0 (16.16) — Y step amount
    add r0, r2                           ! r2 += 1.0 — advance Y position to next row
    add #-0x1, r6                        ! r6-- — inner loop counter
    cmp/pl r6                            ! is inner counter still positive?
    .byte   0x89, 0xE2    /* bt 0x06033226 (external) */ ! if yes, branch back to inner loop in caller
    mov.l @r15+, r7                      ! restore r7
    mov.l @r15+, r6                      ! restore r6
    rts                                  ! return to caller
    nop                                  ! (branch delay slot)

    /* constant pool for results_full_render */
    .4byte  0x00030000                   /* 3.0 (16.16 fixed-point) — unused padding / alignment */
    .4byte  sym_0603390C                 /* pointer to display element descriptor table */
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_pool_neg_eighth:
    .4byte  0xFFF80000                   /* -8.0 (16.16 fixed-point) — X row-reset delta */

/*
 * place_result_cell — inner BSR target: stamp one nibble into the results
 * cell colour table at the position given by (r1, r2) in 16.16 fixed point.
 *
 * Entry:
 *   r1  = x coord (16.16)   r2  = y coord (16.16)
 *   r5  = colour nibble to write (0-15)
 * Exit:
 *   r0-r3 restored; r4 may be clobbered (restored from stack by caller).
 */
place_result_cell:
    mov.l r0, @-r15                      ! save r0
    mov.l r1, @-r15                      ! save r1
    mov.l r2, @-r15                      ! save r2
    mov.l r3, @-r15                      ! save r3
    mov #0x0, r0                         ! r0 = 0 — used for equality test
    cmp/eq r0, r5                        ! is colour/rank nibble zero?
    bt      .ret_restore                 ! if zero, nothing to draw — early return
    mov.l   .L_pool_x_origin, r0       ! r0 = 0x00240000 (36.0) — grid X origin
    mov.l   .L_pool_y_origin, r3       ! r3 = 0x001C0000 (28.0) — grid Y origin
    add r0, r1                           ! r1 += 36.0 — translate to screen X
    add r3, r2                           ! r2 += 28.0 — translate to screen Y
    mov.l   .L_fp_four, r0             ! r0 = 4.0 (16.16) — left/top clip boundary
    cmp/gt r1, r0                        ! is 4.0 > x? (i.e. x < 4.0)
    bt      .ret_restore                 ! clip: x too small
    cmp/gt r2, r0                        ! is 4.0 > y? (i.e. y < 4.0)
    bt      .ret_restore                 ! clip: y too small
    mov.l   .L_pool_x_max, r0          ! r0 = 0x00460000 (70.0) — right clip boundary
    cmp/gt r0, r1                        ! is x > 70.0?
    bt      .ret_restore                 ! clip: x too large
    mov.l   .L_pool_y_max, r0          ! r0 = 0x00360000 (54.0) — bottom clip boundary
    cmp/gt r0, r2                        ! is y > 54.0?
    bt      .ret_restore                 ! clip: y too large
    mov.l   .L_fp_half, r0             ! r0 = 0x00008000 (0.5) — rounding bias mask
    mov.l   .L_fp_one_b, r3            ! r3 = 1.0 (16.16) — rounding increment
    tst r0, r2                           ! test if y has fractional half-bit set
    bt      .y_no_round                  ! if not, skip Y rounding
    add r3, r2                           ! r2 += 1.0 — round Y up
.y_no_round:
    tst r0, r1                           ! test if x has fractional half-bit set
    bt      .x_no_round                  ! if not, skip X rounding
    add r3, r1                           ! r1 += 1.0 — round X up
.x_no_round:
    shlr16 r2                            ! r2 >>= 16 — convert Y to integer pixels
    shlr16 r1                            ! r1 >>= 16 — convert X to integer pixels
    exts.w r2, r2                        ! sign-extend Y word to 32 bits
    exts.w r1, r1                        ! sign-extend X word to 32 bits

    /* Compute packed-nibble cell index into the colour table.
     * The table stores two nibbles per byte, so each byte covers two adjacent
     * X positions.  Index formula (derived from the shift/AND sequence):
     *   row_base  = (y & 0xF8) * 4 * 8  =  (y & 0xF8) << 5
     *   row_frac  = (y & 0x07) * 4       =  (y & 0x07) << 2
     *   col_coarse= (x & 0xF8) * 4       =  (x & 0xF8) << 2  (then halved by nibble packing)
     *   col_fine  = (x & 0x07) >> 1      (nibble select handled below)
     *   byte_idx  = row_base + row_frac + col_coarse_half + col_fine
     */
    mov r2, r0                           ! r0 = y (integer)
    and #0xF8, r0                        ! r0 = y & 0xF8 — coarse Y (8-pixel groups)
    shll2 r0                             ! r0 <<= 2
    mov r0, r3                           ! r3 = (y & 0xF8) << 2
    shll r0                              ! r0 <<= 1
    shll2 r0                             ! r0 <<= 2  → r0 = (y & 0xF8) << 5
    add r0, r3                           ! r3 += (y & 0xF8) << 5  (= row_base + partial)
    mov r2, r0                           ! r0 = y
    and #0x7, r0                         ! r0 = y & 0x7 — fine Y within group
    shll2 r0                             ! r0 <<= 2 — row_frac
    add r0, r3                           ! r3 += row_frac

    mov r1, r0                           ! r0 = x (integer)
    and #0xF8, r0                        ! r0 = x & 0xF8 — coarse X
    shll2 r0                             ! r0 <<= 2 — column contribution (halved by nibble)
    mov r0, r4                           ! r4 = (x & 0xF8) << 2
    mov r1, r0                           ! r0 = x
    and #0x7, r0                         ! r0 = x & 0x7 — fine X within group
    shlr r0                              ! r0 >>= 1 — nibble-byte select within fine X
    add r0, r4                           ! r4 += fine X contribution
    add r4, r3                           ! r3 = final byte offset into colour table

    mov.l   .L_pool_cell_table, r4      ! r4 = sym_060629AC — base of colour cell table
    add r3, r4                           ! r4 = pointer to target byte in colour table
    mov.b @r4, r0                        ! r0 = current packed-nibble byte at that cell
    mov.l r4, @-r15                      ! save cell pointer for write-back

    mov #-0x10, r2                       ! r2 = 0xFFFFFFF0 — high-nibble mask (clear low 4 bits)
    mov #0x1, r4                         ! r4 = 1 — test bit for odd X (nibble select)
    tst r4, r1                           ! test x bit 0: 0 = even (high nibble), 1 = odd (low nibble)
    bf      .odd_x                       ! if x is odd, write into low nibble
    mov #0xF, r2                         ! r2 = 0x0F — low-nibble mask (for even-x: mask existing low)
    shll2 r5                             ! r5 <<= 2
    shll2 r5                             ! r5 <<= 2  → r5 <<= 4 (shift colour to high nibble)
.odd_x:
    and r2, r0                           ! r0 &= mask — clear the nibble being written
    or r5, r0                            ! r0 |= colour nibble — insert new value
    mov.l @r15+, r4                      ! restore cell pointer
    mov.b r0, @r4                        ! write updated byte back to colour table
.ret_restore:
    mov.l @r15+, r3                      ! restore r3
    mov.l @r15+, r2                      ! restore r2
    mov.l @r15+, r1                      ! restore r1
    mov.l @r15+, r0                      ! restore r0
    rts                                  ! return to caller (results_full_render BSR)
    nop                                  ! (branch delay slot)

    /* constant pool for place_result_cell */
    .2byte  0x0000                       /* alignment padding */
.L_pool_x_origin:
    .4byte  0x00240000                   /* 36.0 (16.16) — results grid X origin offset */
.L_pool_y_origin:
    .4byte  0x001C0000                   /* 28.0 (16.16) — results grid Y origin offset */
.L_fp_four:
    .4byte  0x00040000                  /* 4.0 (16.16 fixed-point) */
.L_pool_x_max:
    .4byte  0x00460000                   /* 70.0 (16.16) — results grid right clip boundary */
.L_pool_y_max:
    .4byte  0x00360000                   /* 54.0 (16.16) — results grid bottom clip boundary */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_fp_one_b:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_pool_cell_table:
    .4byte  sym_060629AC                 /* base address of results colour cell table */
    .4byte  0xD505D406                   /* trailing data (after cell table ptr — not code) */
    .4byte  0x9606D006                   /* trailing data */
