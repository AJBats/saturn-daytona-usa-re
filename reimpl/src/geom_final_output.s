/* geom_final_output -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601FEC0 - 0x0601FFA8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Geometry final output — writes display list entry parameters into the
 * current car struct's geometry output fields.
 *
 * Called once per car from geom_display_handler with r4 pointing to a
 * 6-byte display list entry. Reads 3 words from the entry:
 *   word[0] (+0) = vertex count (halved with round-up, stored to 4 car fields)
 *   word[1] (+2) = scale factor (fpmul'd with 0x035A, stored to car fields)
 *   word[2] (+4) = surface type value (stored to car[+0x01FC] and car[+0x01F8])
 *
 * Then calls race_pos_interp to interpolate the car's track position,
 * writing interpolated XYZ coords + angles into car struct fields at
 * offsets +16..+52 of the output block.
 *
 * Finally increments the output counter and wraps if it exceeds the
 * track section count (sym_0607EA9C).
 *
 * Car struct output block base: sym_0607E940 (indirect pointer to car struct)
 *
 * Car struct offsets written (relative to car struct base):
 *   +0x01EC = half_vertex_count (rounded up)
 *   +0x01F0 = half_vertex_count (copy)
 *   +0x01E4 = half_vertex_count (copy)
 *   +0x01E8 = half_vertex_count (copy)
 *   +8      = raw vertex count (unsigned word[1])
 *   +12     = fpmul(word[1] << 16, 0x035A) result
 *   +0x0194 = same fpmul result (copy)
 *   +0x01FC = surface type (unsigned word[2])
 *   +0x01F8 = surface type (copy)
 *   +16..+52 = interpolated position/angle data from race_pos_interp
 *   +48     = angle copy (from +32)
 *   +40     = angle copy (from +32)
 *   +0x01B0 = angle copy (from +32)
 *   +0x01A4 = heading angle (from +28)
 *   +0x01A8 = angle (from +32)
 *   +0x01AC = angle (from +36)
 *   +0x0150 = output counter (incremented, wraps at section count)
 *   +0x01E4 = wrapped counter copy (from +0x01EC)
 *
 * Persistent registers:
 *   r12 = display list entry pointer (from r4)
 *   r13 = course data base (sym_06078680)
 *   r14 = car struct base (loaded from sym_0607E940 indirect)
 */

    .section .text.FUN_0601FEC0


    .global geom_final_output
    .type geom_final_output, @function
geom_final_output:
    mov.l r14, @-r15                       ! save r14 (callee-saved)
    mov #0x0, r3                           ! r3 = 0 (used for rounding below)
    mov.l r13, @-r15                       ! save r13 (callee-saved)
    mov.l r12, @-r15                       ! save r12 (callee-saved)
    sts.l pr, @-r15                        ! save return address
    mov r4, r12                            ! r12 = display list entry pointer (argument)
    mov.l   .L_p_car_struct, r14           ! r14 = &car_struct_ptr (sym_0607E940)
    mov.l   .L_p_course_data, r13          ! r13 = &course_data_base (sym_06078680)
    mov.w   DAT_0601ff8a, r0              ! r0 = 0x01EC (car offset: track segment index)
    mov.w @r12, r4                         ! r4 = entry.word[0] (vertex count, signed)
    mov.l @r14, r14                        ! r14 = car struct base (dereference pointer)
    extu.w r4, r4                          ! r4 = zero-extend to 32-bit unsigned
    cmp/gt r4, r3                          ! T = (0 > r4)? sets T if r4 was negative
    addc r3, r4                            ! r4 = r4 + 0 + T (round up if odd via carry)
    shar r4                                ! r4 = r4 / 2 (arithmetic shift right)
    mov.l r4, @(r0, r14)                   ! car[+0x01EC] = half_vertex_count
    add #0x4, r0                           ! r0 = 0x01F0
    mov.l r4, @(r0, r14)                   ! car[+0x01F0] = half_vertex_count (copy)
    add #-0x8, r0                          ! r0 = 0x01E8 (was 0x01F0, subtract 8)
    mov.l r4, @(r0, r14)                   ! car[+0x01E4] = half_vertex_count (copy) -- NOTE: wrong offset comment, see below
    add #-0x4, r0                          ! r0 = 0x01E4 (was 0x01E8, subtract 4)
    mov.l r4, @(r0, r14)                   ! car[+0x01E4] = half_vertex_count (copy)
    mov.w @(2, r12), r0                    ! r0 = entry.word[1] (scale factor, signed)
    mov r0, r3                             ! r3 = scale factor
    extu.w r3, r3                          ! r3 = zero-extend scale factor
    mov r3, r5                             ! r5 = scale factor (arg for fpmul)
    mov.l r3, @(8, r14)                    ! car[+8] = raw scale factor (unsigned)
    mov.w   .L_w_scale_multiplier, r4      ! r4 = 0x035A (fpmul fixed-point multiplier)
    mov.l   .L_p_fn_fpmul, r3             ! r3 = &fpmul
    jsr @r3                                ! r0 = fpmul(0x035A, scale << 16)
    shll16 r5                              ! (delay slot) r5 = scale << 16 (convert to 16.16 FP)
    mov r0, r4                             ! r4 = fpmul result (scaled geometry value)
    mov.l r0, @(12, r14)                   ! car[+12] = scaled geometry value
    mov.w   DAT_0601ff8e, r0              ! r0 = 0x0194 (car offset: frame time / Y interp)
    mov.l r4, @(r0, r14)                   ! car[+0x0194] = scaled geometry value (copy)
    mov.w @(4, r12), r0                    ! r0 = entry.word[2] (surface type, signed)
    mov r0, r4                             ! r4 = surface type
    extu.w r4, r4                          ! r4 = zero-extend surface type
    mov.w   DAT_0601ff90, r0              ! r0 = 0x01FC (car offset: speed limit / surface type)
    mov.l r4, @(r0, r14)                   ! car[+0x01FC] = surface type
    add #-0x4, r0                          ! r0 = 0x01F8 (car offset: surface type copy)
    mov.l r4, @(r0, r14)                   ! car[+0x01F8] = surface type (copy)
    mov.w @r12, r5                         ! r5 = entry.word[0] (vertex count, for interp)
    mov.l   .L_p_fn_race_pos_interp, r3   ! r3 = &race_pos_interp
    extu.w r5, r5                          ! r5 = zero-extend vertex count
    jsr @r3                                ! call race_pos_interp(r4=course_data, r5=count)
    mov r13, r4                            ! (delay slot) r4 = course data base
    mov.l @r13, r2                         ! r2 = course_data[0] (interp X position)
    mov.l r2, @(16, r14)                   ! car[+16] = interpolated X position
    mov.l @(4, r13), r3                    ! r3 = course_data[4] (interp Y position)
    mov.l r3, @(20, r14)                   ! car[+20] = interpolated Y position
    mov.l @(8, r13), r2                    ! r2 = course_data[8] (interp Z position)
    mov.l r2, @(24, r14)                   ! car[+24] = interpolated Z position
    mov.w @(12, r13), r0                   ! r0 = course_data.w[12] (heading angle A)
    mov r0, r3                             ! r3 = heading angle A (sign-extend via mov)
    mov.l r0, @(28, r14)                   ! car[+28] = heading angle A (32-bit store)
    mov.w @(14, r13), r0                   ! r0 = course_data.w[14] (heading angle B)
    mov r0, r3                             ! r3 = heading angle B
    mov.l r0, @(32, r14)                   ! car[+32] = heading angle B
    mov.w @(16, r13), r0                   ! r0 = course_data.w[16] (heading angle C)
    mov r0, r3                             ! r3 = heading angle C
    mov.l r0, @(36, r14)                   ! car[+36] = heading angle C
    mov.l @(32, r14), r3                   ! r3 = car[+32] (heading angle B, reload)
    mov.l r3, @(48, r14)                   ! car[+48] = heading angle B (copy)
    mov.l @(32, r14), r2                   ! r2 = car[+32] (heading angle B, reload)
    mov.l r2, @(40, r14)                   ! car[+40] = heading angle B (copy)
    mov.l @(32, r14), r3                   ! r3 = car[+32] (heading angle B, reload)
    mov.w   .L_w_ofs_heading_b_copy, r0    ! r0 = 0x01B0 (car offset: yaw/heading copy)
    mov.l r3, @(r0, r14)                   ! car[+0x01B0] = heading angle B (copy)
    mov.l @(28, r14), r3                   ! r3 = car[+28] (heading angle A, reload)
    add #-0xC, r0                          ! r0 = 0x01A4 (car offset: heading A copy)
    mov.l r3, @(r0, r14)                   ! car[+0x01A4] = heading angle A (copy)
    mov.l @(32, r14), r3                   ! r3 = car[+32] (heading angle B, reload)
    add #0x4, r0                           ! r0 = 0x01A8 (car offset: heading B copy)
    mov.l r3, @(r0, r14)                   ! car[+0x01A8] = heading angle B (copy)
    mov.l @(36, r14), r3                   ! r3 = car[+36] (heading angle C, reload)
    add #0x4, r0                           ! r0 = 0x01AC (car offset: heading C copy)
    mov.l r3, @(r0, r14)                   ! car[+0x01AC] = heading angle C (copy)
    add #0x40, r0                          ! r0 = 0x01EC (jump back to track segment index)
    mov.l @(r0, r14), r3                   ! r3 = car[+0x01EC] (current output counter, was track segment)
    add #0x1, r3                           ! r3 = counter + 1
    mov.l r3, @(r0, r14)                   ! car[+0x01EC] = incremented counter
    mov.l   .L_p_section_count, r4         ! r4 = &section_count (sym_0607EA9C)
    mov.l @(r0, r14), r3                   ! r3 = car[+0x01EC] (re-read incremented counter)
    mov.l @r4, r2                          ! r2 = section_count (max value before wrap)
    cmp/gt r2, r3                          ! T = (counter > section_count)?
    bf      .L_no_wrap                     ! no wrap needed → skip
    mov.l @r4, r2                          ! r2 = section_count (reload for subtraction)
    mov.w   DAT_0601ff8a, r0              ! r0 = 0x01EC (car offset: track segment index)
    mov.l @(r0, r14), r3                   ! r3 = car[+0x01EC] (counter that exceeded limit)
    sub r2, r3                             ! r3 = counter - section_count (wrap around)
    mov.l r3, @(r0, r14)                   ! car[+0x01EC] = wrapped counter
.L_no_wrap:
    mov.w   DAT_0601ff8a, r0              ! r0 = 0x01EC (car offset: track segment index)
    mov.l @(r0, r14), r3                   ! r3 = car[+0x01EC] (final counter value)
    add #-0x8, r0                          ! r0 = 0x01E4 (car offset: segment index copy)
    mov.l r3, @(r0, r14)                   ! car[+0x01E4] = final counter (copy from +0x01EC)
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return to caller
    mov.l @r15+, r14                       ! (delay slot) restore r14

    .global DAT_0601ff8a
DAT_0601ff8a:
    .2byte  0x01EC
.L_w_scale_multiplier:
    .2byte  0x035A                         /* [HIGH] geometry scale factor for fpmul (0x035A) */

    .global DAT_0601ff8e
DAT_0601ff8e:
    .2byte  0x0194

    .global DAT_0601ff90
DAT_0601ff90:
    .2byte  0x01FC
.L_w_ofs_heading_b_copy:
    .2byte  0x01B0                         /* [HIGH] car struct offset: heading angle B copy (+0x01B0) */
.L_p_car_struct:
    .4byte  sym_0607E940                   /* &current_car_ptr (indirect) */
.L_p_course_data:
    .4byte  sym_06078680                   /* course/track data base */
.L_p_fn_fpmul:
    .4byte  fpmul                          /* fixed-point multiply: (r4*r5) >> 16 */
.L_p_fn_race_pos_interp:
    .4byte  race_pos_interp                /* race position interpolation function */
.L_p_section_count:
    .4byte  sym_0607EA9C                   /* track section count (wrap boundary) */
