/* display_enable_ctrl -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603806C - 0x06038120
 * Auto-generated by tools/generate_l3_tu.py
 *
 * display_enable_ctrl(r4 = pattern_config_base)
 *   Initializes a pattern configuration struct at sym_06087C84.
 *   Called during engine init (from engine_init_global) to set up
 *   a 512-entry display element table.
 *
 *   Phase 1: Zeros the struct header — 5 flag bytes at offsets 0-4
 *   and 2 longwords at offsets 8 and 12.
 *
 *   Phase 2: Zeros a 64-entry longword array at struct+0x1810
 *   (entries 0..63 only; skipped for indices >= 64).
 *
 *   Phase 3: Initializes 512 entries of 12-byte records starting
 *   at struct+0x10. Each entry:
 *     [+0] = 0 (cleared)
 *     [+4] = float_to_fixed(index / 65536.0)  — normalized position
 *     [+8] = 0x00010000 (1.0 in 16.16 fixed-point) — default scale
 *
 *   The float math chain is:
 *     int_to_fp_stack(index)  → IEEE 754 double of index
 *     float_div(index, 65536.0) → index/65536 as double
 *     float_to_fixed()        → 16.16 fixed-point result
 *
 * Called by: engine_init_global
 * Calls: sym_06035BC8 (int_to_fp_stack), sym_060359E4 (float_div),
 *        sym_060357B8 (float_to_fixed)
 */

    .section .text.FUN_0603806C


    .global display_enable_ctrl
    .type display_enable_ctrl, @function
display_enable_ctrl:
    mov.l r14, @-r15               ! save r14 (callee-saved)
    mov.l r13, @-r15               ! save r13 (callee-saved)
    mov.l r12, @-r15               ! save r12 (callee-saved)
    sts.l pr, @-r15                ! save return address
    mov #0x40, r12                 ! r12 = 64 (aux array entry count)
    mov.w   .L_wpool_06038106, r13 ! r13 = 0x0200 (512 = main loop count)
    mov.l   .L_fixpt_one, r14      ! r14 = 0x00010000 (1.0 in 16.16 fixed-point)
    mov #0x0, r5                   ! r5 = 0 (zero constant used throughout)
    extu.b r5, r0                  ! r0 = 0 (zero-extended byte)
    mov.b r0, @(2, r4)             ! struct->flags[2] = 0
    extu.b r5, r0                  ! r0 = 0 (zero-extended byte)
    mov.b r0, @(1, r4)             ! struct->flags[1] = 0
    mov.b r5, @r4                  ! struct->flags[0] = 0
    extu.b r5, r2                  ! r2 = 0 (zero-extended byte)
    mov r2, r0                     ! r0 = 0
    mov.b r0, @(3, r4)             ! struct->flags[3] = 0
    mov.l r5, @(8, r4)             ! struct->word[2] = 0 (offset 8)
    mov.l r5, @(12, r4)            ! struct->word[3] = 0 (offset 12)
    extu.b r5, r3                  ! r3 = 0 (zero-extended byte)
    mov r3, r0                     ! r0 = 0
    mov.b r0, @(4, r4)             ! struct->flags[4] = 0
    extu.w r5, r6                  ! r6 = 0 (loop counter, zero-extended halfword)
.L_entry_loop:
    extu.w r6, r3                  ! r3 = loop index (zero-extended)
    cmp/ge r12, r3                 ! index >= 64?
    bt      .L_skip_aux_clear      !   yes → skip aux array write
    extu.w r6, r3                  ! r3 = index (zero-extended for shift)
    shll2 r3                       ! r3 = index * 4 (byte offset into aux array)
    mov.w   DAT_06038108, r2       ! r2 = 0x1810 (aux array offset from struct base)
    add r4, r2                     ! r2 = struct + 0x1810 (aux array base)
    add r2, r3                     ! r3 = &aux_array[index]
    mov.l r5, @r3                  ! aux_array[index] = 0
.L_skip_aux_clear:
    mov r6, r7                     ! r7 = index (will become byte offset A)
    mov r6, r3                     ! r3 = index (will become byte offset B)
    mov r4, r2                     ! r2 = struct base (will become entry ptr)
    mov r6, r0                     ! r0 = index
    shll2 r7                       ! r7 = index * 4
    shll2 r3                       ! r3 = index * 4
    add #0x10, r2                  ! r2 = struct + 0x10 (entry array base)
    extu.w r0, r0                  ! r0 = index (zero-extended)
    shll r3                        ! r3 = index * 8
    add r3, r7                     ! r7 = index*4 + index*8 = index*12 (entry stride)
    exts.w r7, r7                  ! sign-extend entry offset to 32-bit
    mov r4, r3                     ! r3 = struct base (for later store)
    add r7, r2                     ! r2 = struct + 0x10 + index*12 (entry ptr)
    add #0x10, r3                  ! r3 = struct + 0x10 (entry array base, for later)
    mov.l r5, @r2                  ! entry[index].field_0 = 0
    add r7, r3                     ! r3 = struct + 0x10 + index*12 (entry ptr copy)
    add #-0x10, r15                ! allocate 16 bytes on stack for double result
    mov.l   .L_fn_int_to_fp, r2    ! r2 = &int_to_fp_stack
    jsr @r2                        ! call int_to_fp_stack(r0=index) → double at *sp
    mov.l r15, @-r15               ! (delay) push output ptr for double result
    mov #0x0, r1                   ! r1 = 0 (low word of 65536.0 double)
    mov.l r1, @-r15                ! push divisor double low word (0x00000000)
    mov.l   .L_double_65536_hi, r1 ! r1 = 0x40F00000 (high word of 65536.0 double)
    mov.l r1, @-r15                ! push divisor double high word
    mov r15, r2                    ! r2 = SP (points to divisor on stack)
    mov.l   .L_fn_float_div, r1    ! r1 = &float_div
    add #0x10, r2                  ! r2 = SP + 0x10 (points to dividend from int_to_fp)
    jsr @r1                        ! call float_div(dividend_ptr, divisor on stack)
    mov.l r2, @-r15                ! (delay) push dividend ptr
    mov.l   .L_fn_float_to_fixed, r2 ! r2 = &float_to_fixed
    jsr @r2                        ! call float_to_fixed() → r0 = 16.16 fixed result
    nop                            ! (delay slot)
    add #0x1, r6                   ! r6++ (increment loop counter)
    mov.l r0, @(4, r3)             ! entry[index].field_4 = float_to_fixed(index/65536)
    extu.w r6, r2                  ! r2 = next index (zero-extended)
    mov r4, r3                     ! r3 = struct base (reload for next iteration)
    add #0x10, r3                  ! r3 = struct + 0x10 (entry array base)
    add r3, r7                     ! r7 = entry array base + old index*12 (UNUSED next iter)
    cmp/ge r13, r2                 ! next index >= 512?
    bf/s    .L_entry_loop          !   no → continue loop
    mov.l r14, @(8, r7)            ! (delay) entry[index].field_8 = 1.0 (16.16 fixed)
    lds.l @r15+, pr                ! restore return address
    mov.l @r15+, r12               ! restore r12
    mov.l @r15+, r13               ! restore r13
    rts                            ! return to caller
    mov.l @r15+, r14               ! (delay) restore r14
.L_wpool_06038106:
    .2byte  0x0200

    .global DAT_06038108
DAT_06038108:
    .2byte  0x1810
    .2byte  0xFFFF
.L_fixpt_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_fn_int_to_fp:
    .4byte  sym_06035BC8
.L_double_65536_hi:
    .4byte  0x40F00000
.L_fn_float_div:
    .4byte  sym_060359E4
.L_fn_float_to_fixed:
    .4byte  sym_060357B8
