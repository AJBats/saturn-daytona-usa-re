/* mat_vec_transform_b -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060272C0 - 0x0602745C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains the Stack B matrix-vector transform, the Stack B no-translation
 * variant (encoded as raw bytes), plus the core trig utility functions:
 * cos_lookup, sin_lookup, sincos_pair, atan_piecewise, and atan2.
 *
 * Stack B is the object/model transform pipeline. It uses:
 *   sym_0608A52C = matrix stack B pointer (current top)
 *   sym_0608A530 = matrix stack B alternate base
 *   sym_0608A6B0 = vector scratch buffer B0
 *   sym_0608A6C0 = vector scratch buffer B1
 *   sym_0608A6F0 = vector output buffer B2 (transform result)
 *
 * Matrix format: 48 bytes per entry
 *   [0x00] 3x3 rotation (9 x int32 = 36 bytes, row-major, 16.16 fixed-point)
 *   [0x24] translation vector (3 x int32 = 12 bytes, 16.16 fixed-point)
 *
 * Angle convention: full circle = 0x10000 (65536 units)
 *   90 degrees = 0x4000, 180 degrees = 0x8000
 *
 * Trig table at 0x002F2F20 (ROM): 4096 entries x 4 bytes, 16.16 fixed-point.
 * Atan table at 0x002F0000 (ROM): piecewise small-angle lookup.
 */

    .section .text.FUN_060272C0


    .global mat_vec_transform_b
    .type mat_vec_transform_b, @function
/* mat_vec_transform_b -- Matrix * vector + translation (Stack B)
 *
 * Computes: result = M * vec + T
 * where M is the 3x3 rotation at top of Stack B,
 * T is the translation at offset +0x24, and vec is the input.
 *
 * Input:  r4 = pointer to input vec3 (12 bytes: X, Y, Z)
 *         r5 = pointer to output vec3 (12 bytes)
 * Output: *r5 = M * vec + T (also stored to sym_0608A6F0)
 *
 * Algorithm:
 *   For each output row i (0..2):
 *     clrmac
 *     acc += M[i][0] * vec[0]
 *     acc += M[i][1] * vec[1]
 *     load T[i] from translation vector
 *     acc += M[i][2] * vec[2]
 *     result[i] = (acc >> 16) + T[i]   (xtrct extracts middle 32 bits)
 *   Copy 3 results from temp buffer to output pointer
 */
mat_vec_transform_b:
    mov.l r14, @-r15                    ! save r14 (callee-saved, used as output ptr)
    mov.l   .L_pool_mat_b_stack_ptr, r0 ! r0 = &matrix_stack_b_ptr (sym_0608A52C)
    mov #0x24, r7                       ! r7 = 0x24 (offset to translation vector)
    mov.l @r0, r6                       ! r6 = *mat_stack_b_ptr = matrix base address
    mov.l   .L_pool_output_buf_b, r14   ! r14 = sym_0608A6F0 (output buffer B2)
    add r6, r7                          ! r7 = matrix_base + 0x24 = translation vector ptr
    mov #0x3, r3                        ! r3 = 3 (loop counter: 3 rows)
.L_transform_row_loop:
    clrmac                              ! clear MAC accumulator for this row
    mac.l @r4+, @r6+                    ! acc += vec[j] * M[i][0]; advance both ptrs
    mac.l @r4+, @r6+                    ! acc += vec[j] * M[i][1]; advance both ptrs
    mov.l @r7+, r2                      ! r2 = T[i] (translation component); advance
    mac.l @r4+, @r6+                    ! acc += vec[j] * M[i][2]; advance both ptrs
    dt r3                               ! r3--; set T flag if r3 == 0
    add #-0xC, r4                       ! rewind input vec ptr back to start (-12 bytes)
    sts mach, r0                        ! r0 = high 32 bits of MAC result
    sts macl, r1                        ! r1 = low 32 bits of MAC result
    xtrct r0, r1                        ! r1 = (mach<<16)|(macl>>16) = dot product >> 16
    add r2, r1                          ! r1 = (M_row . vec) + T[i]
    mov.l r1, @r14                      ! store result to output buffer B2
    bf/s    .L_transform_row_loop       ! loop if rows remain (branch in delay slot)
    add #0x4, r14                       ! advance output ptr by 4 bytes (delay slot)
    add #-0xC, r14                      ! rewind output ptr back to start of results (-12)
    mov.l @r14+, r0                     ! r0 = result[0] (X component)
    mov.l @r14+, r1                     ! r1 = result[1] (Y component)
    mov.l @r14+, r2                     ! r2 = result[2] (Z component)
    mov.l r0, @r5                       ! output->X = result[0]
    mov.l r1, @(4, r5)                  ! output->Y = result[1]
    mov.l r2, @(8, r5)                  ! output->Z = result[2]
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)

/* mat_vec_notrans_b -- Matrix * vector WITHOUT translation (Stack B)
 * Address: 0x060272FC
 *
 * Same algorithm as mat_vec_transform_b but skips the translation
 * addition step. Computes: result = M * vec
 *
 * Encoded as raw .4byte because it shares pool labels with the
 * preceding function and BSR/BRA encoding must be preserved.
 *
 * Input:  r4 = pointer to input vec3
 *         r5 = pointer to output vec3
 * Output: *r5 = M * vec (rotation only, no translation)
 *
 * Instruction sequence (decoded):
 *   mov.l .L_pool_mat_b_stack_ptr, r0  ! r0 = &matrix_stack_b_ptr
 *   mov.l .L_pool_output_buf_b, r6     ! r6 = output buffer B2
 *   mov.l @r0, r2                      ! r2 = matrix base address
 *   mov #0x3, r3                       ! r3 = 3 (row counter)
 *   .L_notrans_row_loop:
 *     clrmac                           ! clear accumulator
 *     mac.l @r4+, @r2+                 ! acc += vec[j] * M[i][0]
 *     mac.l @r4+, @r2+                 ! acc += vec[j] * M[i][1]
 *     mac.l @r4+, @r2+                 ! acc += vec[j] * M[i][2]
 *     dt r3                            ! r3--
 *     add #-0xC, r4                    ! rewind input vec ptr
 *     sts mach, r0                     ! high 32 bits
 *     sts macl, r1                     ! low 32 bits
 *     xtrct r0, r1                     ! dot product >> 16
 *     mov.l r1, @r6                    ! store to output buffer
 *     bf/s .L_notrans_row_loop         ! loop if rows remain
 *     add #0x4, r6                     ! advance output ptr (delay slot)
 *   add #-0xC, r6                      ! rewind output ptr
 *   mov.l @r6+, r0                     ! result[0]
 *   mov.l @r6+, r1                     ! result[1]
 *   mov.l @r6+, r2                     ! result[2] (actually via mov.l @(8,r6))
 *   mov.l r0, @r5                      ! output->X
 *   mov.l r1, @(4, r5)                 ! output->Y
 *   rts                                ! return
 *   mov.l r2, @(8, r5)                 ! output->Z (delay slot)
 */
    .4byte  0xD00BD60F
    .4byte  0x6202E303
    .4byte  0x0028024F
    .4byte  0x024F024F
    .4byte  0x431074F4
    .4byte  0x000A011A
    .4byte  0x210D2612
    .4byte  0x8FF47604
    .4byte  0x76F46062
    .4byte  0x51615262
    .4byte  0x25021511
    .4byte  0x000B1522
.L_pool_mat_b_stack_ptr:
    .4byte  sym_0608A52C                ! matrix stack B pointer (current top)
    .4byte  sym_0608A530                ! matrix stack B alternate base
    .4byte  sym_0608A6B0                ! vector scratch buffer B0 (12 bytes)
    .4byte  sym_0608A6C0                ! vector scratch buffer B1 (12 bytes)
.L_pool_output_buf_b:
    .4byte  sym_0608A6F0                ! vector output buffer B2 (transform result)
    .4byte  0x00010000                  ! 1.0 in 16.16 fixed-point

/* cos_lookup -- Cosine via table lookup
 * Address: 0x06027344
 *
 * Input:  r4 = angle (16-bit, full circle = 0x10000)
 * Output: r0 = cos(angle) in 16.16 fixed-point
 *
 * Algorithm:
 *   r4 += 0x4000               (add 90 degrees to convert cos→sin)
 *   r4 >>= 2                   (reduce to table index)
 *   r4 += 2                    (skip 2-byte table header)
 *   r4 &= 0x3FFC              (wrap to 4096 entries * 4 bytes)
 *   r0 = table[r4]             (load from ROM at 0x002F2F20)
 */
    .global cos_lookup
cos_lookup:
    .byte   0x90, 0xDA    /* mov.w .L_wpool_cos_phase, r0 ! r0 = 0x4000 (90 deg phase) */
    add r0, r4                          ! r4 = angle + 0x4000 (shift cos to sin)

/* sin_lookup -- Sine via table lookup
 * Address: 0x06027348
 *
 * Input:  r4 = angle (16-bit, full circle = 0x10000)
 * Output: r0 = sin(angle) in 16.16 fixed-point
 *
 * Falls through from cos_lookup (which adds 0x4000 phase offset).
 * When called directly, no phase offset is added — pure sine.
 */
    .global sin_lookup
sin_lookup:
    .byte   0x90, 0xD9    /* mov.w .L_wpool_trig_mask, r0 ! r0 = 0x3FFC (table mask) */
    shlr2 r4                            ! r4 >>= 2 (convert angle to 4-byte table index)
    add #0x2, r4                        ! skip 2-byte table header
    and r0, r4                          ! r4 &= 0x3FFC (wrap to 4096 entries)
    .byte   0xD0, 0x66    /* mov.l .L_pool_sincos_table, r0 ! r0 = 0x002F2F20 (ROM table) */
    rts                                 ! return
    mov.l @(r0, r4), r0                 ! r0 = table[index] = sin/cos value (delay slot)
    .2byte  0x0009                      ! nop (alignment padding)

/* sincos_pair -- Look up both sin and cos for an angle
 * Address: 0x06027358
 *
 * Input:  r4 = angle
 *         r5 = pointer to store sin result
 *         r6 = pointer to store cos result
 * Output: *r5 = sin(angle), *r6 = cos(angle), both in 16.16 fixed-point
 *
 * Algorithm:
 *   r3 = 0x4000 (cos phase offset)
 *   r4 += 8     (rounding bias)
 *   r1 = 0x3FFC (table mask)
 *   r3 += r4    (cos angle = angle + 0x4000 + 8)
 *   load table base 0x002F2F20
 *   sin_idx = (r4 >> 2) & 0x3FFC
 *   cos_idx = (r3 >> 2) & 0x3FFC
 *   *r5 = table[sin_idx]
 *   *r6 = table[cos_idx]
 */
    .global sincos_pair
sincos_pair:
    .byte   0x93, 0xD0    /* mov.w .L_wpool_cos_phase, r3 ! r3 = 0x4000 (cos phase) */
    add #0x8, r4                        ! r4 = angle + 8 (rounding bias)
    .byte   0x91, 0xCF    /* mov.w .L_wpool_trig_mask, r1 ! r1 = 0x3FFC (table mask) */
    add r4, r3                          ! r3 = angle + 8 + 0x4000 (cos angle)
    .byte   0xD0, 0x62    /* mov.l .L_pool_sincos_table, r0 ! r0 = 0x002F2F20 (table base) */
    shlr2 r4                            ! r4 >>= 2 (sin table index)
    and r1, r4                          ! r4 &= 0x3FFC (wrap sin index)
    shlr2 r3                            ! r3 >>= 2 (cos table index)
    mov.l @(r0, r4), r2                 ! r2 = table[sin_idx] = sin(angle)
    and r1, r3                          ! r3 &= 0x3FFC (wrap cos index)
    mov.l r2, @r5                       ! *r5 = sin(angle)
    nop                                 ! pipeline stall (load-use hazard)
    mov.l @(r0, r3), r1                 ! r1 = table[cos_idx] = cos(angle)
    rts                                 ! return
    mov.l r1, @r6                       ! *r6 = cos(angle) (delay slot)
    .2byte  0x0009                      ! nop (alignment padding)

/* atan_piecewise -- Piecewise linear arctangent approximation
 * Address: 0x06027378
 *
 * Input:  r4 = value (signed fixed-point ratio)
 *         r6 = sign flag (set internally: 1=positive, 0=negative)
 * Output: r0 = atan(value) as angle (0x0000..0x4000 range)
 *
 * Algorithm:
 *   1. Take absolute value of r4, save sign in r6 via movt
 *   2. Add rounding bias (+0x80)
 *   3. If |value| < 0x100000 (small angle):
 *        Use direct ROM lookup table at 0x002F0000
 *   4. Else (large angle):
 *        Extract integer part (r4 >> 16)
 *        Binary search through 8 thresholds (1000, 500, 250, 150,
 *          100, 70, 50, 40, 30, 16) to find the matching segment
 *        For matching segment:
 *          r4 -= segment_base
 *          r0 = (r4 * slope) >> 16 + intercept
 *   5. If original sign was negative, negate result
 *
 * Piecewise segments approximate the atan curve with decreasing
 * slopes for larger input values (atan flattens toward pi/2).
 */
    .global atan_piecewise
atan_piecewise:
    cmp/pz r4                           ! test if r4 >= 0
    bt/s    .L_abs_done                 ! if positive, skip negation
    .word 0x0629 /* movt r6 -- r6 = T flag (1=was positive, 0=was negative) */
    neg r4, r4                          ! r4 = abs(r4)
.L_abs_done:
    mov #0x10, r0                       ! r0 = 0x10
    shll16 r0                           ! r0 = 0x100000 (upper bound for table lookup)
    add #0x40, r4                       ! r4 += 0x40 (first half of +0x80 rounding)
    add #0x40, r4                       ! r4 += 0x40 (second half, total +0x80 rounding)
    cmp/hi r4, r0                       ! is 0x100000 > r4? (i.e., r4 < 0x100000?)
    bf      .L_large_angle              ! if r4 >= 0x100000, use piecewise segments
    .byte   0xD0, 0x58    /* mov.l .L_pool_atan_table, r0 ! r0 = 0x002F0000 (atan ROM table) */
    shlr8 r4                            ! r4 >>= 8 (reduce to table index)
    shll r4                             ! r4 <<= 1 (word index: 2 bytes per entry)
    tst r6, r6                          ! check sign flag (r6 == 0 means was negative)
    mov.w @(r0, r4), r0                 ! r0 = atan_table[index] (16-bit lookup)
    bf      .L_apply_sign               ! if was positive (r6 != 0), skip to sign apply
    rts                                 ! return (was negative path)
    neg r0, r0                          ! negate result (delay slot)
.L_large_angle:
    .byte   0x90, 0xBB    /* mov.w .L_wpool_thresh_1000, r0 ! r0 = 0x03E8 (1000) */
    swap.w r4, r5                       ! r5 = r4 >> 16 (extract integer part)
    extu.w r5, r5                       ! zero-extend r5 to 32 bits
    cmp/hi r5, r0                       ! is 1000 > integer_part?
    bf      .L_over_1000                ! if integer_part >= 1000, return max angle
    .byte   0x90, 0xBB    /* mov.w .L_wpool_thresh_100, r0 ! r0 = 100 (0x0064) */
    cmp/hi r5, r0                       ! is 100 > integer_part?
    bt      .L_below_100                ! if integer_part < 100, check smaller thresholds
    .byte   0x90, 0xBA    /* mov.w .L_wpool_thresh_250, r0 ! r0 = 250 (0x00FA) */
    cmp/hi r5, r0                       ! is 250 > integer_part?
    bt      .L_range_100_250            ! if 100 <= integer_part < 250
    .byte   0x90, 0xB8    /* mov.w .L_wpool_thresh_500, r0 ! r0 = 500 (0x01F4) */
    cmp/hi r5, r0                       ! is 500 > integer_part?
    bt      .L_range_250_500            ! if 250 <= integer_part < 500
    .byte   0x93, 0xB5    /* mov.w .L_wpool_thresh_500, r3 ! r3 = 500 (segment base) */
    .byte   0xD1, 0x5B    /* mov.l .L_pool_slope_seg1, r1 ! r1 = slope for 500..1000 */
    .byte   0x92, 0xA2    /* mov.w .L_wpool_intercept_seg1, r2 ! r2 = intercept */
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 500 << 16 (segment base in fixed-point, delay slot)
.L_range_250_500:
    .byte   0x93, 0xAF    /* mov.w .L_wpool_thresh_250, r3 ! r3 = 250 (segment base) */
    .byte   0xD1, 0x59    /* mov.l .L_pool_slope_seg2, r1 ! r1 = slope for 250..500 */
    .byte   0x92, 0x9E    /* mov.w .L_wpool_intercept_seg2, r2 ! r2 = intercept */
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 250 << 16 (delay slot)
.L_range_100_250:
    .byte   0x90, 0xA9    /* mov.w .L_wpool_thresh_150, r0 ! r0 = 150 (0x0096) */
    cmp/hi r5, r0                       ! is 150 > integer_part?
    bt      .L_range_100_150            ! if 100 <= integer_part < 150
    .byte   0x93, 0xA6    /* mov.w .L_wpool_thresh_150, r3 ! r3 = 150 (segment base) */
    .byte   0xD1, 0x56    /* mov.l .L_pool_slope_seg3, r1 ! r1 = slope for 150..250 */
    .byte   0x92, 0x97    /* mov.w .L_wpool_intercept_seg3, r2 ! r2 = intercept */
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 150 << 16 (delay slot)
.L_range_100_150:
    .byte   0xD1, 0x55    /* mov.l .L_pool_slope_seg4, r1 ! r1 = slope for 100..150 */
    .byte   0x92, 0x94    /* mov.w .L_wpool_intercept_seg4, r2 ! r2 = intercept */
    mov #0x64, r3                       ! r3 = 100 (0x64, segment base)
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 100 << 16 (delay slot)
.L_below_100:
    .byte   0x90, 0x99    /* mov.w .L_wpool_thresh_50, r0 ! r0 = 50 (0x0032) */
    cmp/hi r5, r0                       ! is 50 > integer_part?
    bt      .L_below_50                 ! if integer_part < 50
    .byte   0x90, 0x97    /* mov.w .L_wpool_thresh_70, r0 ! r0 = 70 (0x0046) */
    cmp/hi r5, r0                       ! is 70 > integer_part?
    bt      .L_range_50_70              ! if 50 <= integer_part < 70
    .byte   0xD1, 0x51    /* mov.l .L_pool_slope_seg5, r1 ! r1 = slope for 70..100 */
    .byte   0x92, 0x8A    /* mov.w .L_wpool_intercept_seg5, r2 ! r2 = intercept */
    mov #0x46, r3                       ! r3 = 70 (0x46, segment base)
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 70 << 16 (delay slot)
.L_range_50_70:
    .byte   0xD1, 0x4F    /* mov.l .L_pool_slope_seg6, r1 ! r1 = slope for 50..70 */
    .byte   0x92, 0x86    /* mov.w .L_wpool_intercept_seg6, r2 ! r2 = intercept */
    mov #0x32, r3                       ! r3 = 50 (0x32, segment base)
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 50 << 16 (delay slot)
.L_below_50:
    .byte   0x90, 0x87    /* mov.w .L_wpool_thresh_30, r0 ! r0 = 30 (0x001E) */
    cmp/hi r5, r0                       ! is 30 > integer_part?
    bt      .L_range_16_30              ! if integer_part < 30 (base segment)
    .byte   0x90, 0x85    /* mov.w .L_wpool_thresh_40, r0 ! r0 = 40 (0x0028) */
    cmp/hi r5, r0                       ! is 40 > integer_part?
    bt      .L_range_30_40              ! if 30 <= integer_part < 40
    .byte   0xD1, 0x4B    /* mov.l .L_pool_slope_seg7, r1 ! r1 = slope for 40..50 */
    .byte   0x92, 0x7C    /* mov.w .L_wpool_intercept_seg7, r2 ! r2 = intercept */
    mov #0x28, r3                       ! r3 = 40 (0x28, segment base)
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 40 << 16 (delay slot)
.L_range_30_40:
    .byte   0xD1, 0x49    /* mov.l .L_pool_slope_seg8, r1 ! r1 = slope for 30..40 */
    .byte   0x92, 0x78    /* mov.w .L_wpool_intercept_seg8, r2 ! r2 = intercept */
    mov #0x1E, r3                       ! r3 = 30 (0x1E, segment base)
    bra     .L_interpolate              ! go to interpolation
    swap.w r3, r3                       ! r3 = 30 << 16 (delay slot)
.L_range_16_30:
    .byte   0xD1, 0x48    /* mov.l .L_pool_slope_seg9, r1 ! r1 = slope for 16..30 */
    .byte   0x92, 0x74    /* mov.w .L_wpool_intercept_seg9, r2 ! r2 = intercept */
    mov #0x10, r3                       ! r3 = 16 (0x10, segment base)
    swap.w r3, r3                       ! r3 = 16 << 16 (segment base in fixed-point)
.L_interpolate:
    sub r3, r4                          ! r4 = value - segment_base (offset within segment)
    dmuls.l r4, r1                      ! mach:macl = offset * slope (64-bit signed)
    sts mach, r0                        ! r0 = high 32 bits of (offset * slope)
    exts.w r0, r0                       ! sign-extend result to 32 bits
    tst r6, r6                          ! check original sign flag (0=was negative)
    bf/s    .L_apply_sign               ! if was positive, jump to sign handling
    add r2, r0                          ! r0 = slope_result + intercept (delay slot)
    neg r0, r0                          ! negate result (original input was negative)
.L_apply_sign:
    rts                                 ! return r0 = atan approximation
    nop                                 ! (delay slot)
.L_over_1000:
    .byte   0x90, 0x5B    /* mov.w .L_wpool_cos_phase, r0 ! r0 = 0x4000 (max atan = 90 deg) */
    tst r6, r6                          ! check sign flag
    bf      .L_apply_sign               ! if was positive, return +0x4000
    rts                                 ! return (was negative path)
    neg r0, r0                          ! r0 = -0x4000 (delay slot)

/* atan2 -- Full two-argument arctangent with quadrant handling
 * Address: 0x0602744C
 *
 * Input:  r4 = x, r5 = y
 * Output: r0 = atan2(y, x) as angle (0x0000..0xFFFF = 0..360 degrees)
 *
 * Special case: y == 0
 *   x >= 0: return 0x4000 (90 degrees)
 *   x < 0:  return -0x4000 (270 degrees)
 * General case: y != 0
 *   Branch to atan2_full (external, in next TU at 0x0602745C)
 */
    .global atan2
atan2:
    tst r5, r5                          ! test if y == 0
    .byte   0x8B, 0x05    /* bf 0x0602745C -- branch to atan2_full if y != 0 (external) */
    .byte   0x90, 0x54    /* mov.w .L_wpool_cos_phase, r0 ! r0 = 0x4000 (90 degrees) */
    cmp/pz r4                           ! test if x >= 0
    bt      .L_atan2_return             ! if x >= 0, return +0x4000
    neg r0, r0                          ! x < 0: r0 = -0x4000 (270 degrees)
.L_atan2_return:
    rts                                 ! return r0
    nop                                 ! (delay slot)
