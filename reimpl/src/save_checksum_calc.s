/* save_checksum_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B93C - 0x0603B9A4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Sets a status/error code in the notification sub-struct and optionally
 * dispatches a callback if one is registered.
 *
 * Args:
 *   r4 = status_code (0 = no-op, nonzero = store + optional callback)
 *
 * The notification sub-struct lives at game_state_base + 0xB8:
 *   [+0x00] = callback function pointer (NULL = none)
 *   [+0x04] = callback first argument
 *   [+0x08] = status code field (written unconditionally)
 *
 * If status_code != 0 and callback != NULL:
 *   calls callback(arg, status_code)
 *
 * Returns: original status_code in r0.
 *
 * Callers: cmd_status_check (-8 error), cmd_queue_process,
 *          menu_sound_trigger (-9 error), menu_ranking_display
 */

    .section .text.FUN_0603B93C


    .global save_checksum_calc
    .type save_checksum_calc, @function
save_checksum_calc:
    mov.l r14, @-r15                ! save r14 (callee-saved)
    mov.l r13, @-r15                ! save r13 (callee-saved)
    sts.l pr, @-r15                 ! save return address
    mov r4, r13                     ! r13 = status_code (preserve across call)
    mov.l   .L_pool_game_state_ptr, r14 ! r14 = &sym_060A4D14 (game state ptr-ptr)
    mov.w   .L_wpool_notify_struct_offset, r3   ! r3 = 0x00B8 (notification sub-struct offset)
    mov.l @r14, r14                 ! r14 = game_state_base (dereference ptr-ptr)
    add r3, r14                     ! r14 = &notify_struct (game_state_base + 0xB8)
    tst r13, r13                    ! test: status_code == 0?
    bt/s    .L_epilogue             ! if zero, skip callback â€” just return
    mov.l r4, @(8, r14)            ! notify_struct[+0x08] = status_code (always written)
    mov.l @r14, r0                  ! r0 = notify_struct[+0x00] (callback fn ptr)
    tst r0, r0                      ! test: callback == NULL?
    bt      .L_epilogue             ! if no callback registered, skip to return
    mov r13, r5                     ! r5 = status_code (second arg to callback)
    mov.l @r14, r3                  ! r3 = callback fn ptr (reload for jsr)
    jsr @r3                         ! call callback(arg, status_code)
    mov.l @(4, r14), r4            ! [delay] r4 = notify_struct[+0x04] (first arg)
.L_epilogue:
    mov r13, r0                     ! r0 = status_code (return value)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r13                ! restore r13
    rts                             ! return to caller
    mov.l @r15+, r14                ! [delay] restore r14
    .2byte  0xD607
    .4byte  0x66627634
    .4byte  0xA00DE500
    .4byte  0x62536363
    .4byte  0x4208323C
    .4byte  0x62223420
    .4byte  0x8B04A008
    .2byte  0x0009
.L_wpool_notify_struct_offset:
    .2byte  0x00B8                      /* [HIGH] notification sub-struct offset within game state */
.L_pool_game_state_ptr:
    .4byte  sym_060A4D14            ! global game state base pointer (ptr-ptr)
    .4byte  0x7501E060
    .4byte  0x026E3523
    .4byte  0x8BEEE060
    .4byte  0x026E3520
    .4byte  0x8B00E5FF
    .4byte  0x000B6053
