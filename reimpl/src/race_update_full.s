/* race_update_full -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600E47C - 0x0600E4F2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Replay/alternative per-car update — dispatched from mode dispatcher
 * (FUN_0600DF66) for modes 1 and 2. Runs a simplified physics and
 * rendering pipeline for one car during replay/demo sequences.
 *
 * Pipeline (10 stages, no player/AI branching):
 *   1. Publish car struct pointer
 *   2. Audio phase ticker (sym_0600A8BC)
 *   3. gas_force_apply → brake_force_apply
 *   4. Timer trigger (sym_06030A06) → timer decrement (sym_06030EE0)
 *   5. Demo physics pipeline (per_frame_race_update via BSR)
 *   6. Coordinate grid pack (sym_06006838) → store result
 *   7. Segment position tracking
 *   8. 3D scene processing (4 geometry channels)
 *   9. Finish proximity → collision detection
 *  10. Render finalize (sym_0603053C) → tail-call checkpoint_detect
 *
 * Unlike car_frame_update (mode 0/full), this path:
 *   - Does NOT branch on player vs AI
 *   - Does NOT do scripted movement / physics counter path
 *   - Uses per_frame_race_update (demo physics) instead of normal integration
 *
 * Arguments: none (car loaded from sym_0607E944 global)
 * Returns:   void (tail-calls checkpoint_detect)
 * Clobbers:  r0-r5, r14, pr
 *
 * Pool entries are in the adjacent car_frame_update TU's constant pool
 * (0x0600E524+), accessed via cross-TU .byte-encoded mov.l instructions.
 */

    .section .text.FUN_0600E47C


    .global race_update_full
    .type race_update_full, @function
/* race_update_full(void)
 *
 * Replay-mode per-car update. Runs simplified physics + rendering for
 * one car during demo/replay playback.
 */
race_update_full:
    mov.l r14, @-r15
    sts.l pr, @-r15
    .byte   0xDE, 0x28    /* mov.l .L_car_array_base, r14 — &sym_0607E944 */
    .byte   0xD3, 0x29    /* mov.l .L_car_struct_ptr, r3 — &sym_0607E940 */
    mov.l @r14, r14                      ! r14 = current car struct pointer
    mov.l r14, @r3                       ! publish car ptr to sym_0607E940
    .byte   0xD3, 0x28    /* mov.l .L_fn_audio_phase, r3 — sym_0600A8BC */
    jsr @r3                              ! audio phase ticker
    nop
    .byte   0xD3, 0x28    /* mov.l .L_fn_gas_force, r3 — gas_force_apply */
    jsr @r3                              ! gas_force_apply(car)
    nop
    .byte   0xD3, 0x27    /* mov.l .L_fn_brake_force, r3 — brake_force_apply */
    jsr @r3                              ! brake_force_apply(car)
    nop
    .byte   0xD3, 0x27    /* mov.l .L_fn_timer_trigger, r3 — sym_06030A06 */
    jsr @r3                              ! per-car countdown timer trigger
    nop
    .byte   0xD3, 0x26    /* mov.l .L_fn_timer_decrement, r3 — sym_06030EE0 */
    jsr @r3                              ! per-car timer decrement (6 insns)
    nop
    .byte   0xB1, 0x8F    /* bsr per_frame_race_update — demo physics pipeline */
    nop
    mov.l @(24, r14), r5                 ! r5 = car[+0x18] (Z position, arg2)
    .byte   0xD3, 0x24    /* mov.l .L_fn_grid_pack, r3 — sym_06006838 */
    jsr @r3                              ! r0 = grid_pack(X, Z)
    mov.l @(16, r14), r4                 ! r4 = car[+0x10] (X position, arg1)
    .byte   0xD3, 0x24    /* mov.l .L_grid_result_store, r3 — &sym_060786B8 */
    mov.l r0, @r3                        ! store grid pack result
    .byte   0xD3, 0x24    /* mov.l .L_fn_seg_track, r3 — segment_position_track */
    jsr @r3                              ! segment_position_track()
    nop
    .byte   0xDE, 0x23    /* mov.l .L_fn_scene_3d, r14 — scene_3d_processor */
    .byte   0xD4, 0x24    /* mov.l .L_geom_channel_0, r4 — &sym_06063EB0 */
    jsr @r14                             ! scene_3d_processor(channel_0, 0)
    mov #0x0, r5
    .byte   0xD4, 0x23    /* mov.l .L_geom_channel_1, r4 — &sym_06063E9C */
    jsr @r14                             ! scene_3d_processor(channel_1, 1)
    mov #0x1, r5
    .byte   0xD4, 0x23    /* mov.l .L_geom_channel_2, r4 — &sym_06063ED8 */
    jsr @r14                             ! scene_3d_processor(channel_2, 2)
    mov #0x2, r5
    .byte   0xD4, 0x22    /* mov.l .L_geom_channel_3, r4 — &sym_06063EC4 */
    jsr @r14                             ! scene_3d_processor(channel_3, 3)
    mov #0x3, r5
    .byte   0xD3, 0x22    /* mov.l .L_fn_finish_prox, r3 — finish_proximity */
    jsr @r3                              ! finish_proximity()
    nop
    .byte   0xD3, 0x21    /* mov.l .L_fn_collision, r3 — collision_detect_main */
    jsr @r3                              ! collision_detect_main()
    nop
    .byte   0xD3, 0x21    /* mov.l .L_fn_render_finalize, r3 — sym_0603053C */
    jsr @r3                              ! render finalize (mode=0)
    mov #0x0, r4                         ! r4 = 0 (render mode parameter)
    mov #0x0, r4                         ! r4 = 0 (tail-call arg for checkpoint_detect)
    lds.l @r15+, pr                      ! restore return address (for tail call)
    .byte   0xD3, 0x1F    /* mov.l .L_fn_checkpoint, r3 — checkpoint_detect */
    jmp @r3                              ! tail-call checkpoint_detect(0)
    mov.l @r15+, r14
