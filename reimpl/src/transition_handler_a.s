/* transition_handler_a -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600F794 - 0x0600F822
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Game state transition handler (variant A).
 *
 * Orchestrates a UI transition step during game state changes:
 *   1. Animate the UI transition overlay (anim_ui_transition, index 0).
 *   2. Render the course HUD (hud_course_render).
 *   3. Based on input state word at +6 in the input struct:
 *      - If == 0x10: call input state inverter (FUN_06010238).
 *      - Otherwise:  call 3-state counter (FUN_060102A8) with button flags.
 *   4. Call countdown timer display (FUN_060102EA) with button flags.
 *   5. If 2-player mode is active (sym_06085FF4 != 0), read the input
 *      button word, test bit 0x0800, and store the result (0 or 1) into
 *      the camera direction flip flag (sym_06078663).
 *
 * Inputs:
 *   (none -- reads global state)
 *
 * Globals:
 *   sym_06063D98 = input/button state struct (+2 = button flags word,
 *                  +6 = input mode/type word)
 *   sym_06085FF4 = 2-player mode flag (byte; 0 = 1P, nonzero = 2P)
 *   sym_06063750 = display config table (used by embedded data block)
 *   sym_0607EADC = transition/animation frame counter (dword)
 *   sym_0607EBCC = state countdown timer (dword)
 *   sym_0607887F = game state byte
 *   sym_06078663 = camera direction flip flag (byte; 0 = normal, 1 = flip)
 */

    .section .text.FUN_0600F794


    .global transition_handler_a
    .type transition_handler_a, @function
transition_handler_a:
    mov.l r14, @-r15            ! save r14
    sts.l pr, @-r15             ! save return address
    add #-0x4, r15              ! allocate 4 bytes on stack

    /* --- load input state struct pointer and read button flags --- */
    mov.l   .L_pool_input_state, r3 ! r3 = &input_state struct (sym_06063D98)
    mov.l r3, @r15              ! save input_state ptr on stack
    mov r3, r14                 ! r14 = &input_state
    add #0x2, r14               ! r14 = &input_state + 2 (button flags field)
    mov.l   .L_pool_anim_ui_fn, r3 ! r3 = &anim_ui_transition
    mov.w @r14, r14             ! r14 = button flags word (read before jsr)
    jsr @r3                     ! call anim_ui_transition(0)
    mov #0x0, r4                ! r4 = 0 (transition index, delay slot)

    /* --- render course HUD --- */
    mov.l   .L_pool_hud_course_fn, r3 ! r3 = &hud_course_render
    jsr @r3                     ! call hud_course_render()
    nop                         ! delay slot

    /* --- check input mode word at +6 in input struct --- */
    mov.l @r15, r0              ! r0 = input_state ptr (from stack)
    mov.w @(6, r0), r0          ! r0 = *(u16*)(input_state + 6) â€” input mode word
    extu.w r0, r0               ! zero-extend to 32 bits
    cmp/eq #0x10, r0            ! is input mode == 0x10?
    bf      .L_not_mode_10      ! if not, branch to 3-state counter path
    .byte   0xB5, 0x3D    /* bsr 0x06010238 (external) */  ! call input_state_inverter()
    nop                         ! delay slot (no arg needed)
    bra     .L_run_countdown    ! skip 3-state counter, go to countdown timer
    nop                         ! delay slot

    /* --- embedded data block (constant pool + config data) --- */
    .2byte  0x0B04
    .4byte  0x0B380170
    .4byte  0x0C2604B0
    .4byte  sym_06063750        /* display config table */
    .4byte  0x00009000
    .4byte  0x0000A000
    .4byte  sym_0607EADC        /* transition frame counter (dword) */
    .4byte  sym_0607EBCC        /* state countdown timer (dword) */
    .4byte  sym_0607887F        /* game state byte */
.L_pool_input_state:
    .4byte  sym_06063D98        /* &input/button state struct */
.L_pool_anim_ui_fn:
    .4byte  anim_ui_transition  /* UI transition animation function */
.L_pool_hud_course_fn:
    .4byte  hud_course_render   /* course HUD renderer function */

    /* --- 3-state counter path (input mode != 0x10) --- */
.L_not_mode_10:
    .byte   0xB5, 0x5A    /* bsr 0x060102A8 (external) */  ! call 3_state_counter(button_flags)
    mov r14, r4                 ! r4 = button flags (delay slot)

    /* --- countdown timer display (both paths converge here) --- */
.L_run_countdown:
    .byte   0xB5, 0x79    /* bsr 0x060102EA (external) */  ! call countdown_timer(button_flags)
    mov r14, r4                 ! r4 = button flags (delay slot)

    /* --- 2-player camera direction flip check --- */
    .byte   0xD0, 0x14    /* mov.l .L_pool_0600F84C, r0 */  ! r0 = &2p_mode_flag (sym_06085FF4)
    mov.b @r0, r0               ! r0 = 2p_mode_flag byte
    tst r0, r0                  ! is 2-player mode off?
    bt      .L_epilogue         ! if 1P mode, skip camera flip update
    .byte   0xD4, 0x13    /* mov.l .L_pool_0600F850, r4 */  ! r4 = &input_state (sym_06063D98)
    .byte   0x92, 0x21    /* mov.w .L_wpool_0600F848, r2 */  ! r2 = 0x0800 (button bit mask)
    mov.w @r4, r4               ! r4 = input button word
    extu.w r4, r4               ! zero-extend to 32 bits
    and r2, r4                  ! r4 = button_word & 0x0800
    tst r4, r4                  ! is the masked bit clear?
    bt      .L_set_flip_zero    ! if clear, set flip = 0
    bra     .L_store_flip       ! if set, set flip = 1
    mov #0x1, r3                ! r3 = 1 (delay slot)
.L_set_flip_zero:
    mov #0x0, r3                ! r3 = 0 (button bit was clear)
.L_store_flip:
    exts.b r3, r3               ! sign-extend r3 to 32 bits (0 or 1)
    .byte   0xD2, 0x0F    /* mov.l .L_pool_0600F854, r2 */  ! r2 = &camera_dir_flip (sym_06078663)
    mov.b r3, @r2               ! store camera direction flip flag

    /* --- epilogue --- */
.L_epilogue:
    add #0x4, r15               ! deallocate stack frame
    lds.l @r15+, pr             ! restore return address
    rts                         ! return
    mov.l @r15+, r14            ! restore r14 (delay slot)
