/* menu_option_adj -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B324 - 0x0603B392
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0603B324


/*
 * menu_option_adj â€” initiate an option adjustment transition
 *
 * Sets up a menu option adjustment on a menu descriptor.  Validates
 * the descriptor via save_data_validate, computes the maximum scroll
 * offset (total_items - visible_items), clamps the requested position
 * to that maximum, then configures the timer block and color transform
 * for the adjustment animation.
 *
 * If the descriptor's "busy" flag (byte at r0 offset) is already set,
 * returns early with error code -0x10 via save_checksum_calc.
 *
 * NOTE: Caller must have pushed r8 and r14 onto the stack before
 * calling this function.  The epilogue restores them on behalf of
 * the caller before tail-calling save_checksum_calc.
 *
 * Args:
 *   r14 = menu descriptor pointer (live from caller)
 *   r0  = offset to busy flag byte within descriptor (live on entry)
 *   r5  = requested adjustment position (clamped to max)
 *
 * Returns:
 *   r0  = 0 on success (via save_checksum_calc), -0x10 if busy
 *
 * Calls:
 *   save_checksum_calc     0x0603B93C  set status/error code and return
 *   save_data_validate     0x0603B9A4  validate/enqueue descriptor
 *   menu_element_dispatch  0x0603B058  dispatch element, returns visible count
 *   (unnamed)              0x0603BE7C  apply scroll offset to data block
 *   sym_0603F9DA           timer_block_init_fields    (pool 0x0603B3B0)
 *   sym_0603EF54           color_transform_set_params (pool 0x0603B3B4)
 *   race_timer_sync        timer_set_active_flag      (pool 0x0603B3B8)
 */
    .global menu_option_adj
    .type menu_option_adj, @function
menu_option_adj:
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l r5, @r15                      ! stack[0] = requested adjustment position
    mov.b @(r0, r14), r3                ! r3 = descriptor[r0] (busy flag byte)
    extu.b r3, r3                       ! zero-extend busy flag
    tst r3, r3                          ! busy flag == 0?
    bt      .L_not_busy                 ! if not busy, proceed with adjustment setup
    mov #-0x10, r4                      ! r4 = -0x10 (error: descriptor is busy)
    add #0x4, r15                       ! free stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8 (caller's frame)
    .byte   0xA2, 0xFF    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-0x10)
    mov.l @r15+, r14                    ! (delay) restore r14 (caller's frame)
.L_not_busy:
    .byte   0xB3, 0x31    /* bsr 0x0603B9A4 (external) */  ! call save_data_validate(r4=descriptor)
    mov r14, r4                         ! (delay) r4 = descriptor pointer
    mov #0x2, r2                        ! r2 = 2 (option adjust type)
    mov #0x11, r0                       ! r0 = 0x11 (scroll_type byte offset)
    mov #0x1, r3                        ! r3 = 1 (active flag value)
    mov.b r2, @(r0, r14)               ! descriptor[0x11] = 2 (mark as option adjust type)
    mov #0x12, r0                       ! r0 = 0x12 (active flag byte offset)
    mov.b r3, @(r0, r14)               ! descriptor[0x12] = 1 (mark as active)
    mov.l @r14, r3                      ! r3 = descriptor->field_0 (linked data block ptr)
    mov.l @(16, r3), r8                 ! r8 = data_block[16] (total item count)
    .byte   0xBE, 0x81    /* bsr 0x0603B058 (external) */  ! call menu_element_dispatch(r4=descriptor)
    mov r14, r4                         ! (delay) r4 = descriptor pointer
    mov r8, r4                          ! r4 = total_items
    mov.l @r15, r3                      ! r3 = requested adjustment position (from stack)
    sub r0, r4                          ! r4 = total_items - visible_count = max_position
    cmp/ge r4, r3                       ! requested_pos >= max_position?
    bt      .L_use_max_pos              ! if so, clamp to max
    bra     .L_pos_clamped              ! otherwise, use requested value
    mov.l @r15, r5                      ! (delay) r5 = requested adjustment position
.L_use_max_pos:
    mov r4, r5                          ! r5 = max_position (clamped)
.L_pos_clamped:
    .byte   0xB5, 0x89    /* bsr 0x0603BE7C (external) */  ! call apply_scroll_offset(r4=data_block, r5=clamped_pos)
    mov.l @r14, r4                      ! (delay) r4 = descriptor->field_0 (data block)
    mov #0x0, r5                        ! r5 = 0 (timer init value)
    .byte   0xD3, 0x10    /* mov.l .L_pool_0603B3B0, r3 */  ! r3 = &timer_block_init_fields
    jsr @r3                             ! call timer_block_init_fields(r4=timer_block, r5=0)
    mov.l @(8, r14), r4                 ! (delay) r4 = descriptor->field_8 (timer block)
    mov #0x1, r7                        ! r7 = 1 (mode flag)
    mov #0x0, r6                        ! r6 = 0 (color target G = 0)
    .byte   0xD3, 0x0F    /* mov.l .L_pool_0603B3B4, r3 */  ! r3 = &color_transform_set_params
    mov r6, r5                          ! r5 = 0 (color target R = 0)
    jsr @r3                             ! call color_transform_set_params(r4, r5=0, r6=0, r7=1)
    mov.l @(4, r14), r4                 ! (delay) r4 = descriptor->field_4 (color transform desc)
    mov #-0x1, r5                       ! r5 = -1 (infinite timeout)
    .byte   0xD3, 0x0D    /* mov.l .L_pool_0603B3B8, r3 */  ! r3 = &timer_set_active_flag
    jsr @r3                             ! call timer_set_active_flag(r4=timer_block, r5=-1)
    mov.l @(8, r14), r4                 ! (delay) r4 = descriptor->field_8 (timer block)
    mov #0x0, r4                        ! r4 = 0 (success code)
    add #0x4, r15                       ! free stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8 (caller's frame)
    .byte   0xA2, 0xD5    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=0)
    mov.l @r15+, r14                    ! (delay) restore r14 (caller's frame)
