/* perspective_proj_3d -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601476C - 0x06014868
 * Auto-generated by tools/generate_l3_tu.py
 *
 * NOTE: The name "perspective_proj_3d" is a historical misidentification from
 * the HUD annotation pass, which labeled this as "3D Perspective Projection"
 * based on its position in the file map. The actual algorithm is a disc/resource
 * file identifier search with chain-redirect capability.
 *
 * PURPOSE: Scan a list of 3-byte file identifiers (e.g., "SEX", "REX", "AM2")
 * for a match against the current search key. When a match is found:
 *   - If index >= 2: store the value from the lookup table into the countdown
 *     timer, set the result flag to 1, and stop.
 *   - If index < 2 (first two entries): replace the search key with a new key
 *     from the replacement table (using a pseudo-random offset) and continue
 *     searching. This implements a chain/redirect mechanism.
 *
 * INPUT:
 *   r4 = pointer to store the final file index count (output parameter)
 *
 * OUTPUT:
 *   r0 = loop status: 0 = terminated (match found at index>=2, or sentinel),
 *                      0xFF = key was replaced during search
 *   *r4 = final file index reached
 *   sym_06084FB8 (result_flag): set to 1 if match found at index >= 2
 *   sym_0607EBCC (countdown_timer): set to value_table[matched_index],
 *                                    or default 180 (0xB4) if no match
 *
 * DATA TABLES:
 *   sym_06084B14 = search key buffer (3 bytes: current file ID to find)
 *   sym_0605B3C4 = file ID list (array of 3-byte ASCII identifiers)
 *   sym_0605B164 = value lookup table (array of 32-bit values, indexed by file position)
 *   sym_06084FB8 = result flag (16-bit word: 0 = not found, 1 = found)
 *   sym_0607EBCC = countdown timer (32-bit long, in frames)
 *   sym_0607EBC8 = environment/random variable (lower 2 bits used as offset)
 *   sym_0605B4A8 = replacement key table (3-byte entries for chain redirect)
 */

    .section .text.FUN_0601476C


    .global perspective_proj_3d
    .type perspective_proj_3d, @function
perspective_proj_3d:

/* ======================================================================
 * Prologue: save callee-saved registers
 * ====================================================================== */
    mov.l r14, @-r15                    ! push r14 (match_count / key_write_ptr)
    mov.l r13, @-r15                    ! push r13 (loop_continue flag)
    mov.l r11, @-r15                    ! push r11 (sentinel value 0xFF)
    mov.l r10, @-r15                    ! push r10 (max_index = 43)
    mov.l r9, @-r15                     ! push r9 (search_key_ptr)
    mov.l r8, @-r15                     ! push r8 (continue constant = 1)

/* ======================================================================
 * Register initialization
 * r4 = output pointer (passed by caller, preserved across function)
 * r7 = zero constant (never modified)
 * r8 = 1 (continue flag constant)
 * r9 = &search_key (3-byte buffer at sym_06084B14)
 * r10 = 43 (max file index clamp)
 * r11 = 0xFF (sentinel byte marking end of file list)
 * r13 = loop_continue (1 = keep going, 0 or 0xFF = stop)
 * r5 = file_list read pointer (advances through 3-byte entries)
 * r6 = file_index (current position in file list)
 * ====================================================================== */
    mov #0x1, r8                        ! r8 = 1 (continue flag constant)
    mov.l   .L_pool_search_key_ptr, r9  ! r9 = &search_key (sym_06084B14)
    mov #0x2B, r10                      ! r10 = 43 (max file index)
    mov.w   DAT_06014818, r11           ! r11 = 0x00FF (sentinel value)
    mov #0x0, r7                        ! r7 = 0 (zero constant, never changes)
    extu.b r8, r13                      ! r13 = 1 (loop_continue = true)
    mov.l   .L_pool_file_id_list, r5    ! r5 = file_list ptr (sym_0605B3C4)
    mov r7, r6                          ! r6 = 0 (file_index = 0)
    extu.w r7, r3                       ! r3 = 0 (zero, 16-bit clean)
    mov.l   .L_pool_result_flag, r2     ! r2 = &result_flag (sym_06084FB8)
    mov.w r3, @r2                       ! *result_flag = 0 (clear: no match yet)
    mov r11, r1                         ! r1 = 0xFF
    add #-0x4B, r1                      ! r1 = 0xB4 = 180 (default timer: 3 sec at 60fps)
    mov.l   .L_pool_countdown_timer, r2 ! r2 = &countdown_timer (sym_0607EBCC)
    mov.l r1, @r2                       ! *countdown_timer = 180 (default)

/* ======================================================================
 * Main search loop: compare 3-byte search key against each file list entry
 * Each iteration: read 3 bytes from file_list, compare against search_key,
 * count matches in r14. If all 3 match (r14 == 3), handle the match.
 * ====================================================================== */
.L_search_loop:
    mov r9, r0                          ! r0 = search_key_ptr (reset for byte reads)

/* --- Byte 0 comparison --- */
    mov.b @r5+, r1                      ! r1 = file_list[i].byte0 (post-increment)
    mov.b @r0+, r2                      ! r2 = search_key.byte0 (post-increment)
    extu.b r1, r1                       ! zero-extend file list byte
    extu.b r2, r2                       ! zero-extend search key byte
    cmp/eq r1, r2                       ! byte0 match?
    bf/s    .L_compare_byte1            ! if no match: branch (delay slot still runs)
    mov r7, r14                         ! r14 = 0 (match_count = 0, always executes)
    add #0x1, r14                       ! match_count++ (only if byte0 matched)

/* --- Byte 1 comparison --- */
.L_compare_byte1:
    mov.b @r0+, r3                      ! r3 = search_key.byte1 (post-increment)
    mov.b @r5+, r1                      ! r1 = file_list[i].byte1 (post-increment)
    extu.b r3, r3                       ! zero-extend search key byte
    extu.b r1, r1                       ! zero-extend file list byte
    cmp/eq r1, r3                       ! byte1 match?
    bf      .L_compare_byte2            ! if no match: skip increment
    add #0x1, r14                       ! match_count++

/* --- Byte 2 comparison --- */
.L_compare_byte2:
    mov.b @r0, r2                       ! r2 = search_key.byte2 (NO post-increment)
    mov.b @r5+, r1                      ! r1 = file_list[i].byte2 (post-increment; r5 now at next entry)
    extu.b r2, r2                       ! zero-extend search key byte
    extu.b r1, r1                       ! zero-extend file list byte
    cmp/eq r1, r2                       ! byte2 match?
    bf      .L_check_full_match         ! if no match: skip increment
    add #0x1, r14                       ! match_count++

/* ======================================================================
 * Check if all 3 bytes matched (r14 == 3)
 * ====================================================================== */
.L_check_full_match:
    mov r14, r0                         ! r0 = match_count
    cmp/eq #0x3, r0                     ! all 3 bytes matched?
    bf      .L_check_sentinel           ! no full match: check for sentinel

/* ======================================================================
 * Full match found: store value from lookup table into countdown timer
 * ====================================================================== */
    mov r6, r3                          ! r3 = file_index
    mov.l   .L_pool_value_table, r2     ! r2 = &value_table (sym_0605B164)
    mov.l   .L_pool_countdown_timer, r0 ! r0 = &countdown_timer (sym_0607EBCC)
    shll2 r3                            ! r3 = file_index * 4 (sizeof(long))
    add r2, r3                          ! r3 = &value_table[file_index]
    mov.l @r3, r1                       ! r1 = value_table[file_index]
    mov #0x2, r3                        ! r3 = 2 (threshold for direct match)
    mov.l r1, @r0                       ! *countdown_timer = value_table[file_index]
    cmp/hs r3, r6                       ! file_index >= 2?
    bt      .L_match_found_final        ! yes: this is a definitive match, done

/* ======================================================================
 * Match at index 0 or 1: chain redirect
 * Replace the search key with a new key from the replacement table,
 * then continue searching. Uses bottom 2 bits of sym_0607EBC8 as a
 * pseudo-random offset to select from among multiple replacement options.
 * ====================================================================== */
    cmp/hs r10, r6                      ! file_index >= max_index (43)?
    bt/s    .L_clamp_index              ! yes: clamp to max (delay slot runs)
    mov r9, r14                         ! r14 = search_key_ptr (write target for replacement)
    bra     .L_compute_replacement      ! index ok, compute replacement key
    nop                                 ! delay slot (nop)
.L_clamp_index:
    mov r10, r6                         ! r6 = 43 (clamp file_index to max)

/* --- Compute replacement key address and copy 3 bytes --- */
.L_compute_replacement:
    mov r6, r5                          ! r5 = file_index (base for replacement calc)
    mov.l   .L_pool_env_variable, r0    ! r0 = &env_variable (sym_0607EBC8)
    shll2 r5                            ! r5 = file_index * 4
    mov.l @r0, r0                       ! r0 = *env_variable
    and #0x3, r0                        ! r0 = env_variable & 0x3 (random offset 0-3)
    add r0, r5                          ! r5 = file_index * 4 + random_offset
    exts.w r5, r5                       ! sign-extend to prevent overflow
    mov r5, r3                          ! r3 = adjusted_index
    shll r5                             ! r5 = adjusted_index * 2
    add r3, r5                          ! r5 = adjusted_index * 3 (3 bytes per entry)
    exts.w r5, r5                       ! sign-extend for address arithmetic
    mov.l   .L_pool_replace_key_table, r2 ! r2 = &replacement_table (sym_0605B4A8)
    add r2, r5                          ! r5 = &replacement_table[adjusted_index * 3]
    mov.b @r5+, r0                      ! r0 = replacement byte 0
    mov.b r0, @r14                      ! search_key[0] = replacement byte 0
    add #0x1, r14                       ! advance write pointer
    mov.b @r5+, r1                      ! r1 = replacement byte 1
    mov.b r1, @r14                      ! search_key[1] = replacement byte 1
    add #0x1, r14                       ! advance write pointer
    mov.b @r5+, r2                      ! r2 = replacement byte 2
    mov.b r2, @r14                      ! search_key[2] = replacement byte 2
    bra     .L_check_sentinel           ! continue to sentinel check (skip match_found_final)
    extu.b r11, r13                     ! r13 = 0xFF (flag: key was replaced; != 1 so loop exits)

/* ======================================================================
 * Constant pool and inline data
 * CRITICAL: Pool entry order must NOT change -- .byte-encoded mov.l/mov.w
 * instructions use hardcoded PC-relative displacements.
 * ====================================================================== */
    .global DAT_06014818
DAT_06014818:
    .2byte  0x00FF                      /* sentinel value (0xFF) loaded as mov.w */
    .2byte  0xFFFF                      /* padding / alignment */
.L_pool_search_key_ptr:
    .4byte  sym_06084B14                /* search key buffer (3 bytes) */
.L_pool_file_id_list:
    .4byte  sym_0605B3C4                /* file ID list (3-byte ASCII entries) */
.L_pool_result_flag:
    .4byte  sym_06084FB8                /* result flag (16-bit word) */
.L_pool_countdown_timer:
    .4byte  sym_0607EBCC                /* countdown timer (32-bit long, frames) */
.L_pool_value_table:
    .4byte  sym_0605B164                /* value lookup table (32-bit per entry) */
.L_pool_env_variable:
    .4byte  sym_0607EBC8                /* environment/random variable (bottom 2 bits) */
.L_pool_replace_key_table:
    .4byte  sym_0605B4A8                /* replacement key table (3-byte entries) */

/* ======================================================================
 * Match found at index >= 2: definitive result
 * Set loop_continue = 0 (stop), result_flag = 1 (match confirmed)
 * Falls through to sentinel check / loop exit
 * ====================================================================== */
.L_match_found_final:
    extu.b r7, r13                      ! r13 = 0 (loop_continue = stop; 0 != 1)
    extu.w r8, r2                       ! r2 = 1 (result: match found)
    mov.l   .L_pool_result_flag_2, r3   ! r3 = &result_flag (sym_06084FB8)
    mov.w r2, @r3                       ! *result_flag = 1 (match confirmed)

/* ======================================================================
 * Sentinel check: detect end-of-list marker (0xFF) in file list.
 * Also increments file_index unconditionally (delay slot).
 * If sentinel found, set loop_continue = 0 to exit.
 * ====================================================================== */
.L_check_sentinel:
    mov.b @r5, r2                       ! r2 = next file_list byte (peek, no advance)
    extu.b r2, r2                       ! zero-extend
    cmp/eq r11, r2                      ! is it the sentinel (0xFF)?
    bf/s    .L_loop_continue_check      ! not sentinel: branch to loop check (delay runs)
    add #0x1, r6                        ! file_index++ (always executes)
    extu.b r7, r13                      ! r13 = 0 (loop_continue = stop; sentinel found)

/* ======================================================================
 * Loop continuation: if loop_continue == 1, jump back to search_loop
 * ====================================================================== */
.L_loop_continue_check:
    extu.b r13, r0                      ! r0 = loop_continue flag
    cmp/eq #0x1, r0                     ! still 1? (keep searching?)
    bt      .L_search_loop              ! yes: loop back to compare next entry

/* ======================================================================
 * Epilogue: store file_index count to output, restore registers, return
 * Return value: r0 = r13 (0 = done, 0xFF = key replaced)
 * ====================================================================== */
    mov.l r6, @r4                       ! *output_ptr = file_index (entries scanned)
    mov r13, r0                         ! r0 = return value (loop termination reason)
    mov.l @r15+, r8                     ! pop r8
    mov.l @r15+, r9                     ! pop r9
    mov.l @r15+, r10                    ! pop r10
    mov.l @r15+, r11                    ! pop r11
    mov.l @r15+, r13                    ! pop r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! pop r14 (delay slot)

/* --- Second pool reference for result_flag (same symbol, different PC offset) --- */
.L_pool_result_flag_2:
    .4byte  sym_06084FB8                /* result flag (16-bit word) â€” duplicate pool entry */
