/* camera_track_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600AFB2 - 0x0600B1A0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Camera track setup — initializes camera transformation matrices for
 * track-viewing mode (attract/replay/pre-race). Very similar pipeline
 * to camera_car_transform but uses track-relative coordinates.
 *
 * Persistent registers:
 *   r11 = &camera_mode_idx (16-bit, indexes bank angle + LOD tables)
 *   r13 = mat_rot_xz_b function pointer (rotation transform)
 *   r14 = car/camera state struct (loaded indirectly)
 *
 * Transform pipeline:
 *   1. Store car state ptr to secondary location
 *   2. fn_camera_init(car[+16], car[+20], car[+24]) — set base XYZ position
 *   3. fn_camera_pos(car[+16], car[+20], car[+24]) — confirm position
 *   4. mat_rot_xy_b(car[+32] + 0.5) — yaw rotation (+ 180 degrees)
 *   5. mat_rot_yz_b(-car[+36]) — pitch rotation (negated)
 *   6. Bank angle: car[+28] negated, offset by table[camera_mode_idx]
 *      Two paths: special mode (flag 0x00800008) or normal
 *   7. mat_rot_xz_b() — apply accumulated rotation
 *   8. mat_rot_xy_b(car[+0x1D8] + car[+0x1CC]) — additional yaw offset
 *   9. If camera_follow_flag set:
 *      → vec_copy_a for rotation sources, vec_copy_b for scaled,
 *        fn_camera_pos, mat_rot_yz_b, mat_rot_xz_b
 *  10. Optional camera shake: BSR render_obj_absolute (external)
 *  11. LOD/distance: table lookup or default, then mat_rot_xz_b
 *  12. Cross-TU final transforms (2 dispatch calls: vec_matrix + scaled)
 *  13. Optional flag-based adjustment call
 *  14. Decrement camera counter by 0x30
 *
 * Car struct offsets:
 *   +16/+20/+24 = X/Y/Z position
 *   +28 = bank angle, +32 = yaw base, +36 = pitch
 *   +0x1B4 = camera roll, +0x1C8 = pitch B, +0x1D0 = pitch A, +0x1D8 = yaw
 */

    .section .text.FUN_0600AFB2


    .global camera_track_setup
    .type camera_track_setup, @function
camera_track_setup:
    mov.l r14, @-r15                  ! save r14
    mov.l r13, @-r15                  ! save r13
    mov.l r12, @-r15                  ! save r12
    mov.l r11, @-r15                  ! save r11
    sts.l pr, @-r15                   ! save return address
    .byte   0xDB, 0x1F    /* mov.l .L_camera_mode_idx, r11 — persistent: &camera_mode_idx */
    .byte   0xDD, 0x20    /* mov.l .L_fn_rot_xz, r13 — persistent: mat_rot_xz_b fn ptr */
    .byte   0xDE, 0x20    /* mov.l .L_car_array_base, r14 — &car_array_base (indirect) */
    .byte   0xD3, 0x21    /* mov.l .L_car_struct_ptr, r3 — &car_struct_ptr */
    mov.l @r14, r14                   ! r14 = *car_array_base (car state struct)
    mov.l r14, @r3                    ! car_struct_ptr = r14 (publish for other subsystems)
    .byte   0xD3, 0x20    /* mov.l .L_fn_camera_init, r3 — camera state init fn */
    jsr @r3                           ! fn_camera_init()
    nop
    mov.l @(24, r14), r6             ! r6 = car[+24] (Z position)
    mov.l @(20, r14), r5             ! r5 = car[+20] (Y position)
    .byte   0xD3, 0x1F    /* mov.l .L_fn_camera_pos, r3 — set camera position fn */
    jsr @r3                           ! fn_camera_pos(X, Y, Z)
    mov.l @(16, r14), r4             ! r4 = car[+16] (X position) [delay slot]
    mov.l @(32, r14), r4             ! r4 = car[+32] (yaw base)
    .byte   0xD2, 0x1E    /* mov.l .L_fp_half, r2 — 0x8000 = 0.5 / 180deg */
    .byte   0xD3, 0x1E    /* mov.l .L_fn_rot_xy, r3 — mat_rot_xy_b fn */
    jsr @r3                           ! mat_rot_xy_b(yaw + 180deg)
    add r2, r4                        ! r4 = yaw + 0x8000 [delay slot]
    mov.l @(36, r14), r4             ! r4 = car[+36] (pitch)
    .byte   0xD3, 0x1D    /* mov.l .L_fn_rot_yz, r3 — mat_rot_yz_b fn */
    jsr @r3                           ! mat_rot_yz_b(-pitch)
    neg r4, r4                        ! negate pitch [delay slot]
    .byte   0xD2, 0x10    /* mov.l .L_game_flags, r2 — game mode flags ptr */
    .byte   0xD3, 0x1C    /* mov.l .L_flag_mask_800008, r3 — special camera mask */
    mov.l @r2, r2                     ! r2 = *game_flags
    and r3, r2                        ! r2 &= 0x00800008
    tst r2, r2                        ! special camera mode active?
    bt      .L_normal_bank            ! no → normal bank angle path
    mov.l @(28, r14), r4             ! --- special bank path ---
    neg r4, r4                        ! r4 = -bank_angle
    mov.w @r11, r3                   ! r3 = camera_mode_idx
    extu.w r3, r2                     ! zero-extend
    shll2 r2                          ! r2 = idx * 4
    .byte   0xD3, 0x18    /* mov.l .L_bank_angle_table, r3 — per-mode offset table */
    add r2, r3                        ! r3 = &table[idx]
    mov.l @r3, r2                     ! r2 = table[idx]
    bra     .L_apply_rotation         ! → apply rotation
    add r2, r4                        ! r4 = -bank + offset [delay slot]
    .2byte  0xFFFF                        /* alignment padding */
    .4byte  sym_06083258               /* (adjacent fn pool: camera LOD offset base) */
    .4byte  sym_060621D8               /* (adjacent fn pool: chain A source table) */
    .4byte  sym_0606212C               /* (adjacent fn pool: chain A parameter table) */
    .4byte  sym_06031D8C               /* (adjacent fn pool: vec_copy_a fn) */
    .4byte  sym_06062180               /* (adjacent fn pool: chain B source table) */
    .4byte  sym_06089E44               /* (adjacent fn pool: rotation scale factor) */
    .4byte  sym_060620D8               /* (adjacent fn pool: chain B parameter table) */
    .4byte  sym_06031A28               /* (adjacent fn pool: vec_copy_b fn) */
.L_game_flags:
    .4byte  sym_0607EBC4               /* game mode flags (32-bit) */
    .4byte  0x20020000                 /* (adjacent fn pool: cache-through const) */
    .4byte  replay_playback            /* (adjacent fn pool: replay playback fn) */
    .4byte  sym_06089EDC               /* (adjacent fn pool: frame counter) */
.L_camera_mode_idx:
    .4byte  sym_06063F46               /* camera mode index (16-bit) */
.L_fn_rot_xz:
    .4byte  mat_rot_xz_b              /* XZ rotation transform */
.L_car_array_base:
    .4byte  sym_0607E944               /* car array base pointer */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* current car struct pointer */
.L_fn_camera_init:
    .4byte  sym_06027080               /* camera state initialization */
.L_fn_camera_pos:
    .4byte  sym_060270F2               /* set camera base position */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) / 180 degrees */
.L_fn_rot_xy:
    .4byte  mat_rot_xy_b              /* XY rotation (yaw) */
.L_fn_rot_yz:
    .4byte  mat_rot_yz_b              /* YZ rotation (pitch) */
.L_flag_mask_800008:
    .4byte  0x00800008                 /* special camera mode flag mask */
.L_bank_angle_table:
    .4byte  sym_0605BDCC               /* per-mode bank angle offset table */
.L_normal_bank:                           /* --- normal bank angle path --- */
    mov.l @(28, r14), r4             ! r4 = car[+28] (bank angle)
    neg r4, r4                        ! negate bank
    .byte   0xD3, 0x26    /* mov.l .L_camera_height_offset, r3 — height offset ptr */
    mov.l @r3, r3                     ! r3 = *camera_height_offset
    add r3, r4                        ! r4 = -bank + height offset
    mov.w @r11, r2                   ! r2 = camera_mode_idx
    extu.w r2, r1                     ! zero-extend
    shll2 r1                          ! r1 = idx * 4
    .byte   0xD2, 0x24    /* mov.l .L_bank_angle_table_2, r2 — bank table (dup for reach) */
    add r1, r2                        ! r2 = &table[idx]
    mov.l @r2, r1                     ! r1 = table[idx]
    add r1, r4                        ! r4 = final bank angle
.L_apply_rotation:                        /* --- apply accumulated rotation --- */
    jsr @r13                           ! mat_rot_xz_b(bank_angle)
    nop
    mov.w   DAT_0600b100, r0         ! r0 = 0x01D8 (camera yaw offset)
    mov.l @(r0, r14), r4             ! r4 = car[+0x1D8] (camera yaw)
    add #-0xC, r0                     ! r0 = 0x01CC (yaw delta offset)
    mov.l @(r0, r14), r3             ! r3 = car[+0x1CC] (yaw delta)
    add r3, r4                        ! r4 = combined yaw
    .byte   0xD3, 0x20    /* mov.l .L_fn_rot_xy_2, r3 — mat_rot_xy_b (dup for reach) */
    jsr @r3                           ! mat_rot_xy_b(combined_yaw)
    nop
    .byte   0xD0, 0x1F    /* mov.l .L_camera_follow_flag, r0 — follow mode flag ptr */
    mov.l @r0, r0                     ! r0 = *camera_follow_flag
    tst r0, r0                        ! follow mode active?
    bt      .L_skip_follow            ! no → skip rotation copy
    .byte   0xD5, 0x1E    /* mov.l .L_rot_src_a, r5 — rotation source A (ptr) */
    .byte   0xD4, 0x1F    /* mov.l .L_rot_dst_a, r4 — rotation dest A (ptr) */
    .byte   0xD3, 0x1F    /* mov.l .L_fn_vec_copy_a, r3 — vector matrix transform fn */
    mov.l @r5, r5                     ! r5 = *rot_src_a (source vector)
    jsr @r3                           ! vec_copy_a(dst, src)
    mov.l @r4, r4                     ! r4 = *rot_dst_a (dest vector) [delay slot]
    .byte   0xD6, 0x1E    /* mov.l .L_rot_src_b, r6 — rotation source B (ptr) */
    .byte   0xD5, 0x1F    /* mov.l .L_rot_scale_b, r5 — rotation scale factor (16-bit) */
    .byte   0xD4, 0x1F    /* mov.l .L_rot_dst_b, r4 — rotation dest B (ptr) */
    .byte   0xD3, 0x20    /* mov.l .L_fn_vec_copy_b, r3 — scaled vector transform fn */
    mov.l @r6, r6                     ! r6 = *rot_src_b (source vector)
    mov.w @r5, r5                     ! r5 = scale factor (16-bit)
    extu.w r5, r5                     ! zero-extend scale
    jsr @r3                           ! vec_copy_b(dst, src, scale)
    mov.l @r4, r4                     ! r4 = *rot_dst_b [delay slot]
    mov #0x0, r6                      ! r6 = 0 (X position = 0)
    mov.w   DAT_0600b102, r0         ! r0 = 0x01B4 (camera roll offset)
    .byte   0xD3, 0x1D    /* mov.l .L_fn_camera_pos_2, r3 — camera position (dup for reach) */
    mov.l @(r0, r14), r5             ! r5 = car[+0x1B4] (camera roll)
    jsr @r3                           ! fn_camera_pos(0, roll, 0)
    mov r6, r4                        ! r4 = 0 [delay slot]
    mov.w   DAT_0600b104, r0         ! r0 = 0x01D0 (pitch A offset)
    .byte   0xD3, 0x1B    /* mov.l .L_fn_rot_yz_2, r3 — mat_rot_yz_b (dup for reach) */
    jsr @r3                           ! mat_rot_yz_b(pitch_A)
    mov.l @(r0, r14), r4             ! r4 = car[+0x1D0] (pitch A) [delay slot]
    mov.w   DAT_0600b106, r0         ! r0 = 0x01C8 (pitch B offset)
    jsr @r13                           ! mat_rot_xz_b(pitch_B)
    mov.l @(r0, r14), r4             ! r4 = car[+0x1C8] (pitch B) [delay slot]
    .byte   0xD0, 0x19    /* mov.l .L_camera_shake_flags, r0 — camera shake flags byte */
    mov.b @r0, r0                     ! r0 = *camera_shake_flags
    tst #0x2, r0                      ! bit 1 = camera shake active?
    bf      .L_after_shake            ! set → skip shake (already applied)
    mov #0x0, r5                      ! r5 = 0 (no shake offset)
    .byte   0xBD, 0xB1    /* bsr render_obj_absolute (external 0x0600AC44) — camera shake handler */
    mov r14, r4                       ! r4 = car struct [delay slot]
.L_after_shake:                           /* --- LOD / distance computation --- */
    mov r14, r0                       ! r0 = car struct base
    mov.b @(1, r0), r0               ! r0 = car[+1] (visibility flags)
    tst #0x1, r0                      ! bit 0 = visible?
    bt/s    .L_default_lod            ! not visible → use default LOD
    mov #0x0, r12                     ! r12 = 0 (default LOD index) [delay slot]
    mov #0xD, r12                     ! r12 = 0xD (active LOD table index)
    mov.w @r11, r4                   ! r4 = camera_mode_idx
    extu.w r4, r4                     ! zero-extend
    .byte   0xD3, 0x13    /* mov.l .L_camera_lod_lut, r3 — per-mode LOD lookup table */
    add r3, r4                        ! r4 = &lut[mode_idx]
    mov.b @r4, r4                     ! r4 = LOD level from table
    .byte   0xD2, 0x12    /* mov.l .L_camera_offset_base, r2 — camera LOD offset base ptr */
    mov.l @r2, r2                     ! r2 = *camera_offset_base
    bra     .L_apply_lod              ! → apply LOD
    add r2, r4                        ! r4 = LOD base + level [delay slot]

    .global DAT_0600b100
DAT_0600b100:
    .2byte  0x01D8                        /* car offset: camera yaw */

    .global DAT_0600b102
DAT_0600b102:
    .2byte  0x01B4                        /* car offset: camera roll */

    .global DAT_0600b104
DAT_0600b104:
    .2byte  0x01D0                        /* car offset: camera pitch A */

    .global DAT_0600b106
DAT_0600b106:
    .2byte  0x01C8                        /* car offset: camera pitch B */
.L_camera_height_offset:
    .4byte  sym_06078668               /* camera height offset value */
.L_bank_angle_table_2:
    .4byte  sym_0605BDCC               /* bank angle table (dup for reach) */
.L_fn_rot_xy_2:
    .4byte  mat_rot_xy_b              /* XY rotation (dup for reach) */
.L_camera_follow_flag:
    .4byte  sym_06059F30               /* camera follow mode flag */
.L_rot_src_a:
    .4byte  sym_060621E8               /* rotation source vector A (ptr) */
.L_rot_dst_a:
    .4byte  sym_0606213C               /* rotation dest vector A (ptr) */
.L_fn_vec_copy_a:
    .4byte  sym_06032158               /* vector matrix transform */
.L_rot_src_b:
    .4byte  sym_06062190               /* rotation source vector B (ptr) */
.L_rot_scale_b:
    .4byte  sym_06089E44               /* rotation scale factor B (16-bit) */
.L_rot_dst_b:
    .4byte  sym_060620E8               /* rotation dest vector B (ptr) */
.L_fn_vec_copy_b:
    .4byte  sym_06031DF4               /* scaled vector transform */
.L_fn_camera_pos_2:
    .4byte  sym_060270F2               /* camera position (dup for reach) */
.L_fn_rot_yz_2:
    .4byte  mat_rot_yz_b              /* YZ rotation (dup for reach) */
.L_camera_shake_flags:
    .4byte  sym_06082A25               /* camera shake flags byte */
.L_camera_lod_lut:
    .4byte  sym_06044740               /* per-mode LOD lookup table */
.L_camera_offset_base:
    .4byte  sym_06083258               /* camera LOD offset base (ptr) */
.L_default_lod:                           /* --- default LOD path --- */
    .byte   0xD4, 0x23    /* mov.l .L_default_lod_base, r4 — cross-TU: default LOD base */
    mov.l @r4, r4                     ! r4 = *default_lod_base
.L_apply_lod:                             /* --- apply LOD transform --- */
    jsr @r13                           ! mat_rot_xz_b(LOD_param)
    nop
    extu.w r12, r14                   ! r14 = LOD table index (0 or 0xD)
    .byte   0xD5, 0x22    /* mov.l .L_chain_src_a, r5 — cross-TU: chain source A table */
    .byte   0xD4, 0x22    /* mov.l .L_chain_dst_a, r4 — cross-TU: chain dest A table */
    .byte   0xD3, 0x23    /* mov.l .L_fn_chain_a, r3 — cross-TU: chain transform A fn */
    shll2 r14                         ! r14 = index * 4
    add r14, r5                       ! r5 = &src_table[idx]
    add r14, r4                       ! r4 = &dst_table[idx]
    mov.l @r5, r5                     ! r5 = src_table[idx]
    jsr @r3                           ! chain_transform_a(dst, src)
    mov.l @r4, r4                     ! r4 = dst_table[idx] [delay slot]
    .byte   0xD6, 0x20    /* mov.l .L_chain_src_b, r6 — cross-TU: chain source B table */
    .byte   0xD5, 0x21    /* mov.l .L_chain_scale_b, r5 — cross-TU: chain scale factor B */
    .byte   0xD4, 0x21    /* mov.l .L_chain_dst_b, r4 — cross-TU: chain dest B table */
    .byte   0xD3, 0x22    /* mov.l .L_fn_chain_b, r3 — cross-TU: chain transform B fn */
    add r14, r6                       ! r6 = &src_b_table[idx]
    mov.w @r5, r5                     ! r5 = scale factor (16-bit)
    add r14, r4                       ! r4 = &dst_b_table[idx]
    mov.l @r6, r6                     ! r6 = src_b_table[idx]
    extu.w r5, r5                     ! zero-extend scale
    jsr @r3                           ! chain_transform_b(dst, src, scale)
    mov.l @r4, r4                     ! r4 = dst_b_table[idx] [delay slot]
.L_skip_follow:                           /* --- flag-based adjustment check --- */
    .byte   0xD2, 0x1F    /* mov.l .L_game_flags_2, r2 — cross-TU: game flags ptr */
    .byte   0xD3, 0x1F    /* mov.l .L_flag_mask_2, r3 — cross-TU: flag mask */
    mov.l @r2, r2                     ! r2 = *game_flags
    and r3, r2                        ! r2 &= flag_mask
    tst r2, r2                        ! adjustment needed?
    bt      .L_skip_adjust            ! no → skip
    .byte   0xD3, 0x1E    /* mov.l .L_fn_adjust, r3 — cross-TU: adjustment fn */
    jsr @r3                           ! fn_adjust()
    nop
.L_skip_adjust:                           /* --- decrement camera counter + return --- */
    .byte   0xD4, 0x1D    /* mov.l .L_camera_counter, r4 — cross-TU: camera counter ptr */
    mov.l @r4, r2                     ! r2 = *camera_counter
    add #-0x30, r2                    ! r2 -= 0x30 (decrement per frame)
    mov.l r2, @r4                     ! write back
    lds.l @r15+, pr                   ! restore return address
    mov.l @r15+, r11                  ! restore r11
    mov.l @r15+, r12                  ! restore r12
    mov.l @r15+, r13                  ! restore r13
    rts                                ! return
    mov.l @r15+, r14                  ! restore r14 [delay slot]
