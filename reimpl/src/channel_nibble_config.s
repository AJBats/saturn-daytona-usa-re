/* channel_nibble_config -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06038BD4 - 0x06038E54
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Channel Config Nibble-Pack Setter (632 bytes)
 *
 * Part of the Scene Data Channel System. Writes display channel
 * configuration as packed nibbles into config words. Each call sets
 * a 4-bit value into one or more fields selected by a bitmask.
 *
 * Function:
 *   channel_nibble_config(r4=bitmask, r5=nibble_value)
 *
 * Args:
 *   r4 = bitmask selecting which 4-bit fields to write
 *   r5 = nibble value to pack into selected fields (low byte used)
 *
 * Each bit in r4 selects a 4-bit field in one of three config word arrays:
 *
 *   Array A at sym_060A4D28 (4 words at offsets 0/2/4/6):
 *     Bit 0x0100: word[0] low nibble   = r5
 *     Bit 0x0200: word[0] high nibble  = r5 << 8
 *     Bit 0x0400: word[2] low nibble   = r5
 *     Bit 0x0800: word[2] high nibble  = r5 << 8
 *     Bit 0x1000: word[4] low nibble   = r5
 *     Bit 0x2000: word[4] high nibble  = r5 << 8
 *     Bit 0x4000: word[6] low nibble   = r5
 *     Bit 0x8000: word[6] high nibble  = r5 << 8
 *
 *   Array B at sym_060A4D30 (2 words at offsets 0/2):
 *     Bit 0x0004: word[0] low byte     = r5        (mask 0xFF00)
 *     Bit 0x0002: word[0] low byte     = r5        (mask 0xFF00, alternate)
 *     Bit 0x0008: word[0] high byte    = r5 << 8   (mask 0x00FF)
 *     Bit 0x0080: word[0] high byte    = r5 << 8   (mask 0x00FF, alternate)
 *     Bit 0x0010: word[2] low byte     = r5        (mask 0xFF00)
 *     Bit 0x0020: word[2] high byte    = r5 << 8   (mask 0x00FF)
 *
 *   Final field at sym_060A4D58 offset 4:
 *     Bit 0x0001: word[4] = r5 directly
 *
 * Each field update first calls sym_06034F78 (bitfield read-modify-write
 * utility) with r0=1, r1=field_descriptor, r2=&target_struct. Then the
 * config word is read, masked to clear the target nibble/byte, OR'd with
 * the new value, and written back.
 *
 * Masks:
 *   0xFFF0 = clear low nibble (for low nibble writes to array A)
 *   0xF0FF = clear high nibble of low byte (for high nibble writes to array A)
 *   0xFF00 = clear low byte (for low byte writes to array B)
 *   0x00FF = clear high byte (for high byte writes to array B)
 *
 * Called from: channel_config_a (0x0601492C), channel_config_b (0x06014994),
 *   and similar HUD display channel setup functions in hud_ui.s.
 */

    .section .text.FUN_06038BD4


    .global channel_nibble_config
    .type channel_nibble_config, @function
channel_nibble_config:
    mov.l r14, @-r15                    ! save r14 (will hold &cfg_final = sym_060A4D58)
    mov #0x1, r7                        ! r7 = 1 (constant: bitfield commit value / bit 0 mask)
    mov.l r13, @-r15                    ! save r13 (will hold &cfg_array_b = sym_060A4D30)
    mov.l r12, @-r15                    ! save r12 (will hold mask 0xFFF0 = clear low nibble)
    mov.l r11, @-r15                    ! save r11 (will hold mask 0xF0FF = clear high nibble)
    mov.l r10, @-r15                    ! save r10 (will hold mask 0x00FF = clear high byte)
    mov.l r9, @-r15                     ! save r9 (will hold mask 0xFF00 = clear low byte)
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_mask_byte1, r9           ! r9 = 0x0000FF00 (mask: keep high byte, clear low byte)
    mov.w   DAT_06038cc8, r10           ! r10 = 0x00FF (mask: keep low byte, clear high byte)
    mov.l   _pool_mask_hi_nib_clear, r11 ! r11 = 0x0000F0FF (mask: clear bits 11:8 = high nibble)
    mov.l   _pool_mask_lo_nib_clear, r12 ! r12 = 0x0000FFF0 (mask: clear bits 3:0 = low nibble)
    mov.l   _pool_cfg_array_b, r13      ! r13 = &sym_060A4D30 (config word array B, 2 words)
    mov.l   _pool_cfg_final, r14        ! r14 = &sym_060A4D58 (final config area)
    mov.l   _pool_cfg_array_a, r6       ! r6 = &sym_060A4D28 (config word array A, 4 words)
    ! --- Bit 0x0100: array_a word[0] low nibble ---
    mov.w   _wpool_bit_a0_lo, r3        ! r3 = 0x0100 (bitmask for array_a[0] low nibble)
    and r4, r3                          ! r3 = bitmask & 0x0100
    tst r3, r3                          ! test if bit 0x0100 is set
    bt/s    .L_check_a0_hi_nib          ! skip if bit not set
    extu.b r5, r5                       ! (delay) r5 = zero-extend nibble value to byte
    mov r7, r0                          ! r0 = 1 (commit value for bitfield RMW)
    mov.w   _wpool_param_0x101, r1      ! r1 = 0x0101 (field descriptor for array A RMW)
    mov.l   _pool_bitfield_rmw, r3      ! r3 = &sym_06034F78 (bitfield RMW utility)
    jsr @r3                             ! call bitfield_rmw(r0=1, r1=0x0101, r2=&cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final (target struct)
    mov.w @r6, r2                       ! r2 = array_a[0] (16-bit config word)
    extu.w r2, r2                       ! zero-extend to 32 bits
    and r12, r2                         ! r2 &= 0xFFF0 (clear low nibble)
    extu.w r5, r3                       ! r3 = nibble value zero-extended
    or r3, r2                           ! r2 |= nibble (pack into low nibble)
    extu.w r2, r2                       ! clean to 16 bits
    mov.w r2, @r6                       ! array_a[0] = updated word
    ! --- Bit 0x0200: array_a word[0] high nibble ---
.L_check_a0_hi_nib:
    mov.w   _wpool_bit_a0_hi, r2        ! r2 = 0x0200 (bitmask for array_a[0] high nibble)
    and r4, r2                          ! r2 = bitmask & 0x0200
    tst r2, r2                          ! test if bit 0x0200 is set
    bt      .L_check_a2_lo_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101, r1      ! r1 = 0x0101 (field descriptor)
    mov.l   _pool_bitfield_rmw, r3      ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @r6, r2                       ! r2 = array_a[0]
    extu.w r2, r2                       ! zero-extend
    and r11, r2                         ! r2 &= 0xF0FF (clear high nibble of low byte)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift nibble to high nibble position)
    or r3, r2                           ! r2 |= shifted nibble
    extu.w r2, r2                       ! clean to 16 bits
    mov.w r2, @r6                       ! array_a[0] = updated word
    ! --- Bit 0x0400: array_a word[2] low nibble ---
.L_check_a2_lo_nib:
    mov.w   _wpool_bit_a2_lo, r2        ! r2 = 0x0400 (bitmask for array_a[2] low nibble)
    and r4, r2                          ! r2 = bitmask & 0x0400
    tst r2, r2                          ! test if bit 0x0400 is set
    bt      .L_check_a2_hi_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101, r1      ! r1 = 0x0101 (field descriptor)
    mov.l   _pool_bitfield_rmw, r3      ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(2, r6), r0                  ! r0 = array_a[2] (word at offset 2)
    mov r0, r2                          ! r2 = array_a[2]
    extu.w r2, r2                       ! zero-extend
    and r12, r2                         ! r2 &= 0xFFF0 (clear low nibble)
    extu.w r5, r3                       ! r3 = nibble value
    or r3, r2                           ! r2 |= nibble
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result (for indexed store)
    mov.w r0, @(2, r6)                  ! array_a[2] = updated word
    ! --- Bit 0x0800: array_a word[2] high nibble ---
.L_check_a2_hi_nib:
    mov.w   _wpool_bit_a2_hi, r3        ! r3 = 0x0800 (bitmask for array_a[2] high nibble)
    and r4, r3                          ! r3 = bitmask & 0x0800
    tst r3, r3                          ! test if bit 0x0800 is set
    bt      .L_check_a4_lo_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101, r1      ! r1 = 0x0101 (field descriptor)
    mov.l   _pool_bitfield_rmw, r3      ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(2, r6), r0                  ! r0 = array_a[2]
    mov r0, r2                          ! r2 = array_a[2]
    extu.w r2, r2                       ! zero-extend
    and r11, r2                         ! r2 &= 0xF0FF (clear high nibble)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift to high nibble)
    or r3, r2                           ! r2 |= shifted nibble
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result
    mov.w r0, @(2, r6)                  ! array_a[2] = updated word
    ! --- Bit 0x1000: array_a word[4] low nibble ---
.L_check_a4_lo_nib:
    mov.w   DAT_06038cd4, r3            ! r3 = 0x1000 (bitmask for array_a[4] low nibble)
    and r4, r3                          ! r3 = bitmask & 0x1000
    tst r3, r3                          ! test if bit 0x1000 is set
    bt      .L_check_a4_hi_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101, r1      ! r1 = 0x0101 (field descriptor)
    mov.l   _pool_bitfield_rmw, r3      ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(4, r6), r0                  ! r0 = array_a[4] (word at offset 4)
    mov r0, r2                          ! r2 = array_a[4]
    extu.w r2, r2                       ! zero-extend
    and r12, r2                         ! r2 &= 0xFFF0 (clear low nibble)
    extu.w r5, r3                       ! r3 = nibble value
    or r3, r2                           ! r2 |= nibble
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result
    mov.w r0, @(4, r6)                  ! array_a[4] = updated word
    ! --- Bit 0x2000: array_a word[4] high nibble ---
.L_check_a4_hi_nib:
    mov.w   DAT_06038cd6, r3            ! r3 = 0x2000 (bitmask for array_a[4] high nibble)
    and r4, r3                          ! r3 = bitmask & 0x2000
    tst r3, r3                          ! test if bit 0x2000 is set
    bt      .L_check_a6_lo_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101, r1      ! r1 = 0x0101 (field descriptor)
    mov.l   _pool_bitfield_rmw, r3      ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(4, r6), r0                  ! r0 = array_a[4]
    mov r0, r2                          ! r2 = array_a[4]
    extu.w r2, r2                       ! zero-extend
    and r11, r2                         ! r2 &= 0xF0FF (clear high nibble)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift to high nibble)
    or r3, r2                           ! r2 |= shifted nibble
    bra     .L_store_a4_hi_result       ! jump past pool to store result
    nop                                 ! (delay) padding

    .global DAT_06038cc8
DAT_06038cc8:
    .2byte  0x00FF                      ! mask: low byte (used as r10 = keep low byte)
_wpool_bit_a0_lo:
    .2byte  0x0100                      ! bitmask: bit 8 = array_a[0] low nibble
_wpool_param_0x101:
    .2byte  0x0101                      ! bitfield RMW param: field descriptor for array A
_wpool_bit_a0_hi:
    .2byte  0x0200                      ! bitmask: bit 9 = array_a[0] high nibble
_wpool_bit_a2_lo:
    .2byte  0x0400                      ! bitmask: bit 10 = array_a[2] low nibble
_wpool_bit_a2_hi:
    .2byte  0x0800                      ! bitmask: bit 11 = array_a[2] high nibble

    .global DAT_06038cd4
DAT_06038cd4:
    .2byte  0x1000                      ! bitmask: bit 12 = array_a[4] low nibble

    .global DAT_06038cd6
DAT_06038cd6:
    .2byte  0x2000                      ! bitmask: bit 13 = array_a[4] high nibble
.L_mask_byte1:
    .4byte  0x0000FF00                  /* byte 1 mask: keep high byte, clear low byte */
_pool_mask_hi_nib_clear:
    .4byte  0x0000F0FF                  /* mask: clear bits 11:8 (high nibble of low byte) */
_pool_mask_lo_nib_clear:
    .4byte  0x0000FFF0                  /* mask: clear bits 3:0 (low nibble) */
_pool_cfg_array_b:
    .4byte  sym_060A4D30                /* config word array B (2 words at offsets 0/2) */
_pool_cfg_final:
    .4byte  sym_060A4D58                /* final config area (word at offset 4) */
_pool_cfg_array_a:
    .4byte  sym_060A4D28                /* config word array A (4 words at offsets 0/2/4/6) */
_pool_bitfield_rmw:
    .4byte  sym_06034F78                /* bitfield read-modify-write utility */
    ! --- (continued from bit 0x2000 handler above) ---
.L_store_a4_hi_result:
    extu.w r2, r2                       ! clean result to 16 bits
    mov r2, r0                          ! r0 = result
    mov.w r0, @(4, r6)                  ! array_a[4] = updated word with high nibble set
    ! --- Bit 0x4000: array_a word[6] low nibble ---
.L_check_a6_lo_nib:
    mov.w   DAT_06038e1a, r3            ! r3 = 0x4000 (bitmask for array_a[6] low nibble)
    and r4, r3                          ! r3 = bitmask & 0x4000
    tst r3, r3                          ! test if bit 0x4000 is set
    bt      .L_check_a6_hi_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101_b, r1    ! r1 = 0x0101 (field descriptor, second pool)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw (second pool)
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(6, r6), r0                  ! r0 = array_a[6] (word at offset 6)
    mov r0, r2                          ! r2 = array_a[6]
    extu.w r2, r2                       ! zero-extend
    and r12, r2                         ! r2 &= 0xFFF0 (clear low nibble)
    extu.w r5, r3                       ! r3 = nibble value
    or r3, r2                           ! r2 |= nibble
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result
    mov.w r0, @(6, r6)                  ! array_a[6] = updated word
    ! --- Bit 0x8000: array_a word[6] high nibble ---
.L_check_a6_hi_nib:
    mov.l   .L_bit_a6_hi, r3            ! r3 = 0x8000 (bitmask for array_a[6] high nibble)
    and r4, r3                          ! r3 = bitmask & 0x8000
    tst r3, r3                          ! test if bit 0x8000 is set
    bt      .L_check_b0_lo_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x101_b, r1    ! r1 = 0x0101 (field descriptor)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0101, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(6, r6), r0                  ! r0 = array_a[6]
    mov r0, r2                          ! r2 = array_a[6]
    extu.w r2, r2                       ! zero-extend
    and r11, r2                         ! r2 &= 0xF0FF (clear high nibble)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift to high nibble)
    or r3, r2                           ! r2 |= shifted nibble
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result
    mov.w r0, @(6, r6)                  ! array_a[6] = updated word
    ! === Array B (sym_060A4D30) field writes ===
    ! --- Bit 0x0004: array_b word[0] low byte ---
.L_check_b0_lo_nib:
    mov #0x4, r3                        ! r3 = 0x04 (bitmask for array_b[0] low byte)
    and r4, r3                          ! r3 = bitmask & 0x04
    tst r3, r3                          ! test if bit 0x04 is set
    bt      .L_check_b0_lo_alt          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201, r1      ! r1 = 0x0201 (field descriptor for array B RMW)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @r13, r2                      ! r2 = array_b[0] (word at base of sym_060A4D30)
    extu.w r2, r2                       ! zero-extend
    and r9, r2                          ! r2 &= 0xFF00 (clear low byte)
    extu.w r5, r3                       ! r3 = nibble value
    or r3, r2                           ! r2 |= value into low byte
    extu.w r2, r2                       ! clean to 16 bits
    mov.w r2, @r13                      ! array_b[0] = updated word
    ! --- Bit 0x0002: array_b word[0] low byte (alternate selector) ---
.L_check_b0_lo_alt:
    mov #0x2, r2                        ! r2 = 0x02 (alternate bitmask for array_b[0] low byte)
    and r4, r2                          ! r2 = bitmask & 0x02
    tst r2, r2                          ! test if bit 0x02 is set
    bt      .L_check_b0_hi_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201, r1      ! r1 = 0x0201 (field descriptor for array B)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @r13, r2                      ! r2 = array_b[0]
    extu.w r2, r2                       ! zero-extend
    and r9, r2                          ! r2 &= 0xFF00 (clear low byte)
    extu.w r5, r3                       ! r3 = nibble value
    or r3, r2                           ! r2 |= value into low byte
    extu.w r2, r2                       ! clean to 16 bits
    mov.w r2, @r13                      ! array_b[0] = updated word
    ! --- Bit 0x0008: array_b word[0] high byte ---
.L_check_b0_hi_nib:
    mov #0x8, r2                        ! r2 = 0x08 (bitmask for array_b[0] high byte)
    and r4, r2                          ! r2 = bitmask & 0x08
    tst r2, r2                          ! test if bit 0x08 is set
    bt      .L_check_b0_hi_alt          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201, r1      ! r1 = 0x0201 (field descriptor for array B)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @r13, r2                      ! r2 = array_b[0]
    extu.w r2, r2                       ! zero-extend
    and r10, r2                         ! r2 &= 0x00FF (clear high byte)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift to high byte)
    or r3, r2                           ! r2 |= shifted value
    extu.w r2, r2                       ! clean to 16 bits
    mov.w r2, @r13                      ! array_b[0] = updated word
    ! --- Bit 0x0080: array_b word[0] high byte (alternate selector) ---
.L_check_b0_hi_alt:
    mov.w   _wpool_bit_b0_hi_alt, r2    ! r2 = 0x0080 (alternate bitmask for array_b[0] high byte)
    and r4, r2                          ! r2 = bitmask & 0x0080
    tst r2, r2                          ! test if bit 0x0080 is set
    bt      .L_check_b2_lo_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201, r1      ! r1 = 0x0201 (field descriptor for array B)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @r13, r2                      ! r2 = array_b[0]
    extu.w r2, r2                       ! zero-extend
    and r10, r2                         ! r2 &= 0x00FF (clear high byte)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift to high byte)
    or r3, r2                           ! r2 |= shifted value
    extu.w r2, r2                       ! clean to 16 bits
    mov.w r2, @r13                      ! array_b[0] = updated word
    ! --- Bit 0x0010: array_b word[2] low byte ---
.L_check_b2_lo_nib:
    mov #0x10, r2                       ! r2 = 0x10 (bitmask for array_b[2] low byte)
    and r4, r2                          ! r2 = bitmask & 0x10
    tst r2, r2                          ! test if bit 0x10 is set
    bt      .L_check_b2_hi_nib          ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201, r1      ! r1 = 0x0201 (field descriptor for array B)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(2, r13), r0                 ! r0 = array_b[2] (word at offset 2)
    mov r0, r2                          ! r2 = array_b[2]
    extu.w r2, r2                       ! zero-extend
    and r9, r2                          ! r2 &= 0xFF00 (clear low byte)
    extu.w r5, r3                       ! r3 = nibble value
    or r3, r2                           ! r2 |= value into low byte
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result (for indexed store)
    mov.w r0, @(2, r13)                 ! array_b[2] = updated word
    ! --- Bit 0x0020: array_b word[2] high byte ---
.L_check_b2_hi_nib:
    mov #0x20, r3                       ! r3 = 0x20 (bitmask for array_b[2] high byte)
    and r4, r3                          ! r3 = bitmask & 0x20
    tst r3, r3                          ! test if bit 0x20 is set
    bt      .L_check_final_field        ! skip if not set
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201, r1      ! r1 = 0x0201 (field descriptor for array B)
    mov.l   _pool_bitfield_rmw_b, r3    ! r3 = &bitfield_rmw
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov.w @(2, r13), r0                 ! r0 = array_b[2]
    mov r0, r2                          ! r2 = array_b[2]
    extu.w r2, r2                       ! zero-extend
    and r10, r2                         ! r2 &= 0x00FF (clear high byte)
    extu.w r5, r3                       ! r3 = nibble value
    shll8 r3                            ! r3 <<= 8 (shift to high byte)
    or r3, r2                           ! r2 |= shifted value
    extu.w r2, r2                       ! clean to 16 bits
    mov r2, r0                          ! r0 = result
    mov.w r0, @(2, r13)                 ! array_b[2] = updated word
    ! === Final field (sym_060A4D58 offset 4) ===
    ! --- Bit 0x0001: cfg_final word[4] direct write ---
.L_check_final_field:
    and r7, r4                          ! r4 &= 1 (isolate bit 0)
    tst r4, r4                          ! test if bit 0x01 is set
    bra     .L_final_field              ! jump past pool to final field handler
    nop                                 ! (delay) padding

    .global DAT_06038e1a
DAT_06038e1a:
    .2byte  0x4000                      ! bitmask: bit 14 = array_a[6] low nibble
_wpool_param_0x101_b:
    .2byte  0x0101                      ! bitfield RMW param: field descriptor for array A (pool 2)
_wpool_param_0x201:
    .2byte  0x0201                      ! bitfield RMW param: field descriptor for array B
_wpool_bit_b0_hi_alt:
    .2byte  0x0080                      ! bitmask: bit 7 = array_b[0] high byte (alternate)
    .2byte  0xFFFF                      ! alignment padding
_pool_bitfield_rmw_b:
    .4byte  sym_06034F78                /* bitfield RMW utility (pool 2) */
.L_bit_a6_hi:
    .4byte  0x00008000                  /* bitmask: bit 15 = array_a word[6] high nibble */
    ! --- (continued: test result of bit 0x01 from .L_check_final_field) ---
.L_final_field:
    bt      .L_epilogue                 ! skip if bit 0x01 was not set (T from tst above)
    mov r7, r0                          ! r0 = 1 (commit value)
    mov.w   _wpool_param_0x201_b, r1    ! r1 = 0x0201 (field descriptor for final write)
    mov.l   _pool_bitfield_rmw_c, r3    ! r3 = &bitfield_rmw (pool 3)
    jsr @r3                             ! call bitfield_rmw(1, 0x0201, &cfg_final)
    mov r14, r2                         ! (delay) r2 = &cfg_final
    mov r5, r0                          ! r0 = nibble value (written directly, no mask)
    mov.w r0, @(4, r13)                 ! cfg_final[4] = nibble value (direct store)
.L_epilogue:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay) restore r14
_wpool_param_0x201_b:
    .2byte  0x0201                      ! bitfield RMW param: field descriptor for final write
    .2byte  0xFFFF                      ! alignment padding
_pool_bitfield_rmw_c:
    .4byte  sym_06034F78                /* bitfield RMW utility (pool 3) */
