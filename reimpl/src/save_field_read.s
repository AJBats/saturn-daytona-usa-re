/* save_field_read -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B9D6 - 0x0603BA2C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Removes a field entry from the save data array by index.
 * Looks up the field ID, decrements the count, and shifts
 * remaining entries down to compact the array.
 */

    .section .text.FUN_0603B9D6


    .global save_field_read
    .type save_field_read, @function
save_field_read:
    mov.l r14, @-r15            ! save r14
    sts.l pr, @-r15             ! save return address
    tst r4, r4                  ! test if field ID is zero
    bf      .L_field_found      ! branch if field ID != 0
    lds.l @r15+, pr             ! restore return address (early exit)
    rts                         ! return — null field ID
    mov.l @r15+, r14            ! (delay) restore r14
    .4byte  sym_060A4D14
.L_field_found:
    .byte   0xBF, 0xBF    /* bsr 0x0603B96A (external) */
    nop                         ! (delay) no-op
    cmp/eq #-0x1, r0            ! check if lookup returned -1 (not found)
    bt/s    .L_epilogue         ! branch if field not found
    mov r0, r4                  ! (delay) r4 = found index
    mov #0x60, r0               ! r0 = 0x60 — offset to entry count field
    mov r4, r6                  ! r6 = found index (source cursor)
    mov r4, r5                  ! r5 = found index (dest cursor)
    .byte   0xD7, 0x1B    /* mov.l .L_pool_0603BA68, r7 */
    add #0x1, r6                ! r6 = index + 1 (start copying from next entry)
    mov.l @r7, r7               ! r7 = dereference save data base pointer
    shll2 r6                    ! r6 = (index + 1) * 4 — source byte offset
    add #0x34, r7               ! r7 = base + 0x34 — fields array base
    mov.l @(r0, r7), r3         ! r3 = entry count at [fields_base + 0x60]
    add #-0x1, r3               ! decrement entry count
    mov r3, r14                 ! r14 = new count (loop limit)
    mov.l r3, @(r0, r7)         ! store decremented count back
    cmp/ge r14, r4              ! check if index >= new count (nothing to shift)
    bt/s    .L_epilogue         ! branch if no entries need shifting
    shll2 r5                    ! (delay) r5 = index * 4 — dest byte offset
.L_shift_loop:
    mov r7, r0                  ! r0 = fields array base (for indexed load)
    mov r7, r2                  ! r2 = fields array base (dest address)
    mov r6, r3                  ! r3 = source offset
    add #0x1, r4                ! advance loop counter
    add r5, r2                  ! r2 = fields_base + dest_offset
    add #0x4, r6                ! advance source offset to next entry
    mov.l @(r0, r3), r1         ! r1 = load entry from source position
    mov.l r1, @r2               ! store entry to dest position (shift down)
    cmp/ge r14, r4              ! check if loop counter >= new count
    bf/s    .L_shift_loop       ! loop if more entries to shift
    add #0x4, r5                ! (delay) advance dest offset to next entry
.L_epilogue:
    lds.l @r15+, pr             ! restore return address
    rts                         ! return
    mov.l @r15+, r14            ! (delay) restore r14
