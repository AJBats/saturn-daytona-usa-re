/* vblank_int_ext -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060410CA - 0x06041128
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track edge validation entry point — validates a car's position against
 * road edges and road width, then writes a checkpoint byte to the car
 * state struct on success.
 *
 * Flow:
 *   1. Call track_road_edge_b(r4, r6) — validate road edge
 *      If non-zero → return -10 (0xFFFFFFF6)
 *   2. Call track_road_width_stub(r4, r6) — validate road width
 *      If non-zero → return -10 (0xFFFFFFF6)
 *   3. Call ai_checkpoint_validate via cross-TU pool (sym_06035228 area)
 *      with stack buffer, write result byte to car_state[+0x40]
 *   4. Return 0
 *
 * Parameters:
 *   r4 = road position parameter
 *   r6 = road edge data parameter
 *
 * Returns:
 *   r0 = 0 on success, -10 on validation failure
 *
 * Stack frame (20 bytes):
 *   @(0, r15)  = saved r4 (road position param)
 *   @(4, r15)  = saved r6 (road edge data param)
 *   @(8, r15)  = checkpoint output buffer (written by cross-TU call)
 */

    .section .text.FUN_060410CA


    .global vblank_int_ext
    .type vblank_int_ext, @function
vblank_int_ext:
    sts.l pr, @-r15                          ! save return address to stack
    add #-0x14, r15                          ! allocate 20 bytes of stack space
    mov.l r4, @r15                           ! save r4 (road position param) to stack[0]
    mov.l r6, @(4, r15)                      ! save r6 (road edge data param) to stack[4]
    .byte   0xD3, 0x0B    /* mov.l .L_pool_fn_road_edge, r3 */
    jsr @r3                                  ! call track_road_edge_b(r4, r6_as_r5)
    mov.l @r15, r4                           ! r4 = restore road position param (delay slot)
    mov r0, r4                               ! r4 = edge check result
    tst r4, r4                               ! test if result == 0 (success)
    bt      .L_edge_ok                       ! result == 0 → edge check passed
    add #0x14, r15                           ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return to caller
    mov #-0xA, r0                            ! r0 = -10 (delay slot: edge failure code)
.L_edge_ok:
    mov.l @(4, r15), r5                      ! r5 = saved r6 (road edge data, passed as arg2)
    .byte   0xD3, 0x06    /* mov.l .L_pool_fn_road_width, r3 */
    jsr @r3                                  ! call track_road_width_stub(r4, r5)
    mov.l @r15, r4                           ! r4 = restore road position param (delay slot)
    mov r0, r4                               ! r4 = width check result
    tst r4, r4                               ! test if result == 0 (success)
    bt      .L_width_ok                      ! result == 0 → width check passed
    add #0x14, r15                           ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return to caller
    mov #-0xA, r0                            ! r0 = -10 (delay slot: width failure code)
    .4byte  sym_06035228                     /* pool: memcpy_byte function (cross-TU ref) */
.L_pool_fn_road_edge:
    .4byte  track_road_edge_b                /* pool: road edge detection function */
.L_pool_fn_road_width:
    .4byte  track_road_width_stub            /* pool: road width validation function */
.L_width_ok:
    mov r15, r4                              ! r4 = stack base (for checkpoint output buffer)
    .byte   0xD3, 0x1B    /* mov.l .L_pool_06041178, r3 */
    jsr @r3                                  ! call checkpoint validate fn (cross-TU pool)
    add #0x8, r4                             ! r4 = stack + 8 (delay slot: output buffer offset)
    .byte   0xD2, 0x1A    /* mov.l .L_pool_0604117C, r2 */
    mov.l @r2, r2                            ! r2 = car state base pointer (dereferenced)
    mov r15, r3                              ! r3 = stack base
    add #0x8, r3                             ! r3 = stack + 8 (checkpoint result location)
    mov.b @r3, r1                            ! r1 = checkpoint result byte from stack
    mov #0x40, r0                            ! r0 = 0x40 (checkpoint byte offset in car state)
    mov.b r1, @(r0, r2)                      ! car_state[+0x40] = checkpoint result byte
    mov #0x0, r0                             ! r0 = 0 (success return value)
    add #0x14, r15                           ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return to caller
    nop                                      ! delay slot (no-op)
