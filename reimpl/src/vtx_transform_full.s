/* vtx_transform_full -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602D934 - 0x0602DB0C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * vtx_transform_full:  Vertex position update — adjusts position based on
 *                      direction flag, applies fixed-point scale from scene
 *                      table, then rotates position delta via sin/cos lookup.
 * sym_0602D9F0:        Terrain collision check — validates car visibility,
 *                      lap count, Z-distance range, and vertex bounding box
 *                      before triggering race-complete flag.
 * sym_0602DB00:        Race abort prologue (register save only; body in
 *                      next TU).
 */

    .section .text.FUN_0602D934


    .global vtx_transform_full
    .type vtx_transform_full, @function
vtx_transform_full:
    sts.l pr, @-r15                 ! save return address
    jsr @r12                        ! call sub-function pointer (callback)
    nop
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r12                ! restore r12
    mov r14, r0                     ! r0 = car struct base
    mov.l @(0, r0), r10             ! r10 = car flags word
    mov.l   .L_dir_flag_mask, r11   ! r11 = 0x300 (direction bits)
    tst r10, r11                    ! test direction flags
    bt      .L_sub_direction        ! if clear → subtract path
    add r1, r5                      ! direction set: pos += offset
    bra     .L_store_position
    nop
    .2byte  0x024C                  ! (out-of-TU pool entry)
    .4byte  0x0000000F              ! (out-of-TU pool entry)
    .4byte  sym_0602ECCC            ! (out-of-TU pool: scene interp fn)
.L_dir_flag_mask:
    .4byte  0x00000300              ! direction flag mask
.L_sub_direction:
    sub r1, r5                      ! direction clear: pos -= offset
.L_store_position:
    mov.l r5, @(48, r0)            ! car[+0x30] = adjusted position
    mov.l r5, @(32, r0)            ! car[+0x20] = adjusted position (copy)
    mov.w   .L_off_angular_vel, r1  ! r1 = 0x248 (angular velocity offset)
    mov.l @(r0, r1), r4            ! r4 = car[+0x248] angular velocity
    mov.l r4, @(40, r0)            ! car[+0x28] = angular velocity backup
    neg r4, r4                      ! r4 = -angular_velocity (rotation angle)
    mov.w   .L_off_scene_idx, r1    ! r1 = 0x250 (scene table index offset)
    mov.w @(r0, r1), r2            ! r2 = car[+0x250] scene index (word)
    mov.l   .L_scene_scale_tbl, r3  ! r3 = scene scale table base
    shll2 r2                        ! r2 *= 4 (dword index)
    add r2, r3                      ! r3 = &scale_tbl[scene_idx]
    mov.l @r3, r5                   ! r5 = scale factor from table
    mov.l @(12, r0), r2            ! r2 = car[+0x0C] (current value)
    dmuls.l r2, r5                  ! MACL:MACH = r2 * scale
    mov.l @(8, r0), r7             ! r7 = car[+0x08] (frame counter)
    sts mach, r2                    ! r2 = high 32 bits of product
    sts macl, r5                    ! r5 = low 32 bits of product
    xtrct r2, r5                    ! r5 = middle 32 bits (16.16 result)
    mov.l r5, @(12, r0)            ! car[+0x0C] = scaled value
    mov #0x28, r2                   ! r2 = 0x28 (frame threshold)
    cmp/gt r2, r7                   ! if frame_counter > 0x28?
    bt      .L_scale_ready          ! yes → keep table scale
    mov.l   .L_default_scale, r5   ! no → use default scale 0x6AAA
.L_scale_ready:
    mov.l @(16, r0), r6            ! r6 = car[+0x10] X position
    mov.l @(24, r0), r7            ! r7 = car[+0x18] Z position
    mov.l r6, @(56, r0)            ! car[+0x38] = X position backup
    mov.l r7, @(60, r0)            ! car[+0x3C] = Z position backup
    mov r4, r9                      ! r9 = rotation angle (saved)
    mov r5, r1                      ! r1 = scale factor (arg for cos)
    mov.l   .L_fn_cos, r0          ! load cos_lookup address
    jsr @r0                         ! r0 = cos(angle) — r4=angle, r1=scale
    nop
    mov r0, r8                      ! r8 = cos result
    mov r9, r4                      ! r4 = rotation angle (restore for sin)
    mov.l   .L_fn_sin, r0          ! load sin_lookup address
    jsr @r0                         ! r0 = sin(angle)
    nop
    dmuls.l r0, r5                  ! MACL:MACH = sin * scale
    mov r14, r0                     ! r0 = car struct base
    mov.l   .L_off_rot_x_delta, r10 ! r10 = 0x18C (X rotation delta offset)
    sts mach, r11                   ! r11 = high product
    sts macl, r5                    ! r5 = low product
    xtrct r11, r5                   ! r5 = sin_delta (16.16)
    mov.l r5, @(r0, r10)           ! car[+0x18C] = X rotation delta
    add r5, r6                      ! r6 = X_pos + sin_delta
    mov.l r6, @(16, r0)            ! car[+0x10] = updated X position
    dmuls.l r8, r1                  ! MACL:MACH = cos * scale
    mov.l   .L_off_rot_z_delta, r10 ! r10 = 0x190 (Z rotation delta offset)
    sts mach, r8                    ! r8 = high product
    sts macl, r1                    ! r1 = low product
    xtrct r8, r1                    ! r1 = cos_delta (16.16)
    mov.l r1, @(r0, r10)           ! car[+0x190] = Z rotation delta
    add r1, r7                      ! r7 = Z_pos + cos_delta
    mov.l r7, @(24, r0)            ! car[+0x18] = updated Z position
    lds.l @r15+, pr                 ! restore return address
    rts                             ! return
    nop
.L_off_angular_vel:
    .2byte  0x0248                  /* car struct +0x248: angular velocity */
.L_off_scene_idx:
    .2byte  0x0250                  /* car struct +0x250: scene table index */
.L_scene_scale_tbl:
    .4byte  sym_0602E8B8            /* scene scale lookup table (main_scene_render) */
.L_default_scale:
    .4byte  0x00006AAA              /* default scale when frame_count <= 0x28 */
.L_fn_cos:
    .4byte  cos_lookup              /* cosine lookup function */
.L_fn_sin:
    .4byte  sin_lookup              /* sine lookup function */
.L_off_rot_x_delta:
    .4byte  0x0000018C              /* car struct +0x18C: X rotation delta */
.L_off_rot_z_delta:
    .4byte  0x00000190              /* car struct +0x190: Z rotation delta */
    .4byte  0x000B0009              /* (padding / out-of-TU data) */

    .global sym_0602D9F0
sym_0602D9F0:                           ! terrain collision check / race complete trigger
    mov.l   .L_car_array_ptr, r0   ! r0 = &car_array_ptr
    mov.l @r0, r0                  ! r0 = car array base
    mov.l   .L_max_lap_count, r3   ! r3 = &max_laps
    mov.l @r3, r3                  ! r3 = max_laps
    add #-0x1, r3                  ! r3 = max_laps - 1 (final lap index)
    mov.l   .L_off_lap_field, r4   ! r4 = 0x228 (lap count offset)
    mov.l @(r0, r4), r4            ! r4 = car[+0x228] current lap
    cmp/ge r3, r4                  ! if current_lap >= final_lap?
    bt      .L_exit_store_mode     ! yes → not eligible, exit
    mov.l   .L_race_end_state, r3  ! r3 = &race_end_state
    mov.l @r3, r3                  ! r3 = race_end_state value
    mov.l   .L_const_one, r4      ! r4 = 1
    cmp/eq r4, r3                  ! race_end_state == 1?
    bf      .L_check_terrain       ! no → skip Z position guard
    mov.l   .L_off_position_z, r1  ! r1 = 0x18 (Z position offset)
    mov.l @(r0, r1), r3            ! r3 = car[+0x18] Z position
    mov.l   .L_mask_byte3, r4     ! r4 = 0xFF000000
    cmp/ge r4, r3                  ! if Z >= 0xFF000000? (out of range)
    bt      .L_exit_store_mode     ! yes → exit
.L_check_terrain:                      ! --- terrain type validation ---
    mov.l   .L_off_terrain_type, r1 ! r1 = 0x1BC (terrain type offset)
    mov.l @(r0, r1), r1            ! r1 = car[+0x1BC] terrain type
    mov.l   .L_const_zero, r3     ! r3 = 0
    cmp/eq r3, r1                  ! terrain_type == 0? (on road)
    bf      .L_exit_store_mode     ! no → off-road, exit
    mov.w   .L_off_clip_flags_a, r1 ! r1 = 0x150 (clip flags A offset)
    mov.w @(r0, r1), r3            ! r3 = car[+0x150] clip flags A (word)
    mov.w   .L_off_clip_flags_b, r1 ! r1 = 0x250 (clip flags B offset)
    mov.w @(r0, r1), r4            ! r4 = car[+0x250] clip flags B (word)
    mov.w   .L_off_visibility, r1  ! r1 = 0xB8 (visibility flags offset)
    mov.l @(r0, r1), r5            ! r5 = car[+0xB8] visibility (dword)
    or r3, r4                      ! r4 = clip_a | clip_b
    or r4, r5                      ! r5 = clip_a | clip_b | visibility
    tst r5, r5                     ! all clip/visibility flags clear?
    bf      .L_exit_store_mode     ! no → car not fully visible, exit
    mov.w   .L_off_vtx_bounds, r1  ! r1 = 0x120 (vertex bounding box offset)
    add r0, r1                     ! r1 = &car[+0x120]
    mov.l @(0, r1), r2             ! r2 = bounds[0]
    mov.l @(4, r1), r3             ! r3 = bounds[1]
    mov.l @(8, r1), r4             ! r4 = bounds[2]
    mov.l @(12, r1), r5            ! r5 = bounds[3]
    mov.w   .L_bounds_mask, r6    ! r6 = 0x41 (required bits pattern)
    and r2, r3                     ! r3 = bounds[0] & bounds[1]
    and r4, r5                     ! r5 = bounds[2] & bounds[3]
    and r3, r5                     ! r5 = all four ANDed together
    cmp/eq r5, r6                  ! result == 0x41? (all verts in view)
    bf      .L_exit_store_mode     ! no → bounding box test failed, exit
    mov.l   .L_cur_car_ptr, r0    ! --- Z-distance range check ---
    mov.l @r0, r0                  ! r0 = current car struct
    mov.w   .L_off_track_section, r1 ! r1 = 0x25C (track section offset)
    mov.l @(r0, r1), r4            ! r4 = car[+0x25C] track section Z
    mov.l @(40, r0), r3            ! r3 = car[+0x28] current Z
    sub r4, r3                     ! r3 = Z_current - Z_section (signed delta)
    exts.w r3, r3                  ! sign-extend word to long
    mov.w   .L_z_half_range, r5   ! r5 = 0x3FFF (half-range bias)
    add r5, r3                     ! r3 = delta + 0x3FFF (bias to positive)
    mov.w   .L_z_dist_min, r5     ! r5 = 0x2800 (minimum distance)
    cmp/ge r3, r5                  ! if min >= biased_delta? (too close)
    bt      .L_exit_store_mode     ! yes → exit
    mov.w   .L_z_dist_max, r5     ! r5 = 0x47FF (maximum distance)
    cmp/ge r3, r5                  ! if max >= biased_delta? (in range)
    bf      .L_exit_store_mode     ! no (too far) → exit
    mov.l @(0, r0), r2             ! r2 = car flags word
    mov.l   .L_flag_bit3, r3     ! r3 = 0x8 (bit 3)
    tst r3, r2                     ! bit 3 clear?
    bf      .L_reject_store_neg    ! no → flag set, reject
    mov.l   .L_race_mode_byte, r1 ! r1 = &race_mode_byte
    mov.b @r1, r1                  ! r1 = race_mode_byte value
    tst r1, r1                     ! race_mode == 0?
    bf      .L_reject_store_neg    ! no → already active, reject
    mov.l @(0, r0), r2             ! --- all checks passed: trigger ---
    mov.l   .L_fp_two, r3        ! r3 = 0x20000 (bit 17 = 2.0 fp flag)
    or r3, r2                      ! set bit 17 in car flags
    mov.l r2, @(0, r0)            ! car[+0x00] = updated flags
    mov.l   .L_checkpoint_ctr, r1 ! r1 = &checkpoint_counter
    mov.w   .L_checkpoint_val, r2 ! r2 = 0x3C (60 frames)
    mov.l r2, @r1                  ! checkpoint_counter = 60
    mov.l   .L_race_complete_flag, r1 ! r1 = &race_complete_flag
    mov.w   .L_one, r2            ! r2 = 1
    mov.l r2, @r1                  ! race_complete_flag = 1
.L_exit_store_mode:                    ! --- normal exit: clear race mode ---
    mov.l   .L_race_mode_byte, r1 ! r1 = &race_mode_byte
    mov.l   .L_const_zero, r2    ! r2 = 0
    mov.b r2, @r1                  ! race_mode_byte = 0 (clear)
    rts                            ! return
    nop
.L_off_clip_flags_a:
    .2byte  0x0150                  /* car struct +0x150: clip flags A */
.L_off_clip_flags_b:
    .2byte  0x0250                  /* car struct +0x250: clip flags B */
.L_off_visibility:
    .2byte  0x00B8                  /* car struct +0xB8: visibility flags */
.L_off_vtx_bounds:
    .2byte  0x0120                  /* car struct +0x120: vertex bounding box */
.L_bounds_mask:
    .2byte  0x0041                  /* required AND result for all-in-view */
.L_off_track_section:
    .2byte  0x025C                  /* car struct +0x25C: track section Z */
.L_z_half_range:
    .2byte  0x3FFF                  /* bias to shift signed delta positive */
.L_z_dist_min:
    .2byte  0x2800                  /* minimum biased Z distance */
.L_z_dist_max:
    .2byte  0x47FF                  /* maximum biased Z distance */
.L_checkpoint_val:
    .2byte  0x003C                  /* 60 (checkpoint timer frames) */
.L_one:
    .2byte  0x0001                  /* 1 (race complete flag value) */
    .2byte  0x0000                  /* (alignment padding) */
.L_car_array_ptr:
    .4byte  sym_0607E944            /* car array base pointer */
.L_max_lap_count:
    .4byte  sym_06063F28            /* maximum lap count for current race */
.L_off_lap_field:
    .4byte  0x00000228              /* car struct +0x228: current lap */
.L_race_end_state:
    .4byte  sym_0607EAD8            /* race end state (0/1/2) */
.L_const_one:
    .4byte  0x00000001              /* constant 1 */
.L_off_position_z:
    .4byte  0x00000018              /* car struct +0x18: Z position */
.L_mask_byte3:
    .4byte  0xFF000000              /* upper byte mask (Z out-of-range guard) */
.L_off_terrain_type:
    .4byte  0x000001BC              /* car struct +0x1BC: terrain type */
.L_const_zero:
    .4byte  0x00000000              /* constant 0 */
.L_cur_car_ptr:
    .4byte  sym_0607E940            /* current car struct pointer */
.L_flag_bit3:
    .4byte  0x00000008              /* bit 3 flag mask */
.L_race_mode_byte:
    .4byte  sym_06083260            /* race mode byte */
.L_fp_two:
    .4byte  0x00020000              /* bit 17 flag (0x20000) */
.L_checkpoint_ctr:
    .4byte  sym_0607EAC8            /* checkpoint counter (32-bit) */
.L_race_complete_flag:
    .4byte  sym_0605A1C4            /* race complete flag (32-bit) */
.L_reject_store_neg:                   ! --- rejection exit: store 0xFF ---
    mov.l   .L_race_mode_byte_b, r1 ! r1 = &race_mode_byte
    mov.l   .L_const_neg1, r2     ! r2 = 0xFFFFFFFF (-1 → byte 0xFF)
    mov.b r2, @r1                  ! race_mode_byte = 0xFF (rejected)
    rts                            ! return
    nop
    .2byte  0x0000                  /* (alignment padding) */
.L_race_mode_byte_b:
    .4byte  sym_06083260            /* race mode byte (duplicate ref) */
.L_const_neg1:
    .4byte  0xFFFFFFFF              /* -1 (byte-stored as 0xFF) */

    .global sym_0602DB00
sym_0602DB00:                           ! race abort register save (prologue only)
    mov.l r8, @-r15                 ! push r8
    mov.l r9, @-r15                 ! push r9
    mov.l r10, @-r15                ! push r10
    mov.l r11, @-r15                ! push r11
    mov.l r12, @-r15                ! push r12
    mov.l r13, @-r15                ! push r13
