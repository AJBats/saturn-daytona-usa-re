/* vdp2_frame_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060171AC - 0x060172BC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Builds VDP1 display commands for VDP2 scroll layer overlays.
 *
 * Checks game state and scroll layer visibility flags to decide which
 * layers to emit. In time-attack mode (state 0x19), four extra scroll
 * layers are emitted first (offsets 0xA8, 0x90, 0x78, 0x60 from the
 * scroll data table base). Then four standard layers are always emitted
 * (offsets 0x48, 0x30, 0x18, 0x00).
 *
 * Each iteration calls the VDP1 command builder (sym_060280F8) with
 * r4 = source scroll data pointer, r5 = VDP1 command write pointer,
 * then advances the write pointer by 0x20 (32 bytes per command) and
 * increments the command counter.
 *
 * Pool references:
 *   sym_06085490 = scroll data table base (24-byte entries per layer)
 *   sym_060280F8 = VDP1 command builder (r4=src, r5=dst)
 *   sym_0605A008 = VDP1 command counter (incremented per command emitted)
 *   sym_060785FC = VDP1 command write pointer (current dest address)
 *   sym_0605AD10 = game state dispatch value (current game mode)
 *   sym_06084FC8 = slot data array (byte flags at [0],[1] = layer visibility)
 *
 * Note: .word 0x0029/0x0129 are MOVT R0/R1 instructions (store T bit).
 * The L3 generator didn't decode these -- they capture boolean comparison
 * results used to build a combined visibility mask.
 */

    .section .text.FUN_060171AC


    .global vdp2_frame_update
    .type vdp2_frame_update, @function
vdp2_frame_update:
    mov.l r14, @-r15                    ! save r14 (VDP1 write ptr address)
    mov.l r13, @-r15                    ! save r13 (cmd counter address)
    mov.l r12, @-r15                    ! save r12 (VDP1 cmd builder fn)
    mov.l r11, @-r15                    ! save r11 (scroll data table base)
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_pool_scroll_data_base, r11 ! r11 = scroll data table base (sym_06085490)
    mov.l   .L_pool_vdp1_cmd_builder, r12 ! r12 = VDP1 command builder function
    mov.l   .L_pool_cmd_counter, r13    ! r13 = &cmd_counter (sym_0605A008)
    mov.l   .L_pool_write_ptr, r14      ! r14 = &VDP1 write pointer (sym_060785FC)
    mov.l   .L_pool_game_state, r4      ! r4 = &game_state (sym_0605AD10)
    mov.l @r4, r0                       ! r0 = current game state
    cmp/eq #0x15, r0                    ! is game state == 0x15 (normal race)?
    .word 0x0129 /* MOVT R1 */          ! r1 = T (1 if normal race)
    cmp/eq #0x19, r0                    ! is game state == 0x19 (time attack)?
    .word 0x0029 /* MOVT R0 */          ! r0 = T (1 if time attack)
    or r1, r0                           ! r0 = (normal_race || time_attack)
    tst r0, r0                          ! test combined flag
    bt      .L_epilogue                 ! if neither race mode -> skip all, return
    mov.l   .L_pool_slot_flags, r5      ! r5 = &slot_flags (sym_06084FC8)
    mov.b @r5, r3                       ! r3 = slot_flags[0] (layer 0 visibility)
    extu.b r3, r3                       ! zero-extend to 32 bits
    tst r3, r3                          ! is layer 0 visible?
    .word 0x0029 /* MOVT R0 */          ! r0 = T (1 if layer 0 is zero/hidden)
    xor #0x1, r0                        ! r0 = !hidden = visible flag for layer 0
    mov #0x1, r3                        ! r3 = 1 (offset to slot_flags[1])
    add r5, r3                          ! r3 = &slot_flags[1]
    mov.b @r3, r3                       ! r3 = slot_flags[1] (layer 1 visibility)
    extu.b r3, r3                       ! zero-extend to 32 bits
    tst r3, r3                          ! is layer 1 visible?
    .word 0x0129 /* MOVT R1 */          ! r1 = T (1 if layer 1 is zero/hidden)
    and r1, r0                          ! r0 = (layer0_visible AND layer1_hidden)
    tst r0, r0                          ! both layers need to be in right state?
    bt      .L_epilogue                 ! if condition not met -> skip, return
    mov.l @r4, r0                       ! r0 = current game state (re-read)
    cmp/eq #0x19, r0                    ! is game state == 0x19 (time attack)?
    bf      .L_standard_layers          ! if not time attack -> skip extra layers
    ! -- Time-attack extra layers (4 commands at offsets 0xA8, 0x90, 0x78, 0x60) --
    mov.l @r14, r5                      ! r5 = VDP1 write pointer (dest cmd)
    mov.w   DAT_0601729e, r4            ! r4 = 0x00A8 (offset for layer 6)
    jsr @r12                            ! call VDP1 cmd builder
    add r11, r4                         ! r4 = scroll_data_base + 0xA8 (delay slot)
    mov.l @r13, r2                      ! r2 = cmd_counter
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes (1 VDP1 command)
    mov.l r3, @r14                      ! store updated write pointer
    mov r3, r5                          ! r5 = next dest cmd slot
    mov.w   .L_wpool_scroll_layer5_offset, r4       ! r4 = 0x0090 (offset for layer 5)
    jsr @r12                            ! call VDP1 cmd builder
    add r11, r4                         ! r4 = scroll_data_base + 0x90 (delay slot)
    mov r11, r4                         ! r4 = scroll_data_base (will add offset below)
    mov.l @r13, r2                      ! r2 = cmd_counter
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov r3, r5                          ! r5 = next dest cmd slot
    mov.l r3, @r14                      ! store updated write pointer
    jsr @r12                            ! call VDP1 cmd builder
    add #0x78, r4                       ! r4 = scroll_data_base + 0x78 (delay slot, layer 4)
    mov r11, r4                         ! r4 = scroll_data_base (will add offset below)
    mov.l @r13, r2                      ! r2 = cmd_counter
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov r3, r5                          ! r5 = next dest cmd slot
    mov.l r3, @r14                      ! store updated write pointer
    jsr @r12                            ! call VDP1 cmd builder
    add #0x60, r4                       ! r4 = scroll_data_base + 0x60 (delay slot, layer 3)
    mov.l @r13, r2                      ! r2 = cmd_counter
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov.l r3, @r14                      ! store updated write pointer
.L_standard_layers:
    ! -- Standard layers (4 commands at offsets 0x48, 0x30, 0x18, 0x00) --
    mov.l @r14, r5                      ! r5 = VDP1 write pointer (dest cmd)
    mov r11, r4                         ! r4 = scroll_data_base
    jsr @r12                            ! call VDP1 cmd builder
    add #0x48, r4                       ! r4 = scroll_data_base + 0x48 (delay slot, layer 2)
    mov.l @r13, r2                      ! r2 = cmd_counter
    mov r11, r4                         ! r4 = scroll_data_base (will add offset below)
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov.l r3, @r14                      ! store updated write pointer
    mov r3, r5                          ! r5 = next dest cmd slot
    jsr @r12                            ! call VDP1 cmd builder
    add #0x30, r4                       ! r4 = scroll_data_base + 0x30 (delay slot, layer 1)
    mov.l @r13, r2                      ! r2 = cmd_counter
    mov r11, r4                         ! r4 = scroll_data_base (will add offset below)
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov.l r3, @r14                      ! store updated write pointer
    mov r3, r5                          ! r5 = next dest cmd slot
    jsr @r12                            ! call VDP1 cmd builder
    add #0x18, r4                       ! r4 = scroll_data_base + 0x18 (delay slot, layer 0.5)
    mov.l @r13, r2                      ! r2 = cmd_counter
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov r3, r5                          ! r5 = next dest cmd slot
    mov.l r3, @r14                      ! store updated write pointer
    jsr @r12                            ! call VDP1 cmd builder
    mov r11, r4                         ! r4 = scroll_data_base + 0x00 (delay slot, layer 0)
    mov.l @r13, r2                      ! r2 = cmd_counter
    add #0x1, r2                        ! cmd_counter++
    mov.l r2, @r13                      ! store updated counter
    mov.l @r14, r3                      ! r3 = current write pointer
    add #0x20, r3                       ! advance by 32 bytes
    mov.l r3, @r14                      ! store updated write pointer
.L_epilogue:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)

    .global DAT_0601729e
DAT_0601729e:
    .2byte  0x00A8                      ! offset 0xA8 into scroll data table (layer 6)
.L_wpool_scroll_layer5_offset:
    .2byte  0x0090                      /* [HIGH] offset 0x90 into scroll data table (layer 5) */
    .2byte  0xFFFF                      ! padding
.L_pool_scroll_data_base:
    .4byte  sym_06085490                ! scroll data table base (per-layer entries)
.L_pool_vdp1_cmd_builder:
    .4byte  sym_060280F8                ! VDP1 command builder function
.L_pool_cmd_counter:
    .4byte  sym_0605A008                ! VDP1 command counter (32-bit)
.L_pool_write_ptr:
    .4byte  sym_060785FC                ! VDP1 command write pointer (current dest)
.L_pool_game_state:
    .4byte  sym_0605AD10                ! game state dispatch value
.L_pool_slot_flags:
    .4byte  sym_06084FC8                ! slot data array (visibility flags at [0],[1])
