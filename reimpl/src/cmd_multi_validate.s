/* cmd_multi_validate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B21C - 0x0603B290
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Multi-stage command block validator / dispatcher.
 *
 * Temporarily replaces the handler pointer at block->data[0x28] with a
 * sentinel value (0x7FFFFFFF), then validates the block's state byte
 * via menu_list_scroll (which checks the busy flag at block[0x12]).
 *
 * If the block is busy (nonzero return), restores the original handler
 * and reports the error via save_checksum_calc.
 *
 * If the block is idle, dispatches it through cmd_dispatch_main in a
 * retry loop: a positive result triggers a cdb_wait_scdq poll before
 * retrying, a negative result is an error, and zero means success.
 *
 * On success (dispatch returns 0), finalises the block by calling the
 * 0x0603B3FA stub (sets r0=0x11 offset and falls into
 * menu_header_render), reports success via save_checksum_calc, restores
 * the original handler pointer, and returns the result from
 * menu_header_render.
 *
 * NOTE: The internal stub at .trampoline_set_offset (address 0x0603B28E)
 * sets r0 = 0x12 and falls through into the next TU (menu_list_scroll).
 * This is an intentional calling-convention trick: bsr saves the return
 * address, the stub provides the offset parameter, and menu_list_scroll
 * returns via rts to the caller.
 *
 * NOTE: The mov.l at .retry_wait loads a cross-TU pool entry
 * (cdb_wait_scdq at retail address 0x0603B30C, inside
 * menu_list_scroll's literal pool).  This only works when the TUs
 * are linked adjacently in the original retail layout.
 *
 * Args:
 *   r4 = command block pointer
 *
 * Returns:
 *   r0 = result from menu_header_render on success, or
 *        control flows through save_checksum_calc on error
 *
 * Calls (external):
 *   save_checksum_calc    0x0603B93C  set status/error code and return
 *   cmd_dispatch_main     0x0603B424  main command dispatch loop
 *   0x0603B3FA            stub → menu_header_render (finalise block)
 *   cdb_wait_scdq         0x0603B30C  (cross-TU pool) poll SCDQ
 *   menu_list_scroll      0x0603B290  (via fall-through trampoline)
 */

    .section .text.FUN_0603B21C


    .global cmd_multi_validate
    .type cmd_multi_validate, @function
cmd_multi_validate:
    mov.l r14, @-r15            ! save r14 (callee-saved)
    mov r4, r14                 ! r14 = command block pointer
    mov.l r13, @-r15            ! save r13 (callee-saved)
    sts.l pr, @-r15             ! save return address
    add #-0xC, r15              ! allocate 12 bytes of stack locals
    mov.l   .L_sentinel_value, r3 ! r3 = 0x7FFFFFFF (sentinel / max value)
    mov.l r3, @(8, r15)        ! stack[8] = sentinel (for later use as arg)
    mov.l @r14, r4              ! r4 = block->data (inner data pointer)
    mov.l @(40, r4), r13        ! r13 = data[0x28] (original handler pointer, saved)
    mov.l r3, @(40, r4)         ! data[0x28] = 0x7FFFFFFF (replace handler with sentinel)
    bsr     .trampoline_set_offset ! call stub: sets r0=0x12, falls into menu_list_scroll
    mov r14, r4                 ! delay: r4 = block pointer (arg for menu_list_scroll)
    mov r0, r4                  ! r4 = menu_list_scroll return value
    tst r4, r4                  ! result == 0? (block idle?)
    bt      .dispatch_loop      ! if zero (idle), proceed to dispatch
    mov.l @r14, r5              ! r5 = block->data (for restoring handler)
    .byte   0xB3, 0x7E    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=nonzero error)
    mov.l r13, @(40, r5)        ! delay: data[0x28] = r13 (restore original handler)
    bra     .epilogue           ! jump to function exit
    nop                         ! delay slot (unused)
.dispatch_loop:
    .byte   0xB0, 0xEE    /* bsr 0x0603B424 (external) */  ! call cmd_dispatch_main(r4=block_ptr)
    mov r14, r4                 ! delay: r4 = block pointer
    mov r0, r4                  ! r4 = dispatch result
    cmp/pz r4                   ! result >= 0? (not an error?)
    bt      .check_dispatch_ok  ! if non-negative, check for success vs retry
    mov.l @r14, r5              ! r5 = block->data (for restoring handler)
    .byte   0xB3, 0x74    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=negative error)
    mov.l r13, @(40, r5)        ! delay: data[0x28] = r13 (restore original handler)
    bra     .epilogue           ! jump to function exit
    nop                         ! delay slot (unused)
.check_dispatch_ok:
    tst r4, r4                  ! result == 0? (success?)
    bf      .retry_wait         ! if nonzero positive, retry after wait
    mov r15, r6                 ! r6 = &stack[0] (3rd arg for finalise stub)
    mov r15, r5                 ! r5 = &stack[0]
    add #0x4, r5                ! r5 = &stack[4] (2nd arg for finalise stub)
    .byte   0xB0, 0xCA    /* bsr 0x0603B3FA (external) */  ! call stub→menu_header_render(r4=block, r5=&stack[4], r6=&stack[0])
    mov r14, r4                 ! delay: r4 = block pointer
    .byte   0xB3, 0x69    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0, success)
    mov #0x0, r4                ! delay: r4 = 0 (success code)
    mov.l @r14, r4              ! r4 = block->data
    bra     .restore_and_return ! jump to restore handler + return result
    mov.l r13, @(40, r4)        ! delay: data[0x28] = r13 (restore original handler)

    .global DAT_0603b270
DAT_0603b270:
    mov.b r1, @(r0, r9)        ! (embedded data, not executed — cross-TU export)
    .word 0xFFFF /* UNKNOWN */  ! padding / data continuation
.L_sentinel_value:
    .4byte  0x7FFFFFFF                  /* sentinel: max positive 16.16 fixed-point */
.retry_wait:
    .byte   0xD3, 0x24    /* mov.l .L_pool_0603B30C, r3 */  ! r3 = &cdb_wait_scdq (cross-TU pool in menu_list_scroll)
    jsr @r3                     ! call cdb_wait_scdq() — poll/wait for SCDQ ready
    nop                         ! delay slot (unused)
    bra     .dispatch_loop      ! retry cmd_dispatch_main
    nop                         ! delay slot (unused)
.restore_and_return:
    mov.l @r15, r0              ! r0 = stack[0] (result from menu_header_render via r6 out-param)
.epilogue:
    add #0xC, r15               ! free stack locals
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r13            ! restore r13
    rts                         ! return to caller
    mov.l @r15+, r14            ! delay: restore r14
.trampoline_set_offset:
    mov #0x12, r0               ! r0 = 0x12 (state byte offset, passed to menu_list_scroll)
                                ! falls through into menu_list_scroll at next TU boundary
