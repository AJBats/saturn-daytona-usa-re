/* cmd_dispatch_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B424 - 0x0603B53C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Entry point for the main command dispatch loop.  The caller passes a
 * pointer to a command block in r4.  The block carries a state byte at
 * offset 0x12 that controls which phase of processing is executed.
 *
 * High-level flow:
 *   1. Read the state byte (+0x12).  If it is zero the block is idle;
 *      jump straight to the tail-call epilogue.
 *   2. Call save_deserialize() to decode the block.  The return value
 *      (in r13 after the call) is the decoded command type / phase code.
 *   3. Switch on that code:
 *       0 → if the async flag (+0x11) is 2, execute via save_field_read
 *           + save_checksum_calc, then return the refreshed state byte.
 *       1 → call cmd_block_check (inside save_commit_write TU); if the
 *           block is not ready, fall through to the error path.
 *       3 → error path: write 0xE9 to +0x12, return -0x17.
 *       4 → error path: write 0xFE to +0x12, return -0x2.
 *       5 → error path: write 0xEC to +0x12, return -0x14.
 *       6 → error path: write 0xFF to +0x12, return -0x1.
 *       anything else / fallthrough → integrity-check path (below).
 *   4. Integrity-check path: call save_integrity_check() to validate the
 *      block.  If the save state is 2 and the integrity result is 5,
 *      compute a diff of two time fields via sym_0603F9F2 / sym_0603F9F6,
 *      then call cmd_error_return() to record the delta.  Afterwards clear
 *      +0x12, notify sys_dma_channel_init, flush via the inner B8F4 helper
 *      and save_field_read, and fall through to the epilogue.
 *   5. Epilogue (.ret_read_state): tail-call save_checksum_calc(0), read
 *      back the (possibly updated) state byte at +0x12, return it in r0.
 *
 * Args:
 *   r4 = command block pointer
 *
 * Returns:
 *   r0 = current value of the state byte at block+0x12 (zero-extended)
 *
 * Calls (external):
 *   save_deserialize      0x0603BD1C  decode / advance block state
 *   cmd_block_check       0x0603BF5A  query whether the block is ready
 *   save_integrity_check  0x0603BDAC  validate block integrity
 *   cmd_error_return      0x0603AFD0  record error delta into block
 *   sys_dma_channel_init  0x0603B8B4  notify DMA channel of block change
 *   0x0603B8F4                        inner flush helper (sys_dma TU)
 *   save_field_read       0x0603B9D6  release / read the save field
 *   save_checksum_calc    0x0603B93C  set status/error code and return
 *   sym_0603F9F2                      get block time-field A (+20)
 *   sym_0603F9F6                      get block time-field B (+24)
 */

    .section .text.FUN_0603B424


    .global cmd_dispatch_main
    .type cmd_dispatch_main, @function
cmd_dispatch_main:
    mov.l r14, @-r15                ! save r14 (callee-saved)
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.l r13, @-r15                ! save r13 (callee-saved)
    mov r4, r14                     ! r14 = command block pointer
    mov.l r8, @-r15                 ! save r8 (callee-saved)
    sts.l pr, @-r15                 ! save return address
    mov.b @(r0, r14), r3            ! r3 = block[0x12] (state byte, byte load)
    extu.b r3, r3                   ! zero-extend to 32 bits
    tst r3, r3                      ! state == 0?
    bf      .check_deserialize      ! if nonzero, proceed to deserialize
    bra     .ret_read_state         ! state is already 0 → jump to epilogue
    nop                             ! delay slot
.check_deserialize:
    .byte   0xB4, 0x6E    /* bsr 0x0603BD1C (external) */  ! call save_deserialize(r4=block_ptr)
    mov r14, r4                     ! delay: r4 = block pointer argument
    bra     .dispatch_code          ! jump to switch on decode result
    mov r0, r13                     ! delay: r13 = save_deserialize return code
.err_state_6:
    mov.w   DAT_0603b4c6, r2        ! r2 = 0x00FF (state byte for "err_state_6")
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b r2, @(r0, r14)            ! block[0x12] = 0xFF (write error state)
    mov #-0x1, r4                   ! r4 = -1 (error code)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r8                 ! restore r8
    mov.l @r15+, r13                ! restore r13
    .byte   0xA2, 0x73    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-1)
    mov.l @r15+, r14                ! delay: restore r14
.err_state_3:
    mov.w   DAT_0603b4c8, r2        ! r2 = 0x00E9 (state byte for "err_state_3")
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b r2, @(r0, r14)            ! block[0x12] = 0xE9 (write error state)
    mov #-0x17, r4                  ! r4 = -0x17 (error code)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r8                 ! restore r8
    mov.l @r15+, r13                ! restore r13
    .byte   0xA2, 0x6A    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-0x17)
    mov.l @r15+, r14                ! delay: restore r14
.err_state_4:
    mov.w   DAT_0603b4ca, r2        ! r2 = 0x00FE (state byte for "err_state_4")
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b r2, @(r0, r14)            ! block[0x12] = 0xFE (write error state)
    mov #-0x2, r4                   ! r4 = -2 (error code)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r8                 ! restore r8
    mov.l @r15+, r13                ! restore r13
    .byte   0xA2, 0x61    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-2)
    mov.l @r15+, r14                ! delay: restore r14
.err_state_5:
    mov.w   DAT_0603b4cc, r2        ! r2 = 0x00EC (state byte for "err_state_5")
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b r2, @(r0, r14)            ! block[0x12] = 0xEC (write error state)
    mov #-0x14, r4                  ! r4 = -0x14 (error code)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r8                 ! restore r8
    mov.l @r15+, r13                ! restore r13
    .byte   0xA2, 0x58    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-0x14)
    mov.l @r15+, r14                ! delay: restore r14
.code_1_check_ready:
    .byte   0xB5, 0x65    /* bsr 0x0603BF5A (external) */  ! call cmd_block_check(r4=block_ptr)
    mov r14, r4                     ! delay: r4 = block pointer argument
    cmp/eq #0x1, r0                 ! block ready? (result == 1?)
    bf      .integrity_check        ! if not ready, fall through to integrity path
    mov.w   DAT_0603b4ce, r3        ! r3 = 0x00E8 (state byte for "not-ready" error)
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b r3, @(r0, r14)            ! block[0x12] = 0xE8 (write not-ready error state)
    mov #-0x18, r4                  ! r4 = -0x18 (error code)
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r8                 ! restore r8
    mov.l @r15+, r13                ! restore r13
    .byte   0xA2, 0x4B    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-0x18)
    mov.l @r15+, r14                ! delay: restore r14
.code_0_exec:
    mov #0x11, r0                   ! r0 = 0x11 (async flag offset)
    mov.b @(r0, r14), r0            ! r0 = block[0x11] (async flag byte)
    extu.b r0, r0                   ! zero-extend to 32 bits
    cmp/eq #0x2, r0                 ! async flag == 2?
    bf      .integrity_check        ! if not, fall through to integrity path
    mov #0x0, r2                    ! r2 = 0 (clear value)
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b r2, @(r0, r14)            ! block[0x12] = 0 (clear state byte)
    .byte   0xB2, 0x8E    /* bsr 0x0603B9D6 (external) */  ! call save_field_read(r4=block_ptr)
    mov r14, r4                     ! delay: r4 = block pointer
    .byte   0xB2, 0x3F    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0)
    mov #0x0, r4                    ! delay: r4 = 0 (success code)
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b @(r0, r14), r0            ! r0 = block[0x12] (refreshed state byte)
    bra     .epilogue               ! jump to function epilogue
    extu.b r0, r0                   ! delay: zero-extend state byte

    .global DAT_0603b4c6
DAT_0603b4c6:
    .2byte  0x00FF                  ! state byte value: 0xFF (used by err_state_6)

    .global DAT_0603b4c8
DAT_0603b4c8:
    .2byte  0x00E9                  ! state byte value: 0xE9 (used by err_state_3)

    .global DAT_0603b4ca
DAT_0603b4ca:
    .2byte  0x00FE                  ! state byte value: 0xFE (used by err_state_4)

    .global DAT_0603b4cc
DAT_0603b4cc:
    .2byte  0x00EC                  ! state byte value: 0xEC (used by err_state_5)

    .global DAT_0603b4ce
DAT_0603b4ce:
    .2byte  0x00E8                  ! state byte value: 0xE8 (used by code_1 not-ready)
.dispatch_code:
    cmp/eq #0x0, r0                 ! code == 0? (execute path)
    bt      .code_0_exec            ! if yes, jump to execute path
    cmp/eq #0x1, r0                 ! code == 1? (readiness check)
    bt      .code_1_check_ready     ! if yes, jump to readiness check
    cmp/eq #0x3, r0                 ! code == 3? (error state 3)
    bt      .err_state_3            ! if yes, jump to error path
    cmp/eq #0x4, r0                 ! code == 4? (error state 4)
    bt      .err_state_4            ! if yes, jump to error path
    cmp/eq #0x5, r0                 ! code == 5? (error state 5)
    bt      .err_state_5            ! if yes, jump to error path
    cmp/eq #0x6, r0                 ! code == 6? (error state 6)
    bt      .err_state_6            ! if yes, jump to error path
.integrity_check:
    .byte   0xB4, 0x60    /* bsr 0x0603BDAC (external) */  ! call save_integrity_check(r4=block_ptr)
    mov r14, r4                     ! delay: r4 = block pointer
    mov r0, r4                      ! r4 = integrity check result
    mov r13, r0                     ! r0 = save_deserialize code (save state)
    cmp/eq #0x2, r0                 ! save state == 2?
    bf      .ret_read_state         ! if not, skip delta path → epilogue
    mov r4, r0                      ! r0 = integrity check result
    cmp/eq #0x5, r0                 ! integrity result == 5?
    bf      .ret_read_state         ! if not, skip delta path → epilogue
    .byte   0xD3, 0x18    /* mov.l .L_pool_0603B55C, r3 */  ! r3 = &sym_0603F9F2 (time-field A getter)
    jsr @r3                         ! call sym_0603F9F2(r4=block_ptr): r0 = block->time_a
    mov.l @(8, r14), r4             ! delay: r4 = block->data_ptr (arg for getter)
    mov r0, r8                      ! r8 = time_a (save getter result)
    .byte   0xD3, 0x17    /* mov.l .L_pool_0603B560, r3 */  ! r3 = &sym_0603F9F6 (time-field B getter)
    jsr @r3                         ! call sym_0603F9F6(r4=block_ptr): r0 = block->time_b
    mov.l @(8, r14), r4             ! delay: r4 = block->data_ptr (arg for getter)
    mov r8, r5                      ! r5 = time_a
    mov r14, r4                     ! r4 = block pointer
    sub r0, r5                      ! r5 = time_a - time_b (time delta)
    .byte   0xBD, 0x5F    /* bsr 0x0603AFD0 (external) */  ! call cmd_error_return(r4=block, r5=delta, r6=1)
    mov #0x1, r6                    ! delay: r6 = 1 (mode flag for error record)
    mov #0x0, r2                    ! r2 = 0 (clear value)
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov r14, r13                    ! r13 = block pointer (save for later calls)
    mov.b r2, @(r0, r14)            ! block[0x12] = 0 (clear state byte)
    .byte   0xB1, 0xCB    /* bsr 0x0603B8B4 (external) */  ! call sys_dma_channel_init(r4=block_ptr)
    mov r14, r4                     ! delay: r4 = block pointer
    .byte   0xB1, 0xE9    /* bsr 0x0603B8F4 (external) */  ! call inner_dma_flush(r4=block_ptr)
    mov r13, r4                     ! delay: r4 = block pointer (from r13)
    .byte   0xB2, 0x58    /* bsr 0x0603B9D6 (external) */  ! call save_field_read(r4=block_ptr)
    mov r13, r4                     ! delay: r4 = block pointer (from r13)
.ret_read_state:
    .byte   0xB2, 0x09    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0)
    mov #0x0, r4                    ! delay: r4 = 0 (success code)
    mov #0x12, r0                   ! r0 = 0x12 (state byte offset)
    mov.b @(r0, r14), r0            ! r0 = block[0x12] (current state byte)
    extu.b r0, r0                   ! zero-extend to 32 bits
.epilogue:
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r8                 ! restore r8
    mov.l @r15+, r13                ! restore r13
    rts                             ! return to caller
    mov.l @r15+, r14                ! delay: restore r14
    .2byte  0xE060                  ! padding / pool alignment
