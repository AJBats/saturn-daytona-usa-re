/* dma_queue_mgr -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06007CEC - 0x06007D8E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * dma_queue_mgr:
 *   Builds the VDP1 command list from sorted sprite entries.
 *
 *   1. Calls render_finalize (sym_0603C000) to reset the VDP1 command list.
 *   2. Iterates over the sort key array (sym_0606A4F8), reading each
 *      16-bit sort index.
 *   3. Uses the sort index to look up a 24-byte sprite entry from the
 *      sprite data table (sym_0608AC20).
 *   4. Reads the entry's type field at byte offset 6:
 *      - type == 9 → dispatches to VDP1 distorted sprite builder
 *        (sym_060281B8) with CMDPMOD = 0x8000 (high-speed shrink).
 *      - type != 9 → dispatches to VDP1 normal sprite builder
 *        (sym_060280F8).
 *   5. Advances the VDP1 write cursor (sym_06078624) by 0x20 (32 bytes,
 *      one VDP1 command slot) after each entry.
 *   6. After all entries are processed, writes 0xFFFF (end-of-list marker)
 *      to the VDP1 command table (0x21800000).
 *
 * Register plan:
 *   r8  = sym_060281B8 (VDP1 distorted sprite builder)
 *   r9  = sym_0606A4F8 (sort key array — 16-bit indices)
 *   r10 = 0x8000 (CMDPMOD: high-speed shrink flag)
 *   r11 = loop counter (current entry index)
 *   r12 = current sort index (16-bit, zero-extended)
 *   r13 = sym_0608AC20 (sprite data table base, 24-byte entries)
 *   r14 = sym_06078624 (pointer to VDP1 write cursor)
 *
 * Pool entries live in the following TU (dma_queue_commit), between
 * .L_wpool_06007DA0 and .L_ovf_retry.
 *
 * Calls: sym_0603C000 (render_finalize), sym_060281B8 (distorted sprite
 *        builder), sym_060280F8 (normal sprite builder)
 */

    .section .text.FUN_06007CEC


    .global dma_queue_mgr
    .type dma_queue_mgr, @function
dma_queue_mgr:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    mov.l r11, @-r15                    ! save r11
    mov.l r10, @-r15                    ! save r10
    mov.l r9, @-r15                     ! save r9
    mov.l r8, @-r15                     ! save r8
    sts.l pr, @-r15                     ! save pr (return address)
    .byte   0xD8, 0x29    /* mov.l .L_pool_06007DA4, r8 */   ! r8 = sym_060281B8 (distorted sprite builder)
    .byte   0xD9, 0x2A    /* mov.l .L_pool_06007DA8, r9 */   ! r9 = sym_0606A4F8 (sort key array)
    .byte   0xDA, 0x2A    /* mov.l .L_pool_06007DAC, r10 */  ! r10 = 0x8000 (CMDPMOD: high-speed shrink)
    .byte   0xDD, 0x2B    /* mov.l .L_pool_06007DB0, r13 */  ! r13 = sym_0608AC20 (sprite data table base)
    .byte   0xDE, 0x2B    /* mov.l .L_pool_06007DB4, r14 */  ! r14 = &vdp1_write_cursor (sym_06078624)
    .byte   0xD3, 0x2C    /* mov.l .L_pool_06007DB8, r3 */   ! r3 = sym_0603C000 (render_finalize)
    jsr @r3                             ! call render_finalize — reset VDP1 command list
    nop                                 ! delay slot
    bra     .L_loop_test                ! jump to loop condition check
    mov #0x0, r11                       ! r11 = 0 (loop counter) [delay slot]
.L_loop_body:
    mov r11, r0                         ! r0 = current entry index
    shll r0                             ! r0 *= 2 (word offset into sort key array)
    mov.w @(r0, r9), r12               ! r12 = sort_keys[index] (16-bit sort index)
    extu.w r12, r12                     ! zero-extend sort index to 32 bits
    extu.w r12, r0                      ! r0 = sort index (copy for offset calc)
    mov r0, r3                          ! r3 = sort index (second copy)
    shll2 r0                            ! r0 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r0                             ! r0 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r0                          ! r0 = index * 24 (entry size = 0x18 bytes)
    extu.w r0, r0                       ! mask to 16 bits (table is <64K)
    add r13, r0                         ! r0 = &sprite_data[index] (absolute address)
    mov.w @(6, r0), r0                  ! r0 = entry.type (halfword at offset 6)
    extu.w r0, r0                       ! zero-extend type field
    cmp/eq #0x9, r0                     ! is type == 9 (distorted sprite)?
    bf      .L_normal_sprite            ! no — use normal sprite builder
    mov r10, r6                         ! r6 = 0x8000 (CMDPMOD: high-speed shrink)
    extu.w r12, r4                      ! r4 = sort index (arg: entry ID)
    mov.l @r14, r5                      ! r5 = VDP1 write cursor (destination pointer)
    mov r4, r3                          ! r3 = sort index (copy for offset calc)
    shll2 r4                            ! r4 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r4                             ! r4 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r4                          ! r4 = index * 24 (entry offset)
    extu.w r4, r4                       ! mask to 16 bits
    jsr @r8                             ! call distorted sprite builder (sym_060281B8)
    add r13, r4                         ! r4 = &sprite_data[index] (source entry) [delay slot]
    bra     .L_advance_cursor           ! skip normal path
    nop                                 ! delay slot
.L_normal_sprite:
    extu.w r12, r4                      ! r4 = sort index (arg: entry ID)
    mov.l @r14, r5                      ! r5 = VDP1 write cursor (destination pointer)
    mov r4, r3                          ! r3 = sort index (copy for offset calc)
    shll2 r4                            ! r4 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r4                             ! r4 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r4                          ! r4 = index * 24 (entry offset)
    extu.w r4, r4                       ! mask to 16 bits
    .byte   0xD3, 0x16    /* mov.l .L_pool_06007DBC, r3 */   ! r3 = sym_060280F8 (normal sprite builder)
    jsr @r3                             ! call normal sprite builder
    add r13, r4                         ! r4 = &sprite_data[index] (source entry) [delay slot]
.L_advance_cursor:
    add #0x1, r11                       ! r11++ (next entry index)
    mov.l @r14, r2                      ! r2 = VDP1 write cursor
    add #0x20, r2                       ! r2 += 0x20 (advance by one VDP1 command slot)
    mov.l r2, @r14                      ! store updated write cursor
.L_loop_test:
    .byte   0xD3, 0x14    /* mov.l .L_pool_06007DC0, r3 */   ! r3 = &sprite_count (sym_06078620)
    mov.l @r3, r3                       ! r3 = sprite count (number of entries to process)
    cmp/hs r3, r11                      ! has loop counter reached sprite count?
    bf      .L_loop_body                ! no — process next entry
    .byte   0xD3, 0x13    /* mov.l .L_pool_06007DC4, r3 */   ! r3 = 0x0000FFFF (VDP1 end-of-list marker)
    .byte   0xD2, 0x13    /* mov.l .L_pool_06007DC8, r2 */   ! r2 = 0x21800000 (VDP1 command table address)
    mov.w r3, @r2                       ! write 0xFFFF end marker to VDP1 command table
    lds.l @r15+, pr                     ! restore pr (return address)
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 [delay slot]
