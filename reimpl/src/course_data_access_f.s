/* course_data_access_f -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036578 - 0x060365C4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Per-course track data reader (variant F).
 * Sends SMPC command 0x51 with a course parameter, reads back a
 * 16-bit word from response offset 6 and stores it to the output pointer.
 *
 * On entry:  r5  = output pointer (where to store the result)
 *            r14 = course/parameter byte (zero-extended before use)
 * On exit:   *r5 = 32-bit zero-extended 16-bit result from SMPC response
 */

    .section .text.FUN_06036578


    .global course_data_access_f
    .type course_data_access_f, @function
course_data_access_f:
    sts.l pr, @-r15                     ! save return address
    mov r5, r13                         ! r13 = output pointer
    add #-0x10, r15                     ! allocate 16-byte stack frame
    mov r15, r4                         ! r4 = stack frame base
    mov.l   .L_fn_input_proc_analog, r3 ! load address of input_proc_analog
    jsr @r3                             ! call input_proc_analog(r4=buf+8)
    add #0x8, r4                        ! (delay) r4 = &buf[8] — SMPC request area
    mov r15, r2                         ! r2 = stack frame base
    mov #0x51, r3                       ! r3 = SMPC command byte 0x51
    extu.b r14, r14                     ! zero-extend course param to byte
    mov r15, r6                         ! r6 = buf (response area)
    mov r15, r5                         ! r5 = buf
    add #0x8, r2                        ! r2 = &buf[8] — request area
    mov r14, r0                         ! r0 = course parameter byte
    add #0x8, r5                        ! r5 = &buf[8]
    mov.b r3, @r2                       ! buf[8] = 0x51 (command byte)
    mov r15, r2                         ! r2 = stack frame base
    add #0x8, r2                        ! r2 = &buf[8]
    mov.b r0, @(4, r2)                  ! buf[12] = course parameter byte
    mov.l   .L_fn_input_proc_digital, r3 ! load address of input_proc_digital
    jsr @r3                             ! call input_proc_digital(r4=0, r5=&buf[8], r6=buf)
    mov #0x0, r4                        ! (delay) r4 = 0 (port selector)
    mov r0, r4                          ! r4 = return value (unused, preserved)
    mov r15, r2                         ! r2 = stack frame base
    mov.w @(6, r2), r0                  ! r0 = 16-bit result from buf[6]
    mov r0, r3                          ! r3 = raw result
    extu.w r3, r3                       ! zero-extend 16 bits to 32 bits
    mov r4, r0                          ! r0 = restore return value
    mov.l r3, @r13                      ! *output_ptr = zero-extended result
    add #0x10, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore callee-saved r13
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay) restore callee-saved r14
.L_fn_input_proc_analog:
    .4byte  input_proc_analog           ! -> SMPC analog axis reader
.L_fn_input_proc_digital:
    .4byte  input_proc_digital          ! -> SMPC digital command dispatcher
