/* course_obj_transform -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600B1A0 - 0x0600B340
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Per-course object transformation pipeline.
 * Dispatches rotation source/dest parameter tables based on race variant
 * (state 0/1/2 from race end state word), then applies the full transform
 * chain: pre-transform setup, position load, mat_rot_y, mat_rot_z,
 * transform_matrix.  If camera follow mode is active, runs a secondary
 * pass with alternate position/rotation tables and dispatches the dual-
 * object renderer (camera_collision_avoid) at the end.
 *
 * Decrements the global animation counter by 0x30 per invocation.
 */

    .section .text.FUN_0600B1A0


    .global course_obj_transform
    .type course_obj_transform, @function
course_obj_transform:
    mov.l r14, @-r15            ! save callee-saved regs
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    sts.l pr, @-r15             ! save return address
    add #-0x8, r15              ! allocate 0x8 bytes locals
    mov.l   .L_ptr_config_struct, r11
    mov.l @r11, r11             ! r11 = config struct (model/enable)
    mov.l   .L_ptr_car_array_base, r14
    mov.l @r14, r14             ! r14 = car array base ptr
    mov.l   .L_ptr_current_car, r3
    mov.l r14, @r3              ! store car array as current car
    mov.l   .L_ptr_race_variant, r0
    bra     .L_dispatch_variant ! branch to variant switch
    mov.l @r0, r0               ! (delay) r0 = race variant (0/1/2)
.L_variant_0:                       ! race variant 0 (beginner course)
    mov.l   .L_ptr_rot_src_state0, r13  ! r13 = rotation source params
    mov.l   .L_ptr_rot_dst_state0, r12  ! r12 = rotation dest params
    bra     .L_run_transform_chain
    nop
.L_variant_1:                       ! race variant 1 (advanced course)
    mov.l   .L_ptr_rot_src_state1, r13  ! r13 = rotation source params
    mov.l   .L_ptr_rot_dst_state1, r12  ! r12 = rotation dest params
    bra     .L_run_transform_chain
    nop
.L_variant_2:                       ! race variant 2 (expert course)
    mov.l   .L_ptr_rot_src_state2, r13  ! r13 = rotation source params
    mov.l   .L_ptr_rot_dst_state2, r12  ! r12 = rotation dest params
    bra     .L_run_transform_chain
    nop
    .2byte  0xFFFF                      ! padding / alignment
    .4byte  sym_06083258                ! (out-of-TU pool) camera LOD offset base
    .4byte  sym_060621D8                ! (out-of-TU pool)
    .4byte  sym_0606212C                ! (out-of-TU pool)
    .4byte  sym_06032158                ! (out-of-TU pool)
    .4byte  sym_06062180                ! (out-of-TU pool)
    .4byte  sym_06089E44                ! (out-of-TU pool)
    .4byte  sym_060620D8                ! (out-of-TU pool)
    .4byte  sym_06031DF4                ! (out-of-TU pool)
    .4byte  sym_0607EBC4                ! (out-of-TU pool)
    .4byte  0x20020000                  ! (out-of-TU pool) cache-through WRAM Low
    .4byte  master_ctrl_dispatch        ! (out-of-TU pool) fn ptr
    .4byte  sym_0608A52C                ! (out-of-TU pool)
.L_ptr_config_struct:
    .4byte  sym_0607EB8C                ! config struct: enable flags + model indices
.L_ptr_car_array_base:
    .4byte  sym_0607E944                ! car array base pointer
.L_ptr_current_car:
    .4byte  sym_0607E940                ! current car struct pointer
.L_ptr_race_variant:
    .4byte  sym_0607EAD8                ! race end state (0/1/2)
.L_ptr_rot_src_state0:
    .4byte  sym_06063488                ! state 0 rotation source params
.L_ptr_rot_dst_state0:
    .4byte  sym_06063434                ! state 0 rotation dest params
.L_ptr_rot_src_state1:
    .4byte  sym_060634A4                ! state 1 rotation source params
.L_ptr_rot_dst_state1:
    .4byte  sym_06063450                ! state 1 rotation dest params
.L_ptr_rot_src_state2:
    .4byte  sym_060634C0                ! state 2 rotation source params
.L_ptr_rot_dst_state2:
    .4byte  sym_0606346C                ! state 2 rotation dest params
.L_dispatch_variant:                    ! switch on race variant
    cmp/eq #0x0, r0             ! variant == 0?
    bt      .L_variant_0
    cmp/eq #0x1, r0             ! variant == 1?
    bt      .L_variant_1
    cmp/eq #0x2, r0             ! variant == 2?
    bt      .L_variant_2        ! (fallthrough if unknown â†’ runs chain anyway)
.L_run_transform_chain:                 ! === primary transform pass ===
    mov.l   .L_fn_pre_transform_setup, r3
    jsr @r3                     ! pre_transform_setup()
    nop
    mov.l @(24, r14), r6        ! r6 = car[+0x18] (pos Z)
    mov.l @(20, r14), r5        ! r5 = car[+0x14] (pos Y)
    mov.l   .L_fn_transform_dispatch, r3
    jsr @r3                     ! transform_dispatch(pos_X, pos_Y, pos_Z)
    mov.l @(16, r14), r4        ! (delay) r4 = car[+0x10] (pos X)
    mov.l   .L_fn_mat_rot_y, r3
    jsr @r3                     ! mat_rot_y(rot_Y)
    mov.l @(32, r14), r4        ! (delay) r4 = car[+0x20] (Y rotation)
    mov.l   .L_fn_mat_rot_z, r3
    jsr @r3                     ! mat_rot_z(rot_Z)
    mov.l @(36, r14), r4        ! (delay) r4 = car[+0x24] (Z rotation)
    mov.l   .L_fn_transform_matrix, r3
    jsr @r3                     ! transform_matrix(rot_X)
    mov.l @(28, r14), r4        ! (delay) r4 = car[+0x1C] (X rotation)
    mov.w   .L_off_car_extra_rot, r0   ! r0 = 0x01D8 (extra rot field offset)
    mov.l   .L_fn_mat_rot_y, r3
    mov.l @(r0, r14), r4        ! r4 = car[+0x1D8] (extra rotation)
    add #-0xC, r0               ! r0 = 0x01CC
    mov.l @(r0, r14), r2        ! r2 = car[+0x1CC] (rotation bias)
    jsr @r3                     ! mat_rot_y(extra_rot + bias)
    add r2, r4                  ! (delay) r4 = extra_rot + bias
    mov.l   .L_ptr_cam_follow_flag, r0  ! === secondary pass (camera follow mode) ===
    mov.l @r0, r0               ! r0 = camera follow mode flag
    tst r0, r0                  ! follow mode active?
    bt      .L_epilogue         ! skip if follow mode == 0
    mov.l   .L_ptr_scale_src_vec, r5
    mov.l   .L_fn_vec_copy_a, r3
    mov.l @r5, r5               ! r5 = scale source vector ptr
    jsr @r3                     ! vec_copy_a(rot_src[+0x18], scale_vec)
    mov.l @(24, r13), r4        ! (delay) r4 = rot_src[+0x18]
    mov.l   .L_ptr_rot_data_src, r6
    mov.l   .L_ptr_mode_scale_factor, r2
    mov.l @r6, r6               ! r6 = rotation data source ptr
    mov r2, r5                  ! r5 = &mode_scale_factor
    mov.l r2, @(4, r15)         ! save scale_factor addr to locals[+4]
    mov.w @r5, r5               ! r5 = mode scale factor (16-bit)
    mov.l   .L_fn_vec_copy_b, r3
    jsr @r3                     ! vec_copy_b(rot_dst[+0x18], scale, rot_data)
    mov.l @(24, r12), r4        ! (delay) r4 = rot_dst[+0x18]
    mov #0x0, r6                ! r6 = 0 (zero position)
    mov.w   .L_off_car_pos_y, r0   ! r0 = 0x01B4
    mov.l   .L_fn_transform_dispatch, r3
    mov.l @(r0, r14), r5        ! r5 = car[+0x1B4] (alt pos Y)
    jsr @r3                     ! transform_dispatch(0, alt_pos_Y, ...)
    mov r6, r4                  ! (delay) r4 = 0 (alt pos X)
    mov.w   .L_off_car_rot_z_alt, r0  ! r0 = 0x01D0
    mov.l   .L_fn_mat_rot_z, r3
    jsr @r3                     ! mat_rot_z(alt_rot_Z)
    mov.l @(r0, r14), r4        ! (delay) r4 = car[+0x1D0] (alt Z rot)
    mov.w   .L_off_car_xform_alt, r0  ! r0 = 0x01C8
    mov.l   .L_ptr_lod_offset_base, r2
    mov.l   .L_fn_transform_matrix, r3
    mov.l @(r0, r14), r4        ! r4 = car[+0x1C8] (alt transform)
    mov.l @r2, r2               ! r2 = LOD offset base value
    jsr @r3                     ! transform_matrix(alt_xform + lod_offset)
    add r2, r4                  ! (delay) r4 += LOD offset
    mov.l @(12, r11), r5        ! r5 = config[+0xC] (model index)
    shll2 r5                    ! r5 *= 0x4 (table stride)
    mov.l r5, @r15              ! save scaled index to locals[+0]
    mov.l   .L_ptr_rot_chain_a, r3
    mov.l @r15, r4              ! r4 = scaled index
    mov.l   .L_fn_vec_copy_a, r2
    add r3, r5                  ! r5 = &rot_chain_a[index]
    add r13, r4                 ! r4 = &rot_src[index]
    mov.l @r5, r5               ! r5 = rot_chain_a[index] (source vec)
    jsr @r2                     ! vec_copy_a(rot_src[index], chain_a[index])
    mov.l @r4, r4               ! (delay) r4 = rot_src[index]
    mov.l @(12, r11), r6        ! r6 = config[+0xC] (model index again)
    shll2 r6                    ! r6 *= 0x4
    mov.l r6, @r15              ! save scaled index to locals[+0]
    mov.l   .L_ptr_rot_chain_b, r3
    mov.l @(4, r15), r5         ! r5 = saved scale_factor addr
    mov.l @r15, r4              ! r4 = scaled index
    mov.l   .L_fn_vec_copy_b, r2
    add r3, r6                  ! r6 = &rot_chain_b[index]
    mov.w @r5, r5               ! r5 = mode scale factor (16-bit)
    add r12, r4                 ! r4 = &rot_dst[index]
    mov.l @r6, r6               ! r6 = rot_chain_b[index] (source vec)
    jsr @r2                     ! vec_copy_b(rot_dst[index], scale, chain_b)
    mov.l @r4, r4               ! (delay) r4 = rot_dst[index]
    .byte   0xB9, 0x97    /* bsr camera_collision_avoid (dual-obj renderer) */
    nop
.L_epilogue:                            ! === epilogue: decrement counter + return ===
    mov.l   .L_ptr_anim_counter, r4
    mov.l @r4, r2               ! r2 = anim counter
    add #-0x30, r2              ! decrement by 0x30
    mov.l r2, @r4               ! store updated counter
    add #0x8, r15               ! free locals
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r11            ! restore callee-saved regs
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14            ! (delay) restore r14
.L_off_car_extra_rot:
    .2byte  0x01D8                      ! car struct offset: extra rotation angle
.L_off_car_pos_y:
    .2byte  0x01B4                      ! car struct offset: alt position Y
.L_off_car_rot_z_alt:
    .2byte  0x01D0                      ! car struct offset: alt Z rotation
.L_off_car_xform_alt:
    .2byte  0x01C8                      ! car struct offset: alt transform param
.L_fn_pre_transform_setup:
    .4byte  sym_06026DBC                ! pre-transform setup function
.L_fn_transform_dispatch:
    .4byte  sym_06026E2E                ! position transform dispatch function
.L_fn_mat_rot_y:
    .4byte  mat_rot_y                   ! Y-axis rotation matrix function
.L_fn_mat_rot_z:
    .4byte  mat_rot_z                   ! Z-axis rotation matrix function
.L_fn_transform_matrix:
    .4byte  transform_matrix            ! full transform matrix function
.L_ptr_cam_follow_flag:
    .4byte  sym_06059F30                ! camera follow mode flag
.L_ptr_scale_src_vec:
    .4byte  sym_06063510                ! scale source vector (ptr)
.L_fn_vec_copy_a:
    .4byte  sym_06031D8C                ! vector copy function A
.L_ptr_rot_data_src:
    .4byte  sym_060634F4                ! rotation data source (ptr)
.L_ptr_mode_scale_factor:
    .4byte  sym_06089E98                ! per-mode scale factor (16-bit)
.L_fn_vec_copy_b:
    .4byte  sym_06031A28                ! scaled vector copy function B
.L_ptr_lod_offset_base:
    .4byte  sym_06083258                ! camera LOD offset base (ptr)
.L_ptr_rot_chain_a:
    .4byte  sym_060634F8                ! rotation chain A params
.L_ptr_rot_chain_b:
    .4byte  sym_060634DC                ! rotation chain B params
.L_ptr_anim_counter:
    .4byte  sym_06089EDC                ! global animation counter (dec by 0x30)
