/* track_normal_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06014468 - 0x0601450C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Car Slot Index Calculator
 * -------------------------
 * Computes a car slot index from the input state struct and stores it
 * in the global car_slot_index variable (sym_06084B08). The previous
 * slot index is saved to sym_06084B0C before the update.
 *
 * Calculation:
 *   1. Read 16-bit button flags word at input_state[+4]
 *   2. Invert (XOR 0xFFFF), mask low byte, arithmetic shift right 3
 *      (signed divide by 8)
 *   3. Clamp: if computed value > r5 (max param), use r5 instead
 *   4. If active_car_count >= 3: force slot to 0x1B (< 15) or 0x1C (>= 15)
 *   5. If slot changed from previous: play sound 0xAB111DFF
 *   6. Look up variant code from table at sym_0605AD2C[slot], store
 *      to sym_06084B20 (current_variant_code)
 *
 * Parameters:
 *   r5 = max slot index (clamp ceiling)
 *
 * Key state variables:
 *   sym_06084B08 = car slot index (32-bit)
 *   sym_06084B0C = previous car slot index (32-bit)
 *   sym_06084B18 = active car count (32-bit, max 3)
 *   sym_06084B20 = current variant code (32-bit, from lookup table)
 *   sym_06063D98 = input/button state struct (+4 = button flags word)
 *   sym_0605AD2C = variant code lookup table (byte-indexed by slot)
 *
 * Sound commands:
 *   0xAB111DFF = slot change notification sound
 */

    .section .text.FUN_06014468


    .global track_normal_calc
    .type track_normal_calc, @function
track_normal_calc:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_ptr_car_slot_idx, r14    ! r14 = &car_slot_index (sym_06084B08)
    mov.l   .L_ptr_input_state, r4      ! r4 = &input_state struct (sym_06063D98)
    mov.l   .L_mask_low16, r3           ! r3 = 0x0000FFFF (16-bit inversion mask)
    mov.w @(4, r4), r0                  ! r0 = input_state[+4] (button flags word)
    extu.w r0, r0                       ! r0 = zero-extend to 32-bit
    xor r3, r0                          ! r0 ^= 0xFFFF (invert all 16 bits)
    and #0xFF, r0                       ! r0 &= 0xFF (isolate low byte)
    shar r0                             ! r0 >>= 1 (arithmetic shift right)
    shar r0                             ! r0 >>= 1
    shar r0                             ! r0 >>= 1 (total: divide by 8, signed)
    extu.w r0, r4                       ! r4 = computed slot index (zero-extended)
    extu.w r4, r2                       ! r2 = slot index copy for comparison
    cmp/gt r5, r2                       ! T = (computed > max_param)?
    bf      .L_clamp_done               ! if computed <= max → keep it
    extu.w r5, r4                       ! r4 = max_param (clamp to ceiling)
.L_clamp_done:
    mov.l @r14, r2                      ! r2 = old car_slot_index
    mov.l   .L_ptr_prev_slot_idx, r3    ! r3 = &prev_slot_index (sym_06084B0C)
    mov.l r2, @r3                       ! prev_slot_index = old value (save before overwrite)
    extu.w r4, r2                       ! r2 = new slot index (zero-extended)
    mov.l r2, @r14                      ! car_slot_index = new value
    mov.l   .L_ptr_car_count, r3        ! r3 = &active_car_count (sym_06084B18)
    mov #0x3, r2                        ! r2 = 3 (threshold for forced clamping)
    mov.l @r3, r3                       ! r3 = active_car_count
    cmp/hs r2, r3                       ! T = (car_count >= 3)?
    bf      .L_check_changed            ! if car_count < 3 → skip forced clamp
    extu.w r4, r4                       ! r4 = new slot (zero-extended for compare)
    mov #0xF, r2                        ! r2 = 15 (threshold)
    cmp/ge r2, r4                       ! T = (slot >= 15)?
    bt      .L_force_high               ! if slot >= 15 → force to 0x1C
    mov #0x1B, r2                       ! r2 = 27 (forced low slot)
    mov.l r2, @r14                      ! car_slot_index = 0x1B
    bra     .L_check_changed            ! → check if value changed
    nop
.L_force_high:
    mov #0x1C, r3                       ! r3 = 28 (forced high slot)
    mov.l r3, @r14                      ! car_slot_index = 0x1C
.L_check_changed:
    mov.l @r14, r3                      ! r3 = current car_slot_index (possibly forced)
    mov.l   .L_ptr_prev_slot_idx, r2    ! r2 = &prev_slot_index (sym_06084B0C)
    mov.l @r2, r2                       ! r2 = prev_slot_index
    cmp/eq r2, r3                       ! T = (new == old)?
    bt      .L_no_sound                 ! if unchanged → skip sound
    mov.l   .L_snd_slot_change, r5      ! r5 = 0xAB111DFF (slot change sound cmd)
    mov.l   .L_ptr_sound_dispatch, r3   ! r3 = &sound_cmd_dispatch
    jsr @r3                             ! call sound_cmd_dispatch(r4=0, r5=sound_cmd)
    mov #0x0, r4                        ! r4 = 0 (channel param, in delay slot)
.L_no_sound:
    mov.l @r14, r2                      ! r2 = car_slot_index
    mov.l   .L_ptr_variant_table, r3    ! r3 = &variant_lookup_table (sym_0605AD2C)
    mov.l   .L_ptr_variant_code, r1     ! r1 = &current_variant_code (sym_06084B20)
    add r3, r2                          ! r2 = &table[slot_index]
    mov.b @r2, r2                       ! r2 = table[slot_index] (byte read)
    extu.b r2, r2                       ! r2 = zero-extend byte to 32-bit
    mov.l r2, @r1                       ! current_variant_code = lookup result
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (in delay slot)
    .4byte  0x01C8FFFF
    .4byte  sym_06084AF0
    .4byte  sym_06034FE0
    .4byte  sym_06028430
.L_ptr_car_slot_idx:
    .4byte  sym_06084B08                /* &car_slot_index (32-bit) */
.L_ptr_input_state:
    .4byte  sym_06063D98                /* &input_state struct (+4 = button flags) */
.L_mask_low16:
    .4byte  0x0000FFFF                  /* low 16-bit mask */
.L_ptr_prev_slot_idx:
    .4byte  sym_06084B0C                /* &prev_slot_index (32-bit) */
.L_ptr_car_count:
    .4byte  sym_06084B18                /* &active_car_count (32-bit, max 3) */
.L_snd_slot_change:
    .4byte  0xAB111DFF                  /* slot change notification sound */
.L_ptr_sound_dispatch:
    .4byte  sound_cmd_dispatch          /* sound command dispatch function */
.L_ptr_variant_table:
    .4byte  sym_0605AD2C                /* variant code lookup table (byte array) */
.L_ptr_variant_code:
    .4byte  sym_06084B20                /* &current_variant_code (32-bit) */
