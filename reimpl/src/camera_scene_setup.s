/* camera_scene_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600A4CA - 0x0600A5B2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Camera scene parameter dispatch — selects and applies camera transform
 * chain parameters based on the current race end state (0, 1, or 2).
 *
 * Reads the race end state variable (sym_0607EAD8) and dispatches to one
 * of three parameter set paths. Each path:
 *   1. Indexes into state-specific rotation source and destination arrays
 *      using the car index (r4 param, scaled by 4)
 *   2. Calls transform chain A (sym_06031D8C) with source and dest params
 *   3. Reads a display scale word from the sprite index table at offset +0x54
 *   4. Calls transform chain B (sym_06031A28) with display params and scale
 *
 * Parameter tables per state:
 *   State 0: source=sym_06063488, dest=sym_06063434
 *            chain_a_src=sym_060628C8, chain_a_dest=sym_06062874
 *            chain_b_disp=sym_0606291C, chain_b_model=sym_060621DC
 *   State 1: source=sym_060634A4, dest=sym_06063450
 *            chain_a_src=sym_06062820, chain_a_dest=sym_060620DC
 *            chain_b_disp=sym_06062130, chain_b_model=sym_06062184
 *   State 2: source=sym_060634C0, dest=sym_0606346C
 *            (same chain_b path, different chain_a tables)
 *
 * Persistent registers:
 *   r8  = sprite index table base (sym_06089E44)
 *   r9  = rotation chain B params (sym_060634DC)
 *   r10 = transform chain B function (sym_06031A28)
 *   r11 = rotation chain A params (sym_060634F8)
 *   r12 = transform chain A function (sym_06031D8C)
 *   r13 = car index (from r4 parameter)
 */

    .section .text.FUN_0600A4CA


    .global camera_scene_setup
    .type camera_scene_setup, @function
camera_scene_setup:
    mov.l r14, @-r15                     ! save r14
    mov.l r13, @-r15                     ! save r13
    mov.l r12, @-r15                     ! save r12
    mov.l r11, @-r15                     ! save r11
    mov.l r10, @-r15                     ! save r10
    mov.l r9, @-r15                      ! save r9
    mov.l r8, @-r15                      ! save r8
    sts.l pr, @-r15                      ! save return address
    mov r4, r13                          ! r13 = car_index (parameter)
    .byte   0xD8, 0x15    /* mov.l .L_sprite_index_table, r8 — sprite index table base */
    .byte   0xD9, 0x17    /* mov.l .L_rot_chain_b_params, r9 — rotation chain B params */
    .byte   0xDA, 0x10    /* mov.l .L_fn_chain_b, r10 — transform chain B function */
    .byte   0xDB, 0x17    /* mov.l .L_rot_chain_a_params, r11 — rotation chain A params */
    .byte   0xDC, 0x0B    /* mov.l .L_fn_chain_a, r12 — transform chain A function */
    .byte   0xD0, 0x17    /* mov.l .L_race_end_state, r0 — &race_end_state */
    bra     .L_dispatch_state            ! jump to state dispatch
    mov.l @r0, r0                        ! r0 = race_end_state value (delay slot)
.L_state_0:                              ! --- state 0: normal camera ---
    mov r13, r14                         ! r14 = car_index
    .byte   0xD4, 0x16    /* mov.l .L_s0_chain_a_src, r4 — state 0 chain A source array */
    shll2 r14                            ! r14 = car_index * 4 (dword offset)
    add r14, r11                         ! r11 += offset into rotation chain A params
    add r14, r4                          ! r4 += offset into chain A source array
    mov.l @r11, r5                       ! r5 = rotation chain A param [car_index]
    jsr @r12                             ! call transform chain A (sym_06031D8C)
    mov.l @r4, r4                        ! r4 = chain A source [car_index] (delay slot)
    add r14, r9                          ! r9 += offset into rotation chain B params
    mov.l @r9, r6                        ! r6 = rotation chain B param [car_index]
    mov r8, r5                           ! r5 = sprite index table base
    add #0x54, r5                        ! r5 = &sprite_index_table[0x2A] (+0x54 bytes)
    .byte   0xD4, 0x11    /* mov.l .L_s0_chain_b_model, r4 — state 0 chain B model array */
    bra     .L_chain_b_call              ! jump to chain B call
    mov.w @r5, r5                        ! r5 = display scale word (delay slot)
    .2byte  0xFFFF                       ! alignment padding
    .4byte  sym_060628C8
    .4byte  sym_06062874
.L_fn_chain_a:
    .4byte  sym_06031D8C
    .4byte  sym_0606291C
    .4byte  sym_06089E9E
    .4byte  sym_06062820
.L_fn_chain_b:
    .4byte  sym_06031A28
    .4byte  sym_060621DC
    .4byte  sym_06062130
    .4byte  sym_06062184
.L_sprite_index_table:
    .4byte  sym_06089E44
    .4byte  sym_060620DC
.L_rot_chain_b_params:
    .4byte  sym_060634DC
.L_rot_chain_a_params:
    .4byte  sym_060634F8
.L_race_end_state:
    .4byte  sym_0607EAD8
.L_s0_chain_a_src:
    .4byte  sym_06063488
.L_s0_chain_b_model:
    .4byte  sym_06063434
.L_state_1:                              ! --- state 1: alternate camera ---
    mov r13, r14                         ! r14 = car_index
    .byte   0xD4, 0x25    /* mov.l .L_s1_chain_a_src, r4 — state 1 chain A source array */
    shll2 r14                            ! r14 = car_index * 4 (dword offset)
    add r14, r11                         ! r11 += offset into rotation chain A params
    add r14, r4                          ! r4 += offset into chain A source array
    mov.l @r11, r5                       ! r5 = rotation chain A param [car_index]
    jsr @r12                             ! call transform chain A (sym_06031D8C)
    mov.l @r4, r4                        ! r4 = chain A source [car_index] (delay slot)
    add r14, r9                          ! r9 += offset into rotation chain B params
    mov.l @r9, r6                        ! r6 = rotation chain B param [car_index]
    mov r8, r5                           ! r5 = sprite index table base
    add #0x54, r5                        ! r5 = &sprite_index_table[0x2A]
    .byte   0xD4, 0x20    /* mov.l .L_s1_chain_b_model, r4 — state 1 chain B model array */
    bra     .L_chain_b_call              ! jump to chain B call
    mov.w @r5, r5                        ! r5 = display scale word (delay slot)
.L_state_2:                              ! --- state 2: third camera variant ---
    mov r13, r14                         ! r14 = car_index
    .byte   0xD4, 0x1F    /* mov.l .L_s2_chain_a_src, r4 — state 2 chain A source array */
    shll2 r14                            ! r14 = car_index * 4 (dword offset)
    add r14, r11                         ! r11 += offset into rotation chain A params
    add r14, r4                          ! r4 += offset into chain A source array
    mov.l @r11, r5                       ! r5 = rotation chain A param [car_index]
    jsr @r12                             ! call transform chain A (sym_06031D8C)
    mov.l @r4, r4                        ! r4 = chain A source [car_index] (delay slot)
    add r14, r9                          ! r9 += offset into rotation chain B params
    mov.l @r9, r6                        ! r6 = rotation chain B param [car_index]
    mov r8, r5                           ! r5 = sprite index table base
    add #0x54, r5                        ! r5 = &sprite_index_table[0x2A]
    mov.w @r5, r5                        ! r5 = display scale word
    .byte   0xD4, 0x1A    /* mov.l .L_s2_chain_b_model, r4 — state 2 chain B model array */
.L_chain_b_call:                         ! --- common chain B dispatch ---
    add r14, r4                          ! r4 += car_index offset into model array
    jsr @r10                             ! call transform chain B (sym_06031A28)
    mov.l @r4, r4                        ! r4 = chain B model param [car_index] (delay slot)
    bra     .L_epilogue                  ! jump to function exit
    nop                                  ! delay slot
.L_dispatch_state:                       ! --- race end state dispatch ---
    cmp/eq #0x0, r0                      ! state == 0?
    bt      .L_state_0                   ! yes: normal camera path
    cmp/eq #0x1, r0                      ! state == 1?
    bt      .L_state_1                   ! yes: alternate camera path
    cmp/eq #0x2, r0                      ! state == 2?
    bt      .L_state_2                   ! yes: third camera variant
.L_epilogue:                             ! --- function epilogue ---
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r8                      ! restore r8
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return to caller
    mov.l @r15+, r14                     ! restore r14 (delay slot)
