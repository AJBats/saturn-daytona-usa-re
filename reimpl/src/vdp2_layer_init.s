/* vdp2_layer_init -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015EB8 - 0x06015FB0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * vdp2_layer_init(layer_index):
 *   Initializes a VDP2 layer slot by copying configuration values from a
 *   per-layer config table into the 68-byte slot struct, then advances the
 *   slot's element_type counter.
 *
 *   The config table (sym_0605B8B8) contains 16-byte entries with initial
 *   velocity/limit values. The entry is selected by combining the slot's
 *   param_byte (+0x41) with the layer_index.
 *
 *   Slot struct fields written:
 *     +0x34  x_limit        (from config[+0x00])
 *     +0x10  x_vel          (from config[+0x04])
 *     +0x1C  abs_vel_flag   (set to 1 if |x_vel| == 16.0 fixed-point)
 *     +0x38  y_limit        (from config[+0x08])
 *     +0x18  y_vel          (from config[+0x0C])
 *     +0x30  alt_y_limit    (from config[+0x28], if bonus mode active)
 *     +0x04  alt_x_pos      (from config[+0x20], if bonus mode active)
 *     +0x02  element_type   (incremented by 1)
 *
 *   Input:  r4 = layer_index (byte)
 *   Output: slot fields updated in-place
 *   Calls:  int_abs (sym_06035438) — r0 = |r4|
 */

    .section .text.FUN_06015EB8


    .global vdp2_layer_init
    .type vdp2_layer_init, @function
vdp2_layer_init:
    mov.l r14, @-r15                        ! save r14
    mov.l r13, @-r15                        ! save r13
    mov.l r12, @-r15                        ! save r12
    mov.l r11, @-r15                        ! save r11
    mov.l r10, @-r15                        ! save r10
    sts.l pr, @-r15                         ! save return address
    mov.l   .L_pool_layer_config_table, r10 ! r10 = layer config table base (sym_0605B8B8)
    mov.l   .L_pool_slot_data_base, r13     ! r13 = slot data array base (sym_06084FC8, 68-byte structs)
    mov r4, r14                             ! r14 = layer_index (preserve across calls)
    extu.b r14, r12                         ! r12 = layer_index & 0xFF
    mov r12, r3                             ! r3 = layer_index (for stride calc)
    shll2 r12                               ! r12 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 16
    shll2 r3                                ! r3 = layer_index * 64
    add r3, r12                             ! r12 = layer_index * 68 (slot struct stride)
    exts.w r12, r12                         ! sign-extend offset to 32-bit
    add r13, r12                            ! r12 = &slot_data[layer_index]
    mov #0x41, r0                           ! r0 = 0x41 (offset of param_byte in slot)
    mov.b @(r0, r12), r11                   ! r11 = slot[+0x41] (param_byte / config sub-index)
    extu.b r11, r11                         ! r11 = zero-extend param_byte
    shll2 r11                               ! r11 = param_byte * 4
    extu.b r14, r2                          ! r2 = layer_index & 0xFF
    shll2 r2                                ! r2 = layer_index * 4
    shll2 r2                                ! r2 = layer_index * 16
    add r2, r11                             ! r11 = param_byte*4 + layer_index*16
    extu.b r11, r11                         ! r11 = combined config index (masked to byte)
    extu.b r11, r4                          ! r4 = config index (copy)
    shll2 r4                                ! r4 = config_index * 4 (byte offset into table)
    add r10, r4                             ! r4 = &layer_config[config_index]
    mov.l @r4, r3                           ! r3 = config[+0x00] (x_limit value)
    mov.l r3, @(52, r12)                    ! slot[+0x34] = x_limit
    mov #0x0, r3                            ! r3 = 0
    mov.l @(4, r4), r2                      ! r2 = config[+0x04] (x_vel value)
    mov.l r2, @(16, r12)                    ! slot[+0x10] = x_vel
    mov.l r3, @(28, r12)                    ! slot[+0x1C] = 0 (clear abs_vel_flag)
    mov.l   .L_pool_int_abs, r3             ! r3 = &int_abs function (sym_06035438)
    jsr @r3                                 ! call int_abs(x_vel) — r0 = |r4|
    mov.l @(16, r12), r4                    ! (delay slot) r4 = slot[+0x10] (x_vel, arg to int_abs)
    mov.l   .L_fp_sixteen, r2               ! r2 = 0x00100000 (16.0 in 16.16 fixed-point)
    cmp/eq r2, r0                           ! test: |x_vel| == 16.0?
    bf      .L_skip_vel_flag                ! if not equal, skip flag set
    extu.b r14, r2                          ! r2 = layer_index & 0xFF
    mov r2, r3                              ! r3 = layer_index (for stride calc)
    shll2 r2                                ! r2 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 16
    shll2 r3                                ! r3 = layer_index * 64
    add r3, r2                              ! r2 = layer_index * 68
    exts.w r2, r2                           ! sign-extend offset
    add r13, r2                             ! r2 = &slot_data[layer_index]
    mov #0x1, r1                            ! r1 = 1
    mov.l r1, @(28, r2)                     ! slot[+0x1C] = 1 (abs_vel_flag: velocity is exactly 16.0)
.L_skip_vel_flag:
    extu.b r14, r5                          ! r5 = layer_index & 0xFF
    extu.b r11, r4                          ! r4 = config_index & 0xFF
    mov r5, r3                              ! r3 = layer_index (for stride calc)
    shll2 r4                                ! r4 = config_index * 4
    shll2 r5                                ! r5 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 4
    add r10, r4                             ! r4 = &layer_config[config_index]
    shll2 r3                                ! r3 = layer_index * 16
    shll2 r3                                ! r3 = layer_index * 64
    add r3, r5                              ! r5 = layer_index * 68
    exts.w r5, r5                           ! sign-extend offset
    mov.l @(8, r4), r3                      ! r3 = config[+0x08] (y_limit value)
    add r13, r5                             ! r5 = &slot_data[layer_index]
    mov.l r3, @(56, r5)                     ! slot[+0x38] = y_limit
    mov.l @(12, r4), r2                     ! r2 = config[+0x0C] (y_vel value)
    mov.l r2, @(24, r5)                     ! slot[+0x18] = y_vel
    mov.l   .L_pool_bonus_mode_flag, r0     ! r0 = &bonus_mode_flag (sym_06085F89)
    mov.b @r0, r0                           ! r0 = bonus_mode_flag (byte)
    tst r0, r0                              ! test: bonus mode active?
    bt      .L_skip_alt_config              ! if zero (inactive), skip alternate config
    extu.b r14, r4                          ! r4 = layer_index & 0xFF
    mov r4, r3                              ! r3 = layer_index (for stride calc)
    shll2 r4                                ! r4 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 16
    shll2 r3                                ! r3 = layer_index * 64
    add r3, r4                              ! r4 = layer_index * 68
    exts.w r4, r4                           ! sign-extend offset
    add r13, r4                             ! r4 = &slot_data[layer_index]
    extu.b r14, r5                          ! r5 = layer_index & 0xFF (for alt config offset)
    shll2 r5                                ! r5 = layer_index * 4
    shll2 r5                                ! r5 = layer_index * 16
    add #0x8, r5                            ! r5 = layer_index * 16 + 8 (alt config block offset)
    shll2 r5                                ! r5 = (layer_index * 16 + 8) * 4 = layer_index*64 + 32
    add r10, r5                             ! r5 = &layer_config_table[alt_offset]
    mov.l @(8, r5), r3                      ! r3 = alt_config[+0x08] (alternate y_limit)
    mov.l r3, @(48, r4)                     ! slot[+0x30] = alt_y_limit
    mov.l @r5, r2                           ! r2 = alt_config[+0x00] (alternate x_pos)
    mov.l r2, @(4, r4)                      ! slot[+0x04] = alt_x_pos
.L_skip_alt_config:
    extu.b r14, r14                         ! r14 = layer_index & 0xFF (final cleanup)
    mov r14, r3                             ! r3 = layer_index (for stride calc)
    shll2 r14                               ! r14 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 4
    shll2 r3                                ! r3 = layer_index * 16
    shll2 r3                                ! r3 = layer_index * 64
    add r3, r14                             ! r14 = layer_index * 68
    exts.w r14, r14                         ! sign-extend offset
    add r13, r14                            ! r14 = &slot_data[layer_index]
    mov.b @(2, r14), r0                     ! r0 = slot[+0x02] (element_type)
    mov r0, r2                              ! r2 = element_type
    add #0x1, r2                            ! r2 = element_type + 1
    mov r2, r0                              ! r0 = new element_type
    mov.b r0, @(2, r14)                     ! slot[+0x02] = incremented element_type
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return
    mov.l @r15+, r14                        ! (delay slot) restore r14
    .2byte  0xFFFF
.L_pool_layer_config_table:
    .4byte  sym_0605B8B8                    /* layer config table (16-byte entries: x_limit, x_vel, y_limit, y_vel) */
.L_pool_slot_data_base:
    .4byte  sym_06084FC8                    /* slot data array base (68-byte structs) */
.L_pool_int_abs:
    .4byte  sym_06035438                    /* int_abs: r0 = |r4| */
.L_fp_sixteen:
    .4byte  0x00100000                      /* 16.0 (16.16 fixed-point) */
.L_pool_bonus_mode_flag:
    .4byte  sym_06085F89                    /* bonus mode flag (byte) */
