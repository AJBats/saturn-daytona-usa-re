/* obj_render_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06020E84 - 0x060210B8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Object render setup — prepares the VDP1 scene command buffer each frame.
 *
 * 1. Manages a render-pending countdown timer (render_timer_byte at
 *    sym_06089594). When the trigger flag (render_trigger at sym_06089595)
 *    is set, resets the timer to 10 and clears the trigger.
 *
 * 2. Reads the current view mode from the car state struct (offset +0x214,
 *    masked with 0xCC). Dispatches to one of four tile-blit paths:
 *      0x00 → default chase view  (config table slot 9)
 *      0x44 → cockpit/bumper view (config table slot 10 or 11)
 *      0x88 → rear-view mirror    (config table slot 10 or 11)
 *      0xCC → replay camera       (config table slot 12, offset +0x60)
 *    Each path calls tile_rect_blit (sym_06028400) to copy a sprite rect
 *    from the scene config table (sym_06063750) into VRAM.
 *
 * 3. Stores the current car state pointer into sym_06089598 for the
 *    secondary SH-2 to reference.
 *
 * 4. If game state (sym_06063E20) == 1 (active race), fills the scene
 *    coordinate array (offset +0x1810 from sym_06087C84) with 22 entries
 *    of interpolated X positions based on car heading angle, then calls
 *    cmd_slot_write + scene_buffer_init + cmd_queue_commit.
 *
 * Called from: per-frame render orchestrator.
 * Related: obj_render_cleanup (resets the same state), obj_render_update.
 */

    .section .text.FUN_06020E84


    .global obj_render_setup
    .type obj_render_setup, @function
obj_render_setup:
    sts.l pr, @-r15
    add #-0x4, r15                          ! allocate 4 bytes scratch on stack
    mov.l   .L_render_timer_byte, r10       ! r10 = &render_timer (countdown byte)
    mov.l   .L_camera_dir_flip, r11         ! r11 = &camera_dir_flip (0=normal, 1=flipped)
    mov.l   .L_scene_config_base, r14       ! r14 = scene config struct base
    mov.l   .L_render_trigger, r4           ! r4 = &render_trigger flag
    mov.b @r4, r0                           ! r0 = trigger flag
    extu.b r0, r0
    tst r0, r0                              ! trigger set?
    bt/s    .L_trigger_cleared              ! if not, skip reset
    mov #0x0, r13                           ! (delay) r13 = 0 (used throughout)
    mov #0xA, r3                            ! reset timer to 10 frames
    mov.b r3, @r10                          ! render_timer = 10
    extu.b r13, r2
    mov.b r2, @r4                           ! clear trigger flag
.L_trigger_cleared:
    mov.b @r10, r0                          ! r0 = render_timer
    extu.b r0, r0
    tst r0, r0                              ! timer already zero?
    bt      .L_timer_done                   ! if zero, skip decrement
    mov.b @r10, r3
    add #-0x1, r3                           ! timer--
    mov.b r3, @r10
.L_timer_done:
    ! --- View mode tile-blit dispatch ---
    mov.l   .L_car_array_base, r2           ! r2 = &car_array_ptr
    mov.w   DAT_06020f2e, r0                ! r0 = 0x0214 (view mode field offset)
    mov.l @r2, r2                           ! r2 = car_array base
    mov.l @(r0, r2), r3                     ! r3 = car_array[+0x214] (current view mode word)
    mov.l   .L_prev_car_state, r2           ! r2 = &prev_car_state
    mov.l @r2, r2                           ! r2 = prev_car_state
    cmp/eq r2, r3                           ! view mode unchanged?
    bt      .L_view_dispatch_done           ! if same as last frame, skip tile blit
    mov.l   .L_secondary_proc_flag, r2      ! r2 = &secondary_processing_flag
    mov.b @r2, r2
    tst r2, r2                              ! secondary SH-2 busy?
    bf      .L_view_dispatch_done           ! if busy, skip (avoid race condition)
    mov.w   .L_vram_dest_offset, r9         ! r9 = 0x0900 (VRAM destination offset)
    mov.l   .L_scene_tile_table, r12        ! r12 = scene tile config table base
    mov.l   .L_car_array_base, r0
    mov.l @r0, r0
    mov.w   DAT_06020f2e, r1
    mov.l @(r0, r1), r0                     ! r0 = view mode word
    bra     .L_view_mode_dispatch
    and #0xCC, r0                           ! (delay) mask to view type bits
.L_view_replay:                             ! view_mode & 0xCC == 0xCC (replay camera)
    mov r12, r7
    mov r9, r6                              ! r6 = VRAM dest offset (0x0900)
    add #0x60, r7                           ! r7 = tile_table + 0x60 (slot 12)
    mov.l r7, @r15                          ! save slot ptr on stack
    mov.l @(4, r7), r7                      ! r7 = slot[12].tile_data (src tiles)
    mov.l @r15, r5                          ! r5 = &slot[12]
    mov.l   .L_fn_tile_rect_blit, r3
    mov.l @r5, r5                           ! r5 = slot[12].dimensions
    jsr @r3                                 ! tile_rect_blit(4, dimensions, dest, tiles)
    mov #0x4, r4                            ! (delay) r4 = blit mode 4
    bra     .L_view_dispatch_done
    nop
.L_view_rear:                               ! view_mode & 0xCC == 0x88 (rear-view)
    mov.b @r11, r0                          ! r0 = camera_dir_flip
    tst r0, r0
    bf      .L_rear_slot_a                  ! if flipped, use slot 10
    bra     .L_rear_compute_src
    mov #0xB, r7                            ! (delay) normal: src = slot 11
.L_rear_slot_a:
    mov #0xA, r7                            ! flipped: src = slot 10
.L_rear_compute_src:
    shll2 r7                                ! r7 *= 4
    mov.b @r11, r0
    shll r7                                 ! r7 *= 2 (total: slot * 8 = entry stride)
    add r12, r7                             ! r7 = &tile_table[slot]
    mov.l @(4, r7), r7                      ! r7 = tile_data pointer
    tst r0, r0                              ! dir_flip == 0?
    bf/s    .L_rear_dest_slot_a             ! if flipped, dest = slot 10
    mov r9, r6                              ! (delay) r6 = VRAM dest offset
    bra     .L_rear_dest_slot_b
    mov #0xB, r5                            ! (delay) normal: dest dims from slot 11
.L_rear_dest_slot_a:
    mov #0xA, r5                            ! flipped: dest dims from slot 10
.L_rear_dest_slot_b:
    shll2 r5                                ! compute table entry address
    mov.l   .L_fn_tile_rect_blit, r3
    shll r5
    add r12, r5
    mov.l @r5, r5                           ! r5 = dimensions word
    jsr @r3                                 ! tile_rect_blit(4, dims, dest, tiles)
    mov #0x4, r4
    bra     .L_view_dispatch_done
    nop
.L_view_cockpit:                            ! view_mode & 0xCC == 0x44 (cockpit/bumper)
    mov.b @r11, r0                          ! r0 = camera_dir_flip
    tst r0, r0
    bf      .L_cockpit_slot_b               ! if flipped, use slot 11
    bra     .L_cockpit_compute_src
    mov #0xA, r7                            ! (delay) normal: src = slot 10

    ! --- Inline data & constant pool A ---
    .global DAT_06020f2e
DAT_06020f2e:
    .2byte  0x0214                          /* car state struct view mode offset */
.L_vram_dest_offset:
    .2byte  0x0900                          /* VRAM destination offset for tile blit */
    .2byte  0xFFFF                          /* padding */
.L_render_timer_byte:
    .4byte  sym_06089594                    /* render countdown timer (byte) */
.L_camera_dir_flip:
    .4byte  sym_06078663                    /* camera direction flip flag (byte) */
.L_scene_config_base:
    .4byte  sym_06087C84                    /* scene config struct base */
.L_render_trigger:
    .4byte  sym_06089595                    /* render trigger flag (byte) */
.L_car_array_base:
    .4byte  sym_0607E944                    /* car array base pointer */
.L_prev_car_state:
    .4byte  sym_06089598                    /* previous car state (for change detect) */
.L_secondary_proc_flag:
    .4byte  sym_06083255                    /* secondary SH-2 processing flag */
.L_scene_tile_table:
    .4byte  sym_06063750                    /* scene tile config table */
.L_fn_tile_rect_blit:
    .4byte  sym_06028400                    /* tile_rect_blit function */
.L_cockpit_slot_b:
    mov #0xB, r7                            ! flipped: src = slot 11
.L_cockpit_compute_src:
    shll2 r7                                ! r7 *= 4
    mov.b @r11, r0
    shll r7                                 ! r7 *= 2 (slot * 8 = entry stride)
    add r12, r7                             ! r7 = &tile_table[slot]
    mov.l @(4, r7), r7                      ! r7 = tile_data pointer
    tst r0, r0                              ! dir_flip == 0?
    bf/s    .L_cockpit_dest_slot_b          ! if flipped, swap dest slot
    mov r9, r6                              ! (delay) r6 = VRAM dest offset
    bra     .L_cockpit_dest_slot_a
    mov #0xA, r5                            ! (delay) normal: dest dims from slot 10
.L_cockpit_dest_slot_b:
    mov #0xB, r5                            ! flipped: dest dims from slot 11
.L_cockpit_dest_slot_a:
    shll2 r5                                ! compute table entry address
    mov.l   .L_fn_tile_rect_blit_b, r3
    shll r5
    add r12, r5
    mov.l @r5, r5                           ! r5 = dimensions word
    jsr @r3                                 ! tile_rect_blit(4, dims, dest, tiles)
    mov #0x4, r4
    bra     .L_view_dispatch_done
    nop
.L_view_default:                            ! view_mode & 0xCC == 0x00 (chase camera)
    mov r12, r7
    mov r9, r6                              ! r6 = VRAM dest offset (0x0900)
    add #0x48, r7                           ! r7 = tile_table + 0x48 (slot 9)
    mov.l r7, @r15                          ! save slot ptr on stack
    mov.l @(4, r7), r7                      ! r7 = slot[9].tile_data
    mov.l @r15, r5
    mov.l   .L_fn_tile_rect_blit_b, r3
    mov.l @r5, r5                           ! r5 = slot[9].dimensions
    jsr @r3                                 ! tile_rect_blit(4, dims, dest, tiles)
    mov #0x4, r4
    bra     .L_view_dispatch_done
    nop
.L_view_mode_dispatch:                      ! r0 = view_mode & 0xCC
    cmp/eq #0x0, r0                         ! 0x00 = chase camera?
    bt      .L_view_default
    cmp/eq #0x44, r0                        ! 0x44 = cockpit/bumper?
    bt      .L_view_cockpit
    mov.w   .L_view_mode_rear, r1           ! r1 = 0x0088
    cmp/eq r1, r0                           ! 0x88 = rear-view?
    bt      .L_view_rear
    mov.w   DAT_06020fc8, r1                ! r1 = 0x00CC
    cmp/eq r1, r0                           ! 0xCC = replay camera?
    bt      .L_view_replay
.L_view_dispatch_done:
    ! --- Store current car state for secondary SH-2, check game state ---
    mov.l   .L_car_array_base_b, r2         ! r2 = &car_array_ptr
    mov.w   DAT_06020fca, r0                ! r0 = 0x0214 (car state offset)
    mov.l   .L_cur_car_state_store, r1      ! r1 = &cur_car_state_store
    mov.l @r2, r2                           ! r2 = car_array base
    mov.l @(r0, r2), r3                     ! r3 = car_array[+0x214] (current state)
    mov.l r3, @r1                           ! store for secondary SH-2 to read
    mov.l   .L_game_state_flag, r0          ! r0 = &game_state
    mov.l @r0, r0                           ! r0 = game_state value
    cmp/eq #0x1, r0                         ! game_state == 1 (active race)?
    bt      .L_active_race                  ! if yes, fill coord array
    bra     .L_early_return                 ! otherwise, return early
    nop
    ! --- Inline data & constant pool B ---
.L_view_mode_rear:
    .2byte  0x0088                          /* view mode: rear-view mirror */

    .global DAT_06020fc8
DAT_06020fc8:
    .2byte  0x00CC                          /* view mode: replay camera */

    .global DAT_06020fca
DAT_06020fca:
    .2byte  0x0214                          /* car state struct view mode offset (dup) */
.L_fn_tile_rect_blit_b:
    .4byte  sym_06028400                    /* tile_rect_blit function (pool B copy) */
.L_car_array_base_b:
    .4byte  sym_0607E944                    /* car array base pointer (pool B copy) */
.L_cur_car_state_store:
    .4byte  sym_06089598                    /* current car state store (for secondary) */
.L_game_state_flag:
    .4byte  sym_06063E20                    /* game state flag (1 = active race) */
.L_active_race:
    ! --- Fill scene coordinate array based on car heading ---
    mov r13, r12                            ! r12 = 0 (running positive X accumulator)
    mov r13, r6                             ! r6 = 0 (running negative X accumulator)
    mov.b @r10, r7                          ! r7 = render_timer value (table index)
    mov #0x60, r0                           ! offset +0x60 in car struct = heading angle
    mov.l   .L_heading_lookup_table, r3     ! r3 = heading lookup table base
    mov.l   .L_car_array_base_c, r4
    extu.b r7, r7                           ! zero-extend timer index
    mov.l @r4, r4                           ! r4 = car_array base
    shll2 r7                                ! r7 *= 4 (table entry size)
    mov.l @(r0, r4), r4                     ! r4 = car[+0x60] (heading angle, fixed-point)
    add r3, r7                              ! r7 = &heading_table[timer]
    shar r4                                 ! arithmetic shift right x14 total
    mov.b @r11, r0                          ! r0 = camera_dir_flip
    shar r4                                 ! (continues 14x shar = divide by 16384)
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4                                 ! r4 = heading >> 14 (coarse heading step)
    tst r0, r0                              ! camera flipped?
    bt/s    .L_heading_positive             ! if not flipped, keep sign
    mov.l @r7, r7                           ! (delay) r7 = heading_table[timer] (Y base)
    neg r4, r4                              ! negate step for flipped camera
.L_heading_positive:
    mov.w   DAT_06021098, r3                ! r3 = 0x1000 (positive clamp limit)
    cmp/ge r3, r4                           ! step >= 0x1000?
    bt      .L_clamp_step_to_zero           ! if so, clamp to zero
    mov.w   DAT_0602109a, r3                ! r3 = 0xF000 (sign-extended = -0x1000)
    cmp/gt r3, r4                           ! step > -0x1000?
    bf      .L_clamp_step_to_zero           ! if step <= -0x1000, clamp to zero
    mov r13, r4                             ! clamp: step = 0
.L_clamp_step_to_zero:
    mov.w   DAT_0602109c, r0                ! r0 = 0x1868 (clear field offset)
    mov.l r13, @(r0, r14)                   ! config[+0x1868] = 0 (clear prev value)
    extu.b r13, r5                          ! r5 = 0 (loop counter)
.L_coord_fill_loop:                         ! fill 22 pairs of X coordinates
    add r4, r12                             ! pos_x += step (positive accumulator)
    extu.b r5, r3                           ! r3 = loop index
    mov r8, r2                              ! r2 = r8 (base index from caller)
    sub r4, r6                              ! neg_x -= step (negative accumulator)
    mov r12, r1                             ! r1 = pos_x
    sub r3, r2                              ! r2 = r8 - index (reverse index)
    add r7, r1                              ! r1 = pos_x + Y_base (final coord)
    shll2 r2                                ! r2 *= 4 (long word stride)
    mov.w   DAT_0602109e, r3                ! r3 = 0x1810 (coord array offset)
    add r14, r3                             ! r3 = &config[+0x1810]
    add r3, r2                              ! r2 = &coord_array[r8 - index]
    extu.b r5, r3
    mov.l r1, @r2                           ! coord_array[r8 - index] = pos_x + Y_base
    shll2 r3                                ! r3 = index * 4
    add #0x1, r5                            ! index++
    mov r6, r1                              ! r1 = neg_x
    mov.w   DAT_0602109e, r2                ! r2 = 0x1810
    add r7, r1                              ! r1 = neg_x + Y_base
    add r14, r2
    add r2, r3                              ! r3 = &coord_array[index]
    add #0x58, r3                           ! r3 += 0x58 (second half of array, 22 entries)
    mov #0x16, r2                           ! r2 = 22 (loop limit)
    mov.l r1, @r3                           ! coord_array[index + 22] = neg_x + Y_base
    extu.b r5, r3
    cmp/ge r2, r3                           ! index >= 22?
    bf      .L_coord_fill_loop              ! loop until 22 entries filled
    ! --- Issue scene commands ---
    mov.l   .L_fn_cmd_slot_write, r3
    jsr @r3                                 ! cmd_slot_write(8) — write channel 8
    mov #0x8, r4                            ! (delay) r4 = channel 8
    mov.l   .L_scene_buf_init_arg, r4       ! r4 = scene config base (pattern config)
    mov.l   .L_fn_scene_buf_init, r3
    jsr @r3                                 ! scene_buffer_init(config_base)
    nop
    add #0x4, r15                           ! free scratch space
    lds.l @r15+, pr                         ! restore registers
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    mov.l   .L_fn_cmd_queue_commit, r3
    jmp @r3                                 ! tail-call cmd_queue_commit()
    mov.l @r15+, r14                        ! (delay) restore r14
.L_early_return:                            ! game_state != 1, skip coord fill
    add #0x4, r15                           ! free scratch space
    lds.l @r15+, pr                         ! restore registers
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14                        ! (delay) restore r14

    ! --- Inline data & constant pool C ---
    .global DAT_06021098
DAT_06021098:
    .2byte  0x1000                          /* heading step positive clamp (+4096) */

    .global DAT_0602109a
DAT_0602109a:
    .2byte  0xF000                          /* heading step negative clamp (-4096 sign-ext) */

    .global DAT_0602109c
DAT_0602109c:
    .2byte  0x1868                          /* config clear field offset */

    .global DAT_0602109e
DAT_0602109e:
    .2byte  0x1810                          /* scene coord array offset in config */
.L_heading_lookup_table:
    .4byte  sym_0604D3E0                    /* heading-to-Y lookup table (indexed by timer) */
.L_car_array_base_c:
    .4byte  sym_0607E944                    /* car array base pointer (pool C copy) */
.L_fn_cmd_slot_write:
    .4byte  sym_0603850C                    /* cmd_slot_write (command queue channel write) */
.L_scene_buf_init_arg:
    .4byte  sym_06087C84                    /* scene config base (arg for scene_buffer_init) */
.L_fn_scene_buf_init:
    .4byte  scene_buffer_init               /* scene buffer initialization function */
.L_fn_cmd_queue_commit:
    .4byte  sym_06038520                    /* cmd_queue_commit (signal command ready) */
