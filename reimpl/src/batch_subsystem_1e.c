#include "game.h"

extern int DAT_0601e162;
extern int DAT_0601e164;
extern int DAT_0601e166;
extern int DAT_0601e238;
extern int DAT_0601e23a;
extern int DAT_0601e23c;
extern int DAT_0601e23e;
extern int DAT_0601e240;
extern int DAT_0601e242;
extern int DAT_0601e244;
extern int DAT_0601e246;
extern int DAT_0601e248;
extern int DAT_0601e24a;
extern int DAT_0601e24c;
extern int DAT_0601e24e;
extern int DAT_0601e444;
extern int DAT_0601efda;
extern int DAT_0601f5c6;
extern int DAT_0601f6ba;
extern int DAT_0601f804;
extern int DAT_0601f806;
extern int DAT_0601f962;
extern int DAT_0601f964;
extern int DAT_0601fa26;
extern int DAT_0601fac4;
extern int DAT_0601fac6;
extern int DAT_0601fac8;
extern int DAT_0601faca;
extern int DAT_0601facc;
extern int DAT_0601face;
extern int DAT_0601fba6;
extern int DAT_0601fba8;
extern int DAT_0601fbaa;
extern int DAT_0601fbac;
extern int DAT_0601fbae;
extern int DAT_0601fbb0;
extern int DAT_0601fbb2;
extern int DAT_0601fbb4;
extern int DAT_0601fbb6;
extern int DAT_0601fbb8;
extern int DAT_0601fbba;
extern int DAT_0601fbbc;
extern int DAT_0601fbbe;
extern int DAT_0601fbc0;
extern int DAT_0601fbc2;
extern int DAT_0601fbc4;
extern int DAT_0601fbc6;
extern int DAT_0601fbc8;
extern int DAT_0601fc8e;
extern int DAT_0601fc90;
extern int DAT_0601fc92;
extern int DAT_0601fc94;
extern int DAT_0601fc96;
extern int DAT_0601fc98;
extern int DAT_0601fc9a;
extern int DAT_0601fc9c;
extern int DAT_0601fc9e;
extern int DAT_0601fca0;
extern int DAT_0601fca2;
extern int DAT_0601fca4;
extern int DAT_0601fca6;
extern int DAT_0601fca8;
extern int DAT_0601fe96;
extern int DAT_0601ff8a;
extern int DAT_0601ff8c;
extern int DAT_0601ff8e;
extern int DAT_0601ff90;
extern int DAT_0601ff92;
extern void input_state_copy();
extern void backup_mem_format();
extern void backup_device_enumerate();
extern int backup_device_open(unsigned short slot);
extern unsigned int backup_mem_write_all();
extern int bios_sound_poll();
extern int backup_mem_write();
extern int backup_mem_read();
extern unsigned int FUN_0601eb70();
extern char * FUN_0601ebda();
extern char * FUN_0601efc4();
extern int cdda_replay_check();
extern void bcd_timestamp_decode();
extern int save_score_check_update();
extern void cdda_buffer_select(unsigned char);
extern void standings_screen_render();
extern void mode_transition_vdp_reset();
extern void replay_car_state_load();
extern void car_replay_state_init();
extern int vdp1_texture_palette_init();
extern int PTR_DAT_0601e168;
extern int PTR_DAT_0601ebf0;
extern int PTR_DAT_0601f808;
extern int PTR_DAT_0601fa28;
extern int PTR_DAT_0601fd48;

/* nop_e0de -- Placeholder / stripped function (no-op). */
void FUN_0601e0de(void)
{
    return;
}

/* menu_vdp_palette_setup -- Load VDP2 palettes for menu/save screen.
 * Normal mode: single palette + sprite. Demo mode: multi-layer palette
 * with 4 sprites, dynamic animation, and course-specific variant. */
#if 0 /* menu_vdp_palette_setup -- redirected to ASM import via linker PROVIDE */
void menu_vdp_palette_setup()
{
    short tile_off;
    char *vdp_base = (char *)0x00008000;           /* VDP2 VRAM base */
    char *vdp_submit = (char *)0x06028400;         /* VDP1 command submit */
    char *gfx_table = (char *)0x06063750;

    if (DEMO_MODE_FLAG == 0) {
        /* Normal mode: single palette + sprite */
        (*(int(*)())0x0602761E)(0x25F00100, 0x0604892C, 0x20);
        (*(int(*)())vdp_submit)(8, *(int *)(gfx_table + 0x10), (int)DAT_0601e162,
                              vdp_base + *(int *)(gfx_table + 0x14));
        vdp_base = vdp_base + *(int *)((int)(gfx_table + DAT_0601e164) + 4);
        gfx_table = *(char **)(gfx_table + DAT_0601e164);
        tile_off = DAT_0601e166;
    } else {
        /* Demo mode: multi-layer palette + sprites */
        (*(int(*)())0x0602761E)(0x25F00100, 0x0605DFCC, 0x20);
        tile_off = DAT_0601e238;
        if (*(int *)0x06078644 == 1) {
            tile_off = PTR_DAT_0601e168;           /* alternate course */
        }
        (*(int(*)())vdp_submit)(8, *(int *)(gfx_table + tile_off), (int)DAT_0601e23a,
                              vdp_base + *(int *)((int)(gfx_table + tile_off) + 4));
        vdp_base = (char *)0x00009000;
        (*(int(*)())vdp_submit)(8, *(int *)(gfx_table + DAT_0601e23c), 0x3c2,
                              0x00009000 + *(int *)((int)(gfx_table + DAT_0601e23c) + 4));
        (*(int(*)())vdp_submit)(8, *(int *)(gfx_table + DAT_0601e240), 0x4c2,
                              vdp_base + *(int *)((int)(gfx_table + DAT_0601e240) + 4));
        (*(int(*)())vdp_submit)(8, *(int *)(gfx_table + DAT_0601e244), 0x5c2,
                              vdp_base + *(int *)((int)(gfx_table + DAT_0601e244) + 4));
        (*(int(*)())0x0601AB8C)();                 /* animation handler */
        FUN_0601e26c(*(int *)0x06086008);
        tile_off = DAT_0601e248;
        (*(int(*)())vdp_submit)(8, 0x0605DFF4, (int)DAT_0601e24a,
                              vdp_base + *(int *)(gfx_table + DAT_0601e248 + 4));
        FUN_0601e26c(*(int *)0x06086004);
        (*(int(*)())vdp_submit)(8, 0x0605DFF4, (int)DAT_0601e24c,
                              vdp_base + *(int *)(gfx_table + tile_off + 4));
        FUN_0601e26c(0);
        vdp_base = vdp_base + *(int *)(gfx_table + tile_off + 4);
        gfx_table = (char *)0x0605DFF4;
        tile_off = DAT_0601e24e;
    }

    (*(int(*)())vdp_submit)(8, gfx_table, (int)tile_off, vdp_base);
    *(int *)0x06087068 = 0;
    *(int *)0x0605DFF0 = 0;
}
#endif /* menu_vdp_palette_setup */
#if 0 /* FUN_0601E100 -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // void FUN_0601e100() __attribute__((alias("menu_vdp_palette_setup")));
#endif

/* input_state_copy -- Read 8-byte input buffer from peripheral handler. */
#if 0 /* input_state_copy -- redirected to ASM import via linker PROVIDE */
void input_state_copy(void)
{
  int *periph_ptr = (int *)0x06087064;
  unsigned short *input_arr = (unsigned short *)(0x0605DFF4 + 4);
  unsigned char i;

  *periph_ptr = (*(int(*)())0x06005DD4)();

  i = 0;
  do {
    input_arr[i] = (unsigned short)*(unsigned char *)(*periph_ptr + i);
    i++;
  } while (i < 8);
}
#endif /* input_state_copy */
#if 0 /* FUN_0601E26C -- replaced by ASM import */
/* REMOVED: conflicting alias */ // void FUN_0601e26c() __attribute__((alias("input_state_copy")));
#endif

void backup_mem_format()
{
    char *smpc_status = (char *)0x20100063;     /* SMPC SF register */
    char *buf_ptr     = (char *)0x0605E068;     /* partition buffer pointer */
    char *size_table  = (char *)0x0604A5C0;     /* partition size table */
    char *channel_ptr = (char *)0x060877D8;     /* current channel */
    unsigned int i;

    /* Clear partition buffer if not yet formatted */
    if (*(int *)0x06087080 == '\0') {
        for (i = 0; i < *(unsigned int *)(size_table + (unsigned int)(unsigned char)(*channel_ptr << 2)); i = i + 1) {
            *(char *)(*(int *)buf_ptr + i) = 0;
        }
    }

    /* Acquire SMPC bus */
    do { } while ((*smpc_status & 1) == 1);
    *smpc_status = 1;
    SMPC_COMREG = 0x1a;
    do { } while ((*smpc_status & 1) != 0);

    /* Call BIOS format function */
    (*(int(*)())(*(int *)0x06000358))(*(int *)0x0605E060, *(int *)0x0605E064, 0x06087086);
    backup_device_enumerate();

    /* Release SMPC bus */
    do { } while ((*smpc_status & 1) == 1);
    *smpc_status = 1;
    SMPC_COMREG = 0x19;
    do { } while ((*smpc_status & 1) != 0);
}

/* FUN_0601E26C -- original binary (72 bytes) */
__asm__(
    ".section .text.FUN_0601E26C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E26C\n"
    ".global _FUN_0601e26c\n"
    ".type _FUN_0601E26C, @function\n"
    "_FUN_0601E26C:\n"
    "_FUN_0601e26c:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0xDC, 0x0C, 0xDD, 0x0D, 0xD3, 0x0D, 0x43, 0x0B\n"  /* 0x0601E26C */
    ".byte 0xEE, 0x08, 0x2D, 0x02, 0xE4, 0x00, 0x62, 0x4C, 0x60, 0x4C, 0x63, 0xD2, 0x42, 0x00, 0x74, 0x01\n"  /* 0x0601E27C */
    ".byte 0x01, 0x3C, 0x32, 0xCC, 0x61, 0x1C, 0x63, 0x4C, 0x60, 0x13, 0x81, 0x22, 0x33, 0xE3, 0x8B, 0xF2\n"  /* 0x0601E28C */
    ".byte 0x4F, 0x26, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xFF, 0xFF, 0x06, 0x05, 0xDF, 0xF4\n"  /* 0x0601E29C */
    ".byte 0x06, 0x08, 0x70, 0x64, 0x06, 0x00, 0x5D, 0xD4\n"  /* 0x0601E2AC */
);


/* backup_device_enumerate -- Scan up to 3 backup devices, open each,
 * verify, check capacity, and store descriptors. */
#if 0 /* backup_device_enumerate -- redirected to ASM import via linker PROVIDE */
void backup_device_enumerate()
{
    char *desc_base = (char *)0x06087094;       /* device descriptor array */
    short default_wp = DAT_0601e444;            /* default write-protect flag */
    unsigned int dev_count = 0;
    unsigned short dev_idx = 0;

    do {
        if (2 < dev_idx) {
            *(short *)0x06087084 = (short)dev_count;
            return;
        }
        if (*(short *)(0x06087086 + (unsigned int)(dev_idx << 2)) != 0) {
            /* Store device ID in descriptor */
            *(unsigned short *)(desc_base + (((dev_count & 0xffff) << 5) + 0x1c)) = dev_idx;
            int status = backup_device_open(dev_count);

            if (status != 0) {
                if (status == 1) goto LAB_0601e46a;
                if (status == 2) {
                    /* Verify device and set write-protect */
                    int verify = bios_sound_poll(*(short *)(desc_base + (((dev_count & 0xffff) << 5) + 0x1c)));
                    if (verify == 0) {
                        desc_base[(dev_count & 0xffff) << 5 + 0x1f] = 1;
                    } else {
                        desc_base[(dev_count & 0xffff) << 5 + 0x1f] = (char)default_wp;
                    }
                }
            }

            /* Check capacity: compare available space vs required */
            if (*(unsigned int *)(desc_base + (((dev_count & 0xffff) << 5) + 0xc)) <
                *(int *)(0x0604A5C0 + (unsigned int)(unsigned char)*(int *)(0x060877D8 << 2)) + 0x20U) {
                desc_base[(dev_count & 0xffff) << 5 + 0x1e] = 0;   /* insufficient */
            } else {
                desc_base[(dev_count & 0xffff) << 5 + 0x1e] = 1;   /* sufficient */
            }
            dev_count = dev_count + 1;
        }
LAB_0601e46a:
        dev_idx = dev_idx + 1;
    } while( 1 );
}
#endif /* backup_device_enumerate */
#if 0 /* FUN_0601E37C -- replaced by ASM import */
/* REMOVED: conflicting alias */ // void FUN_0601e37c() __attribute__((alias("backup_device_enumerate")));
#endif

#if 0 /* backup_device_open -- redirected to ASM import via linker PROVIDE */
int backup_device_open(unsigned short slot)
{
    char *desc = (char *)(0x06087094 + (unsigned int)(slot << 5));
    short sound_id = *(short *)(desc + 0x1C);

    /* BIOS sound open (vtable[1]) */
    (*(int(*)())(*(int *)(*(int *)0x06000354 + 4)))(sound_id, 0);
    /* BIOS sound play (vtable[3]) */
    (*(int(*)())(*(int *)(*(int *)0x06000354 + 0xC)))(sound_id,
        *(int *)(0x0604A5C0 + (unsigned int)(unsigned char)*(int *)(0x060877D8 << 2)), desc);

    return 0;
}
#endif /* backup_device_open */

/* FUN_0601E37C -- original binary (268 bytes) */
__asm__(
    ".section .text.FUN_0601E37C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E37C\n"
    ".global _FUN_0601e37c\n"
    ".type _FUN_0601E37C, @function\n"
    "_FUN_0601E37C:\n"
    "_FUN_0601e37c:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x4F, 0x22\n"  /* 0x0601E37C */
    ".byte 0x98, 0x5A, 0xE9, 0x03, 0xEA, 0x00, 0xEB, 0x01, 0xDE, 0x2C, 0x6D, 0xAD, 0xA0, 0x68, 0x6C, 0xD3\n"  /* 0x0601E38C */
    ".byte 0x62, 0xCD, 0xD3, 0x2B, 0x42, 0x08, 0x32, 0x3C, 0x62, 0x21, 0x62, 0x2D, 0x22, 0x28, 0x8B, 0x01\n"  /* 0x0601E39C */
    ".byte 0xA0, 0x5D, 0x00, 0x09, 0x62, 0xDD, 0x60, 0xC3, 0x42, 0x08, 0x42, 0x08, 0x42, 0x00, 0x32, 0xEC\n"  /* 0x0601E3AC */
    ".byte 0x81, 0x2E, 0xB0, 0x63, 0x64, 0xD3, 0xA0, 0x1F, 0x00, 0x09, 0x64, 0xDD, 0x44, 0x08, 0x44, 0x08\n"  /* 0x0601E3BC */
    ".byte 0x44, 0x00, 0x34, 0xEC, 0x85, 0x4E, 0x64, 0x03, 0xB1, 0x66, 0x64, 0x4D, 0x20, 0x08, 0x89, 0x09\n"  /* 0x0601E3CC */
    ".byte 0x63, 0xDD, 0x43, 0x08, 0x43, 0x08, 0x43, 0x00, 0x33, 0xEC, 0x62, 0x8C, 0xE0, 0x1F, 0x03, 0x24\n"  /* 0x0601E3DC */
    ".byte 0xA0, 0x10, 0x00, 0x09, 0x62, 0xDD, 0x42, 0x08, 0x42, 0x08, 0x42, 0x00, 0x32, 0xEC, 0x63, 0xBC\n"  /* 0x0601E3EC */
    ".byte 0xE0, 0x1F, 0x02, 0x34, 0xA0, 0x06, 0x00, 0x09, 0x88, 0x00, 0x89, 0x03, 0x88, 0x01, 0x89, 0x2E\n"  /* 0x0601E3FC */
    ".byte 0x88, 0x02, 0x89, 0xDA, 0x64, 0xDD, 0xD3, 0x0F, 0xD2, 0x0F, 0x44, 0x08, 0x63, 0x30, 0x44, 0x08\n"  /* 0x0601E40C */
    ".byte 0x63, 0x3C, 0x44, 0x00, 0x43, 0x08, 0x34, 0xEC, 0x33, 0x2C, 0x54, 0x43, 0x63, 0x32, 0x73, 0x20\n"  /* 0x0601E41C */
    ".byte 0x34, 0x32, 0x89, 0x13, 0x63, 0xDD, 0x43, 0x08, 0x43, 0x08, 0x43, 0x00, 0x33, 0xEC, 0x62, 0xAC\n"  /* 0x0601E42C */
    ".byte 0xE0, 0x1E, 0x03, 0x24, 0xA0, 0x12, 0x00, 0x09, 0x00, 0xFF, 0xFF, 0xFF, 0x06, 0x08, 0x70, 0x94\n"  /* 0x0601E43C */
    ".byte 0x06, 0x08, 0x70, 0x86, 0x06, 0x08, 0x77, 0xD8, 0x06, 0x04, 0xA5, 0xC0, 0x62, 0xDD, 0x42, 0x08\n"  /* 0x0601E44C */
    ".byte 0x42, 0x08, 0x42, 0x00, 0x32, 0xEC, 0x63, 0xBC, 0xE0, 0x1E, 0x02, 0x34, 0x7D, 0x01, 0x7C, 0x01\n"  /* 0x0601E45C */
    ".byte 0x63, 0xCD, 0x33, 0x93, 0x8B, 0x94, 0xD3, 0x29, 0x23, 0xD1, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6\n"  /* 0x0601E46C */
    ".byte 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601E47C */
);

#if 0 /* FUN_0601E488 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // int FUN_0601e488(unsigned short slot) __attribute__((alias("backup_device_open")));
#endif

/* backup_mem_write_all -- Write save data to all backup devices.
 * Returns first successful device index, or 8 if all failed. */
unsigned int backup_mem_write_all()
{
    char *smpc_cmd = (char *)0x2010001F;           /* SMPC command register */
    unsigned char *smpc_sf = (unsigned char *)(0x2010001F + 0x44); /* SMPC SF */
    char write_protect[4];
    char write_ok[8];

    write_protect[0] = '\0';
    write_ok[0] = '\0';
    write_protect[1] = 0;
    write_ok[1] = 0;
    write_protect[2] = 0;
    write_ok[2] = 0;

    char *dev_array;
    int dev;
    for (dev = 0;
         dev_array = (char *)0x06087094,
         dev < (int)(unsigned int)*(unsigned short *)0x06087084;
         dev = dev + 1) {
        /* Acquire SMPC bus */
        do { } while ((*smpc_sf & 1) == 1);
        *smpc_sf = 1;
        *smpc_cmd = (char *)0x1a;                  /* NETLINK OFF / bus acquire */
        do { } while ((*smpc_sf & 1) != 0);

        /* Init device and write save */
        (*(int(*)())(*(int *)(*(int *)0x06000354 + 4)))(
            *(short *)(dev_array + (dev << 5) + 0x1c), 0);
        int result = backup_mem_write(
            (int)*(short *)(dev_array + (dev << 5) + 0x1c),
            0x0604A57C + (unsigned int)(unsigned char)*(int *)0x060877D8 * 0xc,
            *(int *)0x0605E098);

        /* Release SMPC bus */
        do { } while ((*smpc_sf & 1) == 1);
        *smpc_sf = 1;
        *smpc_cmd = (char *)0x19;                  /* NETLINK ON / bus release */
        do { } while ((*smpc_sf & 1) != 0);

        if (result == 0) {
            write_ok[dev] = '\x01';
        }
        if (dev_array[(dev << 5) + 0x1e] != '\0') {
            write_protect[dev] = '\x01';
        }
    }

    /* Return first successful device */
    unsigned int idx = 0;
    do {
        if (write_ok[idx] != '\0') {
            return idx & 0xff;
        }
        idx = idx + 1;
    } while ((int)idx < 3);

    /* Fallback: return first write-protected device */
    char *scan = write_protect;
    idx = 3;
    while (1) {
        if (write_protect + 3 <= scan) {
            return 8;                              /* all failed */
        }
        if (*scan != '\0') break;
        scan = scan + 1;
        idx = idx + 1;
    }

    return idx & 0xff;
}

/* FUN_0601E488 -- original binary (4 bytes) */
__asm__(
    ".section .text.FUN_0601E488, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E488\n"
    ".global _FUN_0601e488\n"
    ".type _FUN_0601E488, @function\n"
    "_FUN_0601E488:\n"
    "_FUN_0601e488:\n"
    ".byte 0x2F, 0xE6, 0xE5, 0x00\n"  /* 0x0601E488 */
);

unsigned int FUN_0601e4d4() __attribute__((alias("backup_mem_write_all")));

/* bios_sound_poll -- Poll BIOS handler up to 10 times, return 0 on success. */
#if 0 /* bios_sound_poll -- redirected to ASM import via linker PROVIDE */
int bios_sound_poll(int param_1)
{
  int *bios_vec = (int *)0x06000354;       /* BIOS vector table pointer */
  int result;
  int attempt = 0;

  do {
    result = (*(int(*)())(*(int *)(*bios_vec + 8)))(param_1);
    if (result == 0) return 0;
    attempt++;
  } while (attempt < 10);

  return result;
}
#endif /* bios_sound_poll */
#if 0 /* FUN_0601E6A4 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // int FUN_0601e6a4(int param_1) __attribute__((alias("bios_sound_poll")));
#endif

#if 0 /* backup_mem_write -- redirected to ASM import via linker PROVIDE */
int backup_mem_write(param_1, param_2, param_3)
    unsigned short param_1;
    int param_2;
    int param_3;
{
    char *smpc_status = (char *)0x20100063;     /* SMPC SF register */
    int len;
    int result;

    len = (*(int(*)())0x06035C1C)(param_2);     /* strlen */
    if (0xb < len) {
        *(char *)(param_2 + 0xb) = 0;           /* truncate to 11 chars */
    }

    /* Acquire SMPC bus */
    do { } while ((*smpc_status & 1) == 1);
    *smpc_status = 1;
    SMPC_COMREG = 0x1a;                         /* NETLINK OFF / bus acquire */
    do { } while ((*smpc_status & 1) != 0);

    /* Call BIOS backup write */
    result = (*(int(*)())(*(int *)(*(int *)0x06000354 + 0x14)))(
                 *(short *)(0x06087094 + (unsigned int)(param_1 << 5) + 0x1c),
                 param_2, param_3);

    /* Release SMPC bus */
    do { } while ((*smpc_status & 1) == 1);
    *smpc_status = 1;
    SMPC_COMREG = 0x19;                         /* NETLINK ON / bus release */
    do { } while ((*smpc_status & 1) != 0);

    return result;
}
#endif /* backup_mem_write */

/* FUN_0601E6A4 -- original binary (60 bytes) */
__asm__(
    ".section .text.FUN_0601E6A4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E6A4\n"
    ".global _FUN_0601e6a4\n"
    ".type _FUN_0601E6A4, @function\n"
    "_FUN_0601E6A4:\n"
    "_FUN_0601e6a4:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0x7F, 0xFC, 0xEC, 0x0A, 0xDD, 0x0A, 0x2F, 0x42\n"  /* 0x0601E6A4 */
    ".byte 0xEE, 0x00, 0x63, 0xD2, 0x52, 0x32, 0x42, 0x0B, 0x64, 0xF2, 0x64, 0x03, 0x24, 0x48, 0x8B, 0x01\n"  /* 0x0601E6B4 */
    ".byte 0xA0, 0x04, 0xE0, 0x00, 0x7E, 0x01, 0x3E, 0xC3, 0x8B, 0xF3, 0x60, 0x43, 0x7F, 0x04, 0x4F, 0x26\n"  /* 0x0601E6C4 */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x06, 0x00, 0x03, 0x54\n"  /* 0x0601E6D4 */
);

#if 0 /* FUN_0601E764 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // int FUN_0601e764() __attribute__((alias("backup_mem_write")));
#endif

#if 0 /* backup_mem_read -- redirected to ASM import via linker PROVIDE */
int backup_mem_read(param_1, param_2, param_3)
    unsigned short param_1;
    int param_2;
    int param_3;
{
    char *smpc_status = (char *)0x20100063;     /* SMPC SF register */
    char *channel_ptr = (char *)0x060877D8;     /* current channel */
    char *label_base  = (char *)0x0605E06C;     /* channel label array */
    int len;
    int result;

    /* Truncate filename to 11 chars */
    len = (*(int(*)())0x06035C1C)(param_2);     /* strlen */
    if (0xb < len) {
        *(char *)(param_2 + 0xb) = 0;
    }

    /* Truncate channel label to 10 chars */
    len = (*(int(*)())0x06035C1C)(label_base + (unsigned int)(unsigned char)*channel_ptr * 0xb);
    if (10 < len) {
        label_base[(unsigned int)(unsigned char)*channel_ptr * 0xb + 10] = 0;
    }

    /* Build save descriptor */
    bcd_timestamp_decode(0x060877E8);
    char *desc = (char *)0x060877B4;
    (*(int(*)())0x06035C08)(0x060877B4, param_2);       /* strcpy filename */
    (*(int(*)())0x06035C08)(desc + 0xc,
                 label_base + (unsigned int)(unsigned char)*channel_ptr * 0xb);  /* strcpy label */
    desc[0x17] = 0;

    /* Get save data size from BIOS */
    result = (*(int(*)())(*(int *)(*(int *)0x06000354 + 0x28)))(0x060877E8);
    *(int *)(desc + 0x18) = result;
    *(int *)(desc + 0x1c) = *(int *)(0x0604A5C0 + (unsigned int)(unsigned char)(*channel_ptr << 2));

    /* Acquire SMPC bus */
    do { } while ((*smpc_status & 1) == 1);
    *smpc_status = 1;
    SMPC_COMREG = 0x1a;
    do { } while ((*smpc_status & 1) != 0);

    /* Call BIOS read function */
    result = (*(int(*)())(*(int *)(*(int *)0x06000354 + 0x10)))(
                 *(short *)(0x06087094 + (unsigned int)(param_1 << 5) + 0x1c),
                 0x060877B4, param_3, 0);

    /* Release SMPC bus */
    do { } while ((*smpc_status & 1) == 1);
    *smpc_status = 1;
    SMPC_COMREG = 0x19;
    do { } while ((*smpc_status & 1) != 0);

    return result;
}
#endif /* backup_mem_read */

/* FUN_0601E764 -- original binary (12 bytes) */
__asm__(
    ".section .text.FUN_0601E764, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E764\n"
    ".global _FUN_0601e764\n"
    ".type _FUN_0601E764, @function\n"
    "_FUN_0601E764:\n"
    "_FUN_0601e764:\n"
    ".byte 0x2F, 0xE6, 0x60, 0x43, 0x2F, 0xD6, 0xEE, 0x01, 0x2F, 0xC6, 0x6C, 0x53\n"  /* 0x0601E764 */
);

#if 0 /* FUN_0601E810 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // int FUN_0601e810() __attribute__((alias("backup_mem_read")));
#endif

#if 0 /* save_data_load_or_create -- redirected to ASM import via linker PROVIDE */
int save_data_load_or_create()
{
    char *state_ptr     = (char *)0x0605E05C;   /* save operation state */
    char *error_handler = (char *)0x0601F8BC;   /* error recovery function */
    char *playback_ptr  = (char *)0x0605E098;   /* playback data pointer */
    int result;

    result = (int)(char)*(int *)0x0605E05D;     /* current state byte */

    if (result == 0) {
        backup_mem_format();                     /* format backup memory */

        char *channel_ptr = (char *)0x060877D8;
        unsigned char ch = (unsigned char)*(int *)0x060877D8;
        unsigned char track_status = backup_mem_write_all(0x0604A57C + (unsigned int)ch * 0xc);

        if (track_status < 7) {
            ((int *)0x060877DD)[ch] = 1;         /* mark channel active */

            if (2 < track_status) {
                /* Deferred track: load and validate */
                ((int *)0x060877D9)[ch] = track_status - 3;
                FUN_0601eb70();
                result = cdda_replay_check();
                return result;
            }

            /* Immediate track: attempt save read */
            ((int *)0x060877D9)[ch] = track_status;
            result = backup_mem_write(((int *)0x060877D9)[ch],
                                  0x0604A57C + (unsigned int)(unsigned char)*channel_ptr * 0xc,
                                  *(int *)playback_ptr);

            if (result == 0) {
                result = 0;
                if (*(int *)0x06087080 == '\0') {
                    /* Verify save data matches reference pattern */
                    result = 0;
                    while (*(char *)(*(int *)playback_ptr + result) == ((int *)0x0604A5AC)[result]) {
                        result = result + 1;
                        if (0xf < result) {
                            result = FUN_0601ebda();
                            return result;
                        }
                    }
                    /* Mismatch: error state */
                    *state_ptr = 8;
                    result = (*(int(*)())error_handler)();
                }
            } else {
                /* Read failed: error state */
                *state_ptr = 8;
                result = (*(int(*)())error_handler)();
            }
        } else {
            /* Track invalid: mark inactive */
            FUN_0601eb70();
            ((int *)0x060877DD)[ch] = 0;
            *state_ptr = 4;
            result = (*(int(*)())error_handler)();
        }
    } else {
        /* Non-zero state: reset */
        *(int *)0x0605E05C = 0;
    }
    return result;
}
#endif /* save_data_load_or_create */

/* FUN_0601E810 -- original binary (328 bytes) */
__asm__(
    ".section .text.FUN_0601E810, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E810\n"
    ".global _FUN_0601e810\n"
    ".type _FUN_0601E810, @function\n"
    "_FUN_0601E810:\n"
    "_FUN_0601e810:\n"
    ".byte 0x2F, 0xE6, 0x60, 0x43, 0x2F, 0xD6, 0xEE, 0x01, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0xEB, 0x0B\n"  /* 0x0601E810 */
    ".byte 0x2F, 0x96, 0x69, 0x53, 0x2F, 0x86, 0x4F, 0x22, 0x4F, 0x12, 0x7F, 0xF8, 0xD8, 0x35, 0xDA, 0x36\n"  /* 0x0601E820 */
    ".byte 0xDD, 0x36, 0x81, 0xF2, 0x2F, 0x62, 0xD3, 0x36, 0x43, 0x0B, 0x64, 0x93, 0x30, 0xB7, 0x8B, 0x02\n"  /* 0x0601E830 */
    ".byte 0xE3, 0x00, 0x60, 0x33, 0x80, 0x9B, 0x64, 0xA0, 0xD3, 0x31, 0x64, 0x4C, 0x04, 0xB7, 0x04, 0x1A\n"  /* 0x0601E840 */
    ".byte 0x43, 0x0B, 0x34, 0x8C, 0xE2, 0x0A, 0x30, 0x27, 0x8B, 0x07, 0x62, 0xA0, 0x62, 0x2C, 0x02, 0xB7\n"  /* 0x0601E850 */
    ".byte 0x02, 0x1A, 0x32, 0x8C, 0xE3, 0x00, 0x60, 0x33, 0x80, 0x2A, 0xD4, 0x2A, 0xB6, 0x22, 0x00, 0x09\n"  /* 0x0601E860 */
    ".byte 0xDC, 0x29, 0x65, 0x93, 0xD3, 0x29, 0x43, 0x0B, 0x64, 0xC3, 0x64, 0xC3, 0xD3, 0x27, 0x65, 0xA0\n"  /* 0x0601E870 */
    ".byte 0x65, 0x5C, 0x05, 0xB7, 0x05, 0x1A, 0x35, 0x8C, 0x43, 0x0B, 0x74, 0x0C, 0xE2, 0x00, 0xE0, 0x17\n"  /* 0x0601E880 */
    ".byte 0x0C, 0x24, 0xD3, 0x23, 0xD4, 0x1F, 0x63, 0x32, 0x52, 0x3A, 0x42, 0x0B, 0x00, 0x09, 0x1C, 0x06\n"  /* 0x0601E890 */
    ".byte 0x63, 0xA0, 0x63, 0x3C, 0x43, 0x08, 0xD2, 0x1F, 0x33, 0x2C, 0x61, 0x32, 0x1C, 0x17, 0x62, 0xD0\n"  /* 0x0601E8A0 */
    ".byte 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x89, 0xFA, 0x62, 0xEC, 0x2D, 0x20, 0xE3, 0x1A, 0xD2, 0x1A\n"  /* 0x0601E8B0 */
    ".byte 0x22, 0x30, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x22, 0x28, 0x8B, 0xFA, 0xE7, 0x00, 0x66, 0xF2\n"  /* 0x0601E8C0 */
    ".byte 0xD3, 0x13, 0xD5, 0x11, 0x85, 0xF2, 0x63, 0x32, 0x64, 0x03, 0x52, 0x34, 0x64, 0x4D, 0xD3, 0x13\n"  /* 0x0601E8D0 */
    ".byte 0x44, 0x08, 0x44, 0x08, 0x44, 0x00, 0x34, 0x3C, 0x85, 0x4E, 0x64, 0x03, 0x42, 0x0B, 0x64, 0x4D\n"  /* 0x0601E8E0 */
    ".byte 0x64, 0x03, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x89, 0xFA, 0x62, 0xEC, 0x2D, 0x20\n"  /* 0x0601E8F0 */
    ".byte 0xA0, 0x16, 0x00, 0x09, 0x06, 0x05, 0xE0, 0x6C, 0x06, 0x08, 0x77, 0xD8, 0x20, 0x10, 0x00, 0x63\n"  /* 0x0601E900 */
    ".byte 0x06, 0x03, 0x5C, 0x1C, 0x06, 0x08, 0x77, 0xE8, 0x06, 0x08, 0x77, 0xB4, 0x06, 0x03, 0x5C, 0x08\n"  /* 0x0601E910 */
    ".byte 0x06, 0x00, 0x03, 0x54, 0x06, 0x04, 0xA5, 0xC0, 0x20, 0x10, 0x00, 0x1F, 0x06, 0x08, 0x70, 0x94\n"  /* 0x0601E920 */
    ".byte 0xE3, 0x19, 0xD2, 0x2F, 0x22, 0x30, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x22, 0x28, 0x8B, 0xFA\n"  /* 0x0601E930 */
    ".byte 0x60, 0x43, 0x7F, 0x08, 0x4F, 0x16, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6\n"  /* 0x0601E940 */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601E950 */
);

#if 0 /* FUN_0601E958 -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // int FUN_0601e958() __attribute__((alias("save_data_load_or_create")));
#endif

#if 0 /* cd_track_validate -- redirected to ASM import via linker PROVIDE */
int cd_track_validate()
{
    char *channel_ptr = (char *)0x060877D8;
    int result = 0;
    unsigned char ch = (unsigned char)*(int *)0x060877D8;

    unsigned char track_status = backup_mem_write_all(0x0604A57C + (unsigned int)ch * 0xc);

    if (track_status < 7) {
        ((int *)0x060877DD)[ch] = 1;            /* mark channel active */
        if (track_status < 3) {
            ((int *)0x060877D9)[ch] = track_status;
            result = 1;                          /* immediate play */
        } else {
            ((int *)0x060877D9)[ch] = track_status - 3;
        }
    } else {
        ((int *)0x060877DD)[ch] = 0;            /* mark channel inactive */
    }
    return result;
}
#endif /* cd_track_validate */
#if 0 /* FUN_0601EAA0 -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // int FUN_0601eaa0() __attribute__((alias("cd_track_validate")));
#endif

#if 0 /* cd_track_play_if_active -- redirected to ASM import via linker PROVIDE */
void cd_track_play_if_active(void)
{
    unsigned char ch = (unsigned char)*(int *)0x060877D8;
    if (((int *)0x060877DD)[ch] != '\0') {
        backup_mem_read(((int *)0x060877D9)[ch],
                     0x0604A57C + (unsigned int)ch * 0xC,
                     *(int *)0x0605E098);
    }
}
#endif /* cd_track_play_if_active */
#if 0 /* FUN_0601EB1C -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // void FUN_0601eb1c(void) __attribute__((alias("cd_track_play_if_active")));
#endif

#if 0 /* FUN_0601EB70 -- replaced by ASM import */
unsigned int FUN_0601eb70()
{
    char *out_buf = (char *)0x0605E09C;
    char *template = (char *)0x0604A5AC;
    char *save_buf = (char *)0x0605E098;
    char *device_id = (char *)0x060877D8;
    char *size_table = (char *)0x0604A5C0;
    unsigned int dev_idx = (unsigned int)(unsigned char)*(int *)0x06087080;

    if (dev_idx == 0) {
        /* Clear save buffer */
        unsigned int i;
        for (i = 0;
             dev_idx = (unsigned int)(unsigned char)(*device_id << 2),
             i < *(unsigned int *)(size_table + dev_idx);
             i = i + 1) {
            *(char *)(*(int *)save_buf + i) = 0;
        }

        /* Copy 16-byte template */
        int j = 0;
        do {
            *(char *)(*(int *)out_buf + j) = template[j];
            *(char *)(*(int *)out_buf + j + 1) = template[j + 1];
            j = j + 2;
        } while (j < 0x10);
    }

    return dev_idx;
}
#endif

/* save_state_load -- deserialize save data from backup RAM into game state */
char * FUN_0601ebda()
{
  char *settings_ptr;
  char *result;
  char *src;
  char *src_end;
  int block_size;
  char *dst_next;
  int *table_end;
  char *dst;
  int *table_ptr;
  char *dst_block;

  block_size = 0xf0;
  result = (char *)(unsigned int)(unsigned char)*(int *)0x06087080; /* save_error_flag */

  if (result == (char *)0x0) {
    src = (char *)(*(int *)0x0605E098 + 0x10); /* save_buffer + header_size */

    /* Block 1: copy 0xF0 bytes per entry from 9 pointer table entries at 0x0605DD6C */
    table_end = (int *)(0x0605DD6C + 0x48);
    table_ptr = (int *)0x0605DD6C;
    do {
      dst_block = (char *)*table_ptr;
      result = dst_block;
      do {
        *result = *src;
        result[1] = src[1];
        result[2] = src[2];
        result[3] = src[3];
        result[4] = src[4];
        result[5] = src[5];
        result[6] = src[6];
        result[7] = src[7];
        result[8] = src[8];
        dst_next = result + 0xc;
        result[9] = src[9];
        src_end = src + 0xb;
        result[10] = src[10];
        src = src + 0xc;
        result[0xb] = *src_end;
        result = dst_next;
      } while (dst_next < dst_block + block_size);
      table_ptr = table_ptr + 2;
    } while (table_ptr < table_end);

    /* Block 2: copy 8 bytes per entry from 6 pointer table entries at 0x0605DE24 */
    table_end = (int *)(0x0605DE24 + 0x18);
    table_ptr = (int *)0x0605DE24;
    do {
      result = (char *)*table_ptr;
      table_ptr = table_ptr + 1;
      *result = *src;
      result[1] = src[1];
      result[2] = src[2];
      result[3] = src[3];
      result[4] = src[4];
      result[5] = src[5];
      dst_block = src + 7;
      result[6] = src[6];
      src = src + 8;
      result[7] = *dst_block;
    } while (table_ptr < table_end);

    /* Block 3: copy 0x20 bytes to 0x0605DDB4 (leaderboard times A) */
    dst_block = 0x0605DDB4 + 0x20;
    dst = (char *)0x0605DDB4;
    do {
      *dst = *src;
      dst[1] = src[1];
      dst[2] = src[2];
      dst[3] = src[3];
      dst_next = dst + 8;
      dst[4] = src[4];
      dst[5] = src[5];
      src_end = src + 7;
      dst[6] = src[6];
      src = src + 8;
      dst[7] = *src_end;
      dst = dst_next;
    } while (dst_next < dst_block);

    /* Block 4: copy 0x20 bytes to 0x0605DDD4 (leaderboard times B) */
    dst_block = 0x0605DDD4 + 0x20;
    dst = (char *)0x0605DDD4;
    do {
      *dst = *src;
      dst[1] = src[1];
      dst[2] = src[2];
      dst[3] = src[3];
      dst_next = dst + 8;
      dst[4] = src[4];
      dst[5] = src[5];
      src_end = src + 7;
      dst[6] = src[6];
      src = src + 8;
      dst[7] = *src_end;
      dst = dst_next;
    } while (dst_next < dst_block);

    /* Block 5: copy 0x24 bytes to 0x0605DE40 (race records) */
    dst_block = 0x0605DE40 + 0x24;
    dst = (char *)0x0605DE40;
    do {
      src_end = src;
      *dst = *src_end;
      dst[1] = src_end[1];
      dst[2] = src_end[2];
      dst[3] = src_end[3];
      dst[4] = src_end[4];
      dst[5] = src_end[5];
      dst[6] = src_end[6];
      dst[7] = src_end[7];
      dst[8] = src_end[8];
      dst[9] = src_end[9];
      dst_next = dst + 0xc;
      dst[10] = src_end[10];
      dst[0xb] = src_end[0xb];
      settings_ptr = (char *)0x0605AD00;
      src = src_end + 0xc;
      dst = dst_next;
    } while (dst_next < dst_block);

    /* Deserialize game settings from save buffer */
    COURSE_SELECT = src_end[0xc];          /* 0x0605AD00 */
    settings_ptr[1] = src_end[0xd];
    settings_ptr[2] = src_end[0xe];
    settings_ptr[3] = src_end[0xf];
    dst = (char *)0x0605AD04;
    *(int *)0x0605AD04 = src_end[0x10];    /* difficulty */
    dst[1] = src_end[0x11];
    dst[2] = src_end[0x12];
    dst[3] = src_end[0x13];
    dst = (char *)0x0605AD0C;
    *(int *)0x0605AD0C = src_end[0x14];    /* laps */
    dst[1] = src_end[0x15];
    dst[2] = src_end[0x16];
    dst[3] = src_end[0x17];
    *(int *)0x0605AB16 = src_end[0x18];    /* game_mode */
    *(int *)0x0605AB17 = src_end[0x19];    /* sub_mode */
    *(int *)0x0605D240 = src_end[0x1a];    /* option_a */
    *(int *)0x0605D241 = src_end[0x1b];    /* option_b */
    /* Leaderboard names and records: 0x06060D40-0x06060D74 (20 two-byte fields + 3 four-byte fields) */
    dst = (char *)0x06060D44;
    *(int *)0x06060D44 = src_end[0x1c];
    dst[1] = src_end[0x1d];
    dst = (char *)0x06060D46;
    *(int *)0x06060D46 = src_end[0x1e];
    dst[1] = src_end[0x1f];
    dst = (char *)0x06060D40;
    *(int *)0x06060D40 = src_end[0x20];
    dst[1] = src_end[0x21];
    dst = (char *)0x06060D42;
    *(int *)0x06060D42 = src_end[0x22];
    dst[1] = src_end[0x23];
    dst = (char *)0x06060D48;
    *(int *)0x06060D48 = src_end[0x24];
    dst[1] = src_end[0x25];
    dst = (char *)0x06060D4A;
    *(int *)0x06060D4A = src_end[0x26];
    dst[1] = src_end[0x27];
    dst = (char *)0x06060D4C;
    *(int *)0x06060D4C = src_end[0x28];
    dst[1] = src_end[0x29];
    dst = (char *)0x06060D4E;
    *(int *)0x06060D4E = src_end[0x2a];
    dst[1] = src_end[0x2b];
    dst = (char *)0x06060D54;
    *(int *)0x06060D54 = src_end[0x2c];
    dst[1] = src_end[0x2d];
    dst[2] = src_end[0x2e];
    dst[3] = src_end[0x2f];
    dst = (char *)0x06060D58;
    *(int *)0x06060D58 = src_end[0x30];
    dst[1] = src_end[0x31];
    dst[2] = src_end[0x32];
    dst[3] = src_end[0x33];
    dst = (char *)0x06060D50;
    *(int *)0x06060D50 = src_end[0x34];
    dst[1] = src_end[0x35];
    dst[2] = src_end[0x36];
    dst[3] = src_end[0x37];
    dst = (char *)0x06060D60;
    *(int *)0x06060D60 = src_end[0x38];
    dst[1] = src_end[0x39];
    dst = (char *)0x06060D62;
    *(int *)0x06060D62 = src_end[0x3a];
    dst[1] = src_end[0x3b];
    src = 0x06060D5C + 1;
    *(int *)0x06060D5C = src_end[0x3c];
    *src = src_end[0x3d];
    dst = (char *)0x06060D5E;
    *(int *)0x06060D5E = src_end[0x3e];
    dst[1] = src_end[0x3f];
    dst = (char *)0x06060D64;
    *(int *)0x06060D64 = src_end[0x40];
    dst[1] = src_end[0x41];
    dst = (char *)0x06060D66;
    *(int *)0x06060D66 = src_end[0x42];
    dst[1] = src_end[0x43];
    dst = (char *)0x06060D68;
    *(int *)0x06060D68 = src_end[0x44];
    dst[1] = src_end[0x45];
    dst = (char *)0x06060D6A;
    *(int *)0x06060D6A = src_end[0x46];
    dst[1] = src_end[0x47];
    dst = (char *)0x06060D70;
    *(int *)0x06060D70 = src_end[0x48];
    dst[1] = src_end[0x49];
    dst[2] = src_end[0x4a];
    dst[3] = src_end[0x4b];
    dst = (char *)0x06060D74;
    *(int *)0x06060D74 = src_end[0x4c];
    dst[1] = src_end[0x4d];
    dst[2] = src_end[0x4e];
    dst[3] = src_end[0x4f];
    dst = (char *)0x06060D6C;
    *(int *)0x06060D6C = src_end[0x50];
    dst[1] = src_end[0x51];
    dst[2] = src_end[0x52];
    dst[3] = src_end[0x53];
  }

  return result;
}

/* save_state_store -- serialize game state into backup RAM save buffer */
char * FUN_0601efc4()
{
  char *settings_ptr;
  char *result;
  char *dst;
  int block_size;
  char *src_next;
  int *table_end;
  char *src;
  int *table_ptr;
  char *src_block;

  block_size = 0xf0;
  result = (char *)(unsigned int)(unsigned char)*(int *)0x06087080; /* save_error_flag */

  if (result == (char *)0x0) {
    dst = (char *)(*(int *)0x0605E098 + 0x10); /* save_buffer + header_size */

    /* Block 1: serialize 0xF0 bytes per entry from 9 pointer table entries at 0x0605DD6C */
    table_end = (int *)(0x0605DD6C + 0x48);
    table_ptr = (int *)0x0605DD6C;
    do {
      src_block = (char *)*table_ptr;
      result = src_block;
      do {
        *dst = *result;
        dst[1] = result[1];
        dst[2] = result[2];
        dst[3] = result[3];
        dst[4] = result[4];
        dst[5] = result[5];
        dst[6] = result[6];
        dst[7] = result[7];
        src_next = result + 0xc;
        dst[8] = result[8];
        dst[9] = result[9];
        dst[10] = result[10];
        dst[0xb] = result[0xb];
        dst = dst + 0xc;
        result = src_next;
      } while (src_next < src_block + block_size);
      table_ptr = table_ptr + 2;
    } while (table_ptr < table_end);

    /* Block 2: serialize 8 bytes per entry from 6 pointer table entries at 0x0605DE24 */
    table_end = (int *)(0x0605DE24 + 0x18);
    table_ptr = (int *)0x0605DE24;
    do {
      result = (char *)*table_ptr;
      table_ptr = table_ptr + 1;
      *dst = *result;
      dst[1] = result[1];
      dst[2] = result[2];
      dst[3] = result[3];
      dst[4] = result[4];
      dst[5] = result[5];
      dst[6] = result[6];
      dst[7] = result[7];
      dst = dst + 8;
    } while (table_ptr < table_end);

    /* Block 3: serialize 0x20 bytes from 0x0605DDB4 (leaderboard times A) */
    src_block = 0x0605DDB4 + 0x20;
    src = (int *)0x0605DDB4;
    do {
      *dst = *src;
      dst[1] = src[1];
      dst[2] = src[2];
      dst[3] = src[3];
      src_next = src + 8;
      dst[4] = src[4];
      dst[5] = src[5];
      dst[6] = src[6];
      dst[7] = src[7];
      dst = dst + 8;
      src = src_next;
    } while (src_next < src_block);

    /* Block 4: serialize 0x20 bytes from 0x0605DDD4 (leaderboard times B) */
    src_block = 0x0605DDD4 + 0x20;
    src = (int *)0x0605DDD4;
    do {
      *dst = *src;
      dst[1] = src[1];
      dst[2] = src[2];
      dst[3] = src[3];
      src_next = src + 8;
      dst[4] = src[4];
      dst[5] = src[5];
      dst[6] = src[6];
      dst[7] = src[7];
      dst = dst + 8;
      src = src_next;
    } while (src_next < src_block);

    /* Block 5: serialize 0x24 bytes from 0x0605DE40 (race records) */
    src_block = 0x0605DE40 + 0x24;
    src = (int *)0x0605DE40;
    do {
      src_next = dst;
      *src_next = *src;
      src_next[1] = src[1];
      src_next[2] = src[2];
      src_next[3] = src[3];
      src_next[4] = src[4];
      src_next[5] = src[5];
      src_next[6] = src[6];
      src_next[7] = src[7];
      src_next[8] = src[8];
      src_next[9] = src[9];
      src = src + 0xc;
      src_next[10] = src[10];
      src_next[0xb] = src[0xb];
      settings_ptr = (char *)0x0605AD00;
      dst = src_next + 0xc;
      src = src;
    } while (src < src_block);

    /* Serialize game settings to save buffer */
    dst = 0x0605AD00 + 1;
    src_next[0xc] = COURSE_SELECT;
    src_next[0xd] = *dst;
    src_next[0xe] = settings_ptr[2];
    src_next[0xf] = settings_ptr[3];
    src = (int *)0x0605AD04;
    dst = 0x0605AD04 + 1;
    src_next[0x10] = *(int *)0x0605AD04;
    src_next[0x11] = *dst;
    src_next[0x12] = src[2];
    src_next[0x13] = src[3];
    src = (int *)0x0605AD0C;
    dst = 0x0605AD0C + 1;
    src_next[0x14] = *(int *)0x0605AD0C;
    src_next[0x15] = *dst;
    src_next[0x16] = src[2];
    src_next[0x17] = src[3];
    src_next[0x18] = *(int *)0x0605AB16;
    src_next[0x19] = *(int *)0x0605AB17;
    src_next[0x1a] = *(int *)0x0605D240;
    src_next[0x1b] = *(int *)0x0605D241;
    /* Leaderboard names and records: 0x06060D40-0x06060D74 */
    dst = 0x06060D44 + 1;
    src_next[0x1c] = *(int *)0x06060D44;
    src_next[0x1d] = *dst;
    dst = 0x06060D46 + 1;
    src_next[0x1e] = *(int *)0x06060D46;
    src_next[0x1f] = *dst;
    dst = 0x06060D40 + 1;
    src_next[0x20] = *(int *)0x06060D40;
    src_next[0x21] = *dst;
    dst = 0x06060D42 + 1;
    src_next[0x22] = *(int *)0x06060D42;
    src_next[0x23] = *dst;
    dst = 0x06060D48 + 1;
    src_next[0x24] = *(int *)0x06060D48;
    src_next[0x25] = *dst;
    dst = 0x06060D4A + 1;
    src_next[0x26] = *(int *)0x06060D4A;
    src_next[0x27] = *dst;
    dst = 0x06060D4C + 1;
    src_next[0x28] = *(int *)0x06060D4C;
    src_next[0x29] = *dst;
    dst = 0x06060D4E + 1;
    src_next[0x2a] = *(int *)0x06060D4E;
    src_next[0x2b] = *dst;
    src = (int *)0x06060D54;
    dst = 0x06060D54 + 1;
    src_next[0x2c] = *(int *)0x06060D54;
    src_next[0x2d] = *dst;
    src_next[0x2e] = src[2];
    src_next[0x2f] = src[3];
    src = (int *)0x06060D58;
    dst = 0x06060D58 + 1;
    src_next[0x30] = *(int *)0x06060D58;
    src_next[0x31] = *dst;
    src_next[0x32] = src[2];
    src_next[0x33] = src[3];
    src = (int *)0x06060D50;
    dst = 0x06060D50 + 1;
    src_next[0x34] = *(int *)0x06060D50;
    src_next[0x35] = *dst;
    src_next[0x36] = src[2];
    src_next[0x37] = src[3];
    dst = 0x06060D60 + 1;
    src_next[0x38] = *(int *)0x06060D60;
    src_next[0x39] = *dst;
    dst = 0x06060D62 + 1;
    src_next[0x3a] = *(int *)0x06060D62;
    src_next[0x3b] = *dst;
    dst = 0x06060D5C + 1;
    src_next[0x3c] = *(int *)0x06060D5C;
    src_next[0x3d] = *dst;
    dst = 0x06060D5E + 1;
    src_next[0x3e] = *(int *)0x06060D5E;
    src_next[0x3f] = *dst;
    dst = 0x06060D64 + 1;
    src_next[0x40] = *(int *)0x06060D64;
    src_next[0x41] = *dst;
    dst = 0x06060D66 + 1;
    src_next[0x42] = *(int *)0x06060D66;
    src_next[0x43] = *dst;
    dst = 0x06060D68 + 1;
    src_next[0x44] = *(int *)0x06060D68;
    src_next[0x45] = *dst;
    dst = 0x06060D6A + 1;
    src_next[0x46] = *(int *)0x06060D6A;
    src_next[0x47] = *dst;
    src = (int *)0x06060D70;
    dst = 0x06060D70 + 1;
    src_next[0x48] = *(int *)0x06060D70;
    src_next[0x49] = *dst;
    src_next[0x4a] = src[2];
    src_next[0x4b] = src[3];
    src = (int *)0x06060D74;
    dst = 0x06060D74 + 1;
    src_next[0x4c] = *(int *)0x06060D74;
    src_next[0x4d] = *dst;
    src_next[0x4e] = src[2];
    src_next[0x4f] = src[3];
    src = (int *)0x06060D6C;
    dst = 0x06060D6C + 1;
    src_next[0x50] = *(int *)0x06060D6C;
    src_next[0x51] = *dst;
    src_next[0x52] = src[2];
    src_next[0x53] = src[3];
  }

  return result;
}

/* cdda_replay_check -- Check if CD audio needs replay, restart if enabled. */
#if 0 /* cdda_replay_check -- redirected to ASM import via linker PROVIDE */
int cdda_replay_check(void)
{
  char *track_idx = (char *)0x060877D8;

  if (((int *)0x060877DD)[(unsigned char)*track_idx] != '\0') {
    FUN_0601efc4();
    int result = backup_mem_read(((int *)0x060877D9)[(unsigned char)*track_idx],
                              0x0604A57C + (unsigned int)(unsigned char)*track_idx * 0xc,
                              *(int *)0x0605E098);
    if (result != 0) {
      *(int *)0x0605E05C = 0xc;            /* set CD error state */
      (*(int(*)())0x0601F8BC)();
      return 0;
    }
  }
  return 0;
}
#endif /* cdda_replay_check */
#if 0 /* FUN_0601F40C -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // int FUN_0601f40c(void) __attribute__((alias("cdda_replay_check")));
#endif

/* bcd_timestamp_decode -- Decode BCD-encoded CD timestamp to binary. */
#if 0 /* bcd_timestamp_decode -- redirected to ASM import via linker PROVIDE */
void bcd_timestamp_decode(char *param_1)
{
  int base = *(int *)0x060A4C98;
  *(int *)0x060877E4 = base;                /* cache timestamp pointer */

  unsigned char sec = *(unsigned char *)(base + 1);
  unsigned char min = *(unsigned char *)(base + 2);
  unsigned char hour = *(unsigned char *)(base + 3);
  unsigned char day = *(unsigned char *)(base + 4);

  /* Year: BCD decode of bytes 5 and 6 with century offset */
  *param_1 = (char)DAT_0601f5c6 +
             (char)((int)(unsigned int)*(unsigned char *)(base + 5) >> 4) * '\n' +
             (*(unsigned char *)(base + 5) & 0xf) +
             (char)((int)(unsigned int)*(unsigned char *)(base + 6) >> 4) * (char)0x03E8F844 +
             (*(unsigned char *)(base + 6) & 0xf) * 'd';

  param_1[1] = day & 0xf;                          /* day low nibble */
  param_1[5] = (char)((int)(unsigned int)day >> 4); /* day high nibble */
  param_1[2] = (hour & 0xf) + (char)((int)(unsigned int)hour >> 4) * '\n';
  param_1[3] = (min & 0xf) + (char)((int)(unsigned int)min >> 4) * '\n';
  param_1[4] = (sec & 0xf) + (char)((int)(unsigned int)sec >> 4) * '\n';
}
#endif /* bcd_timestamp_decode */
#if 0 /* FUN_0601F4B4 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // void FUN_0601f4b4(char *param_1) __attribute__((alias("bcd_timestamp_decode")));
#endif

#if 0 /* save_score_check_update -- redirected to ASM import via linker PROVIDE */
int save_score_check_update()
{
  char *save_data;
  char *temp_score;
  int result;
  char *name_ptr;
  unsigned int slot;
  unsigned int table_end;
  save_data = (char *)0x0607ED90;
  table_end = (unsigned int)DAT_0601f6ba;
  cdda_buffer_select(0);
  (*(int(*)())0x0601E2B4)();            /* format save buffer */
  (*(int(*)())0x0601EB70)();            /* validate track data */
  (*(int(*)())0x0601F40C)();            /* checksum update */
  temp_score = (char *)0x060877F0;
  if (*(int *)0x06078635 == '\0') {
    result = 0;
  }
  else {
    /* Copy saved score to temp buffer */
    *(int *)0x060877F0 = save_data[4];
    temp_score[1] = save_data[5];
    temp_score[2] = save_data[6];
    temp_score[3] = save_data[7];
    /* Check if current score beats saved best */
    if ((*(unsigned int *)0x060786A4 < *(unsigned int *)0x060877F0) ||
       (result = *(int *)0x060877F0, result == 0)) {
      /* New high score â€” update save data */
      *(int *)0x0605E0A1 = 1;
      *(int *)0x0605E0A0 = (char)CAR_COUNT;
      temp_score = (char *)0x060786A4;
      name_ptr = 0x060786A4 + 1;
      save_data[4] = *(int *)0x060786A4;
      save_data[5] = *name_ptr;
      save_data[6] = temp_score[2];
      save_data[7] = temp_score[3];
      /* Fill score table entries */
      for (slot = *(unsigned int *)0x0607ED88; slot < table_end; slot = slot + 2) {
        save_data[slot] = 0x40;
        save_data[slot + 1] = 0x80;
      }
      cdda_buffer_select(CAR_COUNT + 1U & 0xff);
      /* Write player initials (3 chars at 11-byte entry stride) */
      temp_score = (char *)0x060877D8;
      save_data = (char *)0x0605E06C;
      name_ptr = (char *)0x0;
      if (*(int *)0x06085FFC != 0) {
        name_ptr = *(char **)0x06085FFC;
      }
      if (*(int *)0x06086000 != 0) {
        name_ptr = *(char **)0x06086000;
      }
      if (name_ptr == (char *)0x0) {
        /* Default initials "DAY" */
        ((int *)0x0605E06C)[(char)(*(int *)0x060877D8 * '\v') + 7] = 0x44;
        save_data[(char)(*temp_score * '\v') + 8] = 0x41;
        save_data[(char)(*temp_score * '\v') + 9] = 0x59;
      }
      else {
        /* Copy initials from name entry */
        ((int *)0x0605E06C)[(char)(*(int *)0x060877D8 * '\v') + 7] = *name_ptr;
        save_data[(char)(*temp_score * '\v') + 8] = name_ptr[1];
        save_data[(char)(*temp_score * '\v') + 9] = name_ptr[2];
      }
      (*(int(*)())0x0601E2B4)();        /* reformat buffer */
      result = (*(int(*)())0x0601EB1C)();  /* validate and commit */
      return result;
    }
  }
  return result;
}
#endif /* save_score_check_update */

/* FUN_0601F4B4 -- original binary (284 bytes) */
__asm__(
    ".section .text.FUN_0601F4B4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601F4B4\n"
    ".global _FUN_0601f4b4\n"
    ".type _FUN_0601F4B4, @function\n"
    "_FUN_0601F4B4:\n"
    "_FUN_0601f4b4:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x4F, 0x12, 0x7F, 0xE4, 0xD5, 0x41\n"  /* 0x0601F4B4 */
    ".byte 0xD3, 0x41, 0x63, 0x32, 0x25, 0x32, 0x6C, 0x33, 0x7C, 0x01, 0x6C, 0xC0, 0x6C, 0xCC, 0x6B, 0x33\n"  /* 0x0601F4C4 */
    ".byte 0x7B, 0x02, 0x6B, 0xB0, 0x6B, 0xBC, 0x6D, 0x33, 0x7D, 0x03, 0x6D, 0xD0, 0x6D, 0xDC, 0x6A, 0x33\n"  /* 0x0601F4D4 */
    ".byte 0x7A, 0x04, 0x6A, 0xA0, 0x6A, 0xAC, 0x6E, 0x33, 0x7E, 0x05, 0x6E, 0xE0, 0x6E, 0xEC, 0x60, 0x33\n"  /* 0x0601F4E4 */
    ".byte 0xE5, 0x0F, 0x61, 0xE3, 0x67, 0xE3, 0x84, 0x06, 0x41, 0x21, 0x27, 0x59, 0x60, 0x0C, 0x41, 0x21\n"  /* 0x0601F4F4 */
    ".byte 0x6E, 0x03, 0x41, 0x21, 0x4E, 0x21, 0x41, 0x21, 0x4E, 0x21, 0x21, 0x59, 0x4E, 0x21, 0x63, 0x13\n"  /* 0x0601F504 */
    ".byte 0x41, 0x00, 0x43, 0x08, 0x43, 0x00, 0x31, 0x3C, 0x4E, 0x21, 0x2E, 0x59, 0x93, 0x50, 0x0E, 0x37\n"  /* 0x0601F514 */
    ".byte 0x0E, 0x1A, 0x66, 0x03, 0x26, 0x59, 0xE2, 0x64, 0x06, 0x27, 0x06, 0x1A, 0x31, 0x7C, 0x31, 0xEC\n"  /* 0x0601F524 */
    ".byte 0x67, 0xD3, 0x31, 0x6C, 0x47, 0x21, 0x96, 0x44, 0x47, 0x21, 0x36, 0x1C, 0x47, 0x21, 0x24, 0x60\n"  /* 0x0601F534 */
    ".byte 0x47, 0x21, 0x66, 0xA3, 0x27, 0x59, 0x26, 0x59, 0x63, 0x73, 0x60, 0x6C, 0x47, 0x00, 0x43, 0x08\n"  /* 0x0601F544 */
    ".byte 0x66, 0xA3, 0x80, 0x41, 0x46, 0x21, 0x46, 0x21, 0x46, 0x21, 0x46, 0x21, 0x26, 0x59, 0x60, 0x6C\n"  /* 0x0601F554 */
    ".byte 0x80, 0x45, 0x43, 0x00, 0x37, 0x3C, 0x66, 0xD3, 0x26, 0x59, 0x36, 0x7C, 0x60, 0x6C, 0x67, 0xB3\n"  /* 0x0601F564 */
    ".byte 0x66, 0xB3, 0x80, 0x42, 0x47, 0x21, 0x26, 0x59, 0x47, 0x21, 0x47, 0x21, 0x47, 0x21, 0x27, 0x59\n"  /* 0x0601F574 */
    ".byte 0x63, 0x73, 0x47, 0x00, 0x43, 0x08, 0x43, 0x00, 0x37, 0x3C, 0x36, 0x7C, 0x60, 0x6C, 0x67, 0xC3\n"  /* 0x0601F584 */
    ".byte 0x80, 0x43, 0x47, 0x21, 0x47, 0x21, 0x47, 0x21, 0x47, 0x21, 0x27, 0x59, 0x63, 0x73, 0x47, 0x00\n"  /* 0x0601F594 */
    ".byte 0x43, 0x08, 0x43, 0x00, 0x37, 0x3C, 0x66, 0xC3, 0x26, 0x59, 0x36, 0x7C, 0x60, 0x6C, 0x80, 0x44\n"  /* 0x0601F5A4 */
    ".byte 0x7F, 0x1C, 0x4F, 0x16, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601F5B4 */
    ".byte 0x03, 0xE8, 0xF8, 0x44, 0x06, 0x08, 0x77, 0xE4, 0x06, 0x0A, 0x4C, 0x98\n"  /* 0x0601F5C4 */
);

#if 0 /* FUN_0601F5E0 -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // int FUN_0601f5e0() __attribute__((alias("save_score_check_update")));
#endif

#if 0 /* save_data_write_validate -- redirected to ASM import via linker PROVIDE */
unsigned int save_data_write_validate()
{
    int *course_sel = (int *)0x0607EAD8;
    char *save_buf = (char *)0x0607ED90;
    unsigned int buf_size = (unsigned int)DAT_0601f804;
    unsigned int result = 0;

    if (*(int *)0x06078635 != '\0') {
        cdda_buffer_select(CAR_COUNT + 1U & 0xff);
        (*(int(*)())0x0601E2B4)();                 /* backup_mem_format */
        result = (*(int(*)())0x0601EAA0)();        /* cd_track_validate */
        result = result & 0xff;

        if ((result == 0) &&
           ((*(int *)0x0605E0A1 == '\0' ||
            ((unsigned int)(unsigned char)*(int *)0x0605E0A0 != CAR_COUNT)))) {
            /* Write save data, course-specific size */
            if (*course_sel == 0) {
                result = (*(int(*)())0x06027630)(save_buf, 0x002F8000, (int)DAT_0601f806);
            } else if (*course_sel == 1) {
                result = (*(int(*)())0x06027630)(save_buf, 0x002F8000, (int)PTR_DAT_0601f808);
            } else {
                result = *(unsigned int *)course_sel;
                if (result == 2) {
                    result = (*(int(*)())0x06027630)(save_buf, 0x002F8000, buf_size);
                }
            }
        }

        /* Fill unused buffer tail with 0x40/0x80 pattern */
        unsigned int pos;
        for (pos = *(unsigned int *)(0x0604A5C0 + (unsigned int)(unsigned char)*(int *)(0x060877D8 << 2));
             pos < buf_size; pos = pos + 2) {
            result = pos + 1;
            save_buf[pos] = 0x40;
            save_buf[result] = 0x80;
        }

        *(int *)0x0605E0A1 = 0;                    /* clear dirty flag */
    }

    return result;
}
#endif /* save_data_write_validate */
#if 0 /* FUN_0601F784 -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // unsigned int FUN_0601f784() __attribute__((alias("save_data_write_validate")));
#endif

/* cdda_buffer_select -- Select CD audio buffer bank (A or B). */
/* NOT redirected: FUN_0601f87a only defined via alias below */
void cdda_buffer_select(unsigned char param_1)
{
  *(unsigned char *)0x060877D8 = param_1;

  if (param_1 == '\0') {
    *(char **)0x0605E098 = (char *)0x060A0FA8;
    *(char *)0x06087080 = 0;
  } else {
    *(char **)0x0605E098 = (char *)0x0607ED90;
    *(char *)0x06087080 = 1;
  }
}
void FUN_0601f87a(unsigned char param_1) __attribute__((alias("cdda_buffer_select")));

/* nop_f8bc -- Placeholder / stripped function (no-op). */
void FUN_0601f8bc(void)
{
    return;
}

/* FUN_0601f8c0: L2 version in mode_transition.c */
extern int FUN_0601F8C0(void);
#if 0 /* FUN_0601F8C0 -- replaced by ASM import of original bytes */
int FUN_0601f8c0(void) { return FUN_0601F8C0(); }
#endif

/* FUN_0601f900: L2 version in mode_transition.c */
extern int FUN_0601F900(void);
#if 0 /* FUN_0601F900 -- replaced by ASM import of original bytes */
int FUN_0601f900(void) { return FUN_0601F900(); }
#endif

/* standings_screen_render -- Render race standings with layout per game mode. */
#if 0 /* standings_screen_render -- redirected to ASM import via linker PROVIDE */
void standings_screen_render()
{
  short final_y;
  char layout_mode;
  char *sprite_cmd;
  char *layout_base;
  char *position_render;
  char *position_table;
  int base_y;
  int header_cmd;
  int header_data;
  int header_y;
  int *standings_entry;
  int row_height;
  int *entry_ptr;
  short vdp2_priority[4];

  vdp2_priority[0] = DAT_0601fa26;

  (*(int(*)())0x0602853E)(0xc);  /* sprite_priority_set(12) */
  (*(int(*)())0x06028560)();     /* sprite_layer_clear */

  sprite_cmd = (char *)0x06028400;  /* sprite_render_full */
  layout_base = (char *)0x06063750; /* standings layout data */

  if (*(int *)0x06078644 == 1) {
    /* Single-player mode: compact layout */
    (*(int(*)())0x0600511E)(0x25E72194,0x00017700,0,8); /* vdp2_register_write */
    (*(int(*)())0x0602761E)(0x25F00600,0x0604894C,0x20); /* dma_copy palette */

    layout_mode = *(int *)0x0605E05C;
    if (layout_mode == '\x04') {
      /* Layout 4: top standings */
      entry_ptr = (int *)(layout_base + PTR_DAT_0601fa28);
      header_data = entry_ptr[1];
      base_y = 0;
    }
    else {
      if (layout_mode != '\b') {
        if (layout_mode == '\f') {
          /* Layout 12: minimal standings */
          (*(int(*)())sprite_cmd)(0xc,*(int *)(layout_base + DAT_0601fac8),0x400,
                            *(int *)((int)(layout_base + DAT_0601fac8) + 4));
        }
        goto LAB_0601fcd4;
      }
      /* Layout 8: mid standings */
      entry_ptr = (int *)(layout_base + DAT_0601fac4);
      header_data = entry_ptr[1];
      base_y = 0x380;
    }
    (*(int(*)())sprite_cmd)(0xc,*entry_ptr,base_y,header_data);
  }
  else {
    /* Multi-player mode: full standings with position rows */
    (*(int(*)())0x0602761E)(0x25F00600,0x0605CD9C,0x20); /* dma_copy palette */

    position_table = (int *)0x0605E0A4; /* position name sprites */
    position_render = (char *)0x060284AE; /* position_sprite_render */
    base_y = 0x590;
    header_y = base_y + 8;
    row_height = 0x90;

    layout_mode = *(int *)0x0605E05C;
    if (layout_mode == '\x04') {
      /* Layout 4: full 13-row leaderboard */
      (*(int(*)())0x060284AE)(0xc,0x80,row_height,*(int *)0x0605E0A4);
      (*(int(*)())sprite_cmd)(0xc,*(int *)(layout_base + header_y),0x98,
                        *(int *)((int)(layout_base + header_y) + 4));
      (*(int(*)())position_render)(0xc,0x180,row_height,*(int *)(position_table + 4));
      (*(int(*)())position_render)(0xc,0x280,row_height,*(int *)(position_table + 8));
      standings_entry = (int *)(layout_base + base_y);
      (*(int(*)())sprite_cmd)(0xc,*standings_entry,(int)DAT_0601fbae,standings_entry[1]);
      (*(int(*)())position_render)(0xc,0x400,row_height,*(int *)(position_table + 0xc));
      (*(int(*)())position_render)(0xc,0x500,row_height,*(int *)(position_table + 0x10));
      (*(int(*)())sprite_cmd)(0xc,*standings_entry,(int)DAT_0601fbb4,standings_entry[1]);
      (*(int(*)())position_render)(0xc,0x600,row_height,*(int *)(position_table + 0x14));
      (*(int(*)())position_render)(0xc,0x700,row_height,*(int *)(position_table + 0x18));
      (*(int(*)())sprite_cmd)(0xc,*standings_entry,0x730,standings_entry[1]);
      (*(int(*)())position_render)(0xc,0x800,row_height,*(int *)(position_table + 0x1c));
      (*(int(*)())position_render)(0xc,0x900,row_height,*(int *)(position_table + 0x20));
      (*(int(*)())position_render)(0xc,0xa00,row_height,*(int *)(position_table + 0x24));
      (*(int(*)())position_render)(0xc,0xb00,row_height,*(int *)(position_table + 0x28));
      (*(int(*)())sprite_cmd)(0xc,*standings_entry,(int)DAT_0601fbc4,standings_entry[1]);
      (*(int(*)())position_render)(0xc,0xc80,row_height,*(int *)0x0605E0E4);
      header_data = standings_entry[1];
      header_cmd = *standings_entry;
      final_y = DAT_0601fbc8;
    }
    else {
      if (layout_mode != '\b') {
        if (layout_mode == '\f') {
          /* Layout 12: compact 3-row results */
          (*(int(*)())0x060284AE)(0xc,0x480,row_height,*(int *)0x0605E0DC);
          (*(int(*)())sprite_cmd)(0xc,*(int *)(layout_base + header_y),0x498,
                            *(int *)((int)(layout_base + header_y) + 4));
          (*(int(*)())position_render)(0xc,0x600,row_height,*(int *)0x0605E0E0);
          standings_entry = (int *)(layout_base + base_y);
          (*(int(*)())sprite_cmd)(0xc,*standings_entry,0x620,standings_entry[1]);
          (*(int(*)())position_render)(0xc,0x800,row_height,*(int *)0x0605E0E4);
          (*(int(*)())sprite_cmd)(0xc,*standings_entry,0x852,standings_entry[1]);
        }
        goto LAB_0601fcd4;
      }
      /* Layout 8: mid 5-row results */
      (*(int(*)())0x060284AE)(0xc,0x380,row_height,*(int *)0x0605E0D0);
      (*(int(*)())sprite_cmd)(0xc,*(int *)(layout_base + header_y),0x398,
                        *(int *)((int)(layout_base + header_y) + 4));
      (*(int(*)())position_render)(0xc,0x500,row_height,*(int *)0x0605E0D4);
      standings_entry = (int *)(layout_base + base_y);
      (*(int(*)())sprite_cmd)(0xc,*standings_entry,(int)DAT_0601fc94,standings_entry[1]);
      (*(int(*)())position_render)(0xc,0x680,row_height,*(int *)0x0605E0D8);
      (*(int(*)())sprite_cmd)(0xc,*standings_entry,0x6b2,standings_entry[1]);
      (*(int(*)())position_render)(0xc,0x880,row_height,*(int *)0x0605E0E4);
      header_data = standings_entry[1];
      header_cmd = *standings_entry;
      final_y = DAT_0601fc9c;
    }
    (*(int(*)())sprite_cmd)(0xc,header_cmd,(int)final_y,header_data);
  }

LAB_0601fcd4:
  /* Reset all matrix transforms and write VDP2 CRAM priority marker */
  layout_base = (char *)0x06038BD4; /* matrix_set function */
  (*(int(*)())0x06038BD4)(0x100,0);
  (*(int(*)())layout_base)(4,0);
  (*(int(*)())layout_base)(8,0);
  (*(int(*)())layout_base)(0x10,0);
  (*(int(*)())layout_base)(0x20,7);
  (*(int(*)())layout_base)(1,0);
  (*(int(*)())0x06036E90)(0x25E7FFFE,1,vdp2_priority); /* vdp2_cram_write */
  (*(int(*)())layout_base)(0x20,7);

  return;
}
#endif /* standings_screen_render */
#if 0 /* FUN_0601F9CC -- replaced by ASM import of original bytes */
/* REMOVED: conflicting alias */ // void FUN_0601f9cc() __attribute__((alias("standings_screen_render")));
#endif

/* mode_transition_vdp_reset -- Reset VDP state for mode transition. */
#if 0 /* mode_transition_vdp_reset -- redirected to ASM import via linker PROVIDE */
void mode_transition_vdp_reset(void)
{
    INPUT_STATE |= 4;
    vdp1_texture_palette_init();
    *(int *)0x060620D0 = 0;
    *(int *)0x0605A000 = 0;
    *(int *)0x0605A004 = 0;
    VDP1_CMD_BASE_PTR = 0;
    VBLANK_OUT_COUNTER = 0;
}
#endif /* mode_transition_vdp_reset */
#if 0 /* FUN_0601FD20 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // void FUN_0601fd20() __attribute__((alias("mode_transition_vdp_reset")));
#endif

/* FUN_0601fd74: L2 version in mode_dispatch.c */
extern void FUN_0601FD74(void);
void FUN_0601fd74(void) { FUN_0601FD74(); }

/* FUN_0601FD20 -- original binary (84 bytes) */
__asm__(
    ".section .text.FUN_0601FD20, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601FD20\n"
    ".global _FUN_0601fd20\n"
    ".type _FUN_0601FD20, @function\n"
    "_FUN_0601FD20:\n"
    "_FUN_0601fd20:\n"
    ".byte 0x4F, 0x22, 0xD4, 0x0D, 0xD3, 0x0D, 0x60, 0x42, 0xCB, 0x04, 0x43, 0x0B, 0x24, 0x02, 0xE4, 0x00\n"  /* 0x0601FD20 */
    ".byte 0xD3, 0x0B, 0x23, 0x42, 0xD3, 0x0B, 0x23, 0x42, 0xD3, 0x0B, 0x23, 0x42, 0xD3, 0x0B, 0x23, 0x42\n"  /* 0x0601FD30 */
    ".byte 0xD3, 0x0B, 0x4F, 0x26, 0x00, 0x0B, 0x23, 0x42, 0x01, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x8B, 0xD4\n"  /* 0x0601FD40 */
    ".byte 0x25, 0xE7, 0xFF, 0xFE, 0x06, 0x03, 0x6E, 0x90, 0x06, 0x05, 0xB6, 0xD8, 0x06, 0x02, 0x6C, 0xE0\n"  /* 0x0601FD50 */
    ".byte 0x06, 0x06, 0x20, 0xD0, 0x06, 0x05, 0xA0, 0x00, 0x06, 0x05, 0xA0, 0x04, 0x06, 0x05, 0xA0, 0x08\n"  /* 0x0601FD60 */
    ".byte 0x06, 0x05, 0x9F, 0x44\n"  /* 0x0601FD70 */
);

/* replay_car_state_load -- Load car state data from replay descriptor.
 * Reads replay header from pointer at 0x060877F4: [0]=car_count-1,
 * [1]=frame_count, [2]=course_id, [3]=data_start. Iterates each car,
 * assigning car struct pointers (stride 0x268 at 0x06078900) into
 * 0x0607E940, then calls FUN_0601fec0 to load per-car replay data. */
#if 0 /* replay_car_state_load -- redirected to ASM import via linker PROVIDE */
void replay_car_state_load()
{
    char *car_count_ptr = (char *)0x0607EA98;   /* replay car count */
    char *car_base      = (char *)0x06078900;   /* car struct array */
    char *car_ptr_slot  = (char *)0x0607E940;   /* current car pointer */
    int car_stride = 0x268;
    int *replay_hdr = *(int **)0x060877F4;      /* replay data header */
    unsigned int car_idx;

    *(int *)0x060877FC = replay_hdr[1];         /* store frame count */
    *(int *)car_count_ptr = *replay_hdr + -1;   /* car count (0-based) */
    (*(int(*)())0x060054EA)(replay_hdr[2]);     /* set course */

    int data_ptr = replay_hdr[3];               /* per-car data start */
    *(short *)0x06087800 = 0;
    *(short *)0x06087802 = 0;

    for (car_idx = 0; car_idx <= *(unsigned int *)car_count_ptr; car_idx = car_idx + 1) {
        *(char **)car_ptr_slot = car_base + car_idx * car_stride;
        car_replay_state_init(data_ptr);
        data_ptr = data_ptr + 8;
    }

    (*(int(*)())0x0600D280)();                  /* post-load finalize */
    *(short *)0x06087804 = 2;                   /* set replay state = active */
}
#endif /* replay_car_state_load */
#if 0 /* FUN_0601FE20 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // void FUN_0601fe20() __attribute__((alias("replay_car_state_load")));
#endif

#if 0 /* car_replay_state_init -- redirected to ASM import via linker PROVIDE */
void car_replay_state_init(param_1)
    unsigned short *param_1;
{
    char *spline_buf = (char *)0x06078680;
    int speed_off = (int)DAT_0601ff8a;
    int car = CAR_PTR_CURRENT;
    int half_speed = (int)(unsigned int)*param_1 >> 1;

    /* Set speed at 4 adjacent offsets */
    *(int *)(car + speed_off) = half_speed;
    *(int *)(car + speed_off + 4) = half_speed;
    *(int *)(car + speed_off + -4) = half_speed;
    *(int *)(car + speed_off + -8) = half_speed;

    /* Compute heading angle */
    unsigned short heading = param_1[1];
    *(unsigned int *)(car + 8) = (unsigned int)heading;
    int angle = (*(int(*)())0x06027552)(0x35a, (unsigned int)heading << 0x10);
    *(int *)(car + 0xc) = angle;
    *(int *)(car + DAT_0601ff8e) = angle;

    /* Set steering at two adjacent offsets */
    unsigned short steering = param_1[2];
    int steer_off = (int)DAT_0601ff90;
    *(unsigned int *)(car + steer_off) = (unsigned int)steering;
    *(unsigned int *)(car + steer_off + -4) = (unsigned int)steering;

    /* Sample track spline for position/rotation */
    (*(int(*)())0x0600CB90)(spline_buf, *param_1);
    *(int *)(car + 0x10) = *(int *)spline_buf;                /* X */
    *(int *)(car + 0x14) = *(int *)(spline_buf + 4);          /* Y */
    *(int *)(car + 0x18) = *(int *)(spline_buf + 8);          /* Z */
    *(int *)(car + 0x1c) = (int)*(short *)(spline_buf + 0xc); /* rot X */
    *(int *)(car + 0x20) = (int)*(short *)(spline_buf + 0xe); /* rot Y */
    *(int *)(car + 0x24) = (int)*(short *)(spline_buf + 0x10);/* rot Z */

    /* Copy rotation to physics state */
    *(int *)(car + 0x30) = *(int *)(car + 0x20);
    *(int *)(car + 0x28) = *(int *)(car + 0x20);
    int phys_off = 0x1b0;
    *(int *)(car + phys_off) = *(int *)(car + 0x20);
    *(int *)(car + phys_off + -0xc) = *(int *)(car + 0x1c);
    *(int *)(car + phys_off + -8) = *(int *)(car + 0x20);
    *(int *)(car + phys_off + -4) = *(int *)(car + 0x24);

    /* Increment lap counter, wrap if exceeds total */
    int lap_off = phys_off + 0x3c;
    *(int *)(car + lap_off) = *(int *)(car + lap_off) + 1;
    if (*(int *)0x0607EA9C < *(int *)(car + lap_off)) {
        *(int *)(car + DAT_0601ff8a) = *(int *)(car + DAT_0601ff8a) - *(int *)0x0607EA9C;
    }
    *(int *)(car + DAT_0601ff8a + -8) = *(int *)(car + DAT_0601ff8a);
}
#endif /* car_replay_state_init */

/* FUN_0601FE20 -- original binary (160 bytes) */
__asm__(
    ".section .text.FUN_0601FE20, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601FE20\n"
    ".global _FUN_0601fe20\n"
    ".type _FUN_0601FE20, @function\n"
    "_FUN_0601FE20:\n"
    "_FUN_0601fe20:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x4F, 0x22, 0x4F, 0x12\n"  /* 0x0601FE20 */
    ".byte 0xD9, 0x19, 0xDA, 0x1A, 0xDB, 0x1A, 0x9C, 0x2E, 0xDE, 0x1A, 0xD2, 0x1B, 0x6E, 0xE2, 0x53, 0xE1\n"  /* 0x0601FE30 */
    ".byte 0x22, 0x32, 0x63, 0xE2, 0x73, 0xFF, 0x2B, 0x32, 0xD3, 0x18, 0x43, 0x0B, 0x54, 0xE2, 0x5D, 0xE3\n"  /* 0x0601FE40 */
    ".byte 0xE4, 0x00, 0x62, 0x4D, 0xD3, 0x16, 0x23, 0x21, 0x61, 0x4D, 0xD3, 0x16, 0x23, 0x11, 0xA0, 0x08\n"  /* 0x0601FE50 */
    ".byte 0x6E, 0x43, 0x0E, 0xC7, 0x02, 0x1A, 0x32, 0xAC, 0x29, 0x22, 0xB0, 0x29, 0x64, 0xD3, 0x7D, 0x08\n"  /* 0x0601FE60 */
    ".byte 0x7E, 0x01, 0x62, 0xB2, 0x3E, 0x26, 0x8B, 0xF4, 0xD3, 0x0F, 0x43, 0x0B, 0x00, 0x09, 0xE2, 0x02\n"  /* 0x0601FE70 */
    ".byte 0xD3, 0x0E, 0x23, 0x21, 0x4F, 0x16, 0x4F, 0x26, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6\n"  /* 0x0601FE80 */
    ".byte 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x02, 0x68, 0x06, 0x07, 0xE9, 0x40, 0x06, 0x07, 0x89, 0x00\n"  /* 0x0601FE90 */
    ".byte 0x06, 0x07, 0xEA, 0x98, 0x06, 0x08, 0x77, 0xF4, 0x06, 0x08, 0x77, 0xFC, 0x06, 0x00, 0x54, 0xEA\n"  /* 0x0601FEA0 */
    ".byte 0x06, 0x08, 0x78, 0x00, 0x06, 0x08, 0x78, 0x02, 0x06, 0x00, 0xD2, 0x80, 0x06, 0x08, 0x78, 0x04\n"  /* 0x0601FEB0 */
);

#if 0 /* FUN_0601FEC0 -- replaced by ASM import */
/* REMOVED: conflicting alias */ // void FUN_0601fec0() __attribute__((alias("car_replay_state_init")));
#endif

#if 0 /* FUN_0601E2B4 -- replaced by ASM import */
void FUN_0601e2b4()
{

  char *puVar1;

  char *puVar2;

  char *puVar3;

  char *puVar4;

  unsigned int uVar5;

  puVar4 = (char *)0x20100063;

  puVar3 = (char *)0x0605E068;

  puVar2 = (char *)0x0604A5C0;

  puVar1 = (char *)0x060877D8;

  if (*(int *)0x06087080 == '\0') {

    for (uVar5 = 0; uVar5 < *(unsigned int *)(puVar2 + (unsigned int)(unsigned char)(*puVar1 << 2)); uVar5 = uVar5 + 1) {

      *(char *)(*(int *)puVar3 + uVar5) = 0;

    }

  }

  do {

  } while ((*puVar4 & 1) == 1);

  *puVar4 = 1;

  *(int *)0x2010001F = 0x1a;

  do {

  } while ((*puVar4 & 1) != 0);

  (*(int(*)())(*(int *)0x06000358))(*(int *)0x0605E060,*(int *)0x0605E064,0x06087086);

  FUN_0601e37c();

  do {

  } while ((*puVar4 & 1) == 1);

  *puVar4 = 1;

  *(int *)0x2010001F = 0x19;

  do {

  } while ((*puVar4 & 1) != 0);

  return;
}
#endif

/* FUN_0601FEC0 -- original binary (232 bytes) */
__asm__(
    ".section .text.FUN_0601FEC0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601FEC0\n"
    ".global _FUN_0601fec0\n"
    ".type _FUN_0601FEC0, @function\n"
    "_FUN_0601FEC0:\n"
    "_FUN_0601fec0:\n"
    ".byte 0x2F, 0xE6, 0xE3, 0x00, 0x2F, 0xD6, 0x2F, 0xC6, 0x4F, 0x22, 0x6C, 0x43, 0xDE, 0x31, 0xDD, 0x32\n"  /* 0x0601FEC0 */
    ".byte 0x90, 0x5B, 0x64, 0xC1, 0x6E, 0xE2, 0x64, 0x4D, 0x33, 0x47, 0x34, 0x3E, 0x44, 0x21, 0x0E, 0x46\n"  /* 0x0601FED0 */
    ".byte 0x70, 0x04, 0x0E, 0x46, 0x70, 0xF8, 0x0E, 0x46, 0x70, 0xFC, 0x0E, 0x46, 0x85, 0xC1, 0x63, 0x03\n"  /* 0x0601FEE0 */
    ".byte 0x63, 0x3D, 0x65, 0x33, 0x1E, 0x32, 0x94, 0x49, 0xD3, 0x28, 0x43, 0x0B, 0x45, 0x28, 0x64, 0x03\n"  /* 0x0601FEF0 */
    ".byte 0x1E, 0x03, 0x90, 0x44, 0x0E, 0x46, 0x85, 0xC2, 0x64, 0x03, 0x64, 0x4D, 0x90, 0x40, 0x0E, 0x46\n"  /* 0x0601FF00 */
    ".byte 0x70, 0xFC, 0x0E, 0x46, 0x65, 0xC1, 0xD3, 0x22, 0x65, 0x5D, 0x43, 0x0B, 0x64, 0xD3, 0x62, 0xD2\n"  /* 0x0601FF10 */
    ".byte 0x1E, 0x24, 0x53, 0xD1, 0x1E, 0x35, 0x52, 0xD2, 0x1E, 0x26, 0x85, 0xD6, 0x63, 0x03, 0x1E, 0x07\n"  /* 0x0601FF20 */
    ".byte 0x85, 0xD7, 0x63, 0x03, 0x1E, 0x08, 0x85, 0xD8, 0x63, 0x03, 0x1E, 0x09, 0x53, 0xE8, 0x1E, 0x3C\n"  /* 0x0601FF30 */
    ".byte 0x52, 0xE8, 0x1E, 0x2A, 0x53, 0xE8, 0x90, 0x24, 0x0E, 0x36, 0x53, 0xE7, 0x70, 0xF4, 0x0E, 0x36\n"  /* 0x0601FF40 */
    ".byte 0x53, 0xE8, 0x70, 0x04, 0x0E, 0x36, 0x53, 0xE9, 0x70, 0x04, 0x0E, 0x36, 0x70, 0x40, 0x03, 0xEE\n"  /* 0x0601FF50 */
    ".byte 0x73, 0x01, 0x0E, 0x36, 0xD4, 0x0F, 0x03, 0xEE, 0x62, 0x42, 0x33, 0x27, 0x8B, 0x04, 0x62, 0x42\n"  /* 0x0601FF60 */
    ".byte 0x90, 0x0B, 0x03, 0xEE, 0x33, 0x28, 0x0E, 0x36, 0x90, 0x07, 0x03, 0xEE, 0x70, 0xF8, 0x0E, 0x36\n"  /* 0x0601FF70 */
    ".byte 0x4F, 0x26, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0x01, 0xEC, 0x03, 0x5A, 0x01, 0x94\n"  /* 0x0601FF80 */
    ".byte 0x01, 0xFC, 0x01, 0xB0, 0x06, 0x07, 0xE9, 0x40, 0x06, 0x07, 0x86, 0x80, 0x06, 0x02, 0x75, 0x52\n"  /* 0x0601FF90 */
    ".byte 0x06, 0x00, 0xCB, 0x90, 0x06, 0x07, 0xEA, 0x9C\n"  /* 0x0601FFA0 */
);

/* FUN_0601E2B4 -- original binary (200 bytes) */
__asm__(
    ".section .text.FUN_0601E2B4, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E2B4\n"
    ".global _FUN_0601e2b4\n"
    ".type _FUN_0601E2B4, @function\n"
    "_FUN_0601E2B4:\n"
    "_FUN_0601e2b4:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0xEC, 0x00, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x4F, 0x22\n"  /* 0x0601E2B4 */
    ".byte 0xD9, 0x23, 0xDA, 0x24, 0xDB, 0x24, 0xDD, 0x25, 0xD3, 0x25, 0x63, 0x30, 0x63, 0x3C, 0x23, 0x38\n"  /* 0x0601E2C4 */
    ".byte 0x8F, 0x0D, 0xEE, 0x01, 0xA0, 0x05, 0x64, 0xC3, 0x62, 0xB2, 0x32, 0x4C, 0x63, 0xCC, 0x22, 0x30\n"  /* 0x0601E2D4 */
    ".byte 0x74, 0x01, 0x60, 0x90, 0x60, 0x0C, 0x40, 0x08, 0x03, 0xAE, 0x34, 0x32, 0x8B, 0xF4, 0x62, 0xD0\n"  /* 0x0601E2E4 */
    ".byte 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x89, 0xFA, 0x62, 0xEC, 0x2D, 0x20, 0xE3, 0x1A, 0xD2, 0x19\n"  /* 0x0601E2F4 */
    ".byte 0x22, 0x30, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x22, 0x28, 0x8B, 0xFA, 0xD3, 0x16, 0xD6, 0x17\n"  /* 0x0601E304 */
    ".byte 0xD5, 0x17, 0xD4, 0x18, 0x63, 0x32, 0x65, 0x52, 0x43, 0x0B, 0x64, 0x42, 0xB0, 0x2C, 0x00, 0x09\n"  /* 0x0601E314 */
    ".byte 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x32, 0xE0, 0x89, 0xFA, 0x62, 0xEC, 0x2D, 0x20, 0xE3, 0x19\n"  /* 0x0601E324 */
    ".byte 0xD2, 0x0C, 0x22, 0x30, 0x62, 0xD0, 0x62, 0x2C, 0x22, 0xE9, 0x22, 0x28, 0x8B, 0xFA, 0x4F, 0x26\n"  /* 0x0601E334 */
    ".byte 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xFF, 0xFF\n"  /* 0x0601E344 */
    ".byte 0x06, 0x08, 0x77, 0xD8, 0x06, 0x04, 0xA5, 0xC0, 0x06, 0x05, 0xE0, 0x68, 0x20, 0x10, 0x00, 0x63\n"  /* 0x0601E354 */
    ".byte 0x06, 0x08, 0x70, 0x80, 0x20, 0x10, 0x00, 0x1F, 0x06, 0x00, 0x03, 0x58, 0x06, 0x08, 0x70, 0x86\n"  /* 0x0601E364 */
    ".byte 0x06, 0x05, 0xE0, 0x64, 0x06, 0x05, 0xE0, 0x60\n"  /* 0x0601E374 */
);


/* FUN_0601F9CC -- original binary (852 bytes) */
__asm__(
    ".section .text.FUN_0601F9CC, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601F9CC\n"
    ".global _FUN_0601f9cc\n"
    ".type _FUN_0601F9CC, @function\n"
    "_FUN_0601F9CC:\n"
    "_FUN_0601f9cc:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0x2F, 0x96, 0x2F, 0x86, 0x4F, 0x22\n"  /* 0x0601F9CC */
    ".byte 0x7F, 0xF8, 0x93, 0x22, 0x60, 0x33, 0x81, 0xF2, 0xD3, 0x15, 0x43, 0x0B, 0xE4, 0x0C, 0xD3, 0x15\n"  /* 0x0601F9DC */
    ".byte 0x43, 0x0B, 0x00, 0x09, 0xDB, 0x14, 0xDC, 0x15, 0xD0, 0x15, 0x60, 0x02, 0x88, 0x01, 0x8B, 0x55\n"  /* 0x0601F9EC */
    ".byte 0xE7, 0x08, 0xD5, 0x14, 0xD4, 0x14, 0xD3, 0x15, 0x43, 0x0B, 0xE6, 0x00, 0xD5, 0x14, 0xD4, 0x15\n"  /* 0x0601F9FC */
    ".byte 0xD3, 0x15, 0x43, 0x0B, 0xE6, 0x20, 0xD0, 0x15, 0x60, 0x00, 0xA0, 0x3F, 0x60, 0x0C, 0x97, 0x05\n"  /* 0x0601FA0C */
    ".byte 0x37, 0xBC, 0x2F, 0x72, 0x57, 0x71, 0xA0, 0x28, 0xE6, 0x00, 0x7C, 0x00, 0x02, 0xC0, 0xFF, 0xFF\n"  /* 0x0601FA1C */
    ".byte 0x80, 0x00, 0x00, 0x00, 0x06, 0x02, 0x6C, 0xE0, 0x40, 0x00, 0x00, 0x00, 0x06, 0x06, 0x3D, 0x9A\n"  /* 0x0601FA2C */
    ".byte 0x06, 0x02, 0x85, 0x3E, 0x06, 0x02, 0x85, 0x60, 0x06, 0x06, 0x37, 0x50, 0x06, 0x02, 0x84, 0x00\n"  /* 0x0601FA3C */
    ".byte 0x06, 0x07, 0x86, 0x44, 0x00, 0x01, 0x77, 0x00, 0x25, 0xE7, 0x21, 0x94, 0x06, 0x00, 0x51, 0x1E\n"  /* 0x0601FA4C */
    ".byte 0x06, 0x04, 0x89, 0x4C, 0x25, 0xF0, 0x06, 0x00, 0x06, 0x02, 0x76, 0x1E, 0x06, 0x05, 0xE0, 0x5C\n"  /* 0x0601FA5C */
    ".byte 0x97, 0x2A, 0x37, 0xBC, 0x2F, 0x72, 0x57, 0x71, 0x96, 0x27, 0x65, 0xF2, 0x65, 0x52, 0x4C, 0x0B\n"  /* 0x0601FA6C */
    ".byte 0xE4, 0x0C, 0xA1, 0x29, 0x00, 0x09, 0x97, 0x21, 0x37, 0xBC, 0x2F, 0x72, 0x57, 0x71, 0x96, 0x1E\n"  /* 0x0601FA7C */
    ".byte 0x65, 0xF2, 0x65, 0x52, 0x4C, 0x0B, 0xE4, 0x0C, 0xA1, 0x1E, 0x00, 0x09, 0x88, 0x04, 0x89, 0xBE\n"  /* 0x0601FA8C */
    ".byte 0x88, 0x08, 0x89, 0xE5, 0x88, 0x0C, 0x89, 0xEE, 0xA1, 0x16, 0x00, 0x09, 0xD5, 0x09, 0xD4, 0x0A\n"  /* 0x0601FA9C */
    ".byte 0xD3, 0x0A, 0x43, 0x0B, 0xE6, 0x20, 0x98, 0x0B, 0x69, 0x83, 0x79, 0x08, 0xDD, 0x08, 0x9E, 0x08\n"  /* 0x0601FAAC */
    ".byte 0xD0, 0x08, 0x60, 0x00, 0xA1, 0x00, 0x60, 0x0C, 0x02, 0xC8, 0x03, 0x80, 0x02, 0xD0, 0x04, 0x00\n"  /* 0x0601FABC */
    ".byte 0x05, 0x90, 0x00, 0x90, 0x06, 0x05, 0xCD, 0x9C, 0x25, 0xF0, 0x06, 0x00, 0x06, 0x02, 0x76, 0x1E\n"  /* 0x0601FACC */
    ".byte 0x06, 0x02, 0x84, 0xAE, 0x06, 0x05, 0xE0, 0x5C, 0xDA, 0x39, 0x66, 0xE3, 0x95, 0x5D, 0x67, 0xA2\n"  /* 0x0601FADC */
    ".byte 0x4D, 0x0B, 0xE4, 0x0C, 0x67, 0xB3, 0x37, 0x9C, 0x2F, 0x72, 0x57, 0x71, 0x96, 0x56, 0x65, 0xF2\n"  /* 0x0601FAEC */
    ".byte 0x65, 0x52, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x51, 0x57, 0xA1, 0x4D, 0x0B, 0xE4, 0x0C\n"  /* 0x0601FAFC */
    ".byte 0x57, 0xA2, 0x66, 0xE3, 0x95, 0x4C, 0x4D, 0x0B, 0xE4, 0x0C, 0x69, 0xB3, 0x96, 0x49, 0x39, 0x8C\n"  /* 0x0601FB0C */
    ".byte 0x57, 0x91, 0x65, 0x92, 0x4C, 0x0B, 0xE4, 0x0C, 0x57, 0xA3, 0x66, 0xE3, 0x95, 0x42, 0x4D, 0x0B\n"  /* 0x0601FB1C */
    ".byte 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x3F, 0x57, 0xA4, 0x4D, 0x0B, 0xE4, 0x0C, 0x57, 0x91, 0x96, 0x3B\n"  /* 0x0601FB2C */
    ".byte 0x65, 0x92, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x37, 0x57, 0xA5, 0x4D, 0x0B, 0xE4, 0x0C\n"  /* 0x0601FB3C */
    ".byte 0x57, 0xA6, 0x66, 0xE3, 0x95, 0x32, 0x4D, 0x0B, 0xE4, 0x0C, 0x57, 0x91, 0x96, 0x2F, 0x65, 0x92\n"  /* 0x0601FB4C */
    ".byte 0x4C, 0x0B, 0xE4, 0x0C, 0x57, 0xA7, 0x66, 0xE3, 0x95, 0x2A, 0x4D, 0x0B, 0xE4, 0x0C, 0x66, 0xE3\n"  /* 0x0601FB5C */
    ".byte 0x95, 0x27, 0x57, 0xA8, 0x4D, 0x0B, 0xE4, 0x0C, 0x57, 0xA9, 0x66, 0xE3, 0x95, 0x22, 0x4D, 0x0B\n"  /* 0x0601FB6C */
    ".byte 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x1F, 0x57, 0xAA, 0x4D, 0x0B, 0xE4, 0x0C, 0x57, 0x91, 0x96, 0x1B\n"  /* 0x0601FB7C */
    ".byte 0x65, 0x92, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x17, 0xD7, 0x0E, 0x67, 0x72, 0x4D, 0x0B\n"  /* 0x0601FB8C */
    ".byte 0xE4, 0x0C, 0x57, 0x91, 0x96, 0x12, 0xA0, 0x47, 0x65, 0x92, 0x00, 0x80, 0x00, 0x98, 0x01, 0x80\n"  /* 0x0601FB9C */
    ".byte 0x02, 0x80, 0x02, 0x96, 0x04, 0x00, 0x05, 0x00, 0x05, 0x36, 0x06, 0x00, 0x07, 0x00, 0x07, 0x30\n"  /* 0x0601FBAC */
    ".byte 0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B, 0x00, 0x0B, 0x0E, 0x0C, 0x80, 0x0C, 0xD2, 0xFF, 0xFF\n"  /* 0x0601FBBC */
    ".byte 0x06, 0x05, 0xE0, 0xA4, 0x06, 0x05, 0xE0, 0xE4, 0xD7, 0x35, 0x66, 0xE3, 0x95, 0x59, 0x67, 0x72\n"  /* 0x0601FBCC */
    ".byte 0x4D, 0x0B, 0xE4, 0x0C, 0x67, 0xB3, 0x37, 0x9C, 0x2F, 0x72, 0x57, 0x71, 0x96, 0x52, 0x65, 0xF2\n"  /* 0x0601FBDC */
    ".byte 0x65, 0x52, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x4D, 0xD7, 0x2E, 0x67, 0x72, 0x4D, 0x0B\n"  /* 0x0601FBEC */
    ".byte 0xE4, 0x0C, 0x6A, 0xB3, 0x96, 0x48, 0x3A, 0x8C, 0x57, 0xA1, 0x65, 0xA2, 0x4C, 0x0B, 0xE4, 0x0C\n"  /* 0x0601FBFC */
    ".byte 0xD7, 0x29, 0x66, 0xE3, 0x95, 0x41, 0x67, 0x72, 0x4D, 0x0B, 0xE4, 0x0C, 0x57, 0xA1, 0x96, 0x3D\n"  /* 0x0601FC0C */
    ".byte 0x65, 0xA2, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xE3, 0x95, 0x39, 0xD7, 0x24, 0x67, 0x72, 0x4D, 0x0B\n"  /* 0x0601FC1C */
    ".byte 0xE4, 0x0C, 0x57, 0xA1, 0x96, 0x34, 0x65, 0xA2, 0x4C, 0x0B, 0xE4, 0x0C, 0xA0, 0x4C, 0x00, 0x09\n"  /* 0x0601FC2C */
    ".byte 0xD7, 0x1F, 0x66, 0xE3, 0x95, 0x2D, 0x67, 0x72, 0x4D, 0x0B, 0xE4, 0x0C, 0x67, 0xB3, 0x37, 0x9C\n"  /* 0x0601FC3C */
    ".byte 0x2F, 0x72, 0x57, 0x71, 0x96, 0x26, 0x65, 0xF2, 0x65, 0x52, 0x4C, 0x0B, 0xE4, 0x0C, 0x66, 0xE3\n"  /* 0x0601FC4C */
    ".byte 0x95, 0x21, 0xD7, 0x18, 0x67, 0x72, 0x4D, 0x0B, 0xE4, 0x0C, 0x6A, 0xB3, 0x96, 0x1C, 0x3A, 0x8C\n"  /* 0x0601FC5C */
    ".byte 0x57, 0xA1, 0x65, 0xA2, 0x4C, 0x0B, 0xE4, 0x0C, 0xD7, 0x10, 0x66, 0xE3, 0x95, 0x15, 0x67, 0x72\n"  /* 0x0601FC6C */
    ".byte 0x4D, 0x0B, 0xE4, 0x0C, 0x57, 0xA1, 0x96, 0x11, 0x65, 0xA2, 0x4C, 0x0B, 0xE4, 0x0C, 0xA0, 0x23\n"  /* 0x0601FC7C */
    ".byte 0x00, 0x09, 0x03, 0x80, 0x03, 0x98, 0x05, 0x00, 0x05, 0x1E, 0x06, 0x80, 0x06, 0xB2, 0x08, 0x80\n"  /* 0x0601FC8C */
    ".byte 0x08, 0xD2, 0x04, 0x80, 0x04, 0x98, 0x06, 0x00, 0x06, 0x20, 0x08, 0x00, 0x08, 0x52, 0xFF, 0xFF\n"  /* 0x0601FC9C */
    ".byte 0x06, 0x05, 0xE0, 0xD0, 0x06, 0x05, 0xE0, 0xD4, 0x06, 0x05, 0xE0, 0xD8, 0x06, 0x05, 0xE0, 0xE4\n"  /* 0x0601FCAC */
    ".byte 0x06, 0x05, 0xE0, 0xDC, 0x06, 0x05, 0xE0, 0xE0, 0x88, 0x04, 0x8B, 0x01, 0xAF, 0x0C, 0x00, 0x09\n"  /* 0x0601FCBC */
    ".byte 0x88, 0x08, 0x89, 0x81, 0x88, 0x0C, 0x89, 0xB3, 0xDE, 0x1D, 0x94, 0x37, 0x4E, 0x0B, 0xE5, 0x00\n"  /* 0x0601FCCC */
    ".byte 0xE5, 0x00, 0x4E, 0x0B, 0xE4, 0x04, 0xE5, 0x00, 0x4E, 0x0B, 0xE4, 0x08, 0xE5, 0x00, 0x4E, 0x0B\n"  /* 0x0601FCDC */
    ".byte 0xE4, 0x10, 0xE5, 0x07, 0x4E, 0x0B, 0xE4, 0x20, 0xE5, 0x00, 0x4E, 0x0B, 0xE4, 0x01, 0x66, 0xF3\n"  /* 0x0601FCEC */
    ".byte 0xD4, 0x14, 0xD3, 0x15, 0x76, 0x04, 0x43, 0x0B, 0xE5, 0x01, 0xE5, 0x07, 0x4E, 0x0B, 0xE4, 0x20\n"  /* 0x0601FCFC */
    ".byte 0x7F, 0x08, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6\n"  /* 0x0601FD0C */
    ".byte 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601FD1C */
);

/* FUN_0601F5E0 -- original binary (420 bytes) */
__asm__(
    ".section .text.FUN_0601F5E0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601F5E0\n"
    ".global _FUN_0601f5e0\n"
    ".type _FUN_0601F5E0, @function\n"
    "_FUN_0601F5E0:\n"
    "_FUN_0601f5e0:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x4F, 0x22, 0xEB, 0x40, 0x4F, 0x12, 0x6C, 0xB3\n"  /* 0x0601F5E0 */
    ".byte 0x9D, 0x63, 0xDE, 0x32, 0x7C, 0x40, 0xB1, 0x40, 0xE4, 0x00, 0xD3, 0x31, 0x43, 0x0B, 0x00, 0x09\n"  /* 0x0601F5F0 */
    ".byte 0xD3, 0x30, 0x43, 0x0B, 0x00, 0x09, 0xD3, 0x30, 0x43, 0x0B, 0x00, 0x09, 0xD0, 0x2F, 0x60, 0x00\n"  /* 0x0601F600 */
    ".byte 0x60, 0x0C, 0x20, 0x08, 0x8B, 0x01, 0xA0, 0xA9, 0x00, 0x09, 0xD4, 0x2D, 0x84, 0xE4, 0x62, 0x03\n"  /* 0x0601F610 */
    ".byte 0x24, 0x20, 0x74, 0x01, 0x84, 0xE5, 0x62, 0x03, 0x24, 0x20, 0x74, 0x01, 0x84, 0xE6, 0x62, 0x03\n"  /* 0x0601F620 */
    ".byte 0x24, 0x20, 0x74, 0x01, 0x84, 0xE7, 0x63, 0x03, 0x24, 0x30, 0xD4, 0x25, 0xD3, 0x25, 0x62, 0x42\n"  /* 0x0601F630 */
    ".byte 0x63, 0x32, 0x33, 0x22, 0x8B, 0x04, 0x60, 0x42, 0x20, 0x08, 0x89, 0x01, 0xA0, 0x8E, 0x00, 0x09\n"  /* 0x0601F640 */
    ".byte 0xE3, 0x01, 0xD2, 0x21, 0x22, 0x30, 0xD3, 0x21, 0xD2, 0x21, 0x63, 0x32, 0x22, 0x30, 0xD4, 0x1D\n"  /* 0x0601F650 */
    ".byte 0x60, 0x44, 0x80, 0xE4, 0x60, 0x44, 0x80, 0xE5, 0x62, 0x44, 0x60, 0x23, 0x80, 0xE6, 0x60, 0x40\n"  /* 0x0601F660 */
    ".byte 0x80, 0xE7, 0xD4, 0x1C, 0x64, 0x42, 0x34, 0xD2, 0x89, 0x08, 0x60, 0x43, 0x63, 0xCC, 0x74, 0x01\n"  /* 0x0601F670 */
    ".byte 0x0E, 0xB4, 0x60, 0x43, 0x74, 0x01, 0x34, 0xD2, 0x8F, 0xF7, 0x0E, 0x34, 0xD4, 0x13, 0x64, 0x42\n"  /* 0x0601F680 */
    ".byte 0x74, 0x01, 0xB0, 0xF2, 0x64, 0x4C, 0xD5, 0x14, 0x60, 0x52, 0x20, 0x08, 0x8D, 0x01, 0xE4, 0x00\n"  /* 0x0601F690 */
    ".byte 0x64, 0x52, 0xD5, 0x12, 0x60, 0x52, 0x20, 0x08, 0x89, 0x00, 0x64, 0x52, 0xD6, 0x10, 0xD5, 0x11\n"  /* 0x0601F6A0 */
    ".byte 0x24, 0x48, 0x89, 0x38, 0x63, 0x50, 0xA0, 0x1F, 0x00, 0x09, 0x27, 0x10, 0x06, 0x07, 0xED, 0x90\n"  /* 0x0601F6B0 */
    ".byte 0x06, 0x01, 0xE2, 0xB4, 0x06, 0x01, 0xEB, 0x70, 0x06, 0x01, 0xF4, 0x0C, 0x06, 0x07, 0x86, 0x35\n"  /* 0x0601F6C0 */
    ".byte 0x06, 0x08, 0x77, 0xF0, 0x06, 0x07, 0x86, 0xA4, 0x06, 0x05, 0xE0, 0xA1, 0x06, 0x07, 0xEA, 0xD8\n"  /* 0x0601F6D0 */
    ".byte 0x06, 0x05, 0xE0, 0xA0, 0x06, 0x07, 0xED, 0x88, 0x06, 0x08, 0x5F, 0xFC, 0x06, 0x08, 0x60, 0x00\n"  /* 0x0601F6E0 */
    ".byte 0x06, 0x05, 0xE0, 0x6C, 0x06, 0x08, 0x77, 0xD8, 0xE2, 0x0B, 0x23, 0x2F, 0x03, 0x1A, 0x63, 0x3E\n"  /* 0x0601F6F0 */
    ".byte 0x33, 0x6C, 0x60, 0x40, 0x80, 0x37, 0x63, 0x50, 0x23, 0x2F, 0x03, 0x1A, 0x63, 0x3E, 0x33, 0x6C\n"  /* 0x0601F700 */
    ".byte 0x84, 0x41, 0x80, 0x38, 0x63, 0x50, 0x23, 0x2F, 0x03, 0x1A, 0x63, 0x3E, 0x33, 0x6C, 0x84, 0x42\n"  /* 0x0601F710 */
    ".byte 0x80, 0x39, 0xA0, 0x18, 0x61, 0x03, 0x62, 0x50, 0xE3, 0x0B, 0x22, 0x3F, 0x02, 0x1A, 0x62, 0x2E\n"  /* 0x0601F720 */
    ".byte 0x32, 0x6C, 0xE0, 0x44, 0x80, 0x27, 0x63, 0x50, 0xE2, 0x0B, 0x23, 0x2F, 0x03, 0x1A, 0x63, 0x3E\n"  /* 0x0601F730 */
    ".byte 0x33, 0x6C, 0xE0, 0x41, 0x80, 0x38, 0x63, 0x50, 0x23, 0x2F, 0x03, 0x1A, 0x63, 0x3E, 0x33, 0x6C\n"  /* 0x0601F740 */
    ".byte 0xE1, 0x59, 0x60, 0x13, 0x80, 0x39, 0xD3, 0x09, 0x43, 0x0B, 0x00, 0x09, 0x4F, 0x16, 0x4F, 0x26\n"  /* 0x0601F750 */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0xD3, 0x06, 0x43, 0x2B, 0x6E, 0xF6, 0x4F, 0x16, 0x4F, 0x26\n"  /* 0x0601F760 */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6, 0xFF, 0xFF, 0x06, 0x01, 0xE2, 0xB4\n"  /* 0x0601F770 */
    ".byte 0x06, 0x01, 0xEB, 0x1C\n"  /* 0x0601F780 */
);

/* FUN_0601E958 -- original binary (328 bytes) */
__asm__(
    ".section .text.FUN_0601E958, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601E958\n"
    ".global _FUN_0601e958\n"
    ".type _FUN_0601E958, @function\n"
    "_FUN_0601E958:\n"
    "_FUN_0601e958:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0x2F, 0xA6, 0xEB, 0x08, 0x2F, 0x96, 0xEA, 0x10\n"  /* 0x0601E958 */
    ".byte 0x2F, 0x86, 0x4F, 0x22, 0xD9, 0x21, 0xDC, 0x22, 0xDD, 0x22, 0xD0, 0x23, 0x60, 0x00, 0x20, 0x08\n"  /* 0x0601E968 */
    ".byte 0x8D, 0x02, 0xE8, 0x00, 0xA0, 0x87, 0x2D, 0x80, 0xBC, 0x98, 0x00, 0x09, 0xDE, 0x1F, 0xD2, 0x20\n"  /* 0x0601E978 */
    ".byte 0x64, 0xE0, 0x64, 0x4C, 0x63, 0x43, 0x44, 0x08, 0x43, 0x08, 0x43, 0x00, 0x34, 0x3C, 0xBD, 0x9D\n"  /* 0x0601E988 */
    ".byte 0x34, 0x2C, 0x64, 0x0C, 0xE2, 0x07, 0x34, 0x23, 0x8B, 0x0B, 0xB0, 0xE5, 0x00, 0x09, 0x62, 0xE0\n"  /* 0x0601E998 */
    ".byte 0xD3, 0x18, 0x62, 0x2C, 0x32, 0x3C, 0x22, 0x80, 0xE2, 0x04, 0x4C, 0x0B, 0x2D, 0x20, 0xA0, 0x6A\n"  /* 0x0601E9A8 */
    ".byte 0x00, 0x09, 0xE1, 0x01, 0x62, 0xE0, 0xD3, 0x13, 0x62, 0x2C, 0x32, 0x3C, 0x22, 0x10, 0xE3, 0x03\n"  /* 0x0601E9B8 */
    ".byte 0x34, 0x33, 0x8B, 0x23, 0x74, 0xFD, 0x63, 0xE0, 0xD2, 0x0F, 0x64, 0x4C, 0x63, 0x3C, 0x33, 0x2C\n"  /* 0x0601E9C8 */
    ".byte 0x23, 0x40, 0xB0, 0xC9, 0x00, 0x09, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6\n"  /* 0x0601E9D8 */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0xA5, 0x0E, 0x6E, 0xF6, 0x20, 0x10, 0x00, 0x1F, 0x06, 0x05, 0xE0, 0x98\n"  /* 0x0601E9E8 */
    ".byte 0x06, 0x01, 0xF8, 0xBC, 0x06, 0x05, 0xE0, 0x5C, 0x06, 0x05, 0xE0, 0x5D, 0x06, 0x08, 0x77, 0xD8\n"  /* 0x0601E9F8 */
    ".byte 0x06, 0x04, 0xA5, 0x7C, 0x06, 0x08, 0x77, 0xDD, 0x06, 0x08, 0x77, 0xD9, 0x62, 0xE0, 0xD3, 0x2F\n"  /* 0x0601EA08 */
    ".byte 0x62, 0x2C, 0x32, 0x3C, 0x22, 0x40, 0x66, 0x92, 0x65, 0xE0, 0xD2, 0x2D, 0x64, 0xE0, 0x65, 0x5C\n"  /* 0x0601EA18 */
    ".byte 0x64, 0x4C, 0x63, 0x53, 0x45, 0x08, 0x43, 0x08, 0x43, 0x00, 0x35, 0x3C, 0x35, 0x2C, 0xD3, 0x27\n"  /* 0x0601EA28 */
    ".byte 0x34, 0x3C, 0x64, 0x40, 0xBE, 0x92, 0x64, 0x4C, 0x64, 0x03, 0x24, 0x48, 0x89, 0x03, 0x4C, 0x0B\n"  /* 0x0601EA38 */
    ".byte 0x2D, 0xB0, 0xA0, 0x20, 0x00, 0x09, 0xD2, 0x23, 0x62, 0x20, 0x62, 0x2C, 0x22, 0x28, 0x8B, 0x1A\n"  /* 0x0601EA48 */
    ".byte 0x64, 0x83, 0x63, 0x92, 0x33, 0x4C, 0x62, 0x30, 0xD3, 0x1F, 0x62, 0x2C, 0x33, 0x4C, 0x61, 0x30\n"  /* 0x0601EA58 */
    ".byte 0x61, 0x1C, 0x32, 0x10, 0x89, 0x03, 0x4C, 0x0B, 0x2D, 0xB0, 0xA0, 0x0C, 0x00, 0x09, 0x74, 0x01\n"  /* 0x0601EA68 */
    ".byte 0x34, 0xA3, 0x8B, 0xEE, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6, 0x6C, 0xF6\n"  /* 0x0601EA78 */
    ".byte 0x6D, 0xF6, 0xA0, 0xA6, 0x6E, 0xF6, 0x4F, 0x26, 0x68, 0xF6, 0x69, 0xF6, 0x6A, 0xF6, 0x6B, 0xF6\n"  /* 0x0601EA88 */
    ".byte 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601EA98 */
);

/* FUN_0601EAA0 -- original binary (124 bytes) */
__asm__(
    ".section .text.FUN_0601EAA0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601EAA0\n"
    ".global _FUN_0601eaa0\n"
    ".type _FUN_0601EAA0, @function\n"
    "_FUN_0601EAA0:\n"
    "_FUN_0601eaa0:\n"
    ".byte 0x2F, 0xE6, 0x2F, 0xD6, 0x4F, 0x22, 0xED, 0x00, 0xDE, 0x0E, 0xD2, 0x0B, 0x64, 0xE0, 0x64, 0x4C\n"  /* 0x0601EAA0 */
    ".byte 0x63, 0x43, 0x44, 0x08, 0x43, 0x08, 0x43, 0x00, 0x34, 0x3C, 0xBD, 0x0B, 0x34, 0x2C, 0x64, 0x0C\n"  /* 0x0601EAB0 */
    ".byte 0xD6, 0x09, 0xE2, 0x07, 0x34, 0x23, 0x8B, 0x11, 0x60, 0xE0, 0x60, 0x0C, 0xE3, 0x00, 0x06, 0x34\n"  /* 0x0601EAC0 */
    ".byte 0xA0, 0x1F, 0x00, 0x09, 0x06, 0x08, 0x77, 0xD9, 0x06, 0x04, 0xA5, 0x7C, 0x06, 0x08, 0x70, 0x80\n"  /* 0x0601EAD0 */
    ".byte 0x06, 0x04, 0xA5, 0xAC, 0x06, 0x08, 0x77, 0xD8, 0x06, 0x08, 0x77, 0xDD, 0xE5, 0x01, 0xE2, 0x03\n"  /* 0x0601EAE0 */
    ".byte 0x60, 0xE0, 0x60, 0x0C, 0x06, 0x54, 0xD6, 0x19, 0x34, 0x23, 0x8B, 0x05, 0x60, 0xE0, 0x60, 0x0C\n"  /* 0x0601EAF0 */
    ".byte 0x74, 0xFD, 0x64, 0x4C, 0xA0, 0x05, 0x06, 0x44, 0x60, 0xE0, 0x60, 0x0C, 0x64, 0x4C, 0x06, 0x44\n"  /* 0x0601EB00 */
    ".byte 0x6D, 0x5C, 0x60, 0xD3, 0x4F, 0x26, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601EB10 */
);

/* FUN_0601F40C -- original binary (88 bytes) */
__asm__(
    ".section .text.FUN_0601F40C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601F40C\n"
    ".global _FUN_0601f40c\n"
    ".type _FUN_0601F40C, @function\n"
    "_FUN_0601F40C:\n"
    "_FUN_0601f40c:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0xDE, 0x20, 0xD2, 0x21, 0x63, 0xE0, 0x63, 0x3C, 0x33, 0x2C, 0x60, 0x30\n"  /* 0x0601F40C */
    ".byte 0x60, 0x0C, 0x20, 0x08, 0x89, 0x1D, 0xBD, 0xCF, 0x00, 0x09, 0xD6, 0x1D, 0x65, 0xE0, 0xD2, 0x1D\n"  /* 0x0601F41C */
    ".byte 0x64, 0xE0, 0x66, 0x62, 0x65, 0x5C, 0x64, 0x4C, 0x63, 0x53, 0x45, 0x08, 0x43, 0x08, 0x43, 0x00\n"  /* 0x0601F42C */
    ".byte 0x35, 0x3C, 0x35, 0x2C, 0xD3, 0x18, 0x34, 0x3C, 0x64, 0x40, 0xB9, 0xE3, 0x64, 0x4C, 0x64, 0x03\n"  /* 0x0601F43C */
    ".byte 0x24, 0x48, 0x89, 0x06, 0xE3, 0x0C, 0xD2, 0x15, 0x22, 0x30, 0x4F, 0x26, 0xD3, 0x14, 0x43, 0x2B\n"  /* 0x0601F44C */
    ".byte 0x6E, 0xF6, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601F45C */
);

/* FUN_0601EB1C -- original binary (84 bytes) */
__asm__(
    ".section .text.FUN_0601EB1C, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601EB1C\n"
    ".global _FUN_0601eb1c\n"
    ".type _FUN_0601EB1C, @function\n"
    "_FUN_0601EB1C:\n"
    "_FUN_0601eb1c:\n"
    ".byte 0x2F, 0xE6, 0x4F, 0x22, 0xDE, 0x0F, 0xD2, 0x10, 0x63, 0xE0, 0x63, 0x3C, 0x33, 0x2C, 0x60, 0x30\n"  /* 0x0601EB1C */
    ".byte 0x60, 0x0C, 0x20, 0x08, 0x89, 0x11, 0xD6, 0x0D, 0x65, 0xE0, 0xD2, 0x0D, 0x64, 0xE0, 0x66, 0x62\n"  /* 0x0601EB2C */
    ".byte 0x65, 0x5C, 0x64, 0x4C, 0x63, 0x53, 0x45, 0x08, 0x43, 0x08, 0x43, 0x00, 0x35, 0x3C, 0x35, 0x2C\n"  /* 0x0601EB3C */
    ".byte 0xD3, 0x03, 0x34, 0x3C, 0x64, 0x40, 0xBE, 0x5D, 0x64, 0x4C, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601EB4C */
    ".byte 0x06, 0x08, 0x77, 0xD9, 0x06, 0x08, 0x77, 0xD8, 0x06, 0x08, 0x77, 0xDD, 0x06, 0x05, 0xE0, 0x98\n"  /* 0x0601EB5C */
    ".byte 0x06, 0x04, 0xA5, 0x7C\n"  /* 0x0601EB6C */
);

/* FUN_0601EB70 -- original binary (106 bytes) */
__asm__(
    ".section .text.FUN_0601EB70, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0601EB70\n"
    ".global _FUN_0601eb70\n"
    ".type _FUN_0601EB70, @function\n"
    "_FUN_0601EB70:\n"
    "_FUN_0601eb70:\n"
    ".byte 0x2F, 0xE6, 0xEE, 0x10, 0x2F, 0xD6, 0x2F, 0xC6, 0x2F, 0xB6, 0xDB, 0x1E, 0xDC, 0x1E, 0xDD, 0x1F\n"  /* 0x0601EB70 */
    ".byte 0xD7, 0x1F, 0xD6, 0x20, 0xD0, 0x20, 0x60, 0x00, 0x60, 0x0C, 0x20, 0x08, 0x8D, 0x02, 0xE5, 0x00\n"  /* 0x0601EB80 */
    ".byte 0xA0, 0x1E, 0x00, 0x09, 0xA0, 0x05, 0x64, 0x53, 0x62, 0xD2, 0x32, 0x4C, 0x63, 0x5C, 0x22, 0x30\n"  /* 0x0601EB90 */
    ".byte 0x74, 0x01, 0x60, 0xC0, 0x60, 0x0C, 0x40, 0x08, 0x03, 0xBE, 0x34, 0x32, 0x8B, 0xF4, 0x64, 0x53\n"  /* 0x0601EBA0 */
    ".byte 0x63, 0x62, 0x62, 0x43, 0x33, 0x4C, 0x32, 0x7C, 0x74, 0x01, 0x61, 0x20, 0x62, 0x43, 0x23, 0x10\n"  /* 0x0601EBB0 */
    ".byte 0x32, 0x7C, 0x63, 0x62, 0x61, 0x20, 0x33, 0x4C, 0x23, 0x10, 0x74, 0x01, 0x34, 0xE3, 0x8B, 0xEF\n"  /* 0x0601EBC0 */
    ".byte 0x6B, 0xF6, 0x6C, 0xF6, 0x6D, 0xF6, 0x00, 0x0B, 0x6E, 0xF6\n"  /* 0x0601EBD0 */
);
