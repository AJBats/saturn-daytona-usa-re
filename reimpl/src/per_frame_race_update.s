/* per_frame_race_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600E7C8 - 0x0600E906
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Demo/attract mode per-frame physics pipeline — same 5-step physics as
 * player_physics_main (gear, engine, friction, accel, collision) but uses
 * a different collision handler and adds steering interpolation.
 *
 * Physics pipeline:
 *   1. gear_shift_handler    — process gear changes
 *   2. engine_force           — compute engine output
 *   3. friction_stub          — apply surface friction
 *   4. accel_response         — compute acceleration
 *   5. demo_collision         — collision for demo/attract mode
 *
 * Steering interpolation (selected by mode byte):
 *   Mode 1 (fast): new = old + (target - old) / 4
 *     (shift16, shar, shar, shlr16 = divide by ~4)
 *   Mode 2 (smooth): new = old + (target - old + 0x8000) / 2
 *     (shift16, shar, shlr16 = divide by ~2, with rounding)
 *     Also runs the surface timer/slot mechanism.
 *
 * Final: velocity integration + surface type lookup + display speed.
 * Cross-TU pool references (0x0600E920+) are in the adjacent ai_physics_main TU.
 */

    .section .text.FUN_0600E7C8


    .global per_frame_race_update
    .type per_frame_race_update, @function
per_frame_race_update:
    mov.l r14, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    mov.l   .L_car_struct_ptr, r14
    mov.l   .L_fn_gear_shift, r3
    jsr @r3                            /* step 1: gear shift handler */
    mov.l @r14, r14                    /* r14 = car struct */
    mov.l   .L_fn_engine_force, r3
    jsr @r3                            /* step 2: engine force computation */
    nop
    mov.l   .L_fn_friction, r3
    jsr @r3                            /* step 3: surface friction */
    nop
    mov.l   .L_fn_accel_response, r3
    jsr @r3                            /* step 4: acceleration response */
    nop
    mov.l   .L_fn_demo_collision, r3
    jsr @r3                            /* step 5: demo/attract collision */
    nop
    mov.l   .L_steering_mode_byte, r0
    bra     .L_0600E898
    mov.b @r0, r0                      /* read steering interpolation mode */
.L_0600E7F4:                              /* --- mode 1: fast steering interpolation --- */
    mov.l @(40, r14), r4              /* r4 = current steering angle */
    mov.w   DAT_0600e86c, r0          /* +0x25C = target steering angle */
    mov.l @(r0, r14), r2              /* r2 = target angle */
    sub r4, r2                         /* r2 = error (target - current) */
    shll16 r2                          /* scale up for precision */
    shar r2                            /* / 2 */
    shar r2                            /* / 4 total */
    shlr16 r2                          /* scale back down */
    exts.w r2, r2                      /* sign-extend interpolation step */
    add r4, r2                         /* new angle = current + step */
    exts.w r2, r4
    exts.w r4, r5
    mov.l r5, @(48, r14)              /* car[+48] = new angle (display copy) */
    bra     .L_0600E8A0
    mov.l r5, @(40, r14)              /* car[+40] = new angle (physics copy) */
.L_0600E812:                              /* --- mode 2: smooth steering + surface timer --- */
    mov.l @(40, r14), r4              /* r4 = current steering angle */
    mov.w   DAT_0600e86c, r0          /* +0x25C = target steering angle */
    mov.l   .L_rounding_half, r3      /* r3 = 0x8000 (rounding bias) */
    mov.l @(r0, r14), r2              /* r2 = target angle */
    add #-0x54, r0                     /* r0 = +0x208 (surface timer) */
    sub r4, r2                         /* r2 = error */
    add r3, r2                         /* add rounding bias */
    shll16 r2                          /* scale up */
    shar r2                            /* / 2 */
    shlr16 r2                          /* scale back */
    exts.w r2, r2
    add r4, r2                         /* new angle = current + step */
    exts.w r2, r4
    exts.w r4, r5
    mov.l r5, @(48, r14)              /* store display + physics copies */
    mov.l r5, @(40, r14)
    mov.l @(r0, r14), r0              /* check surface timer at +0x208 */
    tst r0, r0
    bt      .L_0600E8A0               /* timer == 0 → skip surface logic */
    mov.w   DAT_0600e86e, r0          /* +0x208 = surface change timer */
    mov.l @(r0, r14), r3
    add #-0x1, r3                      /* decrement timer */
    mov.l r3, @(r0, r14)
    tst r3, r3
    bf      .L_0600E868               /* timer > 0 → skip surface lookup */
    mov.w   DAT_0600e870, r0          /* timer reached 0 → lookup next surface */
    mov.l @(r0, r14), r4              /* r4 = car[+0x1E4] (surface slot index) */
    mov r4, r3
    shll2 r4                           /* idx * 8 */
    shll r4
    shll2 r3                           /* idx * 16 */
    shll2 r3
    add r3, r4                         /* idx * 24 (slot stride) */
    add #-0x4, r0                      /* r0 = +0x1E0 (slot base) */
    mov.l @(r0, r14), r3
    add r3, r4                         /* r4 = &slot[idx] */
    mov.w @(20, r4), r0               /* slot[+20] = surface type */
    mov r0, r3
    mov.w   .L_off_surface_type, r0   /* +0x1F8 */
    mov.l r3, @(r0, r14)              /* store new surface type */
    mov.w   .L_surface_reset_val, r3  /* 0x0400 */
    add #0xC, r0                       /* +0x204 */
    mov.l r3, @(r0, r14)              /* store reset constant */
.L_0600E868:
    bra     .L_0600E8A0
    nop

    .global DAT_0600e86c
DAT_0600e86c:
    .2byte  0x025C                        /* car offset: target steering angle */

    .global DAT_0600e86e
DAT_0600e86e:
    .2byte  0x0208                        /* car offset: surface change timer */

    .global DAT_0600e870
DAT_0600e870:
    .2byte  0x01E4                        /* car offset: surface slot index */
.L_off_surface_type:
    .2byte  0x01F8                        /* car offset: surface type */
.L_surface_reset_val:
    .2byte  0x0400                        /* surface timer reset constant */
    .2byte  0xFFFF
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* pointer to current car struct */
.L_fn_gear_shift:
    .4byte  gear_shift_handler         /* step 1: manual gear shift */
.L_fn_engine_force:
    .4byte  sym_06008640               /* step 2: engine torque/force */
.L_fn_friction:
    .4byte  friction_stub              /* step 3: surface friction */
.L_fn_accel_response:
    .4byte  accel_response             /* step 4: acceleration curve */
.L_fn_demo_collision:
    .4byte  sym_0602D88E               /* step 5: demo/attract collision handler */
.L_steering_mode_byte:
    .4byte  sym_06083261               /* steering interpolation mode (1=fast, 2=smooth) */
.L_rounding_half:
    .4byte  0x00008000                  /* 0.5 rounding bias for mode 2 interpolation */
.L_0600E898:                              /* --- steering mode dispatch --- */
    cmp/eq #0x1, r0
    bt      .L_0600E7F4               /* mode 1 → fast interpolation */
    cmp/eq #0x2, r0
    bt      .L_0600E812               /* mode 2 → smooth interpolation */
.L_0600E8A0:                              /* --- post-steering: track + velocity --- */
    .byte   0xD3, 0x21    /* mov.l .L_pool_0600E928, r3 — track_segment_advance (cross-TU) */
    jsr @r3                            /* advance track segment */
    nop
    .byte   0x90, 0x3A    /* mov.w .L_wpool_0600E91E, r0 — offset +0x228 (speed, cross-TU) */
    .byte   0xD3, 0x20    /* mov.l .L_pool_0600E92C, r3 — speed_coeff (cross-TU) */
    mov.l @(r0, r14), r2              /* r2 = car.forward_speed */
    mov.l @r3, r3                      /* r3 = speed coefficient */
    add #-0x3C, r0                     /* r0 = +0x1EC */
    mul.l r3, r2                       /* speed * coefficient */
    mov.l @(r0, r14), r3              /* r3 = car[+0x1EC] (position base) */
    sts macl, r2                       /* r2 = product */
    add #0x8, r0                       /* r0 = +0x1F4 */
    add r3, r2                         /* position + speed*coeff */
    mov.l r2, @(r0, r14)              /* car[+0x1F4] = integrated position */
    add #-0x10, r0                     /* surface slot lookup (same as mode 2) */
    mov.l @(r0, r14), r4
    add #-0x4, r0
    mov r4, r3
    shll2 r4
    shll2 r3
    shll r4
    shll2 r3
    add r3, r4
    mov.l @(r0, r14), r3
    add r3, r4
    mov.w @(20, r4), r0               /* read surface type from slot */
    mov r0, r3
    .byte   0x90, 0x23    /* mov.w .L_wpool_0600E920, r0 — +0x1F8 (cross-TU) */
    mov.l r3, @(r0, r14)              /* store surface type */
    .byte   0xD3, 0x15    /* mov.l .L_pool_0600E930, r3 — game_state_flags (cross-TU) */
    .byte   0xD2, 0x15    /* mov.l .L_pool_0600E934, r2 — 0x00200000 bitmask (cross-TU) */
    mov.l @r3, r3
    and r2, r3                         /* check game flags bit 21 */
    tst r3, r3
    bt      .L_0600E8FE               /* bit clear → skip display speed */
    .byte   0xD5, 0x14    /* mov.l .L_pool_0600E938, r5 — display coeff (cross-TU) */
    .byte   0xD3, 0x14    /* mov.l .L_pool_0600E93C, r3 — fpmul (cross-TU) */
    jsr @r3                            /* fpmul(speed, display_coeff) */
    mov.l @(12, r14), r4
    shlr16 r0                          /* convert to 16-bit */
    exts.w r0, r0
    .byte   0x91, 0x16    /* mov.w .L_wpool_0600E922, r1 — +0x1F8 display (cross-TU) */
    add r14, r1
    mov.l r0, @r1                      /* store display speed A */
    .byte   0x91, 0x14    /* mov.w .L_wpool_0600E924, r1 — +0xE0 display (cross-TU) */
    add r14, r1
    mov.l r0, @r1                      /* store display speed B */
.L_0600E8FE:
    lds.l @r15+, macl
    lds.l @r15+, pr
    rts
    mov.l @r15+, r14
