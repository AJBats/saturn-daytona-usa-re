/* atan2_full -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602745C - 0x06027498
 * Auto-generated by tools/generate_l3_tu.py
 *
 * atan2_full(x, y) -- Full atan2 computation for non-degenerate case
 *   Input:  r4 = x, r5 = y (y guaranteed non-zero by caller)
 *   Output: r0 = atan2(y, x) as angle (16-bit, 0x0000-0xFFFF = 0-360 deg)
 *
 *   Algorithm:
 *     1. Save sign of y into r7 via cmp/pz + movt
 *     2. Call fpdiv_setup to compute x/y ratio
 *     3. Call atan_piecewise to get base angle from ratio
 *     4. If y was negative (r7 == 0): add 0x8000 (180 degrees)
 *     5. Sign-extend result to 32 bits
 *
 * isqrt(value) -- Integer square root via binary search
 *   Input:  r4 = value (32-bit unsigned)
 *   Output: r0 = floor(sqrt(value)) << 8 (fixed-point shifted)
 *
 *   Algorithm:
 *     guess = 0, bit = 0x8000
 *     loop: trial = guess + bit
 *       if trial^2 == value: done
 *       if trial^2 > value: undo (guess -= bit)
 *       bit >>= 1; repeat while bit > 0
 *     return guess << 8
 */

    .section .text.FUN_0602745C


    .global atan2_full
    .type atan2_full, @function
atan2_full:
    sts.l pr, @-r15                 ! save return address
    cmp/pz r5                      ! test if y >= 0 (sets T flag)
    .byte   0xB0, 0x7C    /* bsr 0x0602755C (external: fpdiv_setup) */
    .word 0x0729 /* movt r7 -- r7 = T flag (1=y positive, 0=y negative) */
    .byte   0xBF, 0x88    /* bsr 0x06027378 (external: atan_piecewise) */
    mov r0, r4                     ! r4 = x/y ratio (result of fpdiv_setup) as atan input
    lds.l @r15+, pr                ! restore return address
    tst r7, r7                     ! was y negative? (r7 == 0 means negative)
    bf      .L_no_quadrant_adjust  ! y was positive, skip 180-degree offset
    .byte   0xD2, 0x21    /* mov.l .L_pool_060274F4, r2 ! r2 = 0x8000 (180 degrees) */
    add r2, r0                     ! add 180 degrees for quadrants 3-4
.L_no_quadrant_adjust:
    rts                            ! return
    exts.w r0, r0                  ! sign-extend angle to 32 bits (delay slot)

    .global isqrt
isqrt:
    cmp/pl r4                      ! test if value > 0
    bf/s    .L_isqrt_done          ! if value <= 0, return 0 (delay slot sets r0 = 0)
    mov #0x0, r0                   ! r0 = 0 (initial guess)
    .byte   0xD2, 0x1D    /* mov.l .L_pool_060274F4, r2 ! r2 = 0x8000 (initial bit = MSB) */
.L_isqrt_loop:
    add r2, r0                     ! trial = guess + bit
    mul.l r0, r0                   ! compute trial^2
    sts macl, r3                   ! r3 = trial^2
    cmp/eq r4, r3                  ! trial^2 == value? (exact match)
    bt      .L_isqrt_done          ! exact match found, done
    cmp/hi r4, r3                  ! trial^2 > value? (overshot)
    bf      .L_isqrt_no_undo       ! trial^2 <= value, keep the bit
    sub r2, r0                     ! undo: guess -= bit (overshot)
.L_isqrt_no_undo:
    shlr r2                        ! bit >>= 1 (try next smaller bit)
    cmp/pl r2                      ! bit > 0? (more bits to try)
    bt      .L_isqrt_loop          ! continue binary search
.L_isqrt_done:
    rts                            ! return
    shll8 r0                       ! r0 <<= 8 (scale to fixed-point, delay slot)
