/* geom_pipeline_coord -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060173AC - 0x0601772E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Geometry Pipeline Coordinator
 * =============================
 * Coordinates the per-frame track geometry rendering pipeline.
 * This is the top-level function that drives track segment selection,
 * vertex generation, and submission to the render queue.
 *
 * Pipeline stages:
 *   1. Copy vertex data from ROM tables into local workspace
 *      (two memcpy_byte calls for vertex source A and B)
 *   2. Select segment table (default vs demo mode variant)
 *   3. Read segment descriptors — each has width (r6) and height (r7) counts
 *   4. Call geom_computation (BSR 0x06017784) to build vertex arrays
 *      for 3 primary segment groups (offsets +0, +6, +0x12 from table)
 *   5. Clamp frame counter to max (599,999), apply frame multiply for timing
 *   6. Call anim_frame_transform to compute animation frame index
 *   7. Copy transformed vertex indices into output buffer (8 iterations)
 *   8. Process segment group at offset +0x0C with another geom_computation pass
 *   9. Call anim_frame_transform again for second vertex copy pass (8 iterations)
 *  10. Process segment group at offset +0x18 with geom_computation
 *  11. Compute model_data_lookup and mem_store_helper for the current segment
 *  12. If demo mode: process extra segment at offset +0x1E, then return
 *  13. If normal mode: range-check segment index, dispatch to 4 variant
 *      geom_computation calls (cases 1-3 + default) using offset +0x2A
 *  14. Optionally process segment at offset +0x1E (model_data_lookup result)
 *  15. Always process segment at offset +0x24 (mem_store_helper result)
 *
 * Key data structures:
 *   sym_06044B84 = default segment selection table (10 entries, 6 bytes each)
 *   sym_06044BB4 = demo mode segment selection table (same format)
 *   sym_06078900 = car array base (stride 0x268)
 *   sym_060786A4 = frame counter (current animation frame)
 *   sym_0607EAE0 = demo mode / race-end flag (nonzero = demo)
 *   sym_0607EBF4 = race event bitfield (bit 0 = special timing)
 *   sym_0607EBD0 = frame count variable (for frame multiply)
 *   sym_06063750 = globals base (offsets for geometry buffers)
 *   sym_0605BC6C = vertex source data A
 *   sym_0605BC90 = vertex source data B
 *
 * Called from: per-frame track rendering pipeline (state 9 = car select,
 *   also during active racing).
 * Calls: memcpy_byte (sym_06035228), geom_computation (BSR),
 *   anim_frame_transform, model_data_lookup (sym_06034FE0),
 *   mem_store_helper (sym_06035C2C).
 *
 * Register conventions (persistent across function):
 *   r8  = 0x3000 (vertex buffer offset added to base pointers)
 *   r11 = 8 (vertex copy loop count)
 *   r12 = sp+0x10 (local vertex index lookup table)
 *   r13 = segment table pointer (default or demo)
 *   r14 = globals base (sym_06063750)
 *
 * Stack frame (0x6C = 108 bytes):
 *   sp+0x00 = temp storage (segment descriptor ptr / geom struct ptr)
 *   sp+0x04 = model_data_lookup result
 *   sp+0x08 = mem_store_helper result
 *   sp+0x10..0x47 = vertex source B copy (0x38 bytes)
 *   sp+0x48..0x6B = vertex source A copy (0x24 bytes)
 */

    .section .text.FUN_060173AC


    .global geom_pipeline_coord
    .type geom_pipeline_coord, @function
geom_pipeline_coord:
    mov.l r14, @-r15                 ! save r14
    mov.l r13, @-r15                 ! save r13
    mov.l r12, @-r15                 ! save r12
    mov.l r11, @-r15                 ! save r11
    mov.l r10, @-r15                 ! save r10
    mov #0x8, r11                    ! r11 = 8 (vertex copy loop count)
    mov.l r9, @-r15                  ! save r9
    mov.l r8, @-r15                  ! save r8
    sts.l pr, @-r15                  ! save pr (return address)
    add #-0x6C, r15                  ! allocate 108-byte stack frame
    mov.w   DAT_0601748a, r8         ! r8 = 0x3000 (vertex buffer offset)
    mov r15, r12                     ! r12 = sp (local frame base)
    mov.l   _pool_globals_base, r14  ! r14 = globals base (sym_06063750)
    mov r15, r1                      ! r1 = sp (memcpy dst)
    mov.l   _pool_vtx_src_a, r2     ! r2 = vertex source A (sym_0605BC6C)
    mov.l   _pool_fn_memcpy_byte, r3 ! r3 = memcpy_byte function
    add #0x10, r12                   ! r12 = sp+0x10 (vertex index table)
    add #0x48, r1                    ! r1 = sp+0x48 (dst for vtx src A)
    jsr @r3                          ! memcpy_byte(r0=count, r1=dst, r2=src)
    mov #0x24, r0                    ! r0 = 0x24 (36 bytes to copy)
    mov r15, r1                      ! r1 = sp
    mov.l   _pool_vtx_src_b, r2     ! r2 = vertex source B (sym_0605BC90)
    mov.l   _pool_fn_memcpy_byte, r3 ! r3 = memcpy_byte function
    add #0x10, r1                    ! r1 = sp+0x10 (dst for vtx src B)
    jsr @r3                          ! memcpy_byte(r0=count, r1=dst, r2=src)
    mov #0x38, r0                    ! r0 = 0x38 (56 bytes to copy)
    mov.l   _pool_seg_tbl_default, r13 ! r13 = default segment table (sym_06044B84)
    mov.l   _pool_demo_mode_flag, r0   ! r0 = &demo_mode_flag
    mov.l @r0, r0                    ! r0 = demo_mode_flag value
    tst r0, r0                       ! test if demo mode active
    bt      .L_seg_table_selected    ! if zero (normal): keep default table
    mov.l   _pool_seg_tbl_demo, r13  ! r13 = demo segment table (sym_06044BB4)
.L_seg_table_selected:
    mov.w @(2, r13), r0              ! r0 = seg_table[0].height (word at +2)
    mov.w @r13, r6                   ! r6 = seg_table[0].width (word at +0)
    mov.w   DAT_0601748c, r10        ! r10 = 0x02D8 (globals offset for geom struct A)
    mov r0, r7                       ! r7 = height
    extu.w r6, r6                    ! zero-extend width
    add r14, r10                     ! r10 = globals_base + 0x02D8 (geom struct A ptr)
    extu.w r7, r7                    ! zero-extend height
    mov.l @(4, r10), r5              ! r5 = geom_struct_A[1] (vertex base)
    add r8, r5                       ! r5 += 0x3000 (apply vertex buffer offset)
    .byte   0xB1, 0xC1    /* bsr 0x06017784 (geom_computation) */
    mov.l @r10, r4                   ! r4 = geom_struct_A[0] (segment data ptr) [delay]
    mov r13, r7                      ! r7 = seg_table ptr
    add #0x6, r7                     ! r7 = &seg_table[1] (2nd entry, offset +6)
    mov.l r7, @r15                   ! sp[0] = &seg_table[1] (save for later)
    mov.w @(2, r7), r0               ! r0 = seg_table[1].height
    mov.l @r15, r6                   ! r6 = &seg_table[1] (reload ptr)
    mov.l @(4, r10), r5              ! r5 = geom_struct_A[1] (vertex base)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[1].width
    add r8, r5                       ! r5 += 0x3000 (vertex buffer offset)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_0601748e, r0         ! r0 = 0x02E8 (globals offset for geom struct B)
    extu.w r6, r6                    ! zero-extend width
    .byte   0xB1, 0xB3    /* bsr 0x06017784 (geom_computation) */
    mov.l @(r0, r14), r4             ! r4 = globals[0x02E8] (segment data B) [delay]
    mov r13, r7                      ! r7 = seg_table ptr
    add #0x12, r7                    ! r7 = &seg_table[3] (4th entry, offset +0x12)
    mov.l r7, @r15                   ! sp[0] = &seg_table[3]
    mov.w @(2, r7), r0               ! r0 = seg_table[3].height
    mov.l @r15, r6                   ! r6 = &seg_table[3] (reload ptr)
    mov.l @(4, r10), r5              ! r5 = geom_struct_A[1] (vertex base)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[3].width
    add r8, r5                       ! r5 += 0x3000 (vertex buffer offset)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_06017490, r0         ! r0 = 0x02E0 (globals offset for geom struct C)
    extu.w r6, r6                    ! zero-extend width
    .byte   0xB1, 0xA5    /* bsr 0x06017784 (geom_computation) */
    mov.l @(r0, r14), r4             ! r4 = globals[0x02E0] (segment data C) [delay]
    mov.l   _pool_car_array_base, r2 ! r2 = car array base (sym_06078900)
    mov.l r2, @r15                   ! sp[0] = car_array_base
    mov r2, r3                       ! r3 = car_array_base
    mov.w   DAT_06017492, r0         ! r0 = 0x0240 (car struct field offset)
    mov.l @(r0, r3), r2              ! r2 = car[0].field_0x240 (segment index)
    mov.l r2, @(4, r15)              ! sp[4] = segment index
    mov.l   _pool_frame_counter, r4  ! r4 = &frame_counter (sym_060786A4)
    mov.l   _pool_max_frame_idx, r5  ! r5 = 599,999 (max frame index)
    mov.l @r4, r4                    ! r4 = current frame counter value
    cmp/ge r5, r4                    ! frame >= max?
    bf      .L_frame_clamped         ! if less: skip clamp
    mov r5, r4                       ! r4 = max (clamp to 599,999)
.L_frame_clamped:
    mov.l   _pool_race_event_flags, r0 ! r0 = &race_event_bitfield (sym_0607EBF4)
    mov.l @r0, r0                    ! r0 = race event flags
    tst #0x1, r0                     ! test bit 0 (special timing mode)
    bf      .L_no_frame_multiply     ! if set: skip frame multiply
    mov.l   _pool_frame_count_var, r4 ! r4 = &frame_count_var (sym_0607EBD0)
    mov.l @r4, r4                    ! r4 = frame count value
    mov r4, r3                       ! r3 = frame count (copy)
    shll2 r4                         ! r4 = frame_count * 4
    add r3, r4                       ! r4 = frame_count * 5 (multiply by 5)
.L_no_frame_multiply:
    mov.l   _pool_fn_anim_xform, r3 ! r3 = anim_frame_transform function
    jsr @r3                          ! r0 = anim_frame_transform(r4=frame)
    nop                              ! delay slot
    mov r0, r6                       ! r6 = transform result (index map ptr)
    mov #0x0, r4                     ! r4 = 0 (loop counter i)
.L_vtx_copy_loop_a:
    extu.b r4, r2                    ! r2 = i (zero-extended byte)
    mov r15, r3                      ! r3 = sp
    extu.b r4, r5                    ! r5 = i
    shll r2                          ! r2 = i * 2 (word index)
    add #0x48, r3                    ! r3 = sp+0x48 (vtx src A workspace)
    add r6, r5                       ! r5 = &index_map[i]
    add r3, r2                       ! r2 = &output_buf_a[i] (sp+0x48 + i*2)
    mov.b @r5, r0                    ! r0 = index_map[i] (byte lookup)
    extu.b r0, r0                    ! zero-extend byte index
    shll r0                          ! r0 = index * 2 (word offset)
    mov.w @(r0, r12), r0             ! r0 = vtx_src_b[index] (from sp+0x10)
    mov.w r0, @(4, r2)              ! output_buf_a[i].field4 = vertex data
    bra     .L_vtx_copy_body_a       ! jump to loop body continuation
    nop                              ! delay slot

    .global DAT_0601748a
DAT_0601748a:
    .2byte  0x3000

    .global DAT_0601748c
DAT_0601748c:
    .2byte  0x02D8

    .global DAT_0601748e
DAT_0601748e:
    .2byte  0x02E8

    .global DAT_06017490
DAT_06017490:
    .2byte  0x02E0

    .global DAT_06017492
DAT_06017492:
    .2byte  0x0240
_pool_globals_base:
    .4byte  sym_06063750
_pool_vtx_src_a:
    .4byte  sym_0605BC6C
_pool_fn_memcpy_byte:
    .4byte  sym_06035228
_pool_vtx_src_b:
    .4byte  sym_0605BC90
_pool_seg_tbl_default:
    .4byte  sym_06044B84
_pool_demo_mode_flag:
    .4byte  sym_0607EAE0
_pool_seg_tbl_demo:
    .4byte  sym_06044BB4
_pool_car_array_base:
    .4byte  sym_06078900
_pool_frame_counter:
    .4byte  sym_060786A4
_pool_max_frame_idx:
    .4byte  0x000927BF
_pool_race_event_flags:
    .4byte  sym_0607EBF4
_pool_frame_count_var:
    .4byte  sym_0607EBD0
_pool_fn_anim_xform:
    .4byte  anim_frame_transform
.L_vtx_copy_body_a:
    extu.b r4, r3                    ! r3 = i (zero-extended)
    mov r15, r2                      ! r2 = sp
    mov.b @r5, r1                    ! r1 = index_map[i] (re-read byte)
    add #0x2, r3                     ! r3 = i + 2 (secondary output index)
    add #0x1, r4                     ! r4 = i + 1 (advance loop counter)
    add #0x48, r2                    ! r2 = sp+0x48 (vtx src A workspace)
    extu.b r1, r1                    ! zero-extend byte index
    shll r3                          ! r3 = (i+2) * 2 (word offset)
    shll r1                          ! r1 = index * 2 (word offset)
    add r2, r3                       ! r3 = &output_buf_a[i+2]
    add r12, r1                      ! r1 = &vtx_src_b[index] (sp+0x10)
    mov.w @(28, r1), r0              ! r0 = vtx_src_b[index + 14] (word at +28)
    mov.w r0, @(16, r3)              ! output_buf_a[i+2].field16 = vertex data
    extu.b r4, r3                    ! r3 = new i (zero-extended)
    cmp/ge r11, r3                   ! i >= 8?
    bf      .L_vtx_copy_loop_a       ! if not: continue loop
    mov r13, r7                      ! r7 = seg_table ptr
    mov r15, r4                      ! r4 = sp (output buffer)
    add #0xC, r7                     ! r7 = &seg_table[2] (3rd entry, offset +0x0C)
    mov.l r7, @(8, r15)             ! sp[8] = &seg_table[2]
    mov.w @(2, r7), r0               ! r0 = seg_table[2].height
    mov.l @(8, r15), r6              ! r6 = &seg_table[2] (reload)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[2].width
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_060175b4, r0         ! r0 = 0x02BC (globals offset for geom struct D)
    extu.w r6, r6                    ! zero-extend width
    mov.l @(r0, r14), r5             ! r5 = globals[0x02BC] (vertex base D)
    add r8, r5                       ! r5 += 0x3000 (vertex buffer offset)
    .byte   0xB1, 0x3F    /* bsr 0x06017784 (geom_computation) */
    add #0x48, r4                    ! r4 = sp+0x48 (output buffer) [delay]
    mov.l   _pool_fn_anim_xform_b, r3 ! r3 = anim_frame_transform function
    jsr @r3                          ! r0 = anim_frame_transform(r4=seg_index)
    mov.l @(4, r15), r4              ! r4 = segment index (from sp[4]) [delay]
    mov r0, r6                       ! r6 = transform result (index map ptr)
    mov #0x0, r4                     ! r4 = 0 (loop counter i)
.L_vtx_copy_loop_b:
    extu.b r4, r2                    ! r2 = i (zero-extended)
    mov r15, r3                      ! r3 = sp
    extu.b r4, r5                    ! r5 = i
    shll r2                          ! r2 = i * 2 (word index)
    add #0x48, r3                    ! r3 = sp+0x48 (vtx src A workspace)
    add r6, r5                       ! r5 = &index_map[i]
    add r3, r2                       ! r2 = &output_buf_a[i]
    mov.b @r5, r0                    ! r0 = index_map[i] (byte lookup)
    extu.b r4, r3                    ! r3 = i (for secondary index)
    extu.b r0, r0                    ! zero-extend byte index
    add #0x2, r3                     ! r3 = i + 2 (secondary output index)
    add #0x1, r4                     ! r4 = i + 1 (advance counter)
    shll r0                          ! r0 = index * 2 (word offset)
    shll r3                          ! r3 = (i+2) * 2 (word offset)
    mov.w @(r0, r12), r0             ! r0 = vtx_src_b[index]
    mov.w r0, @(4, r2)              ! output_buf_a[i].field4 = vertex data
    mov r15, r2                      ! r2 = sp
    mov.b @r5, r1                    ! r1 = index_map[i] (re-read)
    add #0x48, r2                    ! r2 = sp+0x48
    extu.b r1, r1                    ! zero-extend byte index
    add r2, r3                       ! r3 = &output_buf_a[i+2]
    shll r1                          ! r1 = index * 2 (word offset)
    add r12, r1                      ! r1 = &vtx_src_b[index]
    mov.w @(28, r1), r0              ! r0 = vtx_src_b[index + 14]
    mov.w r0, @(16, r3)              ! output_buf_a[i+2].field16 = vertex data
    extu.b r4, r3                    ! r3 = new i
    cmp/ge r11, r3                   ! i >= 8?
    bf      .L_vtx_copy_loop_b       ! if not: continue loop
    mov r13, r7                      ! r7 = seg_table ptr
    mov r15, r4                      ! r4 = sp (output buffer)
    add #0x18, r7                    ! r7 = &seg_table[4] (5th entry, offset +0x18)
    mov.l r7, @(4, r15)             ! sp[4] = &seg_table[4]
    mov.w @(2, r7), r0               ! r0 = seg_table[4].height
    mov.l @(4, r15), r6              ! r6 = &seg_table[4] (reload)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[4].width
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_060175b4, r0         ! r0 = 0x02BC (globals offset for geom struct D)
    extu.w r6, r6                    ! zero-extend width
    mov.l @(r0, r14), r5             ! r5 = globals[0x02BC] (vertex base D)
    add r8, r5                       ! r5 += 0x3000 (vertex buffer offset)
    .byte   0xB1, 0x0F    /* bsr 0x06017784 (geom_computation) */
    add #0x48, r4                    ! r4 = sp+0x48 (output buffer) [delay]
    mov #0xA, r5                     ! r5 = 10 (division constant)
    mov.l @r15, r4                   ! r4 = car_array_base (from sp[0])
    mov.w   DAT_060175b6, r0         ! r0 = 0x0224 (car struct field offset)
    mov.l   _pool_fn_model_lookup, r3 ! r3 = model_data_lookup (sym_06034FE0)
    mov.l @(r0, r4), r4              ! r4 = car[0].field_0x224 (track position)
    add #0x1, r4                     ! r4 = track_position + 1
    mov r4, r1                       ! r1 = track_position + 1 (dividend)
    jsr @r3                          ! r0 = model_data_lookup(r0=10, r1=position)
    mov r5, r0                       ! r0 = 10 (divisor) [delay]
    mov r4, r1                       ! r1 = quotient (save)
    mov.l r0, @(4, r15)             ! sp[4] = lookup result A
    mov.l   _pool_fn_mem_store, r3   ! r3 = mem_store_helper (sym_06035C2C)
    jsr @r3                          ! r0 = mem_store_helper(r0=10, r1=position)
    mov r5, r0                       ! r0 = 10 (divisor) [delay]
    mov.l r0, @(8, r15)             ! sp[8] = lookup result B
    mov.l   _pool_demo_flag_b, r1   ! r1 = &demo_mode_flag (sym_0607EAE0)
    mov.l @r1, r1                    ! r1 = demo_mode_flag value
    tst r1, r1                       ! test if demo mode
    bt      .L_normal_seg_path       ! if zero (normal): take normal path
    mov r13, r7                      ! r7 = seg_table ptr
    add #0x1E, r7                    ! r7 = &seg_table[5] (6th entry, offset +0x1E)
    mov.l r7, @(4, r15)             ! sp[4] = &seg_table[5]
    mov.w @(2, r7), r0               ! r0 = seg_table[5].height
    mov.l @(4, r15), r6              ! r6 = &seg_table[5] (reload)
    mov.w   DAT_060175b8, r5         ! r5 = 0x02F0 (globals offset for geom struct E)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[5].width
    add r14, r5                      ! r5 = globals_base + 0x02F0 (geom struct E ptr)
    extu.w r7, r7                    ! zero-extend height
    extu.w r6, r6                    ! zero-extend width
    mov.l r5, @r15                   ! sp[0] = geom_struct_E ptr
    mov.l @(4, r5), r5               ! r5 = geom_struct_E[1] (vertex base)
    mov.w   DAT_060175ba, r3         ! r3 = 0x5000 (secondary vertex offset)
    mov.l @r15, r4                   ! r4 = geom_struct_E ptr (reload)
    add r3, r5                       ! r5 += 0x5000 (secondary buffer offset)
    .byte   0xB0, 0xEA    /* bsr 0x06017784 (geom_computation) */
    mov.l @r4, r4                    ! r4 = geom_struct_E[0] (segment data) [delay]
    bra     .L_epilogue              ! done (demo mode path) -- skip to return
    nop                              ! delay slot

    .global DAT_060175b4
DAT_060175b4:
    .2byte  0x02BC

    .global DAT_060175b6
DAT_060175b6:
    .2byte  0x0224

    .global DAT_060175b8
DAT_060175b8:
    .2byte  0x02F0

    .global DAT_060175ba
DAT_060175ba:
    .2byte  0x5000
_pool_fn_anim_xform_b:
    .4byte  anim_frame_transform
_pool_fn_model_lookup:
    .4byte  sym_06034FE0
_pool_fn_mem_store:
    .4byte  sym_06035C2C
_pool_demo_flag_b:
    .4byte  sym_0607EAE0
.L_normal_seg_path:
    mov.w   DAT_06017692, r9         ! r9 = 0x6000 (secondary vertex offset)
    mov #0xB, r3                     ! r3 = 11 (lower segment bound)
    mov.w   _wpool_seg_struct_ofs, r10 ! r10 = 0x0348 (globals offset for geom struct F)
    mov.l @r15, r4                   ! r4 = car_array_base
    mov.w   DAT_06017696, r0         ! r0 = 0x0224 (car struct: track position offset)
    mov.l @(r0, r4), r4              ! r4 = car[0].field_0x224 (track position)
    add #0x1, r4                     ! r4 = track_position + 1
    cmp/ge r3, r4                    ! track_position+1 >= 11?
    .word 0x0029 /* movt r0 — set r0 = T bit (1 if >= 11) */
    xor #0x1, r0                     ! r0 = !r0 (invert: 1 if < 11)
    mov #0xD, r3                     ! r3 = 13 (upper segment bound)
    cmp/gt r3, r4                    ! track_position+1 > 13?
    .word 0x0129 /* movt r1 — set r1 = T bit (1 if > 13) */
    or r1, r0                        ! r0 = out_of_range (< 11 OR > 13)
    tst r0, r0                       ! test out_of_range
    bt      .L_no_seg_variant        ! if in range [11..13]: use default path
    bra     .L_seg_dispatch          ! else: dispatch to variant
    mov.l @(8, r15), r0              ! r0 = lookup result B [delay]
.L_dispatch_case_1:
    mov r13, r7                      ! r7 = seg_table ptr
    mov r14, r5                      ! r5 = globals_base
    add #0x2A, r7                    ! r7 = &seg_table[7] (offset +0x2A)
    add r10, r5                      ! r5 = globals_base + 0x0348 (geom struct F)
    mov.l r7, @(12, r15)            ! sp[12] = &seg_table[7]
    mov.w @(2, r7), r0               ! r0 = seg_table[7].height
    mov.l @(12, r15), r6             ! r6 = &seg_table[7] (reload)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[7].width
    extu.w r7, r7                    ! zero-extend height
    extu.w r6, r6                    ! zero-extend width
    mov.l r5, @r15                   ! sp[0] = geom_struct_F ptr
    mov.l @(4, r5), r5               ! r5 = geom_struct_F[1] (vertex base)
    mov.l @r15, r4                   ! r4 = geom_struct_F ptr (reload)
    add r9, r5                       ! r5 += 0x6000 (secondary vertex offset)
    .byte   0xB0, 0xB9    /* bsr 0x06017784 (geom_computation) */
    mov.l @r4, r4                    ! r4 = geom_struct_F[0] (segment data) [delay]
    bra     .L_after_seg_geom        ! continue to optional segment processing
    nop                              ! delay slot
.L_dispatch_case_2:
    mov r13, r7                      ! r7 = seg_table ptr
    mov r14, r5                      ! r5 = globals_base
    add #0x2A, r7                    ! r7 = &seg_table[7] (offset +0x2A)
    add r10, r5                      ! r5 = globals_base + 0x0348 (geom struct F)
    mov.l r7, @r15                   ! sp[0] = &seg_table[7]
    mov.w @(2, r7), r0               ! r0 = seg_table[7].height
    mov.l @r15, r6                   ! r6 = &seg_table[7] (reload)
    mov.l @(4, r5), r5               ! r5 = geom_struct_F[1] (vertex base)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[7].width
    add r9, r5                       ! r5 += 0x6000 (secondary vertex offset)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_06017698, r0         ! r0 = 0x0350 (globals offset for variant B)
    extu.w r6, r6                    ! zero-extend width
    .byte   0xB0, 0xA7    /* bsr 0x06017784 (geom_computation) */
    mov.l @(r0, r14), r4             ! r4 = globals[0x0350] (seg data variant B) [delay]
    bra     .L_after_seg_geom        ! continue to optional segment processing
    nop                              ! delay slot
.L_dispatch_case_3:
    mov r13, r7                      ! r7 = seg_table ptr
    mov r14, r5                      ! r5 = globals_base
    add #0x2A, r7                    ! r7 = &seg_table[7] (offset +0x2A)
    add r10, r5                      ! r5 = globals_base + 0x0348 (geom struct F)
    mov.l r7, @r15                   ! sp[0] = &seg_table[7]
    mov.w @(2, r7), r0               ! r0 = seg_table[7].height
    mov.l @r15, r6                   ! r6 = &seg_table[7] (reload)
    mov.l @(4, r5), r5               ! r5 = geom_struct_F[1] (vertex base)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[7].width
    add r9, r5                       ! r5 += 0x6000 (secondary vertex offset)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_0601769a, r0         ! r0 = 0x0358 (globals offset for variant C)
    extu.w r6, r6                    ! zero-extend width
    .byte   0xB0, 0x95    /* bsr 0x06017784 (geom_computation) */
    mov.l @(r0, r14), r4             ! r4 = globals[0x0358] (seg data variant C) [delay]
    bra     .L_after_seg_geom        ! continue to optional segment processing
    nop                              ! delay slot
.L_dispatch_default:
    mov r13, r7                      ! r7 = seg_table ptr
    mov r14, r5                      ! r5 = globals_base
    add #0x2A, r7                    ! r7 = &seg_table[7] (offset +0x2A)
    add r10, r5                      ! r5 = globals_base + 0x0348 (geom struct F)
    mov.l r7, @r15                   ! sp[0] = &seg_table[7]
    mov.w @(2, r7), r0               ! r0 = seg_table[7].height
    mov.l @r15, r6                   ! r6 = &seg_table[7] (reload)
    mov.l @(4, r5), r5               ! r5 = geom_struct_F[1] (vertex base)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[7].width
    add r9, r5                       ! r5 += 0x6000 (secondary vertex offset)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_0601769c, r0         ! r0 = 0x0360 (globals offset for variant D)
    extu.w r6, r6                    ! zero-extend width
    .byte   0xB0, 0x83    /* bsr 0x06017784 (geom_computation) */
    mov.l @(r0, r14), r4             ! r4 = globals[0x0360] (seg data variant D) [delay]
    bra     .L_after_seg_geom        ! continue to optional segment processing
    nop                              ! delay slot
.L_seg_dispatch:
    cmp/eq #0x1, r0                  ! case 1: lookup result == 1?
    bt      .L_dispatch_case_1       ! -> case 1
    cmp/eq #0x2, r0                  ! case 2: lookup result == 2?
    bt      .L_dispatch_case_2       ! -> case 2
    cmp/eq #0x3, r0                  ! case 3: lookup result == 3?
    bt      .L_dispatch_case_3       ! -> case 3
    bra     .L_dispatch_default      ! default: fall through to default
    nop                              ! delay slot

    .global DAT_06017692
DAT_06017692:
    .2byte  0x6000
_wpool_seg_struct_ofs:
    .2byte  0x0348

    .global DAT_06017696
DAT_06017696:
    .2byte  0x0224

    .global DAT_06017698
DAT_06017698:
    .2byte  0x0350

    .global DAT_0601769a
DAT_0601769a:
    .2byte  0x0358

    .global DAT_0601769c
DAT_0601769c:
    .2byte  0x0360
.L_no_seg_variant:
    mov r13, r7                      ! r7 = seg_table ptr
    mov r14, r5                      ! r5 = globals_base
    add #0x2A, r7                    ! r7 = &seg_table[7] (offset +0x2A)
    add r10, r5                      ! r5 = globals_base + 0x0348 (geom struct F)
    mov.l r7, @r15                   ! sp[0] = &seg_table[7]
    mov.w @(2, r7), r0               ! r0 = seg_table[7].height
    mov.l @r15, r6                   ! r6 = &seg_table[7] (reload)
    mov.l @(4, r5), r5               ! r5 = geom_struct_F[1] (vertex base)
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[7].width
    add r9, r5                       ! r5 += 0x6000 (secondary vertex offset)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_06017728, r0         ! r0 = 0x0360 (globals offset for default geom)
    extu.w r6, r6                    ! zero-extend width
    .byte   0xB0, 0x63    /* bsr 0x06017784 (geom_computation) */
    mov.l @(r0, r14), r4             ! r4 = globals[0x0360] (default seg data) [delay]
.L_after_seg_geom:
    mov.l @(4, r15), r0              ! r0 = model_data_lookup result (from sp[4])
    tst r0, r0                       ! test if result is zero
    bt      .L_skip_opt_seg          ! if zero: skip optional segment processing
    mov r13, r7                      ! r7 = seg_table ptr
    add #0x1E, r7                    ! r7 = &seg_table[5] (offset +0x1E)
    mov.l r7, @r15                   ! sp[0] = &seg_table[5]
    mov.w @(2, r7), r0               ! r0 = seg_table[5].height
    mov.l @r15, r6                   ! r6 = &seg_table[5] (reload)
    mov.w   DAT_0601772c, r3         ! r3 = 0x5000 (secondary vertex offset)
    mov.l @(4, r15), r4              ! r4 = model_data_lookup result
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[5].width
    add #0x5F, r4                    ! r4 = result + 0x5F (index adjustment)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_0601772a, r0         ! r0 = 0x02FC (globals offset for vertex ptr E)
    extu.w r6, r6                    ! zero-extend width
    shll2 r4                         ! r4 = (result + 0x5F) * 4
    mov.l @(r0, r14), r5             ! r5 = globals[0x02FC] (vertex base E)
    shll r4                          ! r4 = (result + 0x5F) * 8 (table index)
    add r3, r5                       ! r5 += 0x5000 (secondary buffer offset)
    add r14, r4                      ! r4 = globals_base + table_index
    .byte   0xB0, 0x4C    /* bsr 0x06017784 (geom_computation) */
    mov.l @r4, r4                    ! r4 = globals[table_index] (seg data) [delay]
.L_skip_opt_seg:
    mov r13, r7                      ! r7 = seg_table ptr
    add #0x24, r7                    ! r7 = &seg_table[6] (offset +0x24)
    mov.l r7, @r15                   ! sp[0] = &seg_table[6]
    mov.w @(2, r7), r0               ! r0 = seg_table[6].height
    mov.l @r15, r6                   ! r6 = &seg_table[6] (reload)
    mov.w   DAT_0601772c, r3         ! r3 = 0x5000 (secondary vertex offset)
    mov.l @(8, r15), r4              ! r4 = mem_store_helper result (from sp[8])
    mov r0, r7                       ! r7 = height
    mov.w @r6, r6                    ! r6 = seg_table[6].width
    add #0x5F, r4                    ! r4 = result + 0x5F (index adjustment)
    extu.w r7, r7                    ! zero-extend height
    mov.w   DAT_0601772a, r0         ! r0 = 0x02FC (globals offset for vertex ptr E)
    extu.w r6, r6                    ! zero-extend width
    shll2 r4                         ! r4 = (result + 0x5F) * 4
    mov.l @(r0, r14), r5             ! r5 = globals[0x02FC] (vertex base E)
    shll r4                          ! r4 = (result + 0x5F) * 8 (table index)
    add r3, r5                       ! r5 += 0x5000 (secondary buffer offset)
    add r14, r4                      ! r4 = globals_base + table_index
    .byte   0xB0, 0x38    /* bsr 0x06017784 (geom_computation) */
    mov.l @r4, r4                    ! r4 = globals[table_index] (seg data) [delay]
.L_epilogue:
    add #0x6C, r15                   ! deallocate stack frame
    lds.l @r15+, pr                  ! restore pr (return address)
    mov.l @r15+, r8                  ! restore r8
    mov.l @r15+, r9                  ! restore r9
    mov.l @r15+, r10                 ! restore r10
    mov.l @r15+, r11                 ! restore r11
    mov.l @r15+, r12                 ! restore r12
    mov.l @r15+, r13                 ! restore r13
    rts                              ! return
    mov.l @r15+, r14                 ! restore r14 [delay]

    .global DAT_06017728
DAT_06017728:
    .2byte  0x0360

    .global DAT_0601772a
DAT_0601772a:
    .2byte  0x02FC

    .global DAT_0601772c
DAT_0601772c:
    .2byte  0x5000
