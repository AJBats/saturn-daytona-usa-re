/* vblank_display_write -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06038F78 - 0x06039050
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP1 framebuffer mode dispatch — display output path.
 *
 * Called each frame to commit the current scene to VDP1. Reads the
 * framebuffer mode selector (sym_060635B4) and dispatches:
 *
 *   Mode 0 — Default: call scene_data_dispatch, then clear game_state_flag.
 *   Mode 1 — Framebuffer swap with timing: increment frame counter, optionally
 *            trigger early manual swap (FCM) if fb_swap_enable==1 and counter
 *            has reached (delay-1). When counter reaches the full delay, call
 *            scene_data_dispatch and write vblank_cmd_state = 1, then reset
 *            the counter.
 *   Mode 2 — Manual erase: call scene_data_dispatch if game_state active,
 *            write vblank_cmd_state = 2.
 *   Mode 3 — VBlank erase: set VBE bit in TVMR, set FCM+FCT in FBCR, call
 *            scene_data_dispatch, write vblank_cmd_state = 3.
 *
 * The vblank_cmd_state written here is consumed by vblank_cmd_dispatch
 * (FUN_06039050) during the next vblank interrupt to perform the actual
 * VDP1 register writes.
 *
 * Register allocation (callee-saved, loaded in prologue):
 *   r11 = scene_data_dispatch (function pointer)
 *   r12 = &sym_060A4C84 (vblank_cmd_state — written with mode value)
 *   r13 = &sym_060635C4 (game_state_flag — nonzero = active)
 *   r14 = &sym_060635C0 (frame_counter — for mode 1 swap timing)
 *   r10 = caller-provided value, stored to vblank_cmd_state on entry
 *
 * Data symbols:
 *   sym_060635B4  — VDP framebuffer mode selector (half-word, values 0-3)
 *   sym_060635C4  — game state active flag (long, nonzero = scene active)
 *   sym_060635C0  — frame counter (long, for mode 1 delay timing)
 *   sym_060A4C84  — vblank command state (long, written 0/1/2/3)
 *   sym_060A4C92  — FBCR software shadow (half-word)
 *   sym_060A4C90  — TVMR software shadow (half-word)
 *   sym_060635B8  — framebuffer swap enable flag (long, 1 = enabled) [cross-TU pool]
 *   sym_060635BC  — framebuffer swap delay threshold (long) [cross-TU pool]
 *
 * VDP1 registers:
 *   0x25D00000 — TVMR (TV mode register)
 *     bit 3 (VBE) = VBlank erase enable
 *   0x25D00002 — FBCR (framebuffer control register)
 *     bit 0 (FCM) = manual change mode
 *     bit 1 (FCT) = change trigger
 */

    .section .text.FUN_06038F78


    .global vblank_display_write
    .type vblank_display_write, @function
vblank_display_write:
    sts.l pr, @-r15                             ! save return address
    mov.l   .L_fn_scene_dispatch, r11           ! r11 = &scene_data_dispatch
    mov.l   .L_ptr_cmd_state, r12               ! r12 = &vblank_cmd_state (sym_060A4C84)
    mov.l   .L_ptr_game_state, r13              ! r13 = &game_state_flag (sym_060635C4)
    mov.l   .L_ptr_frame_counter, r14           ! r14 = &frame_counter (sym_060635C0)
    mov.l r10, @r12                             ! vblank_cmd_state = r10 (store caller value)
    mov.l   .L_ptr_fb_mode_sel, r4              ! r4 = &fb_mode_selector (sym_060635B4)
    mov.w @r4, r0                               ! r0 = fb_mode_selector (half-word)
    extu.w r0, r0                               ! zero-extend to 32 bits
    cmp/eq #0x2, r0                             ! mode == 2? (manual erase)
    bf      .L_check_mode3                      ! no: check mode 3
    mov.l @r13, r0                              ! r0 = game_state_flag
    tst r0, r0                                  ! game state active? (nonzero = yes)
    bt      .L_epilogue                         ! not active: skip, go to epilogue
    jsr @r11                                    ! scene_data_dispatch() — render for manual erase
    nop                                         ! (delay slot)
    mov #0x2, r3                                ! r3 = 2 (manual erase command)
    mov.l r3, @r12                              ! vblank_cmd_state = 2
    bra     .L_epilogue                         ! done, exit
    nop                                         ! (delay slot)
.L_check_mode3:
    mov.l   .L_ptr_fbcr_shadow, r6              ! r6 = &FBCR_shadow (sym_060A4C92)
    mov.l   .L_vdp1_fbcr, r5                   ! r5 = VDP1 FBCR register (0x25D00002)
    mov.w @r4, r0                               ! r0 = fb_mode_selector (re-read, half-word)
    extu.w r0, r0                               ! zero-extend to 32 bits
    cmp/eq #0x3, r0                             ! mode == 3? (VBlank erase)
    bf      .L_check_mode0                      ! no: check mode 0/1
    mov.l @r13, r0                              ! r0 = game_state_flag
    tst r0, r0                                  ! game state active?
    bt      .L_epilogue                         ! not active: skip
    mov.l   .L_ptr_tvmr_shadow, r0              ! r0 = &TVMR_shadow (sym_060A4C90)
    mov.l   .L_vdp1_tvmr, r3                   ! r3 = VDP1 TVMR register (0x25D00000)
    mov.w @r0, r0                               ! r0 = cached TVMR value (half-word)
    extu.w r0, r0                               ! zero-extend to 32 bits
    or #0x8, r0                                 ! set bit 3: VBE (VBlank erase enable)
    mov.w r0, @r3                               ! write TVMR with VBE set
    mov.w @r6, r0                               ! r0 = cached FBCR value (half-word)
    extu.w r0, r0                               ! zero-extend to 32 bits
    or #0x3, r0                                 ! set FCM+FCT (manual change + trigger)
    jsr @r11                                    ! scene_data_dispatch() — render for VBlank erase
    mov.w r0, @r5                               ! write FBCR with FCM+FCT (delay slot)
    mov #0x3, r3                                ! r3 = 3 (VBlank erase command)
    mov.l r3, @r12                              ! vblank_cmd_state = 3
    bra     .L_epilogue                         ! done, exit
    nop                                         ! (delay slot)
.L_check_mode0:
    mov.w @r4, r2                               ! r2 = fb_mode_selector (re-read, half-word)
    extu.w r2, r2                               ! zero-extend to 32 bits
    tst r2, r2                                  ! mode == 0? (default)
    bf      .L_mode1_fbswap                     ! nonzero and not 2/3: must be mode 1
    jsr @r11                                    ! scene_data_dispatch() — default render
    nop                                         ! (delay slot)
    bra     .L_epilogue                         ! done, exit
    mov.l r10, @r13                             ! game_state_flag = r10 (clear, delay slot)
.L_fn_scene_dispatch:
    .4byte  scene_data_dispatch
.L_ptr_cmd_state:
    .4byte  sym_060A4C84
.L_ptr_game_state:
    .4byte  sym_060635C4
.L_ptr_frame_counter:
    .4byte  sym_060635C0
.L_ptr_fb_mode_sel:
    .4byte  sym_060635B4
.L_ptr_fbcr_shadow:
    .4byte  sym_060A4C92
.L_vdp1_fbcr:
    .4byte  0x25D00002                  /* VDP1 FBCR — framebuffer control */
.L_ptr_tvmr_shadow:
    .4byte  sym_060A4C90
.L_vdp1_tvmr:
    .4byte  0x25D00000                  /* VDP1 TVMR — TV mode */
.L_mode1_fbswap:
    mov.l @r14, r2                              ! r2 = frame_counter
    add #0x1, r2                                ! r2 = frame_counter + 1
    mov.l r2, @r14                              ! frame_counter++ (write back)
    .byte   0xD0, 0x1F    /* mov.l .L_pool_06039088, r0 — &fb_swap_enable (sym_060635B8, cross-TU pool) */
    mov.l @r0, r0                               ! r0 = fb_swap_enable flag value
    cmp/eq #0x1, r0                             ! fb swap enabled? (== 1)
    bf      .L_check_delay                      ! no: skip early swap trigger
    .byte   0xD2, 0x1E    /* mov.l .L_pool_0603908C, r2 — &fb_swap_delay (sym_060635BC, cross-TU pool) */
    mov.l @r14, r3                              ! r3 = frame_counter (re-read after increment)
    mov.l @r2, r2                               ! r2 = fb_swap_delay threshold
    add #-0x1, r2                               ! r2 = delay - 1 (early trigger point)
    cmp/gt r3, r2                               ! frame_counter < (delay - 1)?
    bt      .L_check_delay                      ! yes: not yet time, skip early trigger
    mov.w @r6, r0                               ! r0 = cached FBCR value (half-word)
    extu.w r0, r0                               ! zero-extend to 32 bits
    or #0x2, r0                                 ! set bit 1: FCT (manual framebuffer change trigger)
    extu.w r0, r0                               ! ensure 16-bit clean value
    mov.w r0, @r5                               ! write VDP1 FBCR — trigger early fb swap
.L_check_delay:
    .byte   0xD3, 0x18    /* mov.l .L_pool_0603908C, r3 — &fb_swap_delay (sym_060635BC, cross-TU pool) */
    mov.l @r14, r2                              ! r2 = frame_counter
    mov.l @r3, r3                               ! r3 = fb_swap_delay threshold
    cmp/gt r2, r3                               ! frame_counter < delay?
    bt      .L_epilogue                         ! yes: delay not reached, exit
    mov.l @r13, r0                              ! r0 = game_state_flag
    tst r0, r0                                  ! game state active?
    bt      .L_reset_counter                    ! not active: just reset counter
    jsr @r11                                    ! scene_data_dispatch() — render for mode 1
    nop                                         ! (delay slot)
    mov #0x1, r3                                ! r3 = 1 (mode 1 command)
    mov.l r3, @r12                              ! vblank_cmd_state = 1
.L_reset_counter:
    mov.l r10, @r14                             ! frame_counter = r10 (reset to 0)
.L_epilogue:
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r10                            ! restore r10
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return to caller
    mov.l @r15+, r14                            ! restore r14 (delay slot)
