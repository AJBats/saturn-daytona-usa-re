/* scene_update -- Per-frame scene rendering orchestrator
 * Translation unit: 0x0600C218 - 0x0600C286
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Called during race states 28/29 as the "post-display" step.
 * Orchestrates the per-frame scene update pipeline:
 *
 *   1. Advance secondary obj state buffer by 0x30 (48 bytes)
 *   2. Copy 48 bytes from primary obj state to secondary buffer
 *   3. Dispatch physics calculations (physics_calc_dispatch)
 *   4. Install race_utility_fn as secondary SH-2 callback
 *   5. Write 0xFFFF to MINIT register (wake secondary SH-2)
 *   6. Call frame_dispatch, scene_post_render, replay_playback_engine
 *   7. Poll FTCSR for ICF flag (frame timing sync)
 *   8. Clear ICF, call render_finalize
 *   9. Restore secondary buffer pointer
 *
 * Registers across function body:
 *   r12 = 0xFFFFFE11 (FTCSR -- SH-2 Free-running Timer Control/Status)
 *   r13 = &sym_0608A52C (secondary obj state pointer)
 *   r14 = 0x0080 (ICF bit mask -- Input Capture Flag, bit 7)
 */

    .section .text.FUN_0600C218


    .global scene_update
    .type scene_update, @function
scene_update:
    mov.l r14, @-r15
    mov #0x30, r6                               ! r6 = 48 (byte count for memcpy)
    mov.l r13, @-r15
    mov.l r12, @-r15
    sts.l pr, @-r15
    .byte   0x9C, 0x40    /* mov.w .L_ftcsr_addr, r12 -- r12 = 0xFFFFFE11 (FTCSR register) */
    .byte   0xDD, 0x21    /* mov.l .L_secondary_obj_state_ptr, r13 -- r13 = &sym_0608A52C */
    .byte   0x9E, 0x3F    /* mov.w .L_icf_mask, r14 -- r14 = 0x0080 (ICF bit mask) */
    mov.l @r13, r3                              ! r3 = current secondary buffer ptr
    add #0x30, r3                               ! advance by 48 bytes
    mov.l r3, @r13                              ! store advanced pointer
    mov r3, r4                                  ! r4 = dst for memcpy
    .byte   0xD5, 0x1F    /* mov.l .L_primary_obj_state_ptr, r5 -- r5 = &sym_06089EDC */
    .byte   0xD3, 0x20    /* mov.l .L_fn_memcpy_long_idx, r3 -- r3 = memcpy_long_idx (0x06027630) */
    jsr @r3                                     ! memcpy_long_idx(r4=dst, r5=*primary_ptr, r6=48)
    mov.l @r5, r5                               ! (delay) r5 = *sym_06089EDC (source buffer)
    .byte   0xD3, 0x1F    /* mov.l .L_fn_physics_calc_dispatch, r3 -- r3 = physics_calc_dispatch (0x0600D31C) */
    jsr @r3                                     ! call physics_calc_dispatch()
    nop
    .byte   0xD2, 0x1F    /* mov.l .L_fn_race_utility_fn, r2 -- r2 = race_utility_fn (0x0600C286) */
    .byte   0xD3, 0x1F    /* mov.l .L_secondary_callback_ptr, r3 -- r3 = &sym_06063574 */
    mov.l r2, @r3                               ! *sym_06063574 = race_utility_fn (install callback)
    .byte   0xD2, 0x1F    /* mov.l .L_pool_const_0xFFFF, r2 -- r2 = 0x0000FFFF */
    .byte   0xD3, 0x20    /* mov.l .L_minit_register, r3 -- r3 = 0x21000000 (MINIT register) */
    mov.w r2, @r3                               ! write 0xFFFF to MINIT (wake secondary SH-2)
    .byte   0xD3, 0x20    /* mov.l .L_fn_frame_dispatch, r3 -- r3 = frame_dispatch (0x060058FA) */
    jsr @r3                                     ! call frame_dispatch()
    nop
    .byte   0xD3, 0x1F    /* mov.l .L_fn_scene_post_render, r3 -- r3 = scene_post_render (0x06006868) */
    jsr @r3                                     ! call scene_post_render()
    nop
    .byte   0xD3, 0x1F    /* mov.l .L_fn_replay_playback, r3 -- r3 = replay_playback_engine (0x0601BDEC) */
    jsr @r3                                     ! call replay_playback_engine()
    nop
    .byte   0xD0, 0x1E    /* mov.l .L_timing_var, r0 -- r0 = &sym_06059FF8 */
    mov.l @r0, r0                               ! r0 = *sym_06059FF8 (timing variable)
    tst r0, r0                                  ! test if zero (T flag result unused)
.L_0600C262:                                    ! --- ICF poll loop ---
    mov.b @r12, r2                              ! r2 = FTCSR
    extu.b r2, r2                               ! zero-extend to 32-bit
    and r14, r2                                 ! isolate ICF bit (0x80)
    cmp/eq r14, r2                              ! ICF set?
    bf      .L_0600C262                         ! spin until ICF is set
    mov.b @r12, r0                              ! r0 = FTCSR (re-read for clearing)
    .byte   0xD3, 0x1B    /* mov.l .L_fn_render_finalize, r3 -- r3 = sym_0603C000 (render_finalize) */
    and #0xF, r0                                ! clear upper nibble (clears ICF + status flags)
    jsr @r3                                     ! call render_finalize()
    mov.b r0, @r12                              ! (delay) write cleared FTCSR back
    mov.l @r13, r2                              ! r2 = secondary buffer ptr
    add #-0x30, r2                              ! restore by subtracting 48
    mov.l r2, @r13                              ! write back restored pointer
    lds.l @r15+, pr
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
