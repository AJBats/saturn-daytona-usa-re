/* vblank_cmd_dispatch -- VDP1 framebuffer command dispatcher (vblank context)
 * Translation unit: 0x06039050 - 0x06039100
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Called during vblank to handle framebuffer swap commands. Two paths:
 *
 * 1) High-color interlace mode (sym_060A4C94 != 0):
 *    Reads VDP2 TVSTAT to determine even/odd field, then writes FBCR
 *    with field-appropriate flags (odd: |0x0C, even: |0x08) and exits.
 *    This ensures correct field-alternating framebuffer behavior.
 *
 * 2) Normal mode (sym_060A4C94 == 0):
 *    Dispatches on vblank_cmd_state (sym_060A4C84):
 *      0 — no pending command, exit immediately
 *      2 — if frame-ready flag set, call vdp1_draw_end_wait to sync
 *      3 — write cached TVMR shadow to VDP1 TVMR register directly
 *      other — write FBCR shadow | 0x03 (manual change + erase trigger)
 *    After handling, clears both game_state_flag and vblank_cmd_state.
 *
 * Data symbols:
 *   sym_060A4C92 — FBCR software shadow (half-word)
 *   sym_060A4C84 — vblank command state (long, values 0/1/2/3)
 *   sym_060A4C94 — high-color interlace enable (half-word, 0 = off)
 *   sym_060635CC — frame-ready flag (long, 1 = VDP1 draw complete)
 *   sym_060635C4 — game state active flag (long)
 *   sym_060A4C90 — TVMR software shadow (half-word)
 *   sym_060635B8 — framebuffer swap enable flag (unreferenced in pool)
 *   sym_060635BC — current display mode word (unreferenced in pool)
 *
 * VDP1 registers:
 *   0x25D00000 — TVMR (TV mode)
 *   0x25D00002 — FBCR (framebuffer control)
 *     bit 0 (FCM) = manual change mode
 *     bit 1 (FCT) = change trigger
 *     bit 2       = erase/write-back
 *     bit 3       = plot trigger
 *
 * VDP2 registers:
 *   0x25F80004 — TVSTAT (TV status)
 *     bit 1 (ODD) = 1 during odd field (interlace)
 */

    .section .text.FUN_06039050


    .global vblank_cmd_dispatch
    .type vblank_cmd_dispatch, @function
vblank_cmd_dispatch:
    mov.l r14, @-r15                        ! save r14
    mov.l r13, @-r15                        ! save r13
    mov.l r12, @-r15                        ! save r12
    sts.l pr, @-r15                         ! save return address
    mov.l   .L_pool_vdp1_fbcr, r12         ! r12 = VDP1 FBCR register (0x25D00002)
    mov.l   .L_pool_fbcr_shadow, r13       ! r13 = &sym_060A4C92 (FBCR software shadow)
    mov.l   .L_pool_cmd_state, r14         ! r14 = &sym_060A4C84 (vblank command state)
    mov.l   .L_pool_interlace_enable, r0   ! r0 = &sym_060A4C94 (high-color interlace flag)
    mov.w @r0, r0                           ! r0 = interlace enable value (half-word)
    extu.w r0, r0                           ! zero-extend to 32 bits
    tst r0, r0                              ! test if interlace mode is disabled
    bt      .L_dispatch_cmd                 ! if zero, branch to normal command dispatch
    mov.l   .L_pool_vdp2_tvstat, r4        ! r4 = VDP2 TVSTAT register address
    mov.w @r4, r4                           ! r4 = TVSTAT value (half-word)
    extu.w r4, r0                           ! r0 = zero-extended TVSTAT
    tst #0x2, r0                            ! test bit 1 (ODD field flag)
    bt      .L_even_field                   ! if even field (bit 1 = 0), branch
    mov.w @r13, r0                          ! r0 = current FBCR shadow value (odd field path)
    extu.w r0, r0                           ! zero-extend
    bra     .L_write_fbcr                   ! branch to FBCR write
    or #0xC, r0                             ! r0 |= 0x0C (erase + plot trigger for odd field)
.L_even_field:
    mov.w @r13, r0                          ! r0 = current FBCR shadow value (even field path)
    extu.w r0, r0                           ! zero-extend
    or #0x8, r0                             ! r0 |= 0x08 (plot trigger only for even field)
.L_write_fbcr:
    extu.w r0, r0                           ! zero-extend final FBCR value
    bra     .L_epilogue                     ! branch to function exit
    mov.w r0, @r12                          ! write FBCR value to VDP1 FBCR register
    .2byte  0xFFFF
    .4byte  sym_060635B8
    .4byte  sym_060635BC
.L_pool_vdp1_fbcr:
    .4byte  0x25D00002                  /* VDP1 FBCR — framebuffer control */
.L_pool_fbcr_shadow:
    .4byte  sym_060A4C92
.L_pool_cmd_state:
    .4byte  sym_060A4C84
.L_pool_interlace_enable:
    .4byte  sym_060A4C94
.L_pool_vdp2_tvstat:
    .4byte  0x25F80004                  /* VDP2 TVSTAT — TV status */
.L_dispatch_cmd:
    mov.l @r14, r0                          ! r0 = vblank_cmd_state
    tst r0, r0                              ! test if command state is zero
    bt      .L_epilogue                     ! if no pending command, exit
    mov.l @r14, r0                          ! r0 = vblank_cmd_state (reload)
    cmp/eq #0x2, r0                         ! is command == 2? (draw-end sync)
    bf      .L_not_cmd2                     ! if not, skip
    mov.l   .L_pool_frame_ready, r0        ! r0 = &sym_060635CC (frame-ready flag)
    mov.l @r0, r0                           ! r0 = frame-ready flag value
    tst r0, r0                              ! test if frame is ready
    bt      .L_not_cmd2                     ! if not ready, skip draw-end wait
    mov.l   .L_pool_draw_end_wait, r3     ! r3 = &vdp1_draw_end_wait function
    jsr @r3                                 ! call vdp1_draw_end_wait
    nop                                     ! (delay slot)
.L_not_cmd2:
    mov.l @r14, r0                          ! r0 = vblank_cmd_state (reload)
    cmp/eq #0x3, r0                         ! is command == 3? (TVMR write)
    bf      .L_default_fbcr_write           ! if not, do default FBCR write
    mov.l   .L_pool_tvmr_shadow, r3       ! r3 = &sym_060A4C90 (TVMR shadow)
    mov.w @r3, r3                           ! r3 = cached TVMR value (half-word)
    mov.l   .L_pool_vdp1_tvmr, r2         ! r2 = VDP1 TVMR register address
    mov.w r3, @r2                           ! write cached TVMR to hardware register
    bra     .L_clear_state                  ! skip FBCR write, go to state clear
    nop                                     ! (delay slot)
.L_default_fbcr_write:
    mov.w @r13, r0                          ! r0 = FBCR shadow value
    extu.w r0, r0                           ! zero-extend
    or #0x3, r0                             ! r0 |= 0x03 (manual change + erase trigger)
    extu.w r0, r0                           ! zero-extend
    mov.w r0, @r12                          ! write to VDP1 FBCR register
.L_clear_state:
    mov #0x0, r4                            ! r4 = 0 (clear value)
    mov.l   .L_pool_game_state, r3         ! r3 = &sym_060635C4 (game state flag)
    mov.l r4, @r3                           ! game_state_flag = 0
    mov.l r4, @r14                          ! vblank_cmd_state = 0
.L_epilogue:
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_pool_frame_ready:
    .4byte  sym_060635CC
.L_pool_draw_end_wait:
    .4byte  sym_060394C2
.L_pool_tvmr_shadow:
    .4byte  sym_060A4C90
.L_pool_vdp1_tvmr:
    .4byte  0x25D00000                  /* VDP1 TVMR — TV mode */
.L_pool_game_state:
    .4byte  sym_060635C4
