/* track_scenery_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602FDB0 - 0x060302D2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Processes track scenery animation state for each frame.
 * Two paths: live mode (reads input flags, updates scenery detail level 0-3,
 * manages scroll positions and animation deltas, writes packed byte to ring
 * buffer) and replay mode (reads packed byte from ring buffer, restores
 * scenery state, applies same scroll/animation logic).
 *
 * Ring buffer: sym_0607ED90 (base) + sym_0607ED88 (write index), size 0x2AF6.
 * Scenery object offsets: 0xDE=detail level, 0x6C/0x74=near scroll,
 * 0x88/0x8C/0x90=far scroll, 0x9E=anim flag, 0xA0-0xAC=anim state.
 */

    .section .text.FUN_0602FDB0


    .global track_scenery_render
    .type track_scenery_render, @function
track_scenery_render:
    mov.l r14, @-r15
    sts.l pr, @-r15
    mov #0x0, r9                       ! r9 = packed state byte (accumulates flags)
    mov r0, r6
    mov #0x1, r5
    mov #0x0, r7
    mov.l   .L_scenery_obj_ptr, r0
    mov.l @r0, r0                       ! r0 = scenery object base ptr
    mov.l   .L_replay_mode_flag, r1
    mov.w @r1, r2                       ! r2 = replay mode flag
    tst r2, r2
    bt      .L_live_mode                ! zero => live (input-driven) mode
    bra     .L_replay_mode              ! nonzero => replay (ring buffer) mode
    nop
.L_scenery_obj_ptr:
    .4byte  sym_0607E944                ! ptr to scenery object base
.L_replay_mode_flag:
    .4byte  sym_0607ED8C                ! word: nonzero = replay playback
.L_live_mode:
    mov.l   .L_input_state_a, r2
    mov.w @r2, r1                       ! r1 = current button state word A
    extu.w r1, r1
    mov.l   .L_btn_mask_zoom_in, r2
    mov.w @r2, r2                       ! r2 = zoom-in button mask
    cmp/pl r2                           ! positive => buttons have priority direction
    mov.w   .L_off_detail_level, r3     ! r3 = offset 0xDE (detail level in obj)
    bf      .L_check_btn_detail_3       ! negative => check direct detail selectors
    tst r1, r2                          ! test zoom-in mask against input
    bt      .L_check_zoom_out           ! not pressed => try zoom-out
    mov.w @(r0, r3), r4                 ! r4 = current detail level
    tst r4, r4
    bt      .L_store_detail_level       ! already 0 => no decrement
    add #-0x1, r4                       ! zoom in => decrease detail level
.L_store_detail_level:
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
.L_off_detail_level:
    .2byte  0x00DE                      ! scenery detail level (0-3)
    .2byte  0x0000
.L_input_state_a:
    .4byte  sym_06063D9A                ! button state word A
.L_btn_mask_zoom_in:
    .4byte  sym_0608188A                ! mask: zoom-in / detail decrease
.L_check_zoom_out:
    mov.l   .L_btn_mask_zoom_out, r2
    mov.w @r2, r2
    tst r1, r2
    bt      .L_detail_done
    mov.w @(r0, r3), r4
    mov #0x3, r2
    cmp/eq r4, r2                       ! already at max detail 3?
    bt      .L_zoom_out_clamped
    add #0x1, r4                        ! zoom out => increase detail level
.L_zoom_out_clamped:
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_zoom_out:
    .4byte  sym_06081888                ! mask: zoom-out / detail increase
.L_check_btn_detail_3:
    mov.l   .L_btn_mask_detail_3, r2
    mov.w @r2, r2
    tst r1, r2
    bt      .L_check_btn_detail_2
    mov #0x3, r4                        ! set detail = 3 directly
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_detail_3:
    .4byte  sym_06081896                ! mask: direct detail 3 select
.L_check_btn_detail_2:
    mov.l   .L_btn_mask_detail_2, r2
    mov.w @r2, r2
    tst r1, r2
    bt      .L_check_btn_detail_1
    mov #0x2, r4                        ! set detail = 2 directly
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_detail_2:
    .4byte  sym_06081894                ! mask: direct detail 2 select
.L_check_btn_detail_1:
    mov.l   .L_btn_mask_detail_1, r2
    mov.w @r2, r2
    tst r1, r2
    bt      .L_check_btn_detail_0
    mov #0x1, r4                        ! set detail = 1 directly
    bra     .L_detail_done
    mov.w r4, @(r0, r3)
    .2byte  0x0000
.L_btn_mask_detail_1:
    .4byte  sym_06081892                ! mask: direct detail 1 select
.L_check_btn_detail_0:
    mov.l   .L_btn_mask_detail_0, r2
    mov.w @r2, r2
    tst r1, r2
    bt      .L_detail_done
    mov #0x0, r4                        ! set detail = 0 directly
    mov.w r4, @(r0, r3)
.L_detail_done:
    mov.w @(r0, r3), r4                 ! r4 = final detail level
    mov r4, r9                          ! r9 bits[1:0] = detail level
    mov.l   .L_input_state_b, r3
    mov.w @r3, r1                       ! r1 = button state word B
    extu.w r1, r1
    mov #0x1, r5
    mov.l   .L_btn_mask_near_scroll, r2
    mov.w @r2, r2                       ! r2 = near-scroll button mask
    tst r1, r2
    bt      .L_no_near_scroll           ! not pressed => decay near scroll
    mov #-0x80, r8
    extu.b r8, r8                       ! r8 = 0x80
    or r8, r9                           ! r9 bit7 = near scroll active
    mov.w   .L_off_near_active, r2      ! r2 = offset 0x6C (near scroll active)
    mov.l r5, @(r0, r2)                ! obj[0x6C] = 1 (activate)
    add #0x8, r2                        ! r2 = 0x74 (near scroll position)
    mov.l @(r0, r2), r4                 ! r4 = current near scroll pos
    mov.w   .L_near_scroll_max, r8      ! r8 = 0xB8 (max)
    cmp/gt r8, r4
    bt      .L_near_scroll_store        ! already past max => keep
    add #0xA, r4                        ! increment by 0xA per frame
    mov.w   .L_near_scroll_limit, r3    ! r3 = 0xA0 (soft limit)
    cmp/gt r4, r3
    bt      .L_near_scroll_store        ! under soft limit => accept
    mov r8, r4                          ! clamp to max 0xB8
.L_near_scroll_store:
    bra     .L_check_far_scroll
    mov.l r4, @(r0, r2)
.L_off_near_active:
    .2byte  0x006C                      ! offset: near scroll active flag
.L_near_scroll_max:
    .2byte  0x00B8                      ! near scroll max value
.L_near_scroll_limit:
    .2byte  0x00A0                      ! near scroll soft limit
.L_btn_mask_detail_0:
    .4byte  sym_06081890                ! mask: direct detail 0 select
.L_input_state_b:
    .4byte  g_pad_state                ! button state word B
.L_btn_mask_near_scroll:
    .4byte  sym_0608188C                ! mask: near scroll trigger
.L_no_near_scroll:                      ! near scroll not pressed => decay
    mov.w   .L_off_near_pos, r3         ! r3 = offset 0x74
    mov #-0x50, r2
    mov.l @(r0, r3), r4                 ! r4 = current near scroll pos
    extu.b r2, r2                       ! r2 = 0xB0 (fast decay threshold)
    mov r4, r6
    cmp/gt r4, r2                       ! pos > threshold?
    bt      .L_near_decay_fast          ! yes => fast decay (divide by 16)
    bra     .L_near_decay_store
    add #-0x1, r4                       ! slow decay: subtract 1
.L_off_near_pos:
    .2byte  0x0074
.L_near_decay_fast:
    shlr2 r6                            ! r6 >>= 2
    shlr2 r6                            ! r6 >>= 2 (total >>4)
    sub r6, r4                          ! pos -= pos/16
    mov #0x6F, r6
    cmp/ge r6, r4                       ! pos >= 0x6F?
    bt      .L_near_decay_store
    mov #0x38, r4                       ! clamp to floor 0x38
.L_near_decay_store:
    mov.l r4, @(r0, r3)                ! store updated near scroll pos
    mov.l   .L_off_near_scroll_active, r2
    mov #0x0, r7
    mov.l r7, @(r0, r2)                ! obj[0x6C] = 0 (deactivate near scroll)
.L_check_far_scroll:
    mov.l   .L_btn_mask_far_scroll, r2
    mov.w @r2, r2                       ! r2 = far-scroll button mask
    tst r1, r2
    bt      .L_no_far_scroll            ! not pressed => decay far scroll
    mov #0x40, r8
    or r8, r9                           ! r9 bit6 = far scroll active
    mov.w   .L_off_far_scroll_active, r3 ! offset 0x88
    mov.l r5, @(r0, r3)                ! obj[0x88] = 1 (activate)
    mov.w   .L_off_far_scroll_pos, r3   ! offset 0x90
    mov.l @(r0, r3), r4                 ! r4 = current far scroll pos
    mov.w   .L_off_far_scroll_prev, r6  ! offset 0x8C
    mov.l r4, @(r0, r6)                ! save previous pos
    mov.l   .L_far_scroll_max, r8       ! r8 = 0xB8 (max)
    cmp/gt r8, r4
    bt      .L_far_scroll_store         ! past max => keep
    add #0x28, r4                       ! increment by 0x28 per frame
.L_far_scroll_store:
    bra     .L_check_anim_flag
    mov.l r4, @(r0, r3)
.L_off_far_scroll_active:
    .2byte  0x0088                      ! offset: far scroll active flag
.L_off_far_scroll_pos:
    .2byte  0x0090                      ! offset: far scroll position
.L_off_far_scroll_prev:
    .2byte  0x008C                      ! offset: far scroll previous pos
.L_off_near_scroll_active:
    .4byte  0x0000006C                  ! offset: near scroll active (as .4byte)
.L_btn_mask_far_scroll:
    .4byte  sym_0608188E                ! mask: far scroll trigger
.L_far_scroll_max:
    .4byte  0x000000B8                  ! far scroll max value
.L_no_far_scroll:                       ! far scroll not pressed => decay
    mov.l   .L_off_far_pos, r3          ! offset 0x90
    mov.l @(r0, r3), r4                 ! r4 = current far scroll pos
    mov.l   .L_off_far_prev, r6         ! offset 0x8C
    mov.l r4, @(r0, r6)                ! save previous pos
    mov #0x38, r3                       ! r3 = floor 0x38
    mov r4, r2
    shlr r2                             ! r2 = pos/2
    sub r2, r4                          ! pos -= pos/2 (halve each frame)
    cmp/ge r3, r4
    bt      .L_far_decay_clamped        ! still above floor => keep
    mov r3, r4                          ! clamp to floor 0x38
.L_far_decay_clamped:
    mov.l   .L_off_far_pos, r3
    mov.l r4, @(r0, r3)                ! store updated far scroll pos
    mov.l   .L_off_far_active, r3
    mov.l r7, @(r0, r3)                ! obj[0x88] = 0 (deactivate far scroll)
.L_check_anim_flag:
    mov #0x0, r10                       ! r10 = anim-has-data flag
    mov.w   .L_off_anim_flag, r4        ! offset 0x9E
    mov.w @(r0, r4), r3                 ! r3 = anim flag
    tst r3, r3
    bt      .L_no_anim_active           ! zero => no animation => check buttons
    bra     .L_anim_active              ! nonzero => read anim byte from input
    mov #0x1, r10                       ! r10 = 1 (will write anim byte)
.L_off_anim_flag:
    .2byte  0x009E                      ! offset: animation active flag
    .2byte  0x0000
.L_off_far_pos:
    .4byte  0x00000090                  ! offset: far scroll pos (as .4byte)
.L_off_far_prev:
    .4byte  0x0000008C                  ! offset: far scroll prev (as .4byte)
.L_off_far_active:
    .4byte  0x00000088                  ! offset: far scroll active (as .4byte)
.L_no_anim_active:                      ! no animation running => check anim buttons
    mov.l   .L_btn_mask_left_anim, r2
    mov.w @r2, r2                       ! r2 = left anim button mask
    tst r1, r2
    bt      .L_check_right_anim         ! not pressed => try right
    mov #0x20, r8
    or r8, r9                           ! r9 bit5 = left anim active
    mov #0x0, r7
    mov #0x1, r5
    mov.w   .L_off_anim_dir_l_a, r3
    mov.l r7, @(r0, r3)
    mov.w   .L_off_anim_dir_l_b, r3
    mov.l r5, @(r0, r3)
    mov.w   .L_off_anim_pos_left, r3     ! offset 0xAC (anim position)
    mov.l @(r0, r3), r8                 ! r8 = current left anim pos
    mov.w   .L_off_anim_delta_left, r6  ! offset 0xA8 (anim delta)
    mov.l @(r0, r6), r4
    cmp/pl r8                           ! pos > 0?
    bf      .L_left_anim_interp         ! negative or zero => interp toward target
    mov #-0x32, r7                      ! -0x32 = damping threshold
    shar r8                             ! pos /= 2
    cmp/gt r8, r7
    bt      .L_left_anim_store          ! damped enough => store
    mov #0x0, r8                        ! clamp to zero
.L_left_anim_interp:
    mov #-0x70, r7                      ! target = -0x70
    sub r8, r7                          ! r7 = distance to target
    mov.l r1, @-r15
    mov.l r3, @-r15
    sts.l pr, @-r15
    mov.l   .L_fn_scene_interp, r3       ! scene interpolation fn
    mov r7, r1                          ! arg1 = distance
    jsr @r3                             ! call interp(distance, 7)
    mov #0x7, r0                        ! arg0 = shift factor 7
    add r1, r8                          ! pos += interp result
    lds.l @r15+, pr
    mov.l @r15+, r3
    mov.l @r15+, r1
    mov r14, r0                         ! restore obj base ptr
.L_left_anim_store:
    bra     .L_write_ringbuf
    mov.l r8, @(r0, r3)                ! store left anim pos
.L_off_anim_dir_l_a:
    .2byte  0x00A4                      ! offset: left anim direction A
.L_off_anim_dir_l_b:
    .2byte  0x00A0                      ! offset: left anim direction B
.L_off_anim_pos_left:
    .2byte  0x00AC                      ! offset: left anim position
.L_off_anim_delta_left:
    .2byte  0x00A8                      ! offset: left anim delta
    .2byte  0x0000
.L_btn_mask_left_anim:
    .4byte  sym_06063F48                ! mask: left scenery anim trigger
.L_fn_scene_interp:
    .4byte  sym_0602ECCC                ! scene interpolation / damping fn
.L_check_right_anim:
    mov.l   .L_btn_mask_right_anim, r2
    mov.w @r2, r2                       ! r2 = right anim button mask
    extu.w r2, r2
    tst r1, r2
    bt      .L_no_anim_pressed          ! not pressed => idle decay
    mov #0x10, r8
    or r8, r9                           ! r9 bit4 = right anim active
    mov #0x0, r7
    mov #0x1, r5
    mov.w   .L_off_anim_dir_r_a, r3
    mov.l r7, @(r0, r3)
    mov.w   .L_off_anim_dir_r_b, r3
    mov.l r5, @(r0, r3)
    mov.w   .L_off_anim_pos_right, r3
    mov.l @(r0, r3), r8
    mov.w   .L_off_anim_delta_right, r6
    mov.l @(r0, r6), r4
    cmp/pz r8
    bt      .L_right_anim_interp
    mov #0x32, r7
    shar r8
    cmp/gt r7, r8
    bt      .L_right_anim_store
    mov #0x0, r8
.L_right_anim_interp:
    mov #0x70, r7
    sub r8, r7
    mov.l r1, @-r15
    mov.l r3, @-r15
    sts.l pr, @-r15
    mov.l   .L_fn_scene_interp_b, r3
    mov r7, r1
    jsr @r3
    mov #0x7, r0
    add r1, r8
    lds.l @r15+, pr
    mov.l @r15+, r3
    mov.l @r15+, r1
    mov r14, r0
.L_right_anim_store:
    bra     .L_write_ringbuf
    mov.l r8, @(r0, r3)
.L_off_anim_dir_r_a:
    .2byte  0x00A0
.L_off_anim_dir_r_b:
    .2byte  0x00A4
.L_off_anim_pos_right:
    .2byte  0x00AC
.L_off_anim_delta_right:
    .2byte  0x00A8
.L_btn_mask_right_anim:
    .4byte  sym_06063F4A                ! mask: right scenery anim trigger
.L_fn_scene_interp_b:
    .4byte  sym_0602ECCC                ! scene interpolation / damping fn
.L_no_anim_pressed:                     ! no anim button => decay toward zero
    mov.w   .L_off_idle_delta, r6       ! offset 0xA8 (delta)
    mov #0x0, r4
    mov.l r4, @(r0, r6)                ! clear delta
    mov.w   .L_off_idle_pos, r3         ! offset 0xAC (position)
    mov.l @(r0, r3), r4                 ! r4 = current anim position
    tst r4, r4
    bt      .L_write_ringbuf            ! already zero => done
    cmp/pl r4                           ! positive?
    bt/s    .L_idle_decay_positive
    mov r4, r6                          ! r6 = copy of pos
    mov #-0x68, r8
    mov #-0x7, r7
    cmp/ge r8, r6
    bt      .L_idle_neg_clamped
.L_idle_neg_clamped:
    sub r6, r4
    bra     .L_idle_store_pos
    nop
.L_off_idle_delta:
    .2byte  0x00A8                      ! offset: idle anim delta
.L_off_idle_pos:
    .2byte  0x00AC                      ! offset: idle anim position
.L_idle_decay_positive:
    mov #0x68, r8
    mov #0x7, r7
    cmp/ge r6, r8
    bt      .L_idle_pos_clamped
.L_idle_pos_clamped:
    sub r6, r4
.L_idle_store_pos:
    mov.l r4, @(r0, r3)                ! store decayed anim position
    mov.w   .L_off_idle_dir_a, r3       ! offset 0xA0
    mov #0x0, r7
    mov.l r7, @(r0, r3)                ! clear direction A
    mov.w   .L_off_idle_dir_b, r3       ! offset 0xA4
    mov.l r7, @(r0, r3)                ! clear direction B
    bra     .L_write_ringbuf
    nop
.L_off_idle_dir_a:
    .2byte  0x00A0                      ! offset: anim direction A
.L_off_idle_dir_b:
    .2byte  0x00A4                      ! offset: anim direction B
.L_anim_active:                         ! animation is running => read raw byte
    mov.l   .L_input_state_c, r3
    mov.w @r3, r1                       ! r1 = input state word C (anim source)
    mov.l   .L_dir_flip_flag, r7
    mov.b @r7, r7                       ! r7 = direction flip flag
    tst r7, r7
    bf      .L_anim_no_flip             ! nonzero => keep raw value
    not r1, r1                          ! zero => invert (flip direction)
.L_anim_no_flip:
    extu.b r1, r1                       ! mask to byte
    mov r1, r7                          ! r7 = anim byte for ring buffer
    mov #-0x80, r5
    add r5, r1                          ! r1 = signed anim value (-0x80 bias)
    mov.w   .L_off_anim_pos_out, r3     ! offset 0xAC
    mov.l @(r0, r3), r4                 ! r4 = previous anim pos (unused)
    mov.l r1, @(r0, r3)                ! store new signed anim pos
.L_write_ringbuf:                       ! write packed state to ring buffer
    mov.l   .L_ringbuf_base, r2
    mov.l   .L_ringbuf_index, r4
    mov.l @r4, r6                       ! r6 = current write index
    add r6, r2                          ! r2 = base + index
    add #0x1, r6                        ! advance index for state byte
    mov.b r9, @r2                       ! write packed state byte (detail+flags)
    tst r10, r10                        ! has animation data?
    add #0x1, r2                        ! point to next byte
    add #0x1, r6                        ! advance index for anim byte
    bt      .L_skip_anim_byte           ! no anim => skip second byte
    mov.b r7, @r2                       ! write animation byte
.L_skip_anim_byte:
    mov.w   .L_ringbuf_size, r3         ! r3 = 0x2AF6 (buffer size)
    cmp/ge r6, r3                       ! index < size?
    bt      .L_ringbuf_wrap_done        ! yes => no wrap needed
    add #-0x2, r6                       ! wrap: subtract 2 (back to start)
.L_ringbuf_wrap_done:
    mov.l r6, @r4                       ! store updated write index
    lds.l @r15+, pr
    mov.l @r15+, r14
    mov.l @r15+, r13
    mov.l @r15+, r12
    mov.l @r15+, r11
    mov.l @r15+, r10
    mov.l @r15+, r9
    rts
    mov.l @r15+, r8
.L_off_anim_pos_out:
    .2byte  0x00AC                      ! offset: anim position output
.L_ringbuf_size:
    .2byte  0x2AF6                      ! ring buffer total size
    .2byte  0x0000
.L_input_state_c:
    .4byte  sym_06063D9C                ! button state word C (anim source)
.L_dir_flip_flag:
    .4byte  sym_06078663                ! byte: direction flip (0=invert, 1=normal)
.L_ringbuf_base:
    .4byte  sym_0607ED90                ! ring buffer base address
.L_ringbuf_index:
    .4byte  sym_0607ED88                ! ring buffer write index
.L_replay_mode:                         ! replay path: read state from ring buffer
    mov.l   .L_ringbuf_base_r, r2
    mov.l   .L_ringbuf_index_r, r4
    mov.l @r4, r6                       ! r6 = read index
    add r6, r2                          ! r2 = base + index
    add #0x1, r6                        ! advance index
    mov.b @r2, r1                       ! r1 = packed state byte from buffer
    mov.w   .L_off_detail_level_r, r3   ! offset 0xDE
    extu.b r1, r1
    mov r1, r5
    mov #0x3, r2
    and r2, r5                          ! r5 = detail level (bits[1:0])
    mov.w r5, @(r0, r3)                ! store detail level
    mov.l r6, @r4                       ! save updated read index
    mov #0x1, r5
    mov #-0x80, r2
    extu.b r2, r2                       ! r2 = 0x80
    tst r1, r2                          ! test bit7 (near scroll flag)
    bt      .L_replay_no_near           ! not set => decay near scroll
    mov.w   .L_off_near_active_wr, r2
    mov.l r5, @(r0, r2)
    add #0x8, r2
    mov.l @(r0, r2), r4
    mov.w   .L_near_scroll_max_r, r8
    cmp/gt r8, r4
    bt      .L_replay_near_store
    add #0xA, r4
    mov.w   .L_near_scroll_limit_r, r3
    cmp/gt r4, r3
    bt      .L_replay_near_store
    mov r8, r4
.L_replay_near_store:
    bra     .L_replay_check_far
    mov.l r4, @(r0, r2)
.L_off_detail_level_r:
    .2byte  0x00DE
.L_off_near_active_wr:
    .2byte  0x006C
.L_near_scroll_max_r:
    .2byte  0x00B8
.L_near_scroll_limit_r:
    .2byte  0x00A0
.L_ringbuf_base_r:
    .4byte  sym_0607ED90                ! ring buffer base (replay read)
.L_ringbuf_index_r:
    .4byte  sym_0607ED88                ! ring buffer read index
.L_replay_no_near:
    mov.w   .L_off_near_pos_r, r3
    mov #-0x50, r2
    mov.l @(r0, r3), r4
    extu.b r2, r2
    mov r4, r6
    cmp/gt r4, r2
    bt      .L_replay_near_decay_fast
    bra     .L_replay_near_decay_store
    add #-0x1, r4
.L_off_near_pos_r:
    .2byte  0x0074
.L_replay_near_decay_fast:
    shlr2 r6
    shlr2 r6
    sub r6, r4
    mov #0x6F, r6
    cmp/ge r6, r4
    bt      .L_replay_near_decay_store
    mov #0x38, r4
.L_replay_near_decay_store:
    mov.l r4, @(r0, r3)
    mov.l   .L_off_near_active_r, r2
    mov #0x0, r7
    mov.l r7, @(r0, r2)
.L_replay_check_far:
    mov #0x40, r2
    tst r1, r2                          ! test bit6 (far scroll flag)
    bt      .L_replay_no_far            ! not set => decay far scroll
    mov.w   .L_off_far_active_wr, r3
    mov.l r5, @(r0, r3)
    mov.w   .L_off_far_pos_wr, r3
    mov.l @(r0, r3), r4
    mov.w   .L_off_far_prev_wr, r6
    mov.l r4, @(r0, r6)
    mov.l   .L_far_scroll_max_r, r8
    cmp/gt r8, r4
    bt      .L_replay_far_store
    add #0x28, r4
.L_replay_far_store:
    bra     .L_replay_check_anim
    mov.l r4, @(r0, r3)
.L_off_far_active_wr:
    .2byte  0x0088
.L_off_far_pos_wr:
    .2byte  0x0090
.L_off_far_prev_wr:
    .2byte  0x008C
    .2byte  0x0000
.L_off_near_active_r:
    .4byte  0x0000006C
.L_far_scroll_max_r:
    .4byte  0x000000B8
.L_replay_no_far:
    mov.l   .L_off_far_pos_r, r3
    mov.l @(r0, r3), r4
    mov.l   .L_off_far_prev_r, r6
    mov.l r4, @(r0, r6)
    mov #0x38, r3
    mov r4, r2
    shlr r2
    sub r2, r4
    cmp/ge r3, r4
    bt      .L_replay_far_decay_clamped
    mov r3, r4
.L_replay_far_decay_clamped:
    mov.l   .L_off_far_pos_r, r3
    mov.l r4, @(r0, r3)
    mov.l   .L_off_far_active_r, r3
    mov.l r7, @(r0, r3)
.L_replay_check_anim:
    mov #0x0, r10                       ! r10 = anim-has-data flag
    mov.l   .L_ringbuf_anim_check, r4
    mov.b @r4, r3                       ! peek next byte in ring buffer
    tst r3, r3
    bt      .L_replay_no_anim           ! zero => no anim data follows
    bra     .L_replay_anim_active       ! nonzero => read anim byte
    mov #0x1, r10
.L_off_far_pos_r:
    .4byte  0x00000090
.L_off_far_prev_r:
    .4byte  0x0000008C
.L_off_far_active_r:
    .4byte  0x00000088
.L_ringbuf_anim_check:
    .4byte  sym_0607ED90
.L_replay_no_anim:
    mov #0x20, r2
    tst r1, r2                          ! test bit5 (left anim flag)
    bt      .L_replay_check_right       ! not set => try right
    mov #0x0, r7
    mov #0x1, r5
    mov.w   .L_off_anim_dir_la_r, r3
    mov.l r7, @(r0, r3)
    mov.w   .L_off_anim_dir_lb_r, r3
    mov.l r5, @(r0, r3)
    mov.w   .L_off_anim_pos_l_r, r3
    mov.l @(r0, r3), r8
    mov.w   .L_off_anim_delta_l_r, r6
    mov.l @(r0, r6), r4
    cmp/pl r8
    bf      .L_replay_left_interp
    mov #-0x32, r7
    shar r8
    cmp/gt r8, r7
    bt      .L_replay_left_store
    mov #0x0, r8
.L_replay_left_interp:
    mov #-0x70, r7
    sub r8, r7
    mov.l r1, @-r15
    mov.l r3, @-r15
    sts.l pr, @-r15
    mov.l   .L_fn_interp_left_r, r3
    mov r7, r1
    jsr @r3
    mov #0x7, r0
    add r1, r8
    lds.l @r15+, pr
    mov.l @r15+, r3
    mov.l @r15+, r1
    mov r14, r0
.L_replay_left_store:
    bra     .L_replay_epilogue
    mov.l r8, @(r0, r3)
.L_off_anim_dir_la_r:
    .2byte  0x00A4
.L_off_anim_dir_lb_r:
    .2byte  0x00A0
.L_off_anim_pos_l_r:
    .2byte  0x00AC
.L_off_anim_delta_l_r:
    .2byte  0x00A8
.L_fn_interp_left_r:
    .4byte  sym_0602ECCC                ! scene interpolation fn (replay left)
.L_replay_check_right:
    mov #0x10, r2
    tst r1, r2                          ! test bit4 (right anim flag)
    bt      .L_replay_no_anim_btn       ! not set => idle decay
    mov #0x0, r7
    mov #0x1, r5
    mov.w   .L_off_anim_dir_ra_r, r3
    mov.l r7, @(r0, r3)
    mov.w   .L_off_anim_dir_rb_r, r3
    mov.l r5, @(r0, r3)
    mov.w   .L_off_anim_pos_r_r, r3
    mov.l @(r0, r3), r8
    mov.w   .L_off_anim_delta_r_r, r6
    mov.l @(r0, r6), r4
    cmp/pz r8
    bt      .L_replay_right_interp
    mov #0x32, r7
    shar r8
    cmp/gt r7, r8
    bt      .L_replay_right_store
    mov #0x0, r8
.L_replay_right_interp:
    mov #0x70, r7
    sub r8, r7
    mov.l r1, @-r15
    mov.l r3, @-r15
    sts.l pr, @-r15
    mov.l   .L_fn_interp_right_r, r3
    mov r7, r1
    jsr @r3
    mov #0x7, r0
    add r1, r8
    lds.l @r15+, pr
    mov.l @r15+, r3
    mov.l @r15+, r1
    mov r14, r0
.L_replay_right_store:
    bra     .L_replay_epilogue
    mov.l r8, @(r0, r3)
.L_off_anim_dir_ra_r:
    .2byte  0x00A0
.L_off_anim_dir_rb_r:
    .2byte  0x00A4
.L_off_anim_pos_r_r:
    .2byte  0x00AC
.L_off_anim_delta_r_r:
    .2byte  0x00A8
.L_fn_interp_right_r:
    .4byte  sym_0602ECCC                ! scene interpolation fn (replay right)
.L_replay_no_anim_btn:
    mov.w   .L_off_idle_delta_r, r6
    mov #0x0, r4
    mov.l r4, @(r0, r6)
    mov.w   .L_off_idle_pos_r, r3
    mov.l @(r0, r3), r4
    tst r4, r4
    bt      .L_replay_epilogue
    cmp/pl r4
    bt/s    .L_replay_idle_pos
    mov r4, r6
    mov #-0x68, r8
    mov #-0x7, r7
    cmp/ge r8, r6
    bt      .L_replay_idle_neg_clamp
.L_replay_idle_neg_clamp:
    sub r6, r4
    bra     .L_replay_idle_store
    nop
.L_off_idle_delta_r:
    .2byte  0x00A8
.L_off_idle_pos_r:
    .2byte  0x00AC
.L_replay_idle_pos:
    mov #0x68, r8
    mov #0x7, r7
    cmp/ge r6, r8
    bt      .L_replay_idle_pos_clamp
.L_replay_idle_pos_clamp:
    sub r6, r4
.L_replay_idle_store:
    mov.l r4, @(r0, r3)
    mov.w   .L_off_idle_dir_a_r, r3
    mov #0x0, r7
    mov.l r7, @(r0, r3)
    mov.w   .L_off_idle_dir_b_r, r3
    mov.l r7, @(r0, r3)
    bra     .L_replay_epilogue
    nop
.L_off_idle_dir_a_r:
    .2byte  0x00A0
.L_off_idle_dir_b_r:
    .2byte  0x00A4
.L_replay_anim_active:                  ! anim data present => read from buffer
    mov.l   .L_ringbuf_base_anim, r2
    mov.l   .L_ringbuf_index_anim, r4
    mov.l @r4, r6                       ! r6 = read index
    add r6, r2                          ! r2 = base + index
    mov.b @r2, r1                       ! r1 = raw anim byte from buffer
    mov #-0x80, r5
    extu.b r1, r1
    add r5, r1                          ! r1 = signed anim value (-0x80 bias)
    mov.w   .L_off_anim_pos_out_r, r3   ! offset 0xAC
    mov.l @(r0, r3), r4                 ! r4 = previous anim pos
    mov.l r1, @(r0, r3)                ! store new signed anim pos
.L_replay_epilogue:                     ! replay cleanup: advance buffer index
    mov.l   .L_ringbuf_index_anim, r4
    mov.l @r4, r6
    add #0x1, r6                        ! advance read index by 1
    mov.l r6, @r4                       ! store updated read index
    lds.l @r15+, pr
    mov.l @r15+, r14
    mov.l @r15+, r13
    mov.l @r15+, r12
    mov.l @r15+, r11
    mov.l @r15+, r10
    mov.l @r15+, r9
    rts
    mov.l @r15+, r8
.L_off_anim_pos_out_r:
    .2byte  0x00AC
    .2byte  0x0000
.L_ringbuf_base_anim:
    .4byte  sym_0607ED90                ! ring buffer base (replay anim read)
.L_ringbuf_index_anim:
    .4byte  sym_0607ED88                ! ring buffer index (replay)
    .4byte  0x00090009
    .4byte  0x401589FB
    .2byte  0x0009

    .global sym_060302C6
sym_060302C6:
    mov.l r8, @-r15
    mov.l r9, @-r15
    mov.l r10, @-r15
    mov.l r11, @-r15
    mov.l r12, @-r15
    mov.l r13, @-r15
