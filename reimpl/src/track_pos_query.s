/* track_pos_query -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CD40 - 0x0600CDD0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * AI Waypoint Query & Approach Angle Computation
 * ===============================================
 * Called as step 1 of ai_orchestrator for each AI car.
 * Looks up the current waypoint from the AI waypoint table, computes
 * the approach angle from the car's position to the waypoint using
 * atan2(dx, dz), and determines whether the car has passed the
 * waypoint (angular distance exceeds quarter-turn threshold 0x4000).
 * If so, advances to the next waypoint index, wrapping at the track's
 * section count.
 *
 * Algorithm:
 *   1. Load waypoint index from car[+0x01E4]
 *   2. Compute waypoint struct pointer: base + index * 24  (0x18-byte entries)
 *   3. Copy waypoint's track segment index (waypoint[+0x16]) into car[+0x0184]
 *   4. Compute delta: dx = waypoint.x - car.x, dz = waypoint.z - car.z
 *   5. Call atan2(dx, dz) to get approach angle
 *   6. Read waypoint's half-arc (waypoint[+0x0E]) as quarter-turn scale
 *   7. Compute angular distance to waypoint, accounting for wrap
 *   8. If angular distance > 0x4000 (quarter turn), advance waypoint index
 *      (wrap to 0 at section_count)
 *
 * Arguments:
 *   r14 = pointer to car_state_ptr (sym_0607E940), dereferenced on entry
 *
 * Car struct offsets used:
 *   +0x0010 = X position (world coords)
 *   +0x0018 = Z position (world coords)
 *   +0x0184 = current track segment index
 *   +0x01E0 = waypoint table base pointer
 *   +0x01E4 = current waypoint index
 *
 * Waypoint struct layout (24 bytes per entry):
 *   +0x00 = X position (longword)
 *   +0x04 = Z position (longword)
 *   +0x0E = half-arc angle (word) — scale for angular check
 *   +0x16 = track segment index (word)
 *
 * Returns:
 *   r0 = pointer to current waypoint entry (r13)
 *
 * External references:
 *   sym_0607E940 = pointer to current car struct
 *   atan2        = fixed-point atan2(dx, dz) → heading angle
 *   sym_0607EA9C = track section count (for waypoint wrap)
 */

    .section .text.FUN_0600CD40


    .global track_pos_query
    .type track_pos_query, @function
track_pos_query:
    mov.l r14, @-r15                       ! save r14
    mov.l r13, @-r15                       ! save r13
    sts.l pr, @-r15                        ! save return address
    mov.l   .L_pool_car_state_ptr, r14     ! r14 = &car_state_ptr (sym_0607E940)
    mov.w   DAT_0600cdbe, r0              ! r0 = 0x01E4 (waypoint index offset)
    mov.l @r14, r14                        ! r14 = car struct base
    mov.l @(r0, r14), r13                  ! r13 = car[0x01E4] = current waypoint index
    add #-0x4, r0                          ! r0 = 0x01E0 (waypoint table base offset)
    mov r13, r3                            ! r3 = waypoint index (copy for stride calc)
    shll2 r13                              ! r13 = index * 4
    shll2 r3                               ! r3 = index * 4
    shll r13                               ! r13 = index * 8
    shll2 r3                               ! r3 = index * 16
    add r3, r13                            ! r13 = index * 24 (0x18 bytes per waypoint)
    mov.l @(r0, r14), r3                   ! r3 = car[0x01E0] = waypoint table base pointer
    add r3, r13                            ! r13 = &waypoint[index] (current waypoint entry)
    mov.w @(22, r13), r0                   ! r0 = waypoint[+0x16] = track segment index (word)
    mov r0, r3                             ! r3 = segment index
    extu.w r3, r3                          ! zero-extend segment index to 32-bit
    mov.w   DAT_0600cdc0, r0              ! r0 = 0x0184 (car segment index offset)
    mov.l r3, @(r0, r14)                   ! car[0x0184] = waypoint's track segment index
    mov.l @(4, r13), r5                    ! r5 = waypoint[+0x04] = waypoint Z position
    mov.l @(24, r14), r3                   ! r3 = car[+0x18] = car Z position
    mov.l @(16, r14), r4                   ! r4 = car[+0x10] = car X position
    mov.l @r13, r2                         ! r2 = waypoint[+0x00] = waypoint X position
    sub r3, r5                             ! r5 = dz = waypoint.z - car.z
    mov.l   .L_pool_atan2_fn, r3           ! r3 = &atan2
    jsr @r3                                ! r0 = atan2(dx, dz) → approach angle
    sub r2, r4                             ! (delay) r4 = dx = car.x - waypoint.x
    exts.w r0, r4                          ! r4 = approach angle (sign-extended)
    exts.w r4, r6                          ! r6 = approach angle (working copy)
    mov.w @(14, r13), r0                   ! r0 = waypoint[+0x0E] = half-arc scale
    mov r6, r7                             ! r7 = approach angle (for distance calc)
    mov r0, r5                             ! r5 = half-arc value
    shll2 r5                               ! r5 = half-arc * 4 (full arc span)
    sub r5, r7                             ! r7 = angle - full_arc (wrapped distance A)
    cmp/pz r7                              ! is wrapped distance A >= 0?
    bt      .L_dist_positive               ! if yes, use r7 directly
    mov r5, r2                             ! r2 = full_arc
    bra     .L_have_angular_dist           ! take negated path
    sub r6, r2                             ! (delay) r2 = full_arc - angle (wrapped distance B)
.L_dist_positive:
    mov r7, r2                             ! r2 = angular distance (already positive)
.L_have_angular_dist:
    mov.w   DAT_0600cdc2, r3              ! r3 = 0x4000 (quarter-turn threshold)
    cmp/gt r3, r2                          ! angular distance > quarter turn?
    bf      .L_return                      ! if not, waypoint not yet passed — return
    mov.w   DAT_0600cdbe, r0              ! r0 = 0x01E4 (waypoint index offset)
    mov.l @(r0, r14), r3                   ! r3 = car[0x01E4] = current waypoint index
    add #0x1, r3                           ! r3 = next waypoint index
    mov.l r3, @(r0, r14)                   ! car[0x01E4] = next index
    mov.l @(r0, r14), r3                   ! r3 = re-read updated index (for compare)
    mov.l   .L_pool_section_count, r2      ! r2 = &section_count (sym_0607EA9C)
    mov.l @r2, r2                          ! r2 = total track section count
    cmp/gt r2, r3                          ! new index > section_count?
    bf      .L_return                      ! if not, no wrap needed
    mov #0x0, r2                           ! r2 = 0 (reset to start)
    mov.w   DAT_0600cdbe, r0              ! r0 = 0x01E4 (waypoint index offset)
    mov.l r2, @(r0, r14)                   ! car[0x01E4] = 0 (wrap around)
.L_return:
    mov r13, r0                            ! r0 = pointer to current waypoint entry (return value)
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return
    mov.l @r15+, r14                       ! (delay) restore r14

    .global DAT_0600cdbc
DAT_0600cdbc:
    mov.b @(r0, r14), r1

    .global DAT_0600cdbe
DAT_0600cdbe:
    .2byte  0x01E4
                                           /* car struct offset: waypoint index */
    .global DAT_0600cdc0
DAT_0600cdc0:
    .2byte  0x0184
                                           /* car struct offset: track segment index */
    .global DAT_0600cdc2
DAT_0600cdc2:
    .2byte  0x4000
                                           /* quarter-turn threshold for waypoint pass check */
.L_pool_car_state_ptr:
    .4byte  sym_0607E940
                                           /* → current car struct pointer */
.L_pool_atan2_fn:
    .4byte  atan2
                                           /* → fixed-point atan2(dx, dz) */
.L_pool_section_count:
    .4byte  sym_0607EA9C
                                           /* → track section count (for wrap) */
