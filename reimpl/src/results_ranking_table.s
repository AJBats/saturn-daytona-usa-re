/* results_ranking_table -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060164CE - 0x06016630
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Updates the ranking table for one car entry on the results screen.
 * Each car has a 68-byte results entry in the table at sym_06084FC8.
 *
 * If the bonus mode flag (sym_06085F89) is zero, the entry is reset to
 * its initial state: the animation phase is set to 3, the score field
 * at +44 is cleared, and the function tail-calls the digit renderer.
 *
 * If bonus mode is active, the function:
 *   1. Checks if the entry's elapsed time (+12) exceeds 1.0 (16.16 FP).
 *      If not, the entry is freshly initialized with the threshold loaded
 *      into +12, and counters at +36 and +24 are zeroed.
 *   2. If elapsed time > 1.0, accumulates the per-frame delta (+16) into
 *      the display value (+4), clamping it against the max cap (+52).
 *      The clamp direction depends on whether entry_index < 4 (cmp/ge)
 *      or >= 4 (cmp/gt).
 *   3. Subtracts the countdown step (+24 from +12, +36 from +24). If the
 *      remaining countdown (+24) drops below 2.0 (16.16 FP), it is reset
 *      to 0x0600 and the delta (+16) is cleared.
 *   4. Tail-calls the digit renderer at 0x06016DD8.
 *
 * On entry:
 *   r4 = entry index (byte — upper bits ignored)
 *
 * Results entry struct (68 bytes per entry, at sym_06084FC8):
 *   +0x02 (byte):  animation phase / state byte
 *   +0x04 (long):  display value (accumulated score/time)
 *   +0x0C (long):  elapsed time / remaining threshold (16.16 FP)
 *   +0x10 (long):  delta per frame (increment amount)
 *   +0x18 (long):  countdown timer / remaining counter
 *   +0x24 (long):  countdown step / decrement amount
 *   +0x2C (long):  score field (cleared on init)
 *   +0x34 (long):  max cap value (clamp target)
 */

    .section .text.FUN_060164CE


    .global results_ranking_table
    .type results_ranking_table, @function
results_ranking_table:
    mov.l r14, @-r15                         ! save r14 on stack
    mov.l r13, @-r15                         ! save r13 on stack
    mov.l r12, @-r15                         ! save r12 on stack
    mov #0x0, r12                            ! r12 = 0 (constant zero for clearing fields)
    .byte   0xDD, 0x0A    /* mov.l .L_p_entry_table, r13 */  ! r13 = &results_entry_table (sym_06084FC8)
    .byte   0xD0, 0x0D    /* mov.l .L_p_bonus_flag, r0 */    ! r0 = &bonus_mode_flag (sym_06085F89)
    mov.b @r0, r0                            ! r0 = bonus_mode_flag value
    tst r0, r0                               ! test if bonus mode is active
    bt/s    .L_bonus_active                  ! branch if bonus mode flag == 0 (active path)
    mov r4, r14                              ! r14 = entry_index (delay slot)
    extu.b r14, r4                           ! r4 = entry_index (zero-extended byte)
    mov r4, r3                               ! r3 = entry_index (copy for shift chain)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68 (struct stride)
    exts.w r4, r4                            ! sign-extend offset to word
    add r13, r4                              ! r4 = &entry (base + offset)
    mov.l r12, @(44, r4)                     ! entry.score = 0 (clear score field)
    mov #0x3, r2                             ! r2 = 3 (initial animation phase)
    mov r2, r0                               ! r0 = 3
    bra     .L_epilogue                      ! jump to epilogue (tail-call digit renderer)
    mov.b r0, @(2, r4)                       ! entry.anim_phase = 3 (delay slot)
    .2byte  0xFFFF                           ! padding
.L_p_entry_table:
    .4byte  sym_06084FC8                     /* results entry table base address */
    .4byte  0x000B0000                       /* 11.0 (16.16 FP) — pool data */
    .4byte  0x00040000                       /* 4.0 (16.16 FP) — pool data */
    .4byte  0x0000C000                       /* 0.75 (16.16 FP) — pool data */
.L_p_bonus_flag:
    .4byte  sym_06085F89                     /* bonus mode flag byte address */
.L_bonus_active:
    .byte   0xD5, 0x44    /* mov.l .L_fp_one, r5 */  ! r5 = 0x00010000 (1.0 in 16.16 fixed-point)
    extu.b r14, r2                           ! r2 = entry_index (zero-extended byte)
    mov r2, r3                               ! r3 = entry_index (copy)
    shll2 r2                                 ! r2 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r2                               ! r2 = entry_index * 68 (struct stride)
    exts.w r2, r2                            ! sign-extend offset to word
    add r13, r2                              ! r2 = &entry
    mov.l @(12, r2), r2                      ! r2 = entry.elapsed_time (+0x0C)
    cmp/gt r5, r2                            ! T = (elapsed_time > 1.0)?
    bf      .L_init_fresh_entry              ! if elapsed_time <= 1.0, initialize fresh entry
    extu.b r14, r4                           ! r4 = entry_index (zero-extended)
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68 (struct stride)
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l @(16, r4), r2                      ! r2 = entry.delta (+0x10, per-frame increment)
    mov.l @(4, r4), r3                       ! r3 = entry.display_value (+0x04)
    add r2, r3                               ! r3 = display_value + delta
    mov.l r3, @(4, r4)                       ! store updated display_value
    extu.b r14, r2                           ! r2 = entry_index
    mov #0x4, r3                             ! r3 = 4 (boundary between clamp modes)
    cmp/ge r3, r2                            ! T = (entry_index >= 4)?
    bt      .L_clamp_gt_check                ! if >= 4, use greater-than clamp check
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l @(4, r4), r2                       ! r2 = entry.display_value
    mov.l @(52, r4), r3                      ! r3 = entry.max_cap (+0x34)
    cmp/ge r3, r2                            ! T = (display_value >= max_cap)?
    bf      .L_after_clamp                   ! if not reached cap, skip clamping
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l @(52, r4), r2                      ! r2 = entry.max_cap
    bra     .L_after_clamp                   ! continue to countdown update
    mov.l r2, @(4, r4)                       ! clamp display_value = max_cap (delay slot)
.L_clamp_gt_check:
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l @(4, r4), r2                       ! r2 = entry.display_value
    mov.l @(52, r4), r3                      ! r3 = entry.max_cap
    cmp/gt r3, r2                            ! T = (display_value > max_cap)?
    bt      .L_after_clamp                   ! if not exceeded, skip clamping
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l @(52, r4), r2                      ! r2 = entry.max_cap
    mov.l r2, @(4, r4)                       ! clamp display_value = max_cap
.L_after_clamp:
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l @(24, r4), r2                      ! r2 = entry.countdown_step (+0x18)
    mov.l @(12, r4), r3                      ! r3 = entry.elapsed_time (+0x0C)
    sub r2, r3                               ! r3 = elapsed_time - countdown_step
    mov.l r3, @(12, r4)                      ! store updated elapsed_time
    mov.l @(36, r4), r2                      ! r2 = entry.threshold (+0x24)
    mov.l @(24, r4), r3                      ! r3 = entry.countdown (+0x18)
    sub r2, r3                               ! r3 = countdown - threshold
    mov r3, r2                               ! r2 = updated countdown (for comparison)
    mov.l r3, @(24, r4)                      ! store updated countdown
    .byte   0xD3, 0x15    /* mov.l .L_fp_two, r3 */  ! r3 = 0x00020000 (2.0 in 16.16 FP)
    cmp/gt r3, r2                            ! T = (countdown > 2.0)?
    bt      .L_epilogue                      ! if still above 2.0, skip reset — go render
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.w   .L_wpool_06016624, r2            ! r2 = 0x0600 (countdown reset value)
    mov.l r2, @(24, r4)                      ! entry.countdown = 0x0600 (reset)
    bra     .L_epilogue                      ! go to epilogue
    mov.l r12, @(16, r4)                     ! entry.delta = 0 (stop incrementing, delay slot)
.L_init_fresh_entry:
    extu.b r14, r4                           ! r4 = entry_index
    mov r4, r3                               ! r3 = entry_index (copy)
    shll2 r4                                 ! r4 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 4
    shll2 r3                                 ! r3 = entry_index * 16
    shll2 r3                                 ! r3 = entry_index * 64
    add r3, r4                               ! r4 = entry_index * 68
    exts.w r4, r4                            ! sign-extend offset
    add r13, r4                              ! r4 = &entry
    mov.l r5, @(12, r4)                      ! entry.elapsed_time = 1.0 (threshold from r5)
    mov.l r12, @(36, r4)                     ! entry.threshold = 0 (clear)
    mov r12, r2                              ! r2 = 0 (for comparison, unused)
    mov.l r12, @(24, r4)                     ! entry.countdown = 0 (clear)
    mov.b @(2, r4), r0                       ! r0 = entry.anim_phase (current value)
    mov r0, r3                               ! r3 = current anim_phase
    add #0x1, r3                             ! r3 = anim_phase + 1 (advance to next phase)
    mov r3, r0                               ! r0 = new anim_phase
    mov.b r0, @(2, r4)                       ! store incremented anim_phase
.L_epilogue:
    extu.b r14, r4                           ! r4 = entry_index (arg for digit renderer)
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    .byte   0xA3, 0xDA    /* bra 0x06016DD8 (external) */  ! tail-call digit renderer
    mov.l @r15+, r14                         ! restore r14 (delay slot)
.L_wpool_06016624:
    .2byte  0x0600                           /* countdown reset value */
    .2byte  0xFFFF                           /* padding */
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_fp_two:
    .4byte  0x00020000                  /* 2.0 (16.16 fixed-point) */
