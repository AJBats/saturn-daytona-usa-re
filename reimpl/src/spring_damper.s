/* spring_damper -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060276CC - 0x060279B0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Damped integration with exponential smoothing (IIR filter).
 * Called as a clip handler from the rendering pipeline (Pipeline A,
 * entry 2 = "2-vertex clip handler").
 *
 * Parameters:
 *   r4 = pointer to 12-long (48-byte) vertex/interpolation state struct
 *   r5 = pointer to mode word stream (up to 4 words read)
 *
 * Constants loaded from pool:
 *   r1  = 0xE666 = ~0.9 in 0.16 fixed point (retention/damping factor)
 *   r2  = 0x1999 = ~0.1 in 0.16 fixed point (approach/blend factor)
 *   r14 = convergence limit loaded indirectly from sym_06063F04
 *   Note: 0xE666 + 0x1999 = 0xFFFF (~1.0), so this is a weighted blend:
 *         new = 0.9 * current + 0.1 * target
 *
 * Mode dispatch reads successive words from r5 to select axis config:
 *   Mode word 0 == 1: axis 0 integration (offsets 0/4/8 vel, 12/16/20 target, 20/44 limit)
 *   Mode word 1 == 1: axis 1 integration (offsets 12/16/20 vel, 24/28/32 target, 32/8 limit)
 *   Mode word 2 == 1: axis 2 integration (offsets 24/28/32 vel, 36/40/44 target, 44/20 limit)
 *   Mode word 3 (fallthrough): axis 3 integration (offsets 36/40/44 vel, 0/4/8 target, 8/32 limit)
 *
 * Each axis loop:
 *   vel_A_new = vel_A * 0.9 + target_A * 0.1
 *   vel_B_new = vel_B * 0.9 + target_B * 0.1
 *   pos_new   = vel_C * 0.9 + target_C * 0.1 + 4  (constant bias)
 *   Loop until pos_new >= limit (r14)
 */

    .section .text.FUN_060276CC


    .global spring_damper
    .type spring_damper, @function
spring_damper:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r9, @-r15                     ! save r9 (callee-saved)
    mov.l r8, @-r15                     ! save r8 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_pool_retention, r1       ! r1 = 0xE666 (~0.9 retention factor)
    mov.l   .L_pool_approach, r2        ! r2 = 0x1999 (~0.1 approach factor)
    mov.w @r5+, r0                      ! r0 = mode word 0 from config stream
    mov.l   .L_pool_limit_ptr, r14      ! r14 = ptr to convergence limit ptr
    mov.l @r14, r14                     ! r14 = convergence limit value
    cmp/eq #0x1, r0                     ! mode 0 enabled?
    bf      .L_axis1_dispatch           ! no: skip to axis 1 dispatch
    mov.l @(20, r4), r6                 ! r6 = struct[5] (axis 0 forward limit)
    mov.l @(44, r4), r7                 ! r7 = struct[11] (axis 0 reverse limit)
    cmp/ge r7, r6                       ! forward limit >= reverse limit?
    bf      .L_axis0_reverse            ! no: use reverse target set
.L_axis0_forward:
    mov.l @r4, r7                       ! r7 = struct[0] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @(12, r4), r6                 ! r6 = struct[3] (target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = (mach:macl >> 16) = vel_A * 0.9
    mov.l @(4, r4), r7                  ! r7 = struct[1] (vel B)
    sts mach, r6                        ! high 32 bits of target_A * approach
    sts macl, r9                        ! low 32 bits of target_A * approach
    xtrct r6, r9                        ! r9 = target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + target_A * 0.1 = new vel_A
    mov.l r9, @r4                       ! struct[0] = new vel_A
    mov.l @(16, r4), r6                 ! r6 = struct[4] (target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(8, r4), r7                  ! r7 = struct[2] (vel C / position)
    sts mach, r6                        ! high 32 bits of target_B * approach
    sts macl, r9                        ! low 32 bits of target_B * approach
    xtrct r6, r9                        ! r9 = target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + target_B * 0.1 = new vel_B
    mov.l r9, @(4, r4)                  ! struct[1] = new vel_B
    mov.l @(20, r4), r6                 ! r6 = struct[5] (target C / forward limit)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of target_C * approach
    sts macl, r9                        ! low 32 bits of target_C * approach
    xtrct r6, r9                        ! r9 = target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(8, r4)                  ! struct[2] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis0_forward            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_pool_retention:
    .4byte  0x0000E666                  ! ~0.9 in 0.16 fixed point (retention factor)
.L_pool_approach:
    .4byte  0x00001999                  ! ~0.1 in 0.16 fixed point (approach factor)
.L_pool_limit_ptr:
    .4byte  sym_06063F04                ! ptr to convergence limit (view matrix ptr A)
.L_axis0_reverse:
    mov.l @r4, r7                       ! r7 = struct[0] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @(36, r4), r6                 ! r6 = struct[9] (reverse target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! reverse_target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(4, r4), r7                  ! r7 = struct[1] (vel B)
    sts mach, r6                        ! high 32 bits of reverse_target_A * approach
    sts macl, r9                        ! low 32 bits of reverse_target_A * approach
    xtrct r6, r9                        ! r9 = reverse_target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + reverse_target_A * 0.1
    mov.l r9, @r4                       ! struct[0] = new vel_A
    mov.l @(40, r4), r6                 ! r6 = struct[10] (reverse target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! reverse_target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(8, r4), r7                  ! r7 = struct[2] (vel C / position)
    sts mach, r6                        ! high 32 bits of reverse_target_B * approach
    sts macl, r9                        ! low 32 bits of reverse_target_B * approach
    xtrct r6, r9                        ! r9 = reverse_target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + reverse_target_B * 0.1
    mov.l r9, @(4, r4)                  ! struct[1] = new vel_B
    mov.l @(44, r4), r6                 ! r6 = struct[11] (reverse target C)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! reverse_target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of reverse_target_C * approach
    sts macl, r9                        ! low 32 bits of reverse_target_C * approach
    xtrct r6, r9                        ! r9 = reverse_target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + reverse_target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(8, r4)                  ! struct[2] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis0_reverse            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_axis1_dispatch:
    mov.w @r5+, r0                      ! r0 = mode word 1 from config stream
    cmp/eq #0x1, r0                     ! mode 1 enabled?
    bf      .L_axis2_dispatch           ! no: skip to axis 2 dispatch
    mov.l @(32, r4), r6                 ! r6 = struct[8] (axis 1 forward limit)
    mov.l @(8, r4), r7                  ! r7 = struct[2] (axis 1 reverse limit)
    cmp/ge r7, r6                       ! forward limit >= reverse limit?
    bf      .L_axis1_reverse            ! no: use reverse target set
.L_axis1_forward:
    mov.l @(12, r4), r7                 ! r7 = struct[3] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @(24, r4), r6                 ! r6 = struct[6] (target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(16, r4), r7                 ! r7 = struct[4] (vel B)
    sts mach, r6                        ! high 32 bits of target_A * approach
    sts macl, r9                        ! low 32 bits of target_A * approach
    xtrct r6, r9                        ! r9 = target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + target_A * 0.1 = new vel_A
    mov.l r9, @(12, r4)                 ! struct[3] = new vel_A
    mov.l @(28, r4), r6                 ! r6 = struct[7] (target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(20, r4), r7                 ! r7 = struct[5] (vel C / position)
    sts mach, r6                        ! high 32 bits of target_B * approach
    sts macl, r9                        ! low 32 bits of target_B * approach
    xtrct r6, r9                        ! r9 = target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + target_B * 0.1 = new vel_B
    mov.l r9, @(16, r4)                 ! struct[4] = new vel_B
    mov.l @(32, r4), r6                 ! r6 = struct[8] (target C / forward limit)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of target_C * approach
    sts macl, r9                        ! low 32 bits of target_C * approach
    xtrct r6, r9                        ! r9 = target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(20, r4)                 ! struct[5] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis1_forward            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_axis1_reverse:
    mov.l @(12, r4), r7                 ! r7 = struct[3] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @r4, r6                       ! r6 = struct[0] (reverse target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! reverse_target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(16, r4), r7                 ! r7 = struct[4] (vel B)
    sts mach, r6                        ! high 32 bits of reverse_target_A * approach
    sts macl, r9                        ! low 32 bits of reverse_target_A * approach
    xtrct r6, r9                        ! r9 = reverse_target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + reverse_target_A * 0.1
    mov.l r9, @(12, r4)                 ! struct[3] = new vel_A
    mov.l @(4, r4), r6                  ! r6 = struct[1] (reverse target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! reverse_target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(20, r4), r7                 ! r7 = struct[5] (vel C / position)
    sts mach, r6                        ! high 32 bits of reverse_target_B * approach
    sts macl, r9                        ! low 32 bits of reverse_target_B * approach
    xtrct r6, r9                        ! r9 = reverse_target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + reverse_target_B * 0.1
    mov.l r9, @(16, r4)                 ! struct[4] = new vel_B
    mov.l @(8, r4), r6                  ! r6 = struct[2] (reverse target C)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! reverse_target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of reverse_target_C * approach
    sts macl, r9                        ! low 32 bits of reverse_target_C * approach
    xtrct r6, r9                        ! r9 = reverse_target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + reverse_target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(20, r4)                 ! struct[5] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis1_reverse            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_axis2_dispatch:
    mov.w @r5+, r0                      ! r0 = mode word 2 from config stream
    cmp/eq #0x1, r0                     ! mode 2 enabled?
    bf      .L_axis3_entry              ! no: fall through to axis 3
    mov.l @(44, r4), r6                 ! r6 = struct[11] (axis 2 forward limit)
    mov.l @(20, r4), r7                 ! r7 = struct[5] (axis 2 reverse limit)
    cmp/ge r7, r6                       ! forward limit >= reverse limit?
    bf      .L_axis2_reverse            ! no: use reverse target set
.L_axis2_forward:
    mov.l @(24, r4), r7                 ! r7 = struct[6] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @(36, r4), r6                 ! r6 = struct[9] (target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(28, r4), r7                 ! r7 = struct[7] (vel B)
    sts mach, r6                        ! high 32 bits of target_A * approach
    sts macl, r9                        ! low 32 bits of target_A * approach
    xtrct r6, r9                        ! r9 = target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + target_A * 0.1 = new vel_A
    mov.l r9, @(24, r4)                 ! struct[6] = new vel_A
    mov.l @(40, r4), r6                 ! r6 = struct[10] (target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(32, r4), r7                 ! r7 = struct[8] (vel C / position)
    sts mach, r6                        ! high 32 bits of target_B * approach
    sts macl, r9                        ! low 32 bits of target_B * approach
    xtrct r6, r9                        ! r9 = target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + target_B * 0.1 = new vel_B
    mov.l r9, @(28, r4)                 ! struct[7] = new vel_B
    mov.l @(44, r4), r6                 ! r6 = struct[11] (target C / forward limit)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of target_C * approach
    sts macl, r9                        ! low 32 bits of target_C * approach
    xtrct r6, r9                        ! r9 = target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(32, r4)                 ! struct[8] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis2_forward            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_axis2_reverse:
    mov.l @(24, r4), r7                 ! r7 = struct[6] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @(12, r4), r6                 ! r6 = struct[3] (reverse target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! reverse_target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(28, r4), r7                 ! r7 = struct[7] (vel B)
    sts mach, r6                        ! high 32 bits of reverse_target_A * approach
    sts macl, r9                        ! low 32 bits of reverse_target_A * approach
    xtrct r6, r9                        ! r9 = reverse_target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + reverse_target_A * 0.1
    mov.l r9, @(24, r4)                 ! struct[6] = new vel_A
    mov.l @(16, r4), r6                 ! r6 = struct[4] (reverse target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! reverse_target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(32, r4), r7                 ! r7 = struct[8] (vel C / position)
    sts mach, r6                        ! high 32 bits of reverse_target_B * approach
    sts macl, r9                        ! low 32 bits of reverse_target_B * approach
    xtrct r6, r9                        ! r9 = reverse_target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + reverse_target_B * 0.1
    mov.l r9, @(28, r4)                 ! struct[7] = new vel_B
    mov.l @(20, r4), r6                 ! r6 = struct[5] (reverse target C)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! reverse_target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of reverse_target_C * approach
    sts macl, r9                        ! low 32 bits of reverse_target_C * approach
    xtrct r6, r9                        ! r9 = reverse_target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + reverse_target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(32, r4)                 ! struct[8] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis2_reverse            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_axis3_entry:
    mov.l @(8, r4), r6                  ! r6 = struct[2] (axis 3 forward limit)
    mov.l @(32, r4), r7                 ! r7 = struct[8] (axis 3 reverse limit)
    cmp/ge r7, r6                       ! forward limit >= reverse limit?
    bf      .L_axis3_reverse            ! no: use reverse target set
.L_axis3_forward:
    mov.l @(36, r4), r7                 ! r7 = struct[9] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @r4, r6                       ! r6 = struct[0] (target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(40, r4), r7                 ! r7 = struct[10] (vel B)
    sts mach, r6                        ! high 32 bits of target_A * approach
    sts macl, r9                        ! low 32 bits of target_A * approach
    xtrct r6, r9                        ! r9 = target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + target_A * 0.1 = new vel_A
    mov.l r9, @(36, r4)                 ! struct[9] = new vel_A
    mov.l @(4, r4), r6                  ! r6 = struct[1] (target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(44, r4), r7                 ! r7 = struct[11] (vel C / position)
    sts mach, r6                        ! high 32 bits of target_B * approach
    sts macl, r9                        ! low 32 bits of target_B * approach
    xtrct r6, r9                        ! r9 = target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + target_B * 0.1 = new vel_B
    mov.l r9, @(40, r4)                 ! struct[10] = new vel_B
    mov.l @(8, r4), r6                  ! r6 = struct[2] (target C / forward limit)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of target_C * approach
    sts macl, r9                        ! low 32 bits of target_C * approach
    xtrct r6, r9                        ! r9 = target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(44, r4)                 ! struct[11] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis3_forward            ! no: iterate again
    bra     .L_epilogue                 ! yes: done, return
    nop
.L_axis3_reverse:
    mov.l @(36, r4), r7                 ! r7 = struct[9] (vel A)
    dmuls.l r7, r1                      ! vel_A * 0.9 (retention)
    mov.l @(24, r4), r6                 ! r6 = struct[6] (reverse target A)
    sts mach, r7                        ! high 32 bits of vel_A * retention
    sts macl, r8                        ! low 32 bits of vel_A * retention
    dmuls.l r6, r2                      ! reverse_target_A * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_A * 0.9
    mov.l @(40, r4), r7                 ! r7 = struct[10] (vel B)
    sts mach, r6                        ! high 32 bits of reverse_target_A * approach
    sts macl, r9                        ! low 32 bits of reverse_target_A * approach
    xtrct r6, r9                        ! r9 = reverse_target_A * 0.1
    dmuls.l r7, r1                      ! vel_B * 0.9 (retention)
    add r8, r9                          ! r9 = vel_A * 0.9 + reverse_target_A * 0.1
    mov.l r9, @(36, r4)                 ! struct[9] = new vel_A
    mov.l @(28, r4), r6                 ! r6 = struct[7] (reverse target B)
    sts mach, r7                        ! high 32 bits of vel_B * retention
    sts macl, r8                        ! low 32 bits of vel_B * retention
    dmuls.l r6, r2                      ! reverse_target_B * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_B * 0.9
    mov.l @(44, r4), r7                 ! r7 = struct[11] (vel C / position)
    sts mach, r6                        ! high 32 bits of reverse_target_B * approach
    sts macl, r9                        ! low 32 bits of reverse_target_B * approach
    xtrct r6, r9                        ! r9 = reverse_target_B * 0.1
    dmuls.l r7, r1                      ! vel_C * 0.9 (retention)
    add r8, r9                          ! r9 = vel_B * 0.9 + reverse_target_B * 0.1
    mov.l r9, @(40, r4)                 ! struct[10] = new vel_B
    mov.l @(32, r4), r6                 ! r6 = struct[8] (reverse target C)
    sts mach, r7                        ! high 32 bits of vel_C * retention
    sts macl, r8                        ! low 32 bits of vel_C * retention
    dmuls.l r6, r2                      ! reverse_target_C * 0.1 (approach)
    xtrct r7, r8                        ! r8 = vel_C * 0.9
    sts mach, r6                        ! high 32 bits of reverse_target_C * approach
    sts macl, r9                        ! low 32 bits of reverse_target_C * approach
    xtrct r6, r9                        ! r9 = reverse_target_C * 0.1
    add r8, r9                          ! r9 = vel_C * 0.9 + reverse_target_C * 0.1
    add #0x4, r9                        ! r9 += 4 (constant bias per step)
    mov.l r9, @(44, r4)                 ! struct[11] = new position
    cmp/ge r14, r9                      ! position >= convergence limit?
    bf      .L_axis3_reverse            ! no: iterate again
.L_epilogue:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay slot) restore r14
