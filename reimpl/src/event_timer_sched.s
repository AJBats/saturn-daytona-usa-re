/* event_timer_sched -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040B34 - 0x06040B8E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Schedule an event timer callback with validation.
 *
 * Checks whether the event slot (indexed by r0) is already active in
 * the global event status array (sym_0606367C). If the slot is free,
 * enqueues the event command via cmd_enqueue, validates system state
 * via state_field_read, and confirms the enqueued size is positive.
 * On success, falls through into event_callback_dispatch with r5=0
 * and r6=0 (immediate scheduling, no counter adjustment).
 *
 * All four failure paths (slot busy, cmd_enqueue fail, state_field_read
 * fail, non-positive enqueued size) branch to event_callback_dispatch's
 * epilogue with r0=0.
 *
 * Arguments:
 *   r0 = event slot index (byte offset into status array)
 *   r4 = event struct pointer (saved in r13)
 *     +0x04  command queue key (passed to cmd_enqueue as r4)
 *     +0x10  span / additional size (passed to cmd_enqueue as r5)
 *   r5 = size limit (capacity threshold, passed to cmd_enqueue as r6)
 *
 * Returns:
 *   r0 = event record pointer on success (from event_callback_dispatch)
 *   r0 = 0 on failure (slot busy, enqueue fail, state fail, or bad size)
 *
 * Calls: cmd_enqueue (via pool in event_callback_dispatch)
 *        state_field_read (via pool in event_callback_dispatch)
 * Falls through to: event_callback_dispatch (continuation)
 *
 * Stack frame (0x18 = 24 bytes of locals):
 *   sp+0x00 = cmd_enqueue output (enqueued size, written via r7)
 *   sp+0x04 = cmd_enqueue output field[1]
 *   sp+0x14 = saved r5 (size limit)
 */

    .section .text.FUN_06040B34


    .global event_timer_sched
    .type event_timer_sched, @function
/* ---------------------------------------------------------------
 * event_timer_sched
 *   Validate event slot and schedule timer via event_callback_dispatch.
 * --------------------------------------------------------------- */
event_timer_sched:
    mov.l r14, @-r15              ! save r14 (callee-saved)
    mov #0x0, r14                 ! r14 = 0 (used later as zero for r5/r6 args)
    mov.l r13, @-r15              ! save r13 (callee-saved)
    sts.l pr, @-r15               ! save return address
    add #-0x18, r15               ! allocate 24 bytes for locals
    mov.l r5, @(20, r15)          ! locals[20] = size_limit (caller's r5)
    mov.l   .L_pool_evt_status_array, r3 ! r3 = &event_status_array (sym_0606367C)
    mov.b @(r0, r3), r2           ! r2 = status_array[slot_index]
    extu.b r2, r2                 ! zero-extend byte to word
    tst r2, r2                    ! is this slot free (status == 0)?
    bt/s    .L_slot_free          ! if free, proceed with scheduling
    mov r4, r13                   ! r13 = event struct pointer (delay slot)
    .byte   0xA0, 0x51    /* bra 0x06040BF2 (external: event_callback_dispatch epilogue) */
    mov #0x0, r0                  ! return 0 — slot already active (delay slot)
.L_pool_evt_status_array:
    .4byte  sym_0606367C
.L_slot_free:
    mov r15, r3                   ! r3 = sp
    add #0x4, r3                  ! r3 = sp+4 (temp value, pushed below)
    mov.l r3, @-r15               ! push sp+4; sp -= 4
    mov r15, r7                   ! r7 = sp (after push)
    mov.l @(24, r15), r6          ! r6 = size_limit (locals[20], offset by push = @(sp+24))
    mov.l @(16, r13), r5          ! r5 = event_struct[+0x10] (span)
    .byte   0xD3, 0x26    /* mov.l .L_pool_06040BFC, r3  — r3 = &cmd_enqueue */
    add #0x4, r7                  ! r7 = sp+4 = output buffer for cmd_enqueue
    jsr @r3                       ! call cmd_enqueue(queue_key, span, size_limit, &output)
    mov.l @(4, r13), r4           ! r4 = event_struct[+0x04] (queue key, delay slot)
    tst r0, r0                    ! did cmd_enqueue succeed (r0 == 0)?
    bt/s    .L_enqueue_ok         ! if success, continue
    add #0x4, r15                 ! pop temp push (delay slot)
    .byte   0xA0, 0x40    /* bra 0x06040BF2 (external: event_callback_dispatch epilogue) */
    mov #0x0, r0                  ! return 0 — cmd_enqueue failed (delay slot)
.L_enqueue_ok:
    .byte   0xD3, 0x23    /* mov.l .L_pool_06040C00, r3  — r3 = &state_field_read */
    jsr @r3                       ! call state_field_read()
    nop                           ! delay slot
    tst r0, r0                    ! did state_field_read succeed (r0 == 0)?
    bt      .L_state_ok           ! if success, continue
    .byte   0xA0, 0x39    /* bra 0x06040BF2 (external: event_callback_dispatch epilogue) */
    mov #0x0, r0                  ! return 0 — state validation failed (delay slot)
.L_state_ok:
    mov.l @(4, r15), r3           ! r3 = locals[4] (cmd_enqueue output field)
    cmp/pl r3                     ! is the enqueued size > 0?
    bt      .L_size_ok            ! if positive, proceed to callback dispatch
    .byte   0xA0, 0x34    /* bra 0x06040BF2 (external: event_callback_dispatch epilogue) */
    mov #0x0, r0                  ! return 0 — non-positive size (delay slot)
.L_size_ok:
    mov r14, r6                   ! r6 = 0 (no counter adjustment)
    mov r14, r5                   ! r5 = 0 (no remaining time)
