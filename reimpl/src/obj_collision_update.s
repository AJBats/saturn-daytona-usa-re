/* obj_collision_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06020C3C - 0x06020CF4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Object collision display update dispatcher.
 * Called when bit 26 (collision update trigger) is set in the event flags
 * by obj_culling_pass or obj_state_pack. Copies two 16-byte VDP command
 * templates from ROM data (sym_0605F588, sym_0605F598) into stack buffers,
 * then reads the display_timer word and dispatches on its value:
 *
 *   timer == 1: Write VDP2 control 0xC060 (ch32) to pipe_buf_1+0xA,
 *               set cmd_list+0x20 = 0xF (priority), write timer to
 *               cmd_ready_flag, copy 8 words from stack+0x10 into
 *               cmd_list+0x10 (VDP1 command data from template A).
 *
 *   timer == 2: Write VDP2 control 0xC044 (ch8) to pipe_buf_1+0xA,
 *               set cmd_list+0x20 = 0xF (priority), write timer to
 *               cmd_ready_flag, copy 8 words from stack+0x0 into
 *               cmd_list (VDP1 command data from template B).
 *
 *   timer == 3: Call obj_lod_level (LOD selection for object).
 *
 *   timer == 4: Call display_layer_fill_cfg(4) (display layer config).
 *
 * Epilogue: Clears display_timer to 0 (consume the event).
 *
 * Registers on entry:
 *   (none -- called via event dispatch with no args)
 *
 * Key symbols:
 *   sym_0605F588  -- VDP cmd template A (16 bytes, copied to stack+0x10)
 *   sym_0605F598  -- VDP cmd template B (16 bytes, copied to stack+0x00)
 *   sym_06035228  -- memcpy_byte(r0=count, r1=dst, r2=src)
 *   sym_060635AC  -- cmd_ready_flag (word; set to timer value, cleared on exit)
 *   sym_060A3D88  -- VDP1 cmd_list base (display state word)
 *   sym_060A3DB0  -- pipe_buf_1 (polygon output buffer base)
 *   sym_0608780C  -- display_timer (16-bit word; 1-4 = active, 0 = idle)
 *   sym_06038044  -- vdp1_cmd_copy_8w(r4=src) -- copies 8 words into cmd_list+0x10
 *   sym_0602853E  -- display_layer_fill_cfg(r4=mode)
 */

    .section .text.FUN_06020C3C


    .global obj_collision_update
    .type obj_collision_update, @function
obj_collision_update:
    sts.l pr, @-r15                         ! save return address
    add #-0x20, r15                         ! allocate 0x20 (32) bytes on stack
    mov r15, r1                             ! r1 = stack base (dst for memcpy)
    mov.l   .L_pool_cmd_template_a, r2     ! r2 = &cmd_template_a (sym_0605F588)
    mov.l   .L_pool_memcpy_byte, r3        ! r3 = memcpy_byte function
    add #0x10, r1                           ! r1 = stack+0x10 (dst for template A)
    jsr @r3                                 ! memcpy_byte(0x10, stack+0x10, cmd_template_a)
    mov #0x10, r0                           ! (delay) r0 = 0x10 (16 bytes to copy)
    mov r15, r1                             ! r1 = stack base (dst for template B)
    mov.l   .L_pool_cmd_template_b, r2    ! r2 = &cmd_template_b (sym_0605F598)
    mov.l   .L_pool_memcpy_byte, r3        ! r3 = memcpy_byte function
    jsr @r3                                 ! memcpy_byte(0x10, stack+0x00, cmd_template_b)
    mov #0x10, r0                           ! (delay) r0 = 0x10 (16 bytes to copy)
    mov.l   .L_pool_cmd_ready_flag, r7    ! r7 = &cmd_ready_flag (sym_060635AC)
    mov.l   .L_pool_cmd_list_base, r6     ! r6 = &cmd_list_base (sym_060A3D88)
    mov.l   .L_pool_pipe_buf_1, r5        ! r5 = &pipe_buf_1 (sym_060A3DB0)
    mov #0x1, r4                            ! r4 = 1 (initial timer value / channel ID)
    mov.l   .L_pool_display_timer, r0     ! r0 = &display_timer (sym_0608780C)
    mov.w @r0, r0                           ! r0 = display_timer (16-bit read)
    bra     .L_dispatch_timer               ! jump to dispatch switch
    extu.w r0, r0                           ! (delay) zero-extend timer to 32-bit
.L_case_timer_1:
    mov #0xF, r3                            ! r3 = 0xF (priority mask / all layers)
    extu.w r4, r4                           ! r4 = 1 (unsigned, for cmd_ready_flag write)
    mov.l   .L_pool_vdp2_ctrl_ch32, r0    ! r0 = 0xC060 (VDP2 control value for ch32)
    mov.w r0, @(10, r5)                     ! pipe_buf_1[0xA] = 0xC060 (set ch32 control)
    mov #0x20, r0                           ! r0 = 0x20 (offset into cmd_list)
    mov.w r3, @(r0, r6)                     ! cmd_list[0x20] = 0xF (set all priority bits)
    mov.w r4, @r7                           ! cmd_ready_flag = 1 (signal ready)
    mov r15, r4                             ! r4 = stack base
    mov.l   .L_pool_vdp1_cmd_copy, r3     ! r3 = vdp1_cmd_copy_8w function
    jsr @r3                                 ! vdp1_cmd_copy_8w(stack+0x10) -- copy template A
    add #0x10, r4                           ! (delay) r4 = stack+0x10 (src = template A)
    bra     .L_epilogue                     ! done, go to epilogue
    nop
.L_case_timer_2:
    mov.l   .L_pool_vdp2_ctrl_ch8, r0     ! r0 = 0xC044 (VDP2 control value for ch8)
    mov #0xF, r3                            ! r3 = 0xF (priority mask / all layers)
    extu.w r4, r4                           ! r4 = 1 (unsigned, for cmd_ready_flag write)
    mov.w r0, @(10, r5)                     ! pipe_buf_1[0xA] = 0xC044 (set ch8 control)
    mov #0x20, r0                           ! r0 = 0x20 (offset into cmd_list)
    mov.w r3, @(r0, r6)                     ! cmd_list[0x20] = 0xF (set all priority bits)
    mov.w r4, @r7                           ! cmd_ready_flag = 1 (signal ready)
    mov.l   .L_pool_vdp1_cmd_copy, r3     ! r3 = vdp1_cmd_copy_8w function
    jsr @r3                                 ! vdp1_cmd_copy_8w(stack+0x00) -- copy template B
    mov r15, r4                             ! (delay) r4 = stack base (src = template B)
    bra     .L_epilogue                     ! done, go to epilogue
    nop
.L_case_timer_3:
    .byte   0xBE, 0x55    /* bsr 0x06020946 (external) */
    nop                                     ! (delay) obj_lod_level() -- LOD selection
    bra     .L_epilogue                     ! done, go to epilogue
    nop
.L_case_timer_4:
    mov.l   .L_pool_display_layer_cfg, r3  ! r3 = display_layer_fill_cfg function
    jsr @r3                                 ! display_layer_fill_cfg(4)
    mov #0x4, r4                            ! (delay) r4 = 4 (layer config mode)
    bra     .L_epilogue                     ! done, go to epilogue
    nop
.L_dispatch_timer:
    cmp/eq #0x1, r0                         ! timer == 1?
    bt      .L_case_timer_1                 ! yes: VDP ch32 template A path
    cmp/eq #0x2, r0                         ! timer == 2?
    bt      .L_case_timer_2                 ! yes: VDP ch8 template B path
    cmp/eq #0x3, r0                         ! timer == 3?
    bt      .L_case_timer_3                 ! yes: LOD level select
    cmp/eq #0x4, r0                         ! timer == 4?
    bt      .L_case_timer_4                 ! yes: display layer config
.L_epilogue:
    mov #0x0, r2                            ! r2 = 0 (clear value)
    mov.l   .L_pool_display_timer, r3      ! r3 = &display_timer (sym_0608780C)
    add #0x20, r15                          ! free 0x20 bytes from stack
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    mov.w r2, @r3                           ! (delay) display_timer = 0 (consume event)
    .2byte  0xFFFF
.L_pool_cmd_template_a:
    .4byte  sym_0605F588
.L_pool_memcpy_byte:
    .4byte  sym_06035228
.L_pool_cmd_template_b:
    .4byte  sym_0605F598
.L_pool_cmd_ready_flag:
    .4byte  sym_060635AC
.L_pool_cmd_list_base:
    .4byte  sym_060A3D88
.L_pool_pipe_buf_1:
    .4byte  sym_060A3DB0
.L_pool_display_timer:
    .4byte  sym_0608780C
.L_pool_vdp2_ctrl_ch32:
    .4byte  0x0000C060
.L_pool_vdp1_cmd_copy:
    .4byte  sym_06038044
.L_pool_vdp2_ctrl_ch8:
    .4byte  0x0000C044
.L_pool_display_layer_cfg:
    .4byte  sym_0602853E
