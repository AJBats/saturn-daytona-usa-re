/* obj_coord_setter -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600508C - 0x06005120
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ---------------------------------------------------------------
 * obj_coord_setter
 * ---------------------------------------------------------------
 * Copies object tile data into the heap (via memcpy_word_idx) and
 * records a display command table entry so the VDP2 tilemap DMA
 * system can later transfer it to VRAM.
 *
 * This is a companion to obj_position_update: both write entries
 * into the same command table (sym_06063750) indexed by the mode
 * flag at sym_06059F10. Each 8-byte entry is:
 *   [+0] source data pointer
 *   [+4] flags / context word
 *
 * If r6 (data_present mask result) is nonzero, the function:
 *   1. Computes byte count from the object descriptor (tile_count * row_width + 2) * 2
 *   2. Copies that many bytes from obj_desc into the heap via memcpy_word_idx
 *   3. Advances both heap cursors (sym_06063D90, sym_06063D94) by the byte count
 * If r6 is zero, skips the copy and uses r13 (obj_desc ptr) directly.
 *
 * In both cases, the function writes the source pointer and flags
 * word into the command table and increments the mode flag counter.
 *
 * Register inputs (from caller preamble):
 *   r3 = bitmask (AND'd with r6 to produce data_present flag)
 *   r4 = object descriptor pointer (tile_count@+0, row_width@+2)
 *   r5 = flags / context word (saved to stack, stored in cmd table entry)
 *   r6 = raw flag value (AND'd with r3 to test data presence)
 *
 * Register outputs:
 *   None (writes to heap and command table)
 *
 * Calls: memcpy_word_idx
 */

    .section .text.FUN_0600508C


    .global obj_coord_setter
    .type obj_coord_setter, @function
obj_coord_setter:
    mov.l r14, @-r15                         ! save r14
    and r3, r6                               ! r6 = r3 & r6 (data_present flag)
    mov.l r13, @-r15                         ! save r13
    mov.l r12, @-r15                         ! save r12
    mov.l r11, @-r15                         ! save r11
    sts.l pr, @-r15                          ! save return address
    sts.l macl, @-r15                        ! save macl (used by mulu.w)
    add #-0x4, r15                           ! allocate 4 bytes of local stack
    mov.l r5, @r15                           ! local[0] = flags/context word
    tst r6, r6                               ! test data_present flag
    bt/s    .L_no_data_copy                  ! if zero, skip heap copy
    mov r4, r13                              ! r13 = obj_desc pointer (delay slot)
    /* --- Data copy path: compute byte count and copy to heap --- */
    mov r13, r4                              ! r4 = obj_desc pointer
    mov r13, r5                              ! r5 = obj_desc pointer (memcpy source)
    mov.l   .L_heap_cursor_ptr, r11          ! r11 = &heap_cursor (sym_06063D90)
    mov.w @(2, r4), r0                       ! r0 = obj_desc.row_width (halfword at +2)
    mov.w @r4, r3                            ! r3 = obj_desc.tile_count (halfword at +0)
    mov.l @r11, r14                          ! r14 = heap_cursor value (dest address)
    mov r0, r12                              ! r12 = row_width
    mulu.w r3, r12                           ! macl = tile_count * row_width
    mov.l   .L_fn_memcpy_word, r3            ! r3 = &memcpy_word_idx
    sts macl, r12                            ! r12 = product (total tiles)
    add #0x2, r12                            ! r12 += 2 (header words)
    shll r12                                 ! r12 *= 2 (words to bytes)
    extu.w r12, r12                          ! zero-extend to 16 bits
    extu.w r12, r6                           ! r6 = byte_count (memcpy size arg)
    jsr @r3                                  ! memcpy_word_idx(dest=r4, src=r5, size=r6)
    mov r14, r4                              ! r4 = heap dest address (delay slot)
    /* --- Advance both heap cursors by byte_count --- */
    extu.w r12, r5                           ! r5 = byte_count (zero-extended)
    mov.l @r11, r2                           ! r2 = current heap_cursor value
    add r5, r2                               ! r2 = heap_cursor + byte_count
    mov.l r2, @r11                           ! store advanced heap_cursor
    mov.l   .L_heap_cursor_b_ptr, r4         ! r4 = &heap_cursor_B (sym_06063D94)
    mov.l @r4, r3                            ! r3 = current heap_cursor_B value
    add r5, r3                               ! r3 = heap_cursor_B + byte_count
    mov.l r3, @r4                            ! store advanced heap_cursor_B
    bra     .L_write_cmd_entry               ! continue to command table write
    nop                                      ! (delay slot)
    /* --- Unreferenced pool constants (cross-TU targets from prior TU) --- */
    .4byte  0x25E20000                       /* VDP2 VRAM +0x20000 (cache-through) */
    .4byte  dma_memory_transfer              /* DMA transfer function */
.L_fn_memcpy_word:
    .4byte  memcpy_word_idx                  /* CPU word-copy function */
.L_heap_cursor_ptr:
    .4byte  sym_06063D90                     /* heap write cursor */
.L_heap_cursor_b_ptr:
    .4byte  sym_06063D94                     /* secondary heap cursor */
.L_no_data_copy:
    mov r13, r14                             ! r14 = obj_desc ptr (use directly as source)
.L_write_cmd_entry:
    /* --- Write source pointer and flags into command table entry --- */
    .byte   0xD5, 0x1B    /* mov.l .L_pool_0600515C, r5 -- cross-TU: sym_06063750 (cmd table base) */
    .byte   0xD4, 0x1B    /* mov.l .L_pool_06005160, r4 -- cross-TU: sym_06059F10 (mode flag) */
    mov.l @r15, r3                           ! r3 = flags/context word from stack
    mov.l @r4, r2                            ! r2 = mode_flag (current entry index)
    shll2 r2                                 ! r2 *= 4
    shll r2                                  ! r2 *= 2 (total: index * 8)
    add r5, r2                               ! r2 = &cmd_table[mode_flag]
    mov.l r3, @(4, r2)                       ! cmd_table[idx].context = flags word
    mov.l @r4, r3                            ! r3 = mode_flag (reload)
    shll2 r3                                 ! r3 *= 4
    shll r3                                  ! r3 *= 2 (total: index * 8)
    add r5, r3                               ! r3 = &cmd_table[mode_flag]
    mov.l r14, @r3                           ! cmd_table[idx].source_ptr = r14 (heap or obj_desc)
    mov.l @r4, r2                            ! r2 = mode_flag
    add #0x1, r2                             ! r2 = mode_flag + 1
    mov.l r2, @r4                            ! store incremented mode_flag
    /* --- Epilogue: deallocate locals and restore callee-saved regs --- */
    add #0x4, r15                            ! free 4 bytes of locals
    lds.l @r15+, macl                        ! restore macl
    lds.l @r15+, pr                          ! restore return address
    mov.l @r15+, r11                         ! restore r11
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    rts                                      ! return to caller
    mov.l @r15+, r14                         ! restore r14 (delay slot)

    .global sym_0600511E
sym_0600511E:
    mov #0x3, r3                             ! r3 = 0x3 (bitmask for next TU's preamble)
