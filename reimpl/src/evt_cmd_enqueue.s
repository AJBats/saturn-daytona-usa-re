/* evt_cmd_enqueue -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060408B0 - 0x06040954
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Event command enqueue with field extraction and counter adjustment.
 *
 * Enqueues a command from an event struct via cmd_enqueue, validates
 * state via state_field_read, then optionally extracts timing fields
 * from the event data using evt_field_extract (sym_06040220). If the
 * total consumed size (base + span + enqueued) meets or exceeds the
 * capacity threshold, and there is remaining time, the elapsed time
 * (duration - remaining) is subtracted from the caller's counter.
 *
 * Arguments:
 *   r4 = event struct pointer
 *     +0x00  event data pointer (source for field extraction)
 *     +0x04  command queue key (passed to cmd_enqueue)
 *     +0x08  base position / consumed size
 *     +0x10  span / additional size
 *   r5 = size limit (capacity threshold)
 *   r6 = counter pointer (if non-NULL, enables field extraction and
 *         counter adjustment; the long at *r6 is decremented by elapsed)
 *
 * Returns:
 *   r0 = enqueued size from cmd_enqueue on success
 *   r0 = 0 if cmd_enqueue or state_field_read fails
 *
 * Calls: cmd_enqueue, state_field_read, sym_06040220 (evt_field_extract)
 *
 * Stack frame (20 bytes of locals at sp after prologue):
 *   sp+0x00 = enqueued size (cmd_enqueue output, written via r7)
 *   sp+0x04 = remaining time (evt_field_extract output)
 *   sp+0x08 = duration / field[3] (evt_field_extract output via r7)
 *   sp+0x0C = total capacity / field[4] (evt_field_extract output)
 *   sp+0x10 = size_limit (saved from r5)
 */

    .section .text.FUN_060408B0


    .global evt_cmd_enqueue
    .type evt_cmd_enqueue, @function
/* ---------------------------------------------------------------
 * evt_cmd_enqueue
 *   Enqueue event command, extract timing fields, adjust counter.
 * --------------------------------------------------------------- */
evt_cmd_enqueue:
    mov.l r14, @-r15              ! save r14 (callee-saved)
    mov r4, r14                   ! r14 = event struct pointer
    mov.l r13, @-r15              ! save r13 (callee-saved)
    mov r6, r13                   ! r13 = counter pointer (or NULL)
    mov.l r12, @-r15              ! save r12 (callee-saved)
    sts.l pr, @-r15               ! save return address
    add #-0x14, r15               ! allocate 20 bytes for locals
    mov.l r5, @(16, r15)          ! locals[16] = size_limit
    mov.l r6, @-r15               ! push counter_ptr (temp, will reload as r6 for cmd_enqueue)
    mov r15, r7                   ! r7 = sp (will become output buffer ptr)
    mov.l @(20, r15), r6          ! r6 = size_limit (reload from locals[16], adjusted for push)
    mov.l @(16, r14), r5          ! r5 = event_struct[+0x10] (span)
    mov.l   .L_ptr_cmd_enqueue, r3 ! r3 = &cmd_enqueue
    add #0x4, r7                  ! r7 = sp+4 = &locals[0] (output buffer for enqueued size)
    jsr @r3                       ! call cmd_enqueue(queue_key, span, size_limit, &locals[0])
    mov.l @(4, r14), r4           ! r4 = event_struct[+0x04] (queue key, delay slot)
    mov r0, r4                    ! r4 = cmd_enqueue result (0 = success)
    tst r4, r4                    ! did cmd_enqueue succeed?
    bt/s    .L_enqueue_ok         ! if r4 == 0, continue
    add #0x4, r15                 ! pop the temp counter_ptr push (delay slot)
    bra     .L_return_early       ! cmd_enqueue failed
    mov #0x0, r0                  ! return 0 (error, delay slot)
.L_enqueue_ok:
    mov.l   .L_ptr_state_field_read, r3 ! r3 = &state_field_read
    jsr @r3                       ! call state_field_read()
    nop                           ! delay slot
    tst r0, r0                    ! did state_field_read succeed (r0 == 0)?
    bt      .L_state_ok           ! if success, continue
    bra     .L_return_early       ! state_field_read failed
    mov #0x0, r0                  ! return 0 (error, delay slot)
.L_state_ok:
    tst r13, r13                  ! is counter_ptr NULL?
    bt      .L_return_result      ! if NULL, skip field extraction
    mov #0x0, r12                 ! r12 = 0 (used as NULL for output ptrs)
    mov r12, r6                   ! r6 = NULL (field[1] output ptr = skip)
    mov r12, r5                   ! r5 = NULL (field[0] output ptr = skip)
    mov.l r12, @-r15              ! push NULL (byte[0x1D] output = skip)
    mov.l r12, @-r15              ! push NULL (byte[0x1C] output = skip)
    mov r15, r3                   ! r3 = sp (base for offset calculation)
    add #0xC, r3                  ! r3 = sp+0xC = &locals[4] (remaining time output)
    mov.l r3, @-r15               ! push &locals[4] (remaining time output ptr)
    mov r15, r2                   ! r2 = sp (base for offset calculation)
    add #0x18, r2                 ! r2 = sp+0x18 = &locals[12] (field[4] output)
    mov.l r2, @-r15               ! push &locals[12] (field[4] / capacity output ptr)
    mov r15, r7                   ! r7 = sp (base for field[3] output calculation)
    mov.l   .L_ptr_evt_field_extract, r3 ! r3 = &evt_field_extract (sym_06040220)
    add #0x18, r7                 ! r7 = sp+0x18 = &locals[8] (field[3] / duration output)
    jsr @r3                       ! call evt_field_extract(event_data, NULL, NULL, &duration, ...)
    mov.l @r14, r4                ! r4 = event_struct[+0x00] (event data ptr, delay slot)
    add #0x10, r15                ! pop 4 stack args (restore sp to locals base)
    mov r14, r4                   ! r4 = event struct pointer
    mov.l @(12, r15), r3          ! r3 = locals[12] = field[4] (total capacity)
    mov.l @(8, r4), r5            ! r5 = event_struct[+0x08] (base position)
    mov.l @(16, r4), r2           ! r2 = event_struct[+0x10] (span)
    add r2, r5                    ! r5 = base + span
    mov.l @r15, r2                ! r2 = locals[0] = enqueued size (from cmd_enqueue)
    add r2, r5                    ! r5 = base + span + enqueued_size (total consumed)
    cmp/ge r3, r5                 ! is total_consumed >= capacity?
    bf      .L_return_result      ! if not, skip counter adjustment
    mov.l @(4, r15), r0           ! r0 = locals[4] = remaining time
    tst r0, r0                    ! is remaining time zero?
    bt      .L_return_result      ! if zero, skip (no time to subtract)
    mov.l @r15, r3                ! r3 = locals[0] = enqueued size
    cmp/pl r3                     ! is enqueued size > 0?
    bf      .L_return_result      ! if not positive, skip adjustment
    mov.l @(8, r15), r2           ! r2 = locals[8] = duration (field[3])
    mov.l @(4, r15), r3           ! r3 = locals[4] = remaining time
    sub r3, r2                    ! r2 = duration - remaining = elapsed time
    mov.l @r13, r1                ! r1 = *counter_ptr (current counter value)
    sub r2, r1                    ! r1 = counter - elapsed (adjust downward)
    mov.l r1, @r13                ! *counter_ptr = adjusted counter
.L_return_result:
    mov.l @r15, r0                ! r0 = locals[0] = enqueued size (return value)
.L_return_early:
    add #0x14, r15                ! deallocate 20 bytes of locals
    lds.l @r15+, pr               ! restore return address
    mov.l @r15+, r12              ! restore r12
    mov.l @r15+, r13              ! restore r13
    rts                           ! return to caller
    mov.l @r15+, r14              ! restore r14 (delay slot)
.L_ptr_cmd_enqueue:
    .4byte  cmd_enqueue
.L_ptr_state_field_read:
    .4byte  state_field_read
.L_ptr_evt_field_extract:
    .4byte  sym_06040220
