/* ai_orchestrator -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600C74E - 0x0600C7D4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * AI main processing orchestrator -- coordinates all AI behavior for one
 * frame per AI car. Called from ai_physics_main (FUN_0600E906) for each
 * AI opponent.
 *
 * Pipeline steps:
 *   1. track_pos_query      -- find next waypoint, compute approach angle
 *   2. course_correct       -- smooth waypoint tracking / interpolation
 *   3. Speed zone check     -- if track position in [46,59], override
 *                              target heading to 0x4000; else call
 *                              ai_speed_trampoline to compute target speed
 *   4. Copy target heading  -- state[+0x28] -> state[+0x20]
 *   5. Speed boost lookup   -- if sub-mode==0, apply course-specific
 *                              speed adjustment from table (FUN_0600C970)
 *   6. Velocity/friction    -- aerodynamic drag (FUN_0600C928)
 *   7. heading_speed_damping-- update heading with speed-based damping
 *   8. coord_grid_pack      -- pack X/Z position into grid index
 *   9. scene_render_alt     -- update AI car sprite/rendering
 *
 * Persistent registers:
 *   r14 = AI car state struct (dereferenced from sym_0607E940)
 *   r13 = course/track data base (sym_06078680)
 *
 * AI state struct offsets used:
 *   +0x04  = sub-mode flag (0=normal racing, nonzero=special)
 *   +0x10  = X position (world coords)
 *   +0x18  = Z position (world coords)
 *   +0x20  = current heading (yaw angle)
 *   +0x28  = target heading
 *   +0x01EC = track position index (for speed zone checks)
 *
 * Returns: void (updates AI state struct in-place)
 */

    .section .text.FUN_0600C74E


    .global ai_orchestrator
    .type ai_orchestrator, @function
ai_orchestrator:
    mov.l r14, @-r15                       ! save r14 (will hold AI state ptr)
    mov.l r13, @-r15                       ! save r13 (will hold course data base)
    sts.l pr, @-r15                        ! save return address
    add #-0x4, r15                         ! allocate 4 bytes on stack (local var)
    .byte   0xDE, 0x1D    /* mov.l .L_pool_ai_state_ptr, r14 */ ! r14 = &car_state_ptr (sym_0607E940)
    .byte   0xDD, 0x1D    /* mov.l .L_pool_course_data, r13 */  ! r13 = course/track data base (sym_06078680)

/* --- Step 1: Waypoint targeting --- */
    .byte   0xB2, 0xF1    /* bsr 0x0600CD40 (external) */       ! call track_pos_query — find next waypoint
    mov.l @r14, r14                        ! (delay) dereference: r14 = actual AI state struct

/* --- Step 2: Course correction --- */
    .byte   0xB1, 0x9A    /* bsr 0x0600CA96 (external) */       ! call course_correct — smooth waypoint tracking
    mov r13, r4                            ! (delay) r4 = course data base

/* --- Step 3: Speed zone check --- */
    mov #0x2D, r3                          ! r3 = 45 (lower bound of speed zone)
    mov.w   DAT_0600c7be, r0               ! r0 = 0x01EC (offset to track position index)
    mov.l @(r0, r14), r4                   ! r4 = AI_state[+0x01EC] (track position)
    cmp/gt r3, r4                          ! track_pos > 45?
    bf      .L_no_speed_zone               ! if not, use normal speed calculation
    mov #0x3C, r3                          ! r3 = 60 (upper bound of speed zone)
    cmp/ge r3, r4                          ! track_pos >= 60?
    bt      .L_no_speed_zone               ! if so, past the speed zone
    /* Track position is in [46, 59] -- override target heading */
    mov.w   DAT_0600c7c0, r3               ! r3 = 0x4000 (fixed override heading/speed)
    mov.l r3, @(40, r14)                   ! AI_state[+0x28] = 0x4000 (override target)
    bra     .L_after_speed                 ! skip normal speed computation
    nop                                    ! (delay)

.L_no_speed_zone:
    mov r13, r5                            ! r5 = course data base
    .byte   0xB0, 0xA6    /* bsr 0x0600C8CC (external) */       ! call ai_speed_trampoline — compute target speed
    mov r14, r4                            ! (delay) r4 = AI state struct

/* --- Step 4: Copy target heading to current heading --- */
.L_after_speed:
    mov.l @(40, r14), r2                   ! r2 = AI_state[+0x28] (target heading)
    mov.l r2, @(32, r14)                   ! AI_state[+0x20] = target heading (overwrite current)

/* --- Step 5: Conditional speed boost --- */
    mov.l @(4, r14), r0                    ! r0 = AI_state[+0x04] (sub-mode flag)
    tst r0, r0                             ! is sub-mode zero (normal racing)?
    bf      .L_skip_speed_boost            ! if nonzero, skip speed table lookup
    .byte   0xB0, 0xF1    /* bsr 0x0600C970 (external) */       ! call speed_boost_lookup — apply course-specific adjustment
    mov r14, r4                            ! (delay) r4 = AI state struct

/* --- Step 6: Velocity/friction --- */
.L_skip_speed_boost:
    .byte   0xB0, 0xCB    /* bsr 0x0600C928 (external) */       ! call velocity_friction — apply aerodynamic drag
    mov r14, r4                            ! (delay) r4 = AI state struct

/* --- Step 7: Heading/steering update with speed-based damping --- */
    mov r13, r5                            ! r5 = course data base
    .byte   0xB0, 0x1E    /* bsr 0x0600C7D4 (external) */       ! call heading_speed_damping
    mov r14, r4                            ! (delay) r4 = AI state struct

/* --- Step 8: Pack coordinates into grid index --- */
    mov r15, r6                            ! r6 = local stack buffer (output dest)
    mov r14, r5                            ! r5 = AI state struct base
    mov.l r6, @-r15                        ! push r6 (save for step 9 retrieval)
    add #0x10, r5                          ! r5 = &AI_state[+0x10] (X/Z position area)
    mov.l r5, @-r15                        ! push r5 (position ptr for step 9)
    mov.l @(24, r14), r5                   ! r5 = AI_state[+0x18] (Z position)
    .byte   0xD3, 0x07    /* mov.l .L_pool_coord_grid_pack, r3 */ ! r3 = coord_grid_pack (sym_06006838)
    jsr @r3                                ! r0 = coord_grid_pack(X, Z)
    mov.l @(16, r14), r4                   ! (delay) r4 = AI_state[+0x10] (X position)

/* --- Step 9: Rendering/sprite update --- */
    mov r0, r4                             ! r4 = grid index (result of coord_grid_pack)
    mov.l @r15+, r5                        ! r5 = &AI_state[+0x10] (car position, popped)
    .byte   0xD3, 0x06    /* mov.l .L_pool_scene_render_alt, r3 */ ! r3 = scene_render_alt
    jsr @r3                                ! update AI car rendering/sprite
    mov.l @r15+, r6                        ! (delay) r6 = local stack buffer (popped)

/* --- Epilogue --- */
    add #0x4, r15                          ! deallocate local var
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return
    mov.l @r15+, r14                       ! (delay) restore r14

    .global DAT_0600c7be
DAT_0600c7be:
    .2byte  0x01EC                         /* offset to track position index in AI state */

    .global DAT_0600c7c0
DAT_0600c7c0:
    .2byte  0x4000                         /* fixed override heading for speed zone */
    .2byte  0xFFFF                         /* alignment padding */
.L_pool_coord_grid_pack:
    .4byte  sym_06006838                   /* coord_grid_pack — terrain elevation query */
.L_pool_scene_render_alt:
    .4byte  scene_render_alt               /* AI car sprite/render update */
.L_pool_ai_state_ptr:
    .4byte  sym_0607E940                   /* pointer to current AI car state struct */
.L_pool_course_data:
    .4byte  sym_06078680                   /* course/track data base */
