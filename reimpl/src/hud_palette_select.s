/* hud_palette_select -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603FCE4 - 0x0603FD40
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Selects the palette entry count for HUD rendering and dispatches
 * the palette lookup callback.
 *
 * If desc->phase_counter <= 1 (single-phase mode), uses the full
 * element_a data size directly. Otherwise (multi-phase), computes
 * the remaining data in element_a (data_size - applied_offset),
 * queries the available count from elem_b via cmd_dispatch_slot2,
 * and takes the smaller of the two as the batch size.
 *
 * Finally, calls cmd_dispatch_slot4 to perform the actual palette
 * lookup/selection with the chosen batch size, storing the result
 * in desc->element_c.
 *
 * Called from attract_display_orch phase 1.
 *
 * Args:
 *   r4 = desc      -- palette descriptor struct pointer
 *   r5 = head      -- display list head (unused here, passed through)
 *   r6 = elem_b    -- element_b handle (passed to cmd_dispatch_slot2/slot4)
 *
 * Descriptor struct offsets used:
 *   +4   element_a         -- palette element pointer
 *   +12  element_c         -- result of palette lookup (written on return)
 *   +28  applied_offset    -- current offset into element_a data
 *   +48  phase_counter     -- number of sub-phases for gradual application
 *
 * Calls:
 *   sym_0603F8EE (cmd_dispatch_slot2) -- queries available count from elem_b
 *   sym_0603F90E (cmd_dispatch_slot4) -- palette lookup callback
 *
 * Returns:
 *   desc->element_c is set to the palette lookup result (r0 from slot4)
 */

    .section .text.FUN_0603FCE4


    .global hud_palette_select
    .type hud_palette_select, @function
hud_palette_select:
    mov.l r14, @-r15                    ! save r14
    mov #0x1, r2                        ! r2 = 1 (threshold for multi-phase check)
    mov.l r13, @-r15                    ! save r13
    mov r4, r14                         ! r14 = desc (palette descriptor)
    mov.l r12, @-r15                    ! save r12
    sts.l pr, @-r15                     ! save return address
    mov.l @(48, r14), r3                ! r3 = desc->phase_counter
    cmp/gt r2, r3                       ! phase_counter > 1?
    bf/s    .L_multi_phase              ! if not, go to multi-phase path
    mov r6, r12                         ! r12 = elem_b handle (delay slot)
    mov.l @(4, r14), r5                 ! r5 = desc->element_a
    bra     .L_do_palette_lookup        ! single-phase: use full data size directly
    mov.l @(8, r5), r5                  ! r5 = element_a->data_size (delay slot)
.L_multi_phase:
    mov.l @(4, r14), r13                ! r13 = desc->element_a
    mov.l @(28, r14), r3                ! r3 = desc->applied_offset
    mov.l @(8, r13), r13                ! r13 = element_a->data_size
    sub r3, r13                         ! r13 = data_size - applied_offset = remaining_data
    mov.l   .L_pool_dispatch_slot2, r3  ! r3 = &cmd_dispatch_slot2
    jsr @r3                             ! r0 = slot2_callback(elem_b) — query available count
    mov r12, r4                         ! r4 = elem_b (delay slot arg)
    cmp/ge r0, r13                      ! remaining_data >= available_count?
    bt      .L_clamp_to_available       ! yes — use available_count (smaller)
    bra     .L_do_palette_lookup        ! no — remaining_data is smaller, use it
    mov r13, r5                         ! r5 = remaining_data as batch size (delay slot)
.L_clamp_to_available:
    mov.l   .L_pool_dispatch_slot2, r3  ! r3 = &cmd_dispatch_slot2
    jsr @r3                             ! r0 = slot2_callback(elem_b) — re-query available count
    mov r12, r4                         ! r4 = elem_b (delay slot arg)
    mov r0, r5                          ! r5 = available_count (clamped batch size)
.L_do_palette_lookup:
    mov.l   .L_pool_dispatch_slot4, r3  ! r3 = &cmd_dispatch_slot4
    jsr @r3                             ! r0 = slot4_callback(elem_b, batch_size) — palette lookup
    mov r12, r4                         ! r4 = elem_b (delay slot arg)
    mov.l r0, @(12, r14)                ! desc->element_c = palette lookup result
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .2byte  0x000B
    .4byte  0xE001FFFF
    .4byte  sym_0603F900
.L_pool_dispatch_slot2:
    .4byte  sym_0603F8EE                ! pool: cmd_dispatch_slot2 — virtual dispatch to struct offset +8
.L_pool_dispatch_slot4:
    .4byte  sym_0603F90E                ! pool: cmd_dispatch_slot4 — virtual dispatch to struct offset +16
