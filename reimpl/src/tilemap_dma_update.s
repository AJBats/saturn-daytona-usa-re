/* tilemap_dma_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036E90 - 0x06036F0C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ============================================================
 * tilemap_dma_update — Copy tilemap/palette words to VDP2 VRAM
 * ============================================================
 *
 * Called to DMA-transfer tilemap or palette data into VDP2 address
 * space via the word_copy_helper (sym_06038A48).
 *
 * Parameters:
 *   r4 = VDP2 destination address (e.g., CRAM 0x25F00FFE)
 *   r5 = mode/count: 1 = single-word unconditional copy,
 *        or screen_height value (e.g., 224) for multi-word copy
 *   r6 = pointer to source data in work RAM
 *
 * Behavior:
 *   - If mode == 1 (single word), always proceeds with copy.
 *   - If mode != 1, compares against current screen_height; bails
 *     out if they don't match (stale update for wrong resolution).
 *   - Masks the destination to 19-bit VDP2 VRAM offset, ORs with
 *     VDP2 VRAM base 0x25E00000, and calls word_copy_helper.
 *   - Updates the scene transform struct at offset +60 (rotation
 *     parameter control word): stores the masked dest >> 1, and
 *     if mode != 1, sets the sign bit (0x80000000) as a flag.
 *   - If the scene-ready flag (sym_060635AC) is zero, sets it to 1
 *     to signal that scene data is pending.
 */

    .section .text.FUN_06036E90


    .global tilemap_dma_update
    .type tilemap_dma_update, @function
tilemap_dma_update:
    mov.l r14, @-r15                    ! save r14 on stack (callee-saved)
    mov.l r13, @-r15                    ! save r13 on stack (callee-saved)
    sts.l pr, @-r15                     ! save return address on stack
    mov r5, r13                         ! r13 = mode (preserve across calls)
    add #-0x4, r15                      ! allocate 4 bytes of stack for local
    extu.w r13, r5                      ! r5 = mode zero-extended to 16 bits
    mov.l r6, @r15                      ! store source pointer in local [sp+0]
    mov r5, r0                          ! r0 = mode (for cmp/eq immediate)
    cmp/eq #0x1, r0                     ! is mode == 1 (single-word copy)?
    bt      .L_mode_accepted            ! yes — skip screen height check
    mov.l   .L_screen_height_ptr, r2    ! r2 = &screen_height (sym_060635B0)
    mov.w @r2, r2                       ! r2 = current screen height (e.g., 224)
    extu.w r2, r2                       ! zero-extend to 32 bits
    cmp/eq r2, r5                       ! does mode match screen height?
    bf      .L_epilog                   ! no match — bail out, wrong resolution
.L_mode_accepted:
    extu.w r13, r6                      ! r6 = mode (used as byte count for copy)
    mov.l   .L_scene_transform_ptr, r14 ! r14 = &scene_transform_struct (sym_060A3DF8)
    mov.l   .L_vdp2_offset_mask, r2     ! r2 = 0x0007FFFF (19-bit VRAM offset mask)
    shll r6                             ! r6 = mode * 2 (byte count for word_copy_helper)
    and r2, r4                          ! r4 = dest & 0x7FFFF (isolate VRAM offset)
    mov.l r4, @(60, r14)                ! transform[+60] = masked VRAM offset (temp store)
    mov.l   .L_vdp2_vram_base, r3      ! r3 = 0x25E00000 (VDP2 VRAM base address)
    or r3, r4                           ! r4 = VDP2 base | VRAM offset (full dest address)
    mov.l   .L_word_copy_helper, r3     ! r3 = &word_copy_helper (sym_06038A48)
    jsr @r3                             ! word_copy_helper(r4=dest, r5=src, r6=byte_count)
    mov.l @r15, r5                      ! (delay) r5 = source pointer from local [sp+0]
    mov.l @(60, r14), r2                ! r2 = transform[+60] (masked VRAM offset)
    extu.w r13, r0                      ! r0 = mode (for cmp/eq immediate)
    shlr r2                             ! r2 = offset >> 1 (convert to word address)
    cmp/eq #0x1, r0                     ! is mode == 1?
    bt/s    .L_check_ready_flag         ! yes — skip sign bit, go check ready flag
    mov.l r2, @(60, r14)                ! (delay) transform[+60] = word address
    mov.l   .L_sign_bit, r2             ! r2 = 0x80000000 (sign bit / multi-word flag)
    mov.l @(60, r14), r3                ! r3 = transform[+60] (current value)
    or r2, r3                           ! r3 = value | 0x80000000 (set sign bit)
    mov.l r3, @(60, r14)                ! transform[+60] = value with sign bit set
.L_check_ready_flag:
    mov.l   .L_scene_ready_flag_ptr, r4 ! r4 = &scene_ready_flag (sym_060635AC)
    mov.w @r4, r2                       ! r2 = current scene_ready_flag value
    extu.w r2, r2                       ! zero-extend to 32 bits
    tst r2, r2                          ! is scene_ready_flag == 0?
    bf      .L_epilog                   ! no (already set) — skip to epilog
    mov #0x1, r3                        ! r3 = 1 (mark scene data pending)
    mov.w r3, @r4                       ! scene_ready_flag = 1
.L_epilog:
    add #0x4, r15                       ! free 4 bytes of stack local
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14
.L_screen_height_ptr:
    .4byte  sym_060635B0                /* &screen_height (16-bit, init=224) */
.L_scene_transform_ptr:
    .4byte  sym_060A3DF8                /* &scene_transform_struct (rotation params, 64 bytes) */
.L_vdp2_offset_mask:
    .4byte  0x0007FFFF                  /* 19-bit VDP2 VRAM offset mask */
.L_vdp2_vram_base:
    .4byte  0x25E00000                  /* VDP2 VRAM +0x00000 */
.L_word_copy_helper:
    .4byte  sym_06038A48                /* word_copy_helper (copies r6 bytes as words) */
.L_sign_bit:
    .4byte  0x80000000                  /* sign bit / multi-word transfer flag */
.L_scene_ready_flag_ptr:
    .4byte  sym_060635AC                /* scene-ready flag (0=idle, 1=pending) */
