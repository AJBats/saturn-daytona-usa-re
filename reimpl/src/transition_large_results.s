/* transition_large_results -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600FB78 - 0x0600FD54
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Results screen transition setup for the large (full-screen) results display.
 * Handles both 1P and 2P modes with different rendering paths:
 *
 *   1P path: anim_ui_transition(1) + dispatch by timer mode
 *   2P path: render car stat labels ("ACCELERATION", "GRIP"), car name/subtitle
 *            strings (looked up by car index + transmission type), then dispatch
 *
 * Car name selection logic (2P, car index > 9):
 *   - Index 10-11: render subtitle only (AT vs MT variant)
 *   - Index 12+:   render full car name + subtitle (AT vs MT variant)
 *   - "DAYTONA UMA2" / "   HORSE 2  " = AT variants
 *   - "DAYTONA UMA " / "   HORSE    " = MT variants
 *
 * Common exit: read input bitmask from game status word, check start button
 * (bit 0x0800), set start_pressed_flag, then tail-call dispatch via status[+2].
 *
 * Persistent registers:
 *   r11 = game status base (sym_06063D98)
 *   r10 = car name Y offset (0x0090)
 *   r12 = car name X offset (0x07A2)
 *   r13 = text_render function (sym_060284AE)
 *   r14 = display_channel_config function (sym_060283E0)
 *   r9  = display slot A pointer (sym_06078868)
 *   r8  = stat color code (0x2000)
 */

    .section .text.FUN_0600FB78


    .global transition_large_results
    .type transition_large_results, @function
transition_large_results:
    mov.l r14, @-r15               ! save callee-saved registers
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x8, r15                 ! allocate 0x8 bytes stack space
    mov.l   .L_game_status_base, r11  ! r11 = game status struct base (persistent)
    mov.l   .L_fn_graphics_mode, r3
    jsr @r3                        ! graphics_mode_setup()
    nop
    mov.l   .L_fn_dual_hud_dispatch, r3
    jsr @r3                        ! dual_hud_dispatch()
    nop
    mov.l   .L_two_player_flag, r0
    mov.b @r0, r0                  ! r0 = 2-player mode flag (byte)
    tst r0, r0
    bf      .L_two_player_active   ! if 2P flag set → render car stats
    bra     .L_single_player_path  ! else → 1P animated transition
    nop
.L_two_player_active:                  ! --- 2P path: render car stat strings ---
    mov.w   .L_name_y_offset, r10  ! r10 = 0x0090 (Y position for car name)
    mov.w   .L_name_x_offset, r12  ! r12 = 0x07A2 (X position for car name)
    mov.l   .L_fn_text_render, r13 ! r13 = text_render fn (persistent)
    mov.l   .L_fn_display_channel_config, r14  ! r14 = display_channel_config fn (persistent)
    mov.l   .L_split_display_slot, r0
    mov.l @r0, r0                  ! r0 = split-screen display slot value
    tst r0, r0
    bt      .L_render_car_stats    ! if slot == 0 → render full car stats
    bra     .L_render_split_defaults  ! else → render default tile labels
    nop
.L_render_car_stats:                   ! --- render stat labels + car-specific names ---
    mov.w   .L_stat_color_code, r8 ! r8 = 0x2000 (color/attribute code, persistent)
    mov.l   .L_str_acceleration, r7  ! r7 → "ACCELERATION" string
    mov.w   .L_accel_x_pos, r5    ! r5 = 0x0686 (X position)
    mov r8, r6                     ! r6 = color code
    jsr @r14                       ! display_channel_config(0xC, accel_x, color, "ACCELERATION")
    mov #0xC, r4
    mov.l   .L_display_slot_a, r9  ! r9 → display slot A (persistent)
    mov r8, r6                     ! r6 = color code
    mov.w   .L_car_name_a_x_pos, r5  ! r5 = 0x06A0 (X position)
    mov.l   .L_car_name_table_a, r3  ! r3 → car name lookup table A
    mov.l @r9, r7                  ! r7 = car index from display slot
    shll2 r7                       ! r7 *= 4 (index → offset)
    add r3, r7                     ! r7 → table_a[car_index]
    mov.l @r7, r7                  ! r7 = car name string A pointer
    jsr @r14                       ! display_channel_config(0xC, name_a_x, color, car_name_a)
    mov #0xC, r4
    mov.l   .L_str_grip, r7       ! r7 → "GRIP" string
    mov r8, r6                     ! r6 = color code
    mov.w   .L_grip_x_pos, r5     ! r5 = 0x0706 (X position)
    jsr @r14                       ! display_channel_config(0xC, grip_x, color, "GRIP")
    mov #0xC, r4
    mov r8, r6                     ! r6 = color code
    mov.w   .L_car_name_b_x_pos, r5  ! r5 = 0x0720 (X position)
    mov.l @r9, r7                  ! r7 = car index from display slot
    mov.l   .L_car_name_table_b, r3  ! r3 → car name lookup table B
    shll2 r7                       ! r7 *= 4 (index → offset)
    add r3, r7                     ! r7 → table_b[car_index]
    mov.l @r7, r7                  ! r7 = car name string B pointer
    jsr @r14                       ! display_channel_config(0xC, name_b_x, color, car_name_b)
    mov #0xC, r4
    mov.l @r9, r2                  ! r2 = car index
    mov #0x9, r3
    cmp/hi r3, r2                  ! car_index > 9?
    bf      .L_check_timer_mode    ! if index <= 9 → skip car name rendering
    mov #0xB, r2                   ! --- car index >= 10: render car name/subtitle ---
    mov.l   .L_transmission_flag, r4  ! r4 → transmission type flag
    mov.l @r9, r3                  ! r3 = car index
    cmp/hi r2, r3                  ! car_index > 11?
    bf      .L_check_trans_subtitle  ! if index 10-11 → subtitle only
    mov.l @r4, r0                  ! --- car index >= 12: render full car name ---
    cmp/eq #0x1, r0                ! transmission == AT?
    bf      .L_use_mt_car_name     ! if not AT → use MT name
    mov.l   .L_str_car_at_name, r7  ! r7 → "DAYTONA UMA2" (AT)
    bra     .L_render_car_name
    nop
.L_use_mt_car_name:
    mov.l   .L_str_car_mt_name, r7  ! r7 → "   HORSE 2  " (MT)
.L_render_car_name:
    mov r10, r6                    ! r6 = Y offset (0x0090)
    mov r12, r5                    ! r5 = X offset (0x07A2)
    jsr @r13                       ! text_render(0xC, x, y, car_name_str)
    mov #0xC, r4
    bra     .L_check_timer_mode
    nop
.L_check_trans_subtitle:           ! --- car index 10-11: subtitle only ---
    mov.l @r4, r0                  ! r0 = transmission type
    cmp/eq #0x1, r0                ! transmission == AT?
    bf      .L_use_mt_car_sub      ! if not AT → use MT subtitle
    mov.l   .L_str_car_at_sub, r7  ! r7 → "DAYTONA UMA " (AT subtitle)
    bra     .L_render_car_subtitle
    nop
.L_name_y_offset:                      ! --- constant pool (16-bit) ---
    .2byte  0x0090                 ! car name display Y position
.L_name_x_offset:
    .2byte  0x07A2                 ! car name display X position
.L_stat_color_code:
    .2byte  0x2000                 ! text color/attribute code for stat labels
.L_accel_x_pos:
    .2byte  0x0686                 ! "ACCELERATION" label X position
.L_car_name_a_x_pos:
    .2byte  0x06A0                 ! car name row A X position
.L_grip_x_pos:
    .2byte  0x0706                 ! "GRIP" label X position
.L_car_name_b_x_pos:
    .2byte  0x0720                 ! car name row B X position
    .2byte  0xFFFF                 ! alignment padding
.L_game_status_base:                   ! --- constant pool (32-bit) ---
    .4byte  sym_06063D98           ! game status struct base pointer
.L_fn_graphics_mode:
    .4byte  graphics_mode_setup    ! graphics mode configuration function
.L_fn_dual_hud_dispatch:
    .4byte  sym_06011EB4           ! dual HUD render dispatcher
.L_two_player_flag:
    .4byte  sym_06085FF4           ! 2-player mode flag (byte)
.L_fn_text_render:
    .4byte  sym_060284AE           ! text string renderer function
.L_fn_display_channel_config:
    .4byte  sym_060283E0           ! display channel configuration function
.L_split_display_slot:
    .4byte  sym_0607889C           ! split-screen display slot (dword)
.L_str_acceleration:
    .4byte  sym_06044750           ! → "ACCELERATION" string
.L_display_slot_a:
    .4byte  sym_06078868           ! display slot A / car index (dword)
.L_car_name_table_a:
    .4byte  sym_0605AB28           ! car name lookup table A (ptr array)
.L_str_grip:
    .4byte  sym_0604475D           ! → "GRIP" string
.L_car_name_table_b:
    .4byte  sym_0605AB60           ! car name lookup table B (ptr array)
.L_transmission_flag:
    .4byte  sym_06078644           ! transmission type flag (1=AT, 0=MT)
.L_str_car_at_name:
    .4byte  sym_06044878           ! → "DAYTONA UMA2" (AT car name)
.L_str_car_mt_name:
    .4byte  sym_06044888           ! → "   HORSE 2  " (MT car name)
.L_str_car_at_sub:
    .4byte  sym_06044898           ! → "DAYTONA UMA " (AT car subtitle)
.L_use_mt_car_sub:
    mov.l   .L_str_car_mt_sub, r7 ! r7 → "   HORSE    " (MT subtitle)
.L_render_car_subtitle:
    mov r10, r6                    ! r6 = Y offset (0x0090)
    mov r12, r5                    ! r5 = X offset (0x07A2)
    jsr @r13                       ! text_render(0xC, x, y, car_sub_str)
    mov #0xC, r4
.L_check_timer_mode:                   ! --- dispatch by game status timer mode ---
    mov.w @(6, r11), r0           ! r0 = status[+6] (timer mode word)
    extu.w r0, r0                 ! zero-extend to 32-bit
    cmp/eq #0x10, r0              ! timer mode == 0x10?
    bf      .L_not_timer_mode     ! if not → use alternate dispatch
    mov.l   .L_anim_countdown, r4 ! r4 → animation countdown variable
    mov.l @r4, r0                 ! r0 = countdown value
    tst r0, r0
    bf      .L_decrement_countdown  ! if countdown > 0 → decrement
    .byte   0xB5, 0x63    /* bsr 0x06010760 (external) */  ! countdown == 0: call timer-expired handler
    nop
    bra     .L_check_start_button
    nop
.L_decrement_countdown:
    mov.l @r4, r2                 ! r2 = countdown value
    add #-0x1, r2                 ! r2--
    bra     .L_check_start_button
    mov.l r2, @r4                 ! store decremented countdown (delay slot)
.L_not_timer_mode:
    mov.w @(2, r11), r0           ! r0 = status[+2] (dispatch parameter)
    .byte   0xB4, 0x1A    /* bsr 0x060104E0 (external) */  ! call alternate dispatch handler
    mov r0, r4                    ! r4 = dispatch param (delay slot)
    bra     .L_check_start_button
    nop
.L_render_split_defaults:              ! --- split-screen: render default tile labels ---
    mov.l   .L_str_default_tile_a, r2  ! r2 → default tile data A
    mov #0x0, r6                   ! r6 = 0 (no color attribute)
    mov.l r2, @r15                 ! save tile ptr on stack
    mov r2, r7                     ! r7 → tile data A
    mov.w   .L_alt_accel_x_pos, r5  ! r5 = 0x0686 (X position)
    jsr @r14                       ! display_channel_config(0xC, x, 0, tile_a)
    mov #0xC, r4
    mov #0x0, r6                   ! r6 = 0 (no color attribute)
    mov.w   .L_alt_grip_x_pos, r5 ! r5 = 0x0706 (X position)
    mov.l @r15, r7                 ! r7 → tile data A (reload from stack)
    jsr @r14                       ! display_channel_config(0xC, x, 0, tile_a)
    mov #0xC, r4
    mov.l   .L_str_default_tile_b, r7  ! r7 → default tile data B
    mov r10, r6                    ! r6 = Y offset (0x0090)
    mov r12, r5                    ! r5 = X offset (0x07A2)
    jsr @r13                       ! text_render(0xC, x, y, tile_b)
    mov #0xC, r4
    bra     .L_check_start_button
    nop
.L_single_player_path:                 ! --- 1P path: animate transition + dispatch ---
    mov.l   .L_fn_anim_transition, r3
    jsr @r3                        ! anim_ui_transition(1)
    mov #0x1, r4                   ! r4 = 1 (delay slot)
    mov.w @(6, r11), r0           ! r0 = status[+6] (timer mode word)
    extu.w r0, r0                 ! zero-extend to 32-bit
    cmp/eq #0x10, r0              ! timer mode == 0x10?
    bf      .L_sp_not_timer_mode  ! if not → use alternate dispatch
    .byte   0xB3, 0xC4    /* bsr 0x06010470 (external) */  ! call 1P timer dispatch
    nop
    bra     .L_check_start_button
    nop
.L_sp_not_timer_mode:
    mov.w @(2, r11), r0           ! r0 = status[+2] (dispatch parameter)
    .byte   0xB3, 0x63    /* bsr 0x060103B8 (external) */  ! call 1P alternate dispatch
    mov r0, r4                    ! r4 = dispatch param (delay slot)
.L_check_start_button:                 ! --- common exit: check start button input ---
    mov r11, r2                    ! r2 = game status base
    mov.l r2, @r15                 ! save status base on stack
    mov r2, r3
    mov.w @r3, r2                  ! r2 = status[+0] (input bitmask word)
    mov r2, r0
    mov.w r0, @(4, r15)           ! store input word at sp+4
    mov.w @(4, r15), r0           ! reload input word
    mov.w   .L_button_start_mask, r2  ! r2 = 0x0800 (start button bit)
    mov r0, r3
    extu.w r3, r3                 ! zero-extend input word
    and r2, r3                     ! r3 = input & 0x0800
    tst r3, r3
    bt      .L_clear_start_flag   ! if start not pressed → clear flag
    mov #0x1, r3                   ! start pressed → set flag = 1
    mov.l   .L_start_pressed_flag, r2
    mov.l r3, @r2                  ! *start_pressed_flag = 1
    bra     .L_epilogue
    nop
.L_clear_start_flag:
    mov #0x0, r3                   ! start not pressed → clear flag = 0
    mov.l   .L_start_pressed_flag, r2
    mov.l r3, @r2                  ! *start_pressed_flag = 0
.L_epilogue:                           ! --- restore regs + tail call ---
    mov.l @r15, r4                 ! r4 = game status base (from stack)
    add #0x2, r4                   ! r4 → status[+2]
    mov.w @r4, r4                  ! r4 = status[+2] (tail-call parameter)
    add #0x8, r15                  ! deallocate stack space
    lds.l @r15+, pr                ! restore return address
    mov.l @r15+, r8                ! restore callee-saved registers
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    .byte   0xA6, 0xB7    /* bra 0x06010AA4 (external) */  ! tail-call state dispatch
    mov.l @r15+, r14              ! restore r14 (delay slot)
.L_alt_accel_x_pos:                    ! --- constant pool 2 (16-bit) ---
    .2byte  0x0686                 ! split-screen "ACCELERATION" X position
.L_alt_grip_x_pos:
    .2byte  0x0706                 ! split-screen "GRIP" X position
.L_button_start_mask:
    .2byte  0x0800                 ! start button bitmask (bit 11)
.L_str_car_mt_sub:                     ! --- constant pool 2 (32-bit) ---
    .4byte  sym_060448A8           ! → "   HORSE    " (MT car subtitle)
.L_anim_countdown:
    .4byte  sym_0605AA9C           ! animation countdown timer (dword)
.L_str_default_tile_a:
    .4byte  sym_0605ACE1           ! default tile data A (split-screen)
.L_str_default_tile_b:
    .4byte  sym_0605ACE3           ! default tile data B (split-screen)
.L_fn_anim_transition:
    .4byte  anim_ui_transition     ! animated UI transition function
.L_start_pressed_flag:
    .4byte  sym_0607EAE0           ! start button pressed flag (dword)
