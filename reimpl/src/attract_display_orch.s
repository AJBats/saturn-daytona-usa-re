/* attract_display_orch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603FAE4 - 0x0603FC60
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Attract mode display sequence orchestrator.
 *
 * Manages a multi-phase display pipeline for attract mode elements
 * (logo, title, demo replay). Operates on a display descriptor struct
 * passed via r14, using a state machine encoded in byte [r14+0x34]:
 *   - Bit 7 (0x80): "ready" flag — set when element is initialized
 *   - Bits 2:0: current phase (0-5)
 *
 * Phase progression:
 *   Phase 0: Apply initial VBlank palette (vblank_palette_apply)
 *   Phase 1: Select HUD palette (hud_palette_select)
 *   Phase 2: Execute custom display callback via desc->slot_9
 *   Phase 3: Execute advance callback via desc->slot_11
 *   Phase 4: Frame tick loop — check element completion, accumulate time
 *   Phase 5: Sequence complete
 *
 * Descriptor struct fields (from r14):
 *   [+0x00] r10: display list head pointer
 *   [+0x04]    : element A handle (palette source, NULL = not loaded)
 *   [+0x08] r9 : element B handle (secondary element)
 *   [+0x0C]    : element C handle (palette target, NULL = not loaded)
 *   [+0x14]    : max progress threshold
 *   [+0x18]    : accumulated frame time
 *   [+0x1C]    : frame delta from element A[+0x08]
 *   [+0x20]    : data pointer for callbacks
 *   [+0x24]    : callback slot 9 (function pointer for display)
 *   [+0x2C]    : callback slot 11 (function pointer for advance)
 *   [+0x30]    : data pointer for callback dispatch
 *   [+0x34]    : state byte (bit 7 = ready, bits 2:0 = phase)
 *
 * Register conventions on entry (set by caller's register save):
 *   r8  = output status pointer
 *   r9  = element B handle (also loaded from [r14+0x08])
 *   r10 = display list head (also loaded from [r14+0x00])
 *   r11 = zero (used as NULL and comparison value)
 *   r12 = completion flag (0 = incomplete, 1 = complete)
 *   r13 = bitmask constant (loaded as 0x0080)
 *   r14 = descriptor struct pointer
 *
 * Return value (via r0):
 *   Phase bits from state byte (low 7 bits, ready flag cleared)
 *   Written to *r8 as completion status
 */

    .section .text.FUN_0603FAE4


    .global attract_display_orch
    .type attract_display_orch, @function
attract_display_orch:
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes local stack space
    mov.w   DAT_0603fb22, r13           ! r13 = 0x0080 (ready flag bitmask)
    mov.l @r14, r10                     ! r10 = desc->display_list_head
    mov.l @(20, r14), r3                ! r3 = desc->max_progress
    cmp/gt r11, r3                      ! max_progress > 0 (r11=0)?
    bt/s    .L_check_ready_flag         ! yes — element has work to do
    mov.l @(8, r14), r9                 ! r9 = desc->element_b (delay slot)
    mov.l r12, @r8                      ! *status_out = completion_flag (pass through)
    bra     .L_epilogue                 ! skip processing — no work threshold
    mov #0x5, r0                        ! r0 = 5 (phase "done") for return
.L_check_ready_flag:
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r3                ! r3 = desc->state_byte
    extu.b r3, r3                       ! zero-extend to 32 bits
    and r13, r3                         ! isolate bit 7 (ready flag)
    cmp/eq r13, r3                      ! ready flag set?
    bt      .L_ready_dispatch           ! yes — proceed to state dispatch
    mov.l r12, @r8                      ! *status_out = completion_flag (not ready)
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    mov.w   DAT_0603fb24, r3            ! r3 = 0xFF7F (clear ready flag mask)
    bra     .L_epilogue                 ! return with ready flag cleared
    and r3, r0                          ! r0 = state_byte & ~0x80 (delay slot)
.L_ready_dispatch:
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    mov.w   DAT_0603fb24, r3            ! r3 = 0xFF7F (clear ready flag mask)
    and r3, r0                          ! r0 = phase = state_byte & ~0x80
    bra     .L_state_dispatch           ! jump to state machine dispatcher
    nop

    .global DAT_0603fb22
DAT_0603fb22:
    .2byte  0x0080                      ! ready flag bitmask (bit 7)

    .global DAT_0603fb24
DAT_0603fb24:
    .2byte  0xFF7F                      ! inverse of ready flag (~0x0080)
    .2byte  0xFFFF                      ! padding / alignment
    .4byte  sym_0603F91C                ! fn_dispatch_slot5 (callback dispatcher)
.L_phase0_palette_apply:
    mov r9, r6                          ! arg3 = element_b handle
    mov r10, r5                         ! arg2 = display_list_head
    .byte   0xB0, 0x96    /* bsr 0x0603FC60 (external) */  ! call vblank_palette_apply(desc, head, elem_b)
    mov r14, r4                         ! arg1 = descriptor pointer (delay slot)
    mov.l @(4, r14), r0                 ! r0 = desc->element_a
    tst r0, r0                          ! element_a == NULL?
    bf      .L_phase0_set_flag          ! non-NULL — palette loaded, set phase flag
    bra     .L_write_status_return      ! NULL — not yet loaded, return early
    nop
.L_phase0_set_flag:
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    and r13, r0                         ! keep only ready flag (bit 7)
    or #0x1, r0                         ! set phase = 1
    extu.b r0, r0                       ! zero-extend
    mov #0x34, r1                       ! offset 0x34
    add r14, r1                         ! r1 = &desc->state_byte
    mov.b r0, @r1                       ! desc->state_byte = (ready_flag | 1)
.L_phase1_hud_palette:
    mov r9, r6                          ! arg3 = element_b handle
    mov r10, r5                         ! arg2 = display_list_head
    .byte   0xB0, 0xC6    /* bsr 0x0603FCE4 (external) */  ! call hud_palette_select(desc, head, elem_b)
    mov r14, r4                         ! arg1 = descriptor pointer (delay slot)
    mov.l @(12, r14), r0                ! r0 = desc->element_c
    tst r0, r0                          ! element_c == NULL?
    bf      .L_phase1_set_flag          ! non-NULL — palette selected, set phase flag
    bra     .L_write_status_return      ! NULL — not yet loaded, return early
    nop
.L_phase1_set_flag:
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    and r13, r0                         ! keep only ready flag (bit 7)
    or #0x2, r0                         ! set phase = 2
    extu.b r0, r0                       ! zero-extend
    mov #0x34, r1                       ! offset 0x34
    add r14, r1                         ! r1 = &desc->state_byte
    mov.b r0, @r1                       ! desc->state_byte = (ready_flag | 2)
.L_phase2_display_callback:
    mov.l r14, @r15                     ! save descriptor pointer on stack
    mov r14, r3                         ! r3 = descriptor (for field access)
    mov r14, r4                         ! r4 = descriptor (as callback arg)
    mov.l @(36, r3), r3                 ! r3 = desc->callback_slot_9 (display fn)
    jsr @r3                             ! call display callback
    mov.l @(32, r4), r4                 ! r4 = desc->data_ptr (delay slot)
    mov r0, r4                          ! r4 = callback result
    tst r4, r4                          ! result == 0?
    bf      .L_phase2_set_flag          ! non-zero — display ready, advance phase
    bra     .L_write_status_return      ! zero — not ready, return early
    nop
.L_phase2_set_flag:
    .byte   0xB2, 0x07    /* bsr 0x0603FF9C (external) */  ! call attract_display_main(desc)
    mov r14, r4                         ! arg1 = descriptor pointer (delay slot)
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    and r13, r0                         ! keep only ready flag (bit 7)
    or #0x3, r0                         ! set phase = 3
    extu.b r0, r0                       ! zero-extend
    mov #0x34, r1                       ! offset 0x34
    add r14, r1                         ! r1 = &desc->state_byte
    mov.b r0, @r1                       ! desc->state_byte = (ready_flag | 3)
.L_phase3_advance_callback:
    mov.l r14, @r15                     ! save descriptor pointer on stack
    mov r14, r3                         ! r3 = descriptor (for field access)
    mov r14, r4                         ! r4 = descriptor (as callback arg)
    mov.l @(44, r3), r3                 ! r3 = desc->callback_slot_11 (advance fn)
    jsr @r3                             ! call advance callback
    mov.l @(32, r4), r4                 ! r4 = desc->data_ptr (delay slot)
    mov r0, r4                          ! r4 = callback result
    cmp/pl r4                           ! result > 0?
    bf      .L_phase3_set_complete      ! result <= 0 — advance done, mark complete
    bra     .L_write_status_return      ! result > 0 — still advancing, return early
    nop
.L_phase3_set_complete:
    mov #0x1, r12                       ! r12 = 1 (mark sequence as complete)
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    and r13, r0                         ! keep only ready flag (bit 7)
    or #0x4, r0                         ! set phase = 4
    extu.b r0, r0                       ! zero-extend
    mov #0x34, r1                       ! offset 0x34
    add r14, r1                         ! r1 = &desc->state_byte
    mov.b r0, @r1                       ! desc->state_byte = (ready_flag | 4)
.L_phase4_tick_loop:
    mov.l @(4, r14), r3                 ! r3 = desc->element_a
    mov.l @(28, r14), r2                ! r2 = desc->frame_delta
    mov.l @(8, r3), r3                  ! r3 = element_a->field[2] (total frames)
    cmp/eq r3, r2                       ! frame_delta == total_frames?
    bf      .L_tick_element_b           ! not yet — skip element A teardown
    mov #-0x1, r6                       ! arg3 = -1 (teardown sentinel)
    mov.l @(4, r14), r5                 ! arg2 = element_a handle
    mov.l   .L_fn_dispatch_slot5, r3    ! r3 = dispatch_slot5 function pointer
    jsr @r3                             ! call dispatch_slot5(head, elem_a, -1)
    mov r10, r4                         ! arg1 = display_list_head (delay slot)
    mov.l @(4, r14), r2                 ! r2 = element_a handle
    mov.l @(12, r2), r3                 ! r3 = element_a->field[3] (frame step)
    mov.l @(24, r14), r2                ! r2 = desc->accumulated_time
    add r3, r2                          ! accumulated_time += frame_step
    mov.l r2, @(24, r14)               ! store updated accumulated_time
    mov.l r11, @(4, r14)               ! desc->element_a = NULL (teardown complete)
.L_tick_element_b:
    mov #-0x1, r6                       ! arg3 = -1 (teardown sentinel)
    mov.l @(12, r14), r5                ! arg2 = element_c handle
    mov.l   .L_fn_dispatch_slot5, r3    ! r3 = dispatch_slot5 function pointer
    jsr @r3                             ! call dispatch_slot5(head, elem_c, -1)
    mov r9, r4                          ! arg1 = element_b handle (delay slot)
    mov.l r11, @(12, r14)              ! desc->element_c = NULL (teardown complete)
    mov.l @(24, r14), r2                ! r2 = desc->accumulated_time
    mov.l @(20, r14), r3                ! r3 = desc->max_progress
    cmp/ge r3, r2                       ! accumulated_time >= max_progress?
    bf      .L_reset_phase_keep_ready   ! no — reset phase to 0, keep looping
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    and r13, r0                         ! keep only ready flag (bit 7)
    or #0x5, r0                         ! set phase = 5 (sequence complete)
    extu.b r0, r0                       ! zero-extend
    mov #0x34, r1                       ! offset 0x34
    add r14, r1                         ! r1 = &desc->state_byte
    bra     .L_store_state_and_return   ! store updated state and return
    mov.b r0, @r1                       ! desc->state_byte = (ready_flag | 5) (delay slot)
.L_reset_phase_keep_ready:
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r2                ! r2 = desc->state_byte
    extu.b r2, r2                       ! zero-extend
    and r13, r2                         ! keep only ready flag (bit 7), clear phase
    extu.b r2, r2                       ! zero-extend (phase = 0)
    mov.b r2, @(r0, r14)               ! desc->state_byte = ready_flag | 0 (restart loop)
.L_store_state_and_return:
    bra     .L_write_status_return      ! jump to common status write + return
    nop
    .2byte  0xFFFF                      ! alignment padding
.L_fn_dispatch_slot5:
    .4byte  sym_0603F91C                ! dispatch_slot5 callback dispatcher
.L_state_dispatch:
    cmp/eq #0x0, r0                     ! phase == 0?
    bf      .L_check_phase_1            ! no — check next phase
    bra     .L_phase0_palette_apply     ! yes — apply initial palette
    nop
.L_check_phase_1:
    cmp/eq #0x1, r0                     ! phase == 1?
    bt      .L_phase1_hud_palette       ! yes — select HUD palette
    cmp/eq #0x2, r0                     ! phase == 2?
    bt      .L_phase2_display_callback  ! yes — execute display callback
    cmp/eq #0x3, r0                     ! phase == 3?
    bt      .L_phase3_advance_callback  ! yes — execute advance callback
    cmp/eq #0x4, r0                     ! phase == 4?
    bt      .L_phase4_tick_loop         ! yes — frame tick and teardown
.L_write_status_return:
    mov.l r12, @r8                      ! *status_out = completion_flag
    mov #0x34, r0                       ! offset 0x34 = state byte
    mov.b @(r0, r14), r0                ! r0 = desc->state_byte
    extu.b r0, r0                       ! zero-extend
    .byte   0x93, 0x35    /* mov.w .L_wpool_0603FCB6, r3 */  ! r3 = 0xFF7F (from vblank_palette_apply pool)
    and r3, r0                          ! r0 = state_byte & ~0x80 (clear ready flag)
.L_epilogue:
    add #0x4, r15                       ! free local stack space
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
