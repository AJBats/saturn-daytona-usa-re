/* math_trig_lib -- atan2 via tangent table binary search (16.16 fixed-point)
 * Translation unit: 0x06042646 - 0x060429EC
 *
 * This function computes the angle (in degrees, 16.16 fixed-point) from a
 * ratio y/x, equivalent to atan2(y, x). It is the body of a two-part entry:
 *   div_result_read (0x06042634) saves callee-saved registers r14-r9, mach, macl
 *   math_trig_lib   (0x06042646) performs the actual atan2 computation
 *
 * Algorithm:
 *   1. Take absolute values of y (r4 -> r4) and x (r10 -> r5), track signs.
 *   2. Compute the tangent ratio = |y| / |x| using the SH-2 hardware divider:
 *      - If |x| < 65, clamp to 0x7FFF0000 (near-vertical, ~90 degrees).
 *      - Otherwise, feed |x| as divisor and |y| as 32.16 dividend into DVSR/DVDNT.
 *   3. Binary search the 91-entry tangent table (0..90 degrees) to find the
 *      integer degree whose tangent brackets the ratio.
 *   4. Linear-interpolate within the bracket using the precomputed slope
 *      (reciprocal of tangent delta) to get a fractional degree in 16.16.
 *   5. Combine integer degree (high 16 bits) + fractional part (low 16 bits).
 *   6. Apply quadrant correction based on original signs of y and x:
 *      - x >= 0:  result is in [0..90] range, no correction needed.
 *      - x < 0, y >= 0:  result = 180 - result  (second quadrant)
 *      - x < 0, y < 0:   result = -180 - result (third quadrant, wraps negative)
 *   7. Return angle in r0 (16.16 fixed-point degrees, signed).
 *
 * On entry (after div_result_read prologue):
 *   r4  = y component (numerator)
 *   r10 = x component (denominator), sign indicates hemisphere
 *   r5  = (overwritten) becomes |x| or |y| depending on path
 *
 * On exit:
 *   r0 = angle in degrees (16.16 fixed-point, signed, range roughly -180..+180)
 *
 * Register usage within function:
 *   r4  = |y|, then reused for interpolation delta / final result
 *   r5  = |x|, then reused as binary search high bound
 *   r10 = original x (sign preserved for quadrant detection)
 *   r11 = pointer to tangent lookup table base
 *   r12 = original y (sign preserved for quadrant detection)
 *   r13 = tangent ratio = |y|/|x| in 16.16 fixed-point
 *   r14 = binary search midpoint index (current degree candidate)
 *
 * Tangent table format (sym_06042714):
 *   91 entries (degrees 0 through 90), each 8 bytes:
 *     [0..3] = tan(degree) in 16.16 fixed-point
 *     [4..7] = interpolation reciprocal slope (1 / (tan(deg+1) - tan(deg)))
 *              as 16.16 fixed-point, used to convert tangent residual to
 *              fractional degree offset via dmuls.l
 *
 * Hardware:
 *   SH-2 division unit at 0xFFFFFF00:
 *     DVSR  @ +0x00 = divisor (32-bit)
 *     DVDNTH @ +0x10 = dividend high (32-bit)
 *     DVDNTL @ +0x14 = dividend low (32-bit) — triggers 64/32 division
 *     Result read from DVDNTL @ +0x14
 *
 * External calls: none (standalone math utility)
 * Called by: div_result_read (prologue), which is called by atan2 wrappers
 *
 * Auto-generated by tools/generate_l3_tu.py, then manually annotated.
 */

    .section .text.FUN_06042646


    .global math_trig_lib
    .type math_trig_lib, @function
math_trig_lib:

/* === Prologue: save PR, load table pointer === */
    sts.l pr, @-r15                         ! save return address (div_result_read already saved r14-r9, mach, macl)
    .byte   0xDB, 0x2D    /* mov.l .L_pool_tan_table_ptr, r11 */  ! r11 = base address of tangent lookup table

/* === Normalize inputs: take absolute values, track signs === */
    cmp/pz r10                              ! is x (denominator) >= 0?
    bt/s    .L_x_nonneg                     ! if so, skip negation
    mov r4, r12                             ! r12 = y (save original y for quadrant detection)
    neg r10, r5                             ! r5 = |x| = -x (x was negative)
.L_x_nonneg:
    cmp/pz r12                              ! is y (numerator) >= 0?
    bt      .L_y_nonneg                     ! if so, skip negation
    neg r12, r4                             ! r4 = |y| = -y (y was negative)
.L_y_nonneg:

/* === Compute tangent ratio |y|/|x| using SH-2 hardware divider === */
/*
 * Small-denominator guard: if |x| < 65 (0x41), the ratio would overflow
 * or be near-infinite (angle ~90 degrees). Clamp to 0x7FFF0000.
 */
    mov #0x41, r2                           ! r2 = 65 (small-denominator threshold)
    cmp/ge r2, r5                           ! is |x| >= 65?
    bt      .L_do_hw_divide                 ! if so, safe to divide
    .byte   0xDD, 0x29    /* mov.l .L_pool_tan_clamp_max, r13 */  ! r13 = 0x7FFF0000 (clamped max tangent)
    bra     .L_have_tangent_ratio           ! skip division, use clamped value
    nop

/* --- Hardware division: |y| / |x| as 16.16 fixed-point --- */
.L_do_hw_divide:
    .byte   0xD0, 0x25    /* mov.l .L_pool_sh2_dvsr, r0 */  ! r0 = 0xFFFFFF00 (SH-2 divider base address)
    swap.w r4, r2                           ! r2 = |y| with halfwords swapped (= |y| << 16 >> 16 in high, low swapped)
    mov.l r5, @r0                           ! DVSR = |x| (divisor)
    exts.w r2, r2                           ! r2 = sign-extend low 16 bits of swapped |y| (= high 16 bits of |y|)
    mov.l r2, @(16, r0)                     ! DVDNTH = high part of 48-bit dividend (|y| >> 16)
    shll16 r4                               ! r4 = |y| << 16 (low 32 bits of 48-bit dividend)
    mov.l r4, @(20, r0)                     ! DVDNTL = low part — triggers 64/32 division
    mov.l @(20, r0), r13                    ! r13 = quotient = |y|/|x| in 16.16 fixed-point

/* === Binary search: find integer degree in tangent table === */
/*
 * Binary search over indices 0..90 (degrees). Each table entry is 8 bytes.
 * Entry[i] at offset i*8 from r11 contains tan(i) as 16.16 fixed-point.
 * We find the degree whose tangent is <= ratio < tan(degree+1).
 */
.L_have_tangent_ratio:
    mov #0x0, r4                            ! r4 = lo = 0 (search low bound)
    mov #0x5A, r5                           ! r5 = hi = 90 (search high bound, 0x5A = 90)

.L_bsearch_loop:
    mov r4, r14                             ! r14 = mid = lo
    add r5, r14                             ! r14 = lo + hi
    shar r14                                ! r14 = (lo + hi) / 2 (arithmetic shift right preserves sign)
    mov r14, r0                             ! r0 = mid
    shll2 r0                                ! r0 = mid * 4
    shll r0                                 ! r0 = mid * 8 (byte offset into table)
    mov.l @(r0, r11), r2                    ! r2 = tan_table[mid].tangent
    cmp/gt r13, r2                          ! is table[mid].tangent > ratio?
    bt      .L_bsearch_go_low              ! if so, search lower half

    /* table[mid].tangent <= ratio: check if ratio < table[mid+1].tangent */
    mov r14, r4                             ! lo = mid
    add #0x1, r4                            ! lo = mid + 1
    mov r4, r0                              ! r0 = mid + 1
    shll2 r0                                ! r0 = (mid+1) * 4
    shll r0                                 ! r0 = (mid+1) * 8
    mov.l @(r0, r11), r3                    ! r3 = tan_table[mid+1].tangent
    cmp/ge r3, r13                          ! is ratio >= table[mid+1].tangent?
    bt      .L_bsearch_check_done          ! if so, not yet found — continue search
    bra     .L_bsearch_found               ! ratio is between table[mid] and table[mid+1] — found!
    nop

.L_bsearch_go_low:
    mov r14, r5                             ! hi = mid (narrow search to lower half)

.L_bsearch_check_done:
    cmp/ge r5, r4                           ! is lo >= hi?
    bf      .L_bsearch_loop                ! if not, continue searching

/* === Interpolation: compute fractional degree within bracket === */
/*
 * At this point:
 *   r14 = integer degree (the bracket's lower bound)
 *   r13 = tangent ratio
 *   table[r14].tangent <= r13 < table[r14+1].tangent
 *
 * Fractional part = (ratio - tan[deg]) * reciprocal_slope[deg]
 * where reciprocal_slope = 1.0 / (tan[deg+1] - tan[deg])
 * The result is in 16.16 fixed-point (0x0000 to 0xFFFF for 0.0 to ~1.0 degree).
 */
.L_bsearch_found:
    mov r14, r0                             ! r0 = degree index
    mov r13, r4                             ! r4 = tangent ratio
    shll2 r0                                ! r0 = degree * 4
    shll r0                                 ! r0 = degree * 8 (byte offset)
    mov.l @(r0, r11), r3                    ! r3 = tan_table[degree].tangent
    sub r3, r4                              ! r4 = ratio - tan[degree] (tangent residual)
    add #0x4, r0                            ! r0 += 4 (advance to slope field)
    mov.l @(r0, r11), r5                    ! r5 = tan_table[degree].reciprocal_slope
    dmuls.l r4, r5                          ! MACH:MACL = residual * reciprocal_slope (64-bit product)
    sts mach, r3                            ! r3 = high 32 bits of product
    sts macl, r4                            ! r4 = low 32 bits of product
    xtrct r3, r4                            ! r4 = middle 32 bits (r3[15:0]:r4[31:16]) = fractional degree in 16.16

    /* Clamp fractional part to 1.0 (0x00010000) if it overflows */
    .byte   0xD2, 0x12    /* mov.l .L_pool_fp_one, r2 */  ! r2 = 0x00010000 (1.0 in 16.16)
    cmp/gt r2, r4                           ! is fractional part > 1.0?
    bf      .L_frac_ok                      ! if not, keep computed value
    .byte   0xD4, 0x11    /* mov.l .L_pool_fp_one, r4 */  ! r4 = 0x00010000 (clamp to exactly 1.0)

/* === Combine integer degree + fractional part === */
.L_frac_ok:
    mov r14, r0                             ! r0 = integer degree
    shll16 r0                               ! r0 = degree << 16 (integer part in high word)
    cmp/pz r12                              ! was original y >= 0?
    bt/s    .L_y_was_positive               ! if so, result is positive
    add r0, r4                              ! r4 = (degree << 16) + frac = angle in 16.16 (delay slot, always runs)
    neg r4, r4                              ! y was negative: negate the angle

/* === Quadrant correction for negative x (denominator) === */
.L_y_was_positive:
    cmp/pz r10                              ! was original x >= 0?
    bt      .L_result_ready                 ! if so, angle is in first quadrant — no correction needed

    /* x was negative: need to rotate into second/third quadrant */
    cmp/pz r12                              ! was original y >= 0?
    bf      .L_x_neg_y_neg                  ! if y < 0, go to third quadrant case

    /* Second quadrant: y >= 0, x < 0 => angle = 180 - angle */
    .byte   0xD2, 0x0C    /* mov.l .L_pool_deg_180, r2 */  ! r2 = 0x00B40000 (180.0 degrees in 16.16)
    bra     .L_apply_quadrant_offset        ! apply offset
    nop

    /* Third quadrant: y < 0, x < 0 => angle = -180 - angle */
.L_x_neg_y_neg:
    .byte   0xD2, 0x0C    /* mov.l .L_pool_deg_neg180, r2 */  ! r2 = 0xFF4C0000 (-180.0 degrees in 16.16)

.L_apply_quadrant_offset:
    sub r4, r2                              ! r2 = offset - angle
    mov r2, r4                              ! r4 = corrected angle

/* === Epilogue: return result === */
.L_result_ready:
    mov r4, r0                              ! r0 = final angle result (16.16 FP degrees)
    lds.l @r15+, pr                         ! restore return address
    lds.l @r15+, macl                       ! restore macl (saved by div_result_read)
    lds.l @r15+, mach                       ! restore mach (saved by div_result_read)
    mov.l @r15+, r9                         ! restore r9
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return (r0 = angle in 16.16 fixed-point degrees)
    mov.l @r15+, r14                        ! restore r14 (delay slot)

/* === Constant pool === */
    .2byte  0x0009                          /* padding (nop encoding) */

.L_pool_sh2_dvsr:
    .4byte  0xFFFFFF00                  /* SH-2 division unit base (DVSR register) */
.L_pool_tan_table_ptr:
    .4byte  sym_06042714                /* pointer to 91-entry tangent lookup table */
.L_pool_tan_clamp_max:
    .4byte  0x7FFF0000                  /* tangent clamp: max value when denominator too small (~32767.0) */
.L_pool_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) — interpolation clamp */
.L_pool_deg_180:
    .4byte  0x00B40000                  /* 180.0 degrees (16.16 FP: 0xB4 = 180 decimal) */
.L_pool_deg_neg180:
    .4byte  0xFF4C0000                  /* -180.0 degrees (16.16 FP: 0xFF4C = -180 as signed 16-bit) */

/* ==========================================================================
 * Tangent Lookup Table: 91 entries (degrees 0 through 90)
 *
 * Each entry is 8 bytes:
 *   Bytes [0..3]: tan(degree) in 16.16 fixed-point
 *   Bytes [4..7]: reciprocal slope = floor(0x10000 / (tan(deg+1) - tan(deg)))
 *                 Used to interpolate fractional degrees within the bracket.
 *
 * Examples:
 *   Entry  0: tan(0)  = 0x00000000 (0.0),      slope = 0x00394A3A
 *   Entry  1: tan(1)  = 0x00000477 (0.01746),   slope = 0x0039414B
 *   Entry 45: tan(45) = 0x00010000 (1.0),       slope = 0x001C251D
 *   Entry 89: tan(89) = 0x00394A3A (57.29),     slope = 0x00000105
 *   Entry 90: tan(90) = 0x7FFFFFFF (infinity),  end marker
 *
 * Note: The data below is encoded as raw bytes by the L3 generator because
 * the assembler misinterprets 16-bit data values as SH-2 instructions.
 * The original .word/.4byte declarations produced incorrect disassembly
 * artifacts (e.g., mul.l, mov.b, bf/s) which are NOT real instructions.
 * ========================================================================== */
    .global sym_06042714
sym_06042714:
    /* degree  0: tan =  0.00000 (0x00000000), slope = 0x00394A3A */
    .word 0x0000 /* UNKNOWN */
    .word 0x0000 /* UNKNOWN */
    .word 0x0039 /* UNKNOWN */
    .word 0x4A3A /* UNKNOWN */
    /* degree  1: tan =  0.01746 (0x00000477), slope = 0x0039414B */
    .word 0x0000 /* UNKNOWN */
    mul.l r7, r4
    .word 0x0039 /* UNKNOWN */
    .word 0x414B /* UNKNOWN */
    /* degree  2: tan =  0.03492 (0x000008F0), slope = 0x00392F70 */
    .word 0x0000 /* UNKNOWN */
    .word 0x08F0 /* UNKNOWN */
    .word 0x0039 /* UNKNOWN */
    mov.b r7, @r15
    /* degree  3: tan =  0.05241 (0x00000D6A), slope = 0x003914AD */
    .word 0x0000 /* UNKNOWN */
    .word 0x0D6A /* UNKNOWN */
    .word 0x0039 /* UNKNOWN */
    mov.l r10, @(52, r4)
    /* degree  4: tan =  0.06993 (0x000011E6), slope = 0x0038F10C */
    .word 0x0000 /* UNKNOWN */
    mov.l r14, @(24, r1)
    .word 0x0038 /* UNKNOWN */
    .word 0xF10C /* UNKNOWN */
    /* degree  5: tan =  0.08749 (0x00001665), slope = 0x0038C498 */
    .word 0x0000 /* UNKNOWN */
    mov.l r6, @(20, r6)
    .word 0x0038 /* UNKNOWN */
    mov.b @(152, gbr), r0
    /* degree  6: tan =  0.10510 (0x00001AE8), slope = 0x00388F5F */
    .word 0x0000 /* UNKNOWN */
    mov.l r14, @(32, r10)
    .word 0x0038 /* UNKNOWN */
    bf/s    .L_tan_entry_deg31
    /* degree  7: tan =  0.12278 (0x00001F6E), slope = 0x00385170 */
    .word 0x0000 /* UNKNOWN */
    mov.l r6, @(56, r15)
    .word 0x0038 /* UNKNOWN */
    mov.l @(0, r7), r1
    /* degree  8: tan =  0.14054 (0x000023FA), slope = 0x00380AE0 */
    .word 0x0000 /* UNKNOWN */
    xor r15, r3
    .word 0x0038 /* UNKNOWN */
    .word 0x0AE0 /* UNKNOWN */
    /* degree  9: tan =  0.15838 (0x0000288B), slope = 0x0037BBC4 */
    .word 0x0000 /* UNKNOWN */
    or r8, r8
    mul.l r3, r0
    .byte   0xBB, 0xC4    /* bsr 0x06041EEE (external) */
    /* degree 10: tan =  0.17633 (0x00002D23), slope = 0x00376435 */
    .word 0x0000 /* UNKNOWN */
    .word 0x2D23 /* UNKNOWN */
    mul.l r3, r0
    mov.w @r3+, r4
    /* degree 11: tan =  0.19438 (0x000031C2), slope = 0x0037044F */
    .word 0x0000 /* UNKNOWN */
    cmp/hs r12, r1
    mul.l r3, r0
    mac.l @r4+, @r4+
    /* degree 12: tan =  0.21256 (0x0000366A), slope = 0x00369C2F */
    .word 0x0000 /* UNKNOWN */
    subc r6, r6
    mov.l r3, @(r0, r0)
    mov.w   .L_wpool_zero_interp, r12
    /* degree 13: tan =  0.23087 (0x00003B1A), slope = 0x00362BF6 */
    .word 0x0000 /* UNKNOWN */
    subc r1, r11
    mov.l r3, @(r0, r0)
    mov.l r15, @-r11
    /* degree 14: tan =  0.24933 (0x00003FD3), slope = 0x0035B3C7 */
    .word 0x0000 /* UNKNOWN */
    cmp/ge r13, r15
    mov.w r3, @(r0, r0)
    .byte   0xB3, 0xC7    /* bsr 0x06042F1C (external) */
    /* degree 15: tan =  0.26795 (0x00004498), slope = 0x003533C7 */
    .word 0x0000 /* UNKNOWN */
    .word 0x4498 /* UNKNOWN */
    mov.w r3, @(r0, r0)
    cmp/gt r12, r3
    /* degree 16: tan =  0.28675 (0x00004968), slope = 0x0034AC1E */
    .word 0x0000 /* UNKNOWN */
    .word 0x4968 /* UNKNOWN */
    mov.b r3, @(r0, r0)
    .byte   0xAC, 0x1E    /* bra 0x06041FDA (external) */
    /* degree 17: tan =  0.30573 (0x00004E44), slope = 0x00341CF7 */
    .word 0x0000 /* UNKNOWN */
    .2byte  0x4E44
    .4byte  0x00341CF7
    /* degree 18: tan =  0.32492 (0x0000532D), slope = 0x0033867E */
    .4byte  0x0000532D
    .4byte  0x0033867E
    /* degree 19: tan =  0.34433 (0x00005825), slope = 0x0032E8E2 */
    .4byte  0x00005825
    .4byte  0x0032E8E2
    /* degree 20: tan =  0.36397 (0x00005D2D), slope = 0x00324454 */
    .4byte  0x00005D2D
    .4byte  0x00324454
    /* degree 21: tan =  0.38386 (0x00006244), slope = 0x00319908 */
    .4byte  0x00006244
    .4byte  0x00319908
    /* degree 22: tan =  0.40403 (0x0000676E), slope = 0x0030E733 */
    .4byte  0x0000676E
    .4byte  0x0030E733
    /* degree 23: tan =  0.42447 (0x00006CAA), slope = 0x00302F0C */
    .4byte  0x00006CAA
    .4byte  0x00302F0C
    /* degree 24: tan =  0.44523 (0x000071FA), slope = 0x002F70CD */
    .4byte  0x000071FA
    .4byte  0x002F70CD
.L_wpool_zero_interp:
    .2byte  0x0000                      /* 0 */
    /* degree 25: tan =  0.46631 (0x0000775F), slope = 0x002EACB2 */
    .2byte  0x775F
    .4byte  0x002EACB2
    /* degree 26: tan =  0.48773 (0x00007CDC), slope = 0x002DE2F7 */
    .4byte  0x00007CDC
    .4byte  0x002DE2F7
    /* degree 27: tan =  0.50953 (0x00008270), slope = 0x002D13DB */
    .4byte  0x00008270
    .4byte  0x002D13DB
    /* degree 28: tan =  0.53171 (0x0000881E), slope = 0x002C3F9F */
    .4byte  0x0000881E
    .4byte  0x002C3F9F
    /* degree 29: tan =  0.55431 (0x00008DE7), slope = 0x002B6686 */
    .4byte  0x00008DE7
    .4byte  0x002B6686
    /* degree 30: tan =  0.57735 (0x000093CD), slope = 0x002A88D2 */
    .4byte  0x000093CD
    .4byte  0x002A88D2
.L_tan_entry_deg31:
    /* degree 31: tan =  0.60086 (0x000099D2), slope = 0x0029A6C9 */
    .word 0x0000 /* UNKNOWN */
    mov.w   .L_wpool_tan89_slope_lo, r9
    .word 0x0029 /* UNKNOWN */
    .byte   0xA6, 0xC9    /* bra 0x060435A8 (external) */
    /* degree 32: tan =  0.62487 (0x00009FF7), slope = 0x0028C0B2 */
    .word 0x0000 /* UNKNOWN */
    .2byte  0x9FF7
    .4byte  0x0028C0B2
    /* degree 33: tan =  0.64941 (0x0000A63F), slope = 0x0027D6D3 */
    .4byte  0x0000A63F
    .4byte  0x0027D6D3
    /* degree 34: tan =  0.67451 (0x0000ACAC), slope = 0x0026E978 */
    .4byte  0x0000ACAC
    .4byte  0x0026E978
    /* degree 35: tan =  0.70021 (0x0000B340), slope = 0x0025F8E8 */
    .4byte  0x0000B340
    .4byte  0x0025F8E8
    /* degree 36: tan =  0.72654 (0x0000B9FE), slope = 0x0025056F */
    .4byte  0x0000B9FE
    .4byte  0x0025056F
    /* degree 37: tan =  0.75355 (0x0000C0E8), slope = 0x00240F5A */
    .4byte  0x0000C0E8
    .4byte  0x00240F5A
    /* degree 38: tan =  0.78129 (0x0000C802), slope = 0x002316F5 */
    .4byte  0x0000C802
    .4byte  0x002316F5
    /* degree 39: tan =  0.80978 (0x0000CF4E), slope = 0x00221C8D */
    .4byte  0x0000CF4E
    .4byte  0x00221C8D
    /* degree 40: tan =  0.83910 (0x0000D6CF), slope = 0x00212071 */
    .4byte  0x0000D6CF
    .4byte  0x00212071
    /* degree 41: tan =  0.86929 (0x0000DE89), slope = 0x002022EE */
    .4byte  0x0000DE89
    .4byte  0x002022EE
    /* degree 42: tan =  0.90040 (0x0000E680), slope = 0x001F2455 */
    .4byte  0x0000E680
    .4byte  0x001F2455
    /* degree 43: tan =  0.93252 (0x0000EEB9), slope = 0x001E24F5 */
    .4byte  0x0000EEB9
    .4byte  0x001E24F5
    /* degree 44: tan =  0.96569 (0x0000F737), slope = 0x001D251D */
    .4byte  0x0000F737
    .4byte  0x001D251D
    /* degree 45: tan =  1.00000 (0x00010000), slope = 0x001C251D */
    .4byte  0x00010000
    .4byte  0x001C251D
    /* degree 46: tan =  1.03553 (0x00010918), slope = 0x001B2545 */
    .4byte  0x00010918
    .4byte  0x001B2545
    /* degree 47: tan =  1.07237 (0x00011286), slope = 0x001A25E5 */
    .4byte  0x00011286
    .4byte  0x001A25E5
    /* degree 48: tan =  1.11061 (0x00011C51), slope = 0x0019274C */
    .4byte  0x00011C51
    .4byte  0x0019274C
    /* degree 49: tan =  1.15037 (0x0001267E), slope = 0x001829C9 */
    .4byte  0x0001267E
    .4byte  0x001829C9
    /* degree 50: tan =  1.19175 (0x00013116), slope = 0x00172DAD */
    .4byte  0x00013116
    .4byte  0x00172DAD
    /* degree 51: tan =  1.23490 (0x00013C22), slope = 0x00163345 */
    .4byte  0x00013C22
    .4byte  0x00163345
    /* degree 52: tan =  1.27994 (0x000147AA), slope = 0x00153AE0 */
    .4byte  0x000147AA
    .4byte  0x00153AE0
    /* degree 53: tan =  1.32704 (0x000153B9), slope = 0x001444CB */
    .4byte  0x000153B9
    .4byte  0x001444CB
    /* degree 54: tan =  1.37638 (0x0001605A), slope = 0x00135152 */
    .4byte  0x0001605A
    .4byte  0x00135152
    /* degree 55: tan =  1.42815 (0x00016D9B), slope = 0x001260C2 */
    .4byte  0x00016D9B
    .4byte  0x001260C2
    /* degree 56: tan =  1.48256 (0x00017B89), slope = 0x00117366 */
    .4byte  0x00017B89
    .4byte  0x00117366
    /* degree 57: tan =  1.53986 (0x00018A34), slope = 0x00108988 */
    .4byte  0x00018A34
    .4byte  0x00108988
    /* degree 58: tan =  1.60033 (0x000199AF), slope = 0x000FA371 */
    .4byte  0x000199AF
    .4byte  0x000FA371
    /* degree 59: tan =  1.66428 (0x0001AA0E), slope = 0x000EC168 */
    .4byte  0x0001AA0E
    .4byte  0x000EC168
    /* degree 60: tan =  1.73205 (0x0001BB67), slope = 0x000DE3B4 */
    .4byte  0x0001BB67
    .4byte  0x000DE3B4
    /* degree 61: tan =  1.80405 (0x0001CDD6), slope = 0x000D0A9B */
    .4byte  0x0001CDD6
    .4byte  0x000D0A9B
    /* degree 62: tan =  1.88073 (0x0001E177), slope = 0x000C365F */
    .4byte  0x0001E177
    .4byte  0x000C365F
    /* degree 63: tan =  1.96261 (0x0001F66D), slope = 0x000B6743 */
    .4byte  0x0001F66D
    .4byte  0x000B6743
    /* degree 64: tan =  2.05030 (0x00020CE0), slope = 0x000A9D88 */
    .4byte  0x00020CE0
    .4byte  0x000A9D88
    /* degree 65: tan =  2.14451 (0x000224FE), slope = 0x0009D96D */
    .4byte  0x000224FE
    .4byte  0x0009D96D
    /* degree 66: tan =  2.24604 (0x00023EFC), slope = 0x00091B2E */
    .4byte  0x00023EFC
    .4byte  0x00091B2E
    /* degree 67: tan =  2.35585 (0x00025B19), slope = 0x00086307 */
    .4byte  0x00025B19
    .4byte  0x00086307
    /* degree 68: tan =  2.47509 (0x0002799F), slope = 0x0007B132 */
    .4byte  0x0002799F
    .4byte  0x0007B132
    /* degree 69: tan =  2.60509 (0x00029AE7), slope = 0x000705E6 */
    .4byte  0x00029AE7
    .4byte  0x000705E6
    /* degree 70: tan =  2.74748 (0x0002BF5A), slope = 0x00066158 */
    .4byte  0x0002BF5A
    .4byte  0x00066158
    /* degree 71: tan =  2.90421 (0x0002E77A), slope = 0x0005C3BC */
    .4byte  0x0002E77A
    .4byte  0x0005C3BC
    /* degree 72: tan =  3.07768 (0x000313E3), slope = 0x00052D43 */
    .4byte  0x000313E3
    .4byte  0x00052D43
    /* degree 73: tan =  3.27085 (0x00034556), slope = 0x00049E1C */
    .4byte  0x00034556
    .4byte  0x00049E1C
    /* degree 74: tan =  3.48741 (0x00037CC7), slope = 0x00041673 */
    .4byte  0x00037CC7
    .4byte  0x00041673
    /* degree 75: tan =  3.73205 (0x0003BB67), slope = 0x00039673 */
    .4byte  0x0003BB67
    .4byte  0x00039673
    /* degree 76: tan =  4.01078 (0x000402C2), slope = 0x00031E44 */
    .4byte  0x000402C2
    .4byte  0x00031E44
    /* degree 77: tan =  4.33148 (0x000454DB), slope = 0x0002AE0B */
    .4byte  0x000454DB
    .4byte  0x0002AE0B
    /* degree 78: tan =  4.70463 (0x0004B462), slope = 0x000245EB */
    .4byte  0x0004B462
    .4byte  0x000245EB
    /* degree 79: tan =  5.14455 (0x00052501), slope = 0x0001E605 */
    .4byte  0x00052501
    .4byte  0x0001E605
    /* degree 80: tan =  5.67128 (0x0005ABD9), slope = 0x00018E76 */
    .4byte  0x0005ABD9
    .4byte  0x00018E76
    /* degree 81: tan =  6.31375 (0x00065052), slope = 0x00013F5A */
    .4byte  0x00065052
    .4byte  0x00013F5A
    /* degree 82: tan =  7.11537 (0x00071D88), slope = 0x0000F8CA */
    .4byte  0x00071D88
    .4byte  0x0000F8CA
    /* degree 83: tan =  8.14435 (0x000824F3), slope = 0x0000BADB */
    .4byte  0x000824F3
    .4byte  0x0000BADB
    /* degree 84: tan =  9.51436 (0x000983AD), slope = 0x000085A2 */
    .2byte  0x0009
.L_wpool_tan89_slope_lo:
    .2byte  0x83AD
    .4byte  0x000085A2
    /* degree 85: tan = 11.43005 (0x000B6E17), slope = 0x0000592D */
    .4byte  0x000B6E17
    .4byte  0x0000592D
    /* degree 86: tan = 14.30067 (0x000E4CF8), slope = 0x0000358D */
    .4byte  0x000E4CF8
    .4byte  0x0000358D
    /* degree 87: tan = 19.08114 (0x001314C5), slope = 0x00001ACA */
    .4byte  0x001314C5
    .4byte  0x00001ACA
    /* degree 88: tan = 28.63625 (0x001CA2E1), slope = 0x000008EF */
    .4byte  0x001CA2E1
    .4byte  0x000008EF
    /* degree 89: tan = 57.28996 (0x00394A3A), slope = 0x00000105 */
    .4byte  0x00394A3A
    .4byte  0x00000105
    /* degree 90: tan = infinity sentinel (0x7FFFFFFF), end-of-table marker */
    .4byte  0x7FFFFFFF
    .4byte  0x00000000
