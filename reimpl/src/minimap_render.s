/* minimap_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060155A4 - 0x060156A6
 * Auto-generated by tools/generate_l3_tu.py
 *
 * minimap_render(layer, param, color_mask, data_ptr):
 *   Iterates over 4 minimap element slots and updates their rendering
 *   state. For each slot, computes a scaled velocity using fpmul (16.16
 *   fixed-point multiply) and stores the result into the slot struct.
 *   Special-cases slot indices 0 and 3, which use direct position copy
 *   instead of the fpmul path. For other slots, the y-velocity is
 *   negated if the fpmul result was negative (reflection).
 *
 *   After computing velocities, integrates per-frame deltas into both
 *   position (+0x18 += +0x24) and angle/target (+0x1C += +0x20) fields.
 *
 *   Slot struct layout (68 bytes each, base sym_06084FC8):
 *     +0x02  element_type (byte)
 *     +0x04  x_pos      (32-bit, 16.16 FP)
 *     +0x08  y_pos      (32-bit, 16.16 FP)
 *     +0x0C  z_pos      (32-bit, 16.16 FP)
 *     +0x10  x_vel      (32-bit, computed by this function)
 *     +0x14  y_vel      (32-bit, computed by this function)
 *     +0x18  position_accum  (32-bit, integrated each frame)
 *     +0x1C  angle_accum     (32-bit, integrated each frame)
 *     +0x20  angle_delta     (32-bit, per-frame delta for angle)
 *     +0x24  position_delta  (32-bit, per-frame delta for position)
 *
 *   Input:
 *     r4  = layer index (e.g. 8)
 *     r5  = rendering param (e.g. 0x82)
 *     r6  = color mask (e.g. 0xF000)
 *     r7  = data pointer
 *   Output: slot velocity and accumulator fields updated in-place
 *
 *   Persistent registers:
 *     r8  = 0xDDB2 (fixed-point scaling constant, ~0.866)
 *     r9  = 4 (loop count / slot count)
 *     r10 = 0x8000 (0.5 in 16.16 FP)
 *     r11 = &fpmul (fixed-point multiply function)
 *     r13 = sym_06084FC8 (slot data array base)
 *     r14 = loop counter (0..3)
 *
 * loc_06015678:
 *   Minimap slot dispatch — reads the element type byte from a slot
 *   struct, indexes into a function pointer table (in the next TU's
 *   constant pool), and tail-jumps to the selected handler.
 *
 *   Input:  r4 = slot index (byte)
 *   Output: tail-jumps to the handler for this slot's current element type
 */

    .section .text.FUN_060155A4


    .global minimap_render
    .type minimap_render, @function
minimap_render:
    mov.l r14, @-r15                       ! save r14
    mov.l r13, @-r15                       ! save r13
    mov.l r12, @-r15                       ! save r12
    mov.l r11, @-r15                       ! save r11
    mov.l r10, @-r15                       ! save r10
    mov.l r9, @-r15                        ! save r9
    mov.l r8, @-r15                        ! save r8
    sts.l pr, @-r15                        ! save return address
    mov.l   .L_pool_scale_const, r8        ! r8 = 0xDDB2 (~0.866 in 16.16 FP, scale factor)
    mov #0x4, r9                           ! r9 = 4 (number of minimap slots to process)
    mov.l   .L_fp_half, r10                ! r10 = 0x8000 (0.5 in 16.16 FP)
    mov.l   .L_pool_fpmul, r11             ! r11 = &fpmul (16.16 FP multiply function)
    mov.l   .L_pool_slot_base, r13         ! r13 = sym_06084FC8 (slot array base)
    mov #0x0, r14                          ! r14 = 0 (loop counter init)
.L_slot_loop:
    extu.b r14, r4                         ! r4 = slot_index (zero-extended byte)
    mov r4, r0                             ! r0 = slot_index
    cmp/eq #0x3, r0                        ! T = (slot_index == 3)?
    .word 0x0029 /* MOVT R0 */             ! r0 = T (1 if slot 3, else 0)
    tst r4, r4                             ! T = (slot_index == 0)?
    .word 0x0129 /* MOVT R1 */             ! r1 = T (1 if slot 0, else 0)
    or r1, r0                              ! r0 = is_slot_0 | is_slot_3
    tst r0, r0                             ! test combined flag
    bt      .L_direct_copy                 ! if slot 0 or 3 → use direct position copy
    /* --- fpmul path: compute scaled velocity for slots 1 and 2 --- */
    extu.b r14, r12                        ! r12 = slot_index (working copy)
    mov r8, r5                             ! r5 = 0xDDB2 (scale constant, fpmul arg)
    mov r12, r3                            ! r3 = slot_index (for stride calc)
    shll2 r12                              ! r12 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r12                            ! r12 = idx * 68 (slot struct stride)
    exts.w r12, r12                        ! sign-extend offset to longword
    add r13, r12                           ! r12 = &slot_data[idx] (struct base ptr)
    jsr @r11                               ! call fpmul(slot.angle_accum, scale_const)
    mov.l @(28, r12), r4                   ! (delay) r4 = slot[+0x1C] (angle_accum, fpmul arg)
    mov.l r0, @(16, r12)                   ! slot[+0x10] = fpmul result (x_vel)
    mov r10, r5                            ! r5 = 0x8000 (0.5 FP, fpmul arg)
    jsr @r11                               ! call fpmul(slot.angle_accum, 0.5)
    mov.l @(28, r12), r4                   ! (delay) r4 = slot[+0x1C] (angle_accum, fpmul arg)
    mov r0, r2                             ! r2 = fpmul result (y_vel candidate)
    cmp/pz r2                              ! T = (y_vel >= 0)?
    bt/s    .L_integrate_accum             ! if non-negative → skip negation
    mov.l r0, @(20, r12)                   ! (delay) slot[+0x14] = y_vel
    /* --- y_vel is negative: negate it (reflect) --- */
    extu.b r14, r4                         ! r4 = slot_index
    mov r4, r3                             ! r3 = slot_index (for stride calc)
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(20, r4), r2                    ! r2 = slot[+0x14] (y_vel, negative)
    neg r2, r2                             ! r2 = -y_vel (make positive)
    bra     .L_integrate_accum             ! continue to accumulator integration
    mov.l r2, @(20, r4)                    ! (delay) slot[+0x14] = negated y_vel
.L_direct_copy:
    /* --- slots 0 and 3: copy angle_accum directly to x_vel (no scaling) --- */
    extu.b r14, r4                         ! r4 = slot_index
    mov r4, r3                             ! r3 = slot_index (for stride calc)
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(28, r4), r2                    ! r2 = slot[+0x1C] (angle_accum)
    mov.l r2, @(16, r4)                    ! slot[+0x10] = angle_accum (direct copy to x_vel)
.L_integrate_accum:
    /* --- integrate per-frame deltas into accumulators --- */
    extu.b r14, r4                         ! r4 = slot_index
    mov r4, r3                             ! r3 = slot_index (for stride calc)
    add #0x1, r14                          ! r14++ (advance loop counter)
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(36, r4), r2                    ! r2 = slot[+0x24] (position_delta)
    mov.l @(24, r4), r3                    ! r3 = slot[+0x18] (position_accum)
    add r2, r3                             ! r3 = position_accum + position_delta
    mov.l r3, @(24, r4)                    ! slot[+0x18] = updated position_accum
    mov.l @(32, r4), r2                    ! r2 = slot[+0x20] (angle_delta)
    mov.l @(28, r4), r3                    ! r3 = slot[+0x1C] (angle_accum)
    add r2, r3                             ! r3 = angle_accum + angle_delta
    mov.l r3, @(28, r4)                    ! slot[+0x1C] = updated angle_accum
    extu.b r14, r2                         ! r2 = loop_counter (zero-extended)
    cmp/ge r9, r2                          ! T = (counter >= 4)?
    bf      .L_slot_loop                   ! if not done → process next slot
    /* --- epilogue: restore callee-saved registers --- */
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r8                        ! restore r8
    mov.l @r15+, r9                        ! restore r9
    mov.l @r15+, r10                       ! restore r10
    mov.l @r15+, r11                       ! restore r11
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return to caller
    mov.l @r15+, r14                       ! (delay) restore r14
    .2byte  0xFFFF                         ! padding
.L_pool_scale_const:
    .4byte  0x0000DDB2                  /* ~0.866 (16.16 FP scale factor, sin(60) or cos(30)) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_fpmul:
    .4byte  fpmul
.L_pool_slot_base:
    .4byte  sym_06084FC8

    .global loc_06015678
loc_06015678:
/* loc_06015678 — minimap slot dispatch
 *   Reads the element_type byte from a slot struct (offset +0x02),
 *   indexes into a function pointer table, and tail-jumps to the
 *   selected handler. Uses cross-TU constant pool entries from the
 *   next TU (minimap_car_dot).
 *
 *   Input:  r4 = slot index (byte)
 *   Output: tail-jumps to handler_table[element_type](slot_index)
 */
    add #-0x4, r15                         ! allocate 4-byte stack frame
    mov.b r4, @r15                         ! sp[0] = slot_index (save arg)
    mov.b @r15, r3                         ! r3 = slot_index (re-read from stack)
    extu.b r3, r3                          ! zero-extend slot_index
    mov r3, r2                             ! r2 = slot_index (copy for stride calc)
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68 (slot struct stride)
    exts.w r3, r3                          ! sign-extend offset
    .byte   0xD1, 0x28    /* mov.l .L_pool_06015730, r1 */  ! r1 = sym_06084FC8 (slot array base, cross-TU pool)
    add r1, r3                             ! r3 = &slot_data[idx] (struct base ptr)
    mov.b @(2, r3), r0                     ! r0 = slot[+0x02] (element_type)
    mov r0, r3                             ! r3 = element_type
    extu.b r3, r3                          ! zero-extend element_type byte
    shll2 r3                               ! r3 = type * 4 (function ptr table offset)
    .byte   0xD2, 0x26    /* mov.l .L_pool_06015734, r2 */  ! r2 = handler function table base (cross-TU pool)
    add r2, r3                             ! r3 = &handler_table[element_type]
    mov.l @r3, r3                          ! r3 = handler function pointer
    mov.b @r15, r4                         ! r4 = slot_index (restore from stack, arg for handler)
    jmp @r3                                ! tail-jump to handler(slot_index)
    add #0x4, r15                          ! (delay) deallocate stack frame
