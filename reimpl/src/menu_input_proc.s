/* menu_input_proc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603ACEA - 0x0603ADAC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * menu_input_proc(r4=menu_ctx, r5=mode_flag)
 *
 * Dispatches menu input processing for one frame.
 *
 * When mode_flag (r5) is zero this is an attract/idle call:
 *   - Reads game state base (sym_060A4D14) into r13
 *   - Checks state->field_0x00A0 (a "credits/HUD ready" flag)
 *   - If non-zero: tail-path signals error -7 via save_checksum_calc and returns
 *   - Otherwise calls credits_scroll_entry(r4=menu_ctx) and signals -1 on failure
 *
 * When mode_flag (r5) is non-zero this is an active-input call:
 *   - Checks state->field_0x00A0 again to pick which render helper to call
 *     (hud_toggle_ctrl path when flag is set, save_size_calc path otherwise)
 *   - The helper returns a result struct pointer in r14
 *   - Tests bit 4 (0x10) of byte[r14+11] â€” a "valid input" flag
 *   - If not set: signals error -6 and returns
 *   - If set: calls save_field_write(r4=sp+4, r5=result_ptr, r6=menu_ctx)
 *             to commit the input, stores return value, then calls
 *             save_checksum_calc(r4=result) and save_checksum_calc(r4=0)
 *
 * Returns r0 = result/status value; callers use save_checksum_calc to store it.
 */

    .section .text.FUN_0603ACEA


    .global menu_input_proc
    .type menu_input_proc, @function
menu_input_proc:
    mov.l r14, @-r15                        ! save r14 (callee-save)
    mov.l r13, @-r15                        ! save r13 (callee-save)
    mov.l r12, @-r15                        ! save r12 (callee-save)
    sts.l pr, @-r15                         ! save return address
    mov.w   .L_wpool_stack_adj, r0          ! r0 = -0xF4 (stack frame size, sign-extended)
    add r0, r15                             ! allocate local stack frame
    mov r5, r0                              ! r0 = mode_flag (r5 arg)
    mov.l r5, @r15                          ! spill mode_flag to stack[0]
    .byte   0xDD, 0x0F    /* mov.l .L_pool_game_state_ptr, r13 */  ! r13 = &sym_060A4D14 (game state ptr-ptr)
    tst r0, r0                              ! test mode_flag == 0?
    bf/s    .L_active_input_path            ! if non-zero, jump to active input path
    mov r4, r12                             ! (delay slot) r12 = menu_ctx

    /* --- attract/idle path (mode_flag == 0) --- */
    mov.l @r13, r3                          ! r3 = *game_state_base (dereference ptr)
    mov.w   .L_wpool_state_offset, r0      ! r0 = 0x00A0 (field offset in state struct)
    mov.l @(r0, r3), r0                    ! r0 = game_state->field_0x00A0 (HUD/credits ready flag)
    tst r0, r0                             ! test: is flag zero?
    bt      .L_attract_flag_clear           ! if zero, proceed to credits entry
    .byte   0xB6, 0x16    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc (signal error)
    mov #-0x7, r4                          ! (delay slot) r4 = -7 (error: credits not ready)
    bra     .L_return                       ! jump to epilogue
    nop                                    ! (delay slot)
.L_attract_flag_clear:
    .byte   0xD3, 0x09    /* mov.l .L_pool_credits_scroll_entry, r3 */  ! r3 = &credits_scroll_entry
    jsr @r3                                ! call credits_scroll_entry(r4=menu_ctx)
    mov r12, r4                            ! (delay slot) r4 = menu_ctx
    mov r0, r4                             ! r4 = credits_scroll_entry return value
    cmp/pz r4                              ! test: result >= 0 (success)?
    bt      .L_return_result               ! if positive/zero, return result directly
    .byte   0xB6, 0x0C    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc (signal error)
    mov #-0x1, r4                          ! (delay slot) r4 = -1 (error: credits scroll failed)
    bra     .L_return                       ! jump to epilogue
    nop                                    ! (delay slot)
.L_return_result:
    bra     .L_return                       ! jump to epilogue
    mov r4, r0                             ! (delay slot) r0 = result to return
    /* --- inline constant pool (between attract and active paths) --- */
.L_wpool_stack_adj:
    .2byte  0xFF0C                         ! stack adjustment: -0xF4 (sign-extended from 0xFF0C)
.L_wpool_state_offset:
    .2byte  0x00A0                         ! offset of ready-flag field in game state struct
    .4byte  hud_toggle_ctrl                ! pointer to hud_toggle_ctrl function
    .4byte  save_size_calc                 ! pointer to save_size_calc function
.L_pool_game_state_ptr:
    .4byte  sym_060A4D14                   ! global game state pointer-pointer
.L_pool_credits_scroll_entry:
    .4byte  credits_scroll_entry           ! pointer to credits_scroll_entry function

    /* --- active input path (mode_flag != 0) --- */
.L_active_input_path:
    mov.l @r13, r2                         ! r2 = *game_state_base
    .byte   0x90, 0x4A    /* mov.w .L_wpool_0603ADDA, r0 */  ! r0 = field_0x00A0 offset (cannot rename: mov.w pcrel)
    mov.l @(r0, r2), r0                    ! r0 = game_state->field_0x00A0 (HUD/render ready flag)
    tst r0, r0                             ! T=1 if flag == 0 (not set)
    bf      .L_flag_nonzero                ! if flag != 0, branch to save_size_calc path
    /* flag == 0: call hud_toggle_ctrl */
    mov.l @r13, r5                         ! r5 = *game_state_base
    .byte   0x90, 0x46    /* mov.w .L_wpool_0603ADDC, r0 */  ! r0 = render struct field offset (cannot rename: mov.w pcrel)
    .byte   0xD3, 0x24    /* mov.l .L_pool_0603ADE0, r3 */   ! r3 = &hud_toggle_ctrl (pool ref from .byte)
    mov.l @(r0, r5), r5                    ! r5 = game_state->render_struct_ptr
    jsr @r3                                ! call hud_toggle_ctrl(r4=menu_ctx, r5=render_struct_ptr)
    mov r12, r4                            ! (delay slot) r4 = menu_ctx
    bra     .L_dispatch_done               ! skip alternate path
    nop                                    ! (delay slot)
.L_flag_nonzero:
    /* flag != 0: call save_size_calc */
    mov.l @r13, r5                         ! r5 = *game_state_base
    .byte   0x90, 0x3E    /* mov.w .L_wpool_0603ADDC, r0 */  ! r0 = render struct field offset (cannot rename: mov.w pcrel)
    .byte   0xD3, 0x21    /* mov.l .L_pool_0603ADE4, r3 */   ! r3 = &save_size_calc (pool ref from .byte)
    mov.l @(r0, r5), r5                    ! r5 = game_state->render_struct_ptr
    jsr @r3                                ! call save_size_calc(r4=menu_ctx, r5=render_struct_ptr)
    mov r12, r4                            ! (delay slot) r4 = menu_ctx
.L_dispatch_done:
    mov r0, r14                            ! r14 = result struct pointer from helper
    mov.b @(11, r14), r0                   ! r0 = result_struct->flags_byte (byte at offset 11)
    extu.b r0, r0                          ! zero-extend to 32-bit
    tst #0x10, r0                          ! test bit 4 (0x10): T=1 if bit clear (input flag absent)
    bt      .L_no_input_flag               ! if bit clear: input not flagged as valid, signal error
    bra     .L_process_input               ! bit set: valid-input flag present, proceed
    nop                                    ! (delay slot)
.L_no_input_flag:
    .byte   0xB5, 0xE2    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc (signal error)
    mov #-0x6, r4                          ! (delay slot) r4 = -6 (error: input-valid bit not set)
    bra     .L_return                       ! jump to epilogue
    nop                                    ! (delay slot)
.L_process_input:
    mov r12, r6                            ! r6 = menu_ctx (3rd arg)
    mov r14, r5                            ! r5 = result_struct_ptr (2nd arg)
    mov r15, r4                            ! r4 = stack ptr base (1st arg)
    .byte   0xB6, 0x53    /* bsr 0x0603BA2C (external) */  ! call save_field_write(sp, result_ptr, menu_ctx)
    add #0x4, r4                           ! (delay slot) r4 += 4 (offset into stack frame)
    mov r0, r13                            ! r13 = save_field_write return value
    mov.l @(4, r14), r6                    ! r6 = result_struct->field_4 (secondary param)
    mov.l @r15, r5                         ! r5 = stack[0] (mode_flag saved at entry)
    .byte   0xD3, 0x16    /* mov.l .L_pool_0603ADE8, r3 */  ! r3 = function pointer (pool ref from .byte)
    jsr @r3                                ! call indirect fn(r4=result_index, r5=mode_flag, r6=result_struct->field_4)
    mov r13, r4                            ! (delay slot) r4 = save_field_write result
    mov.l r0, @r15                         ! store indirect-call result back to stack[0]
    .byte   0xB6, 0x1F    /* bsr 0x0603B9D6 (external) */  ! call save_field_read(r4=result_index)
    mov r13, r4                            ! (delay slot) r4 = save_field_write result
    .byte   0xB5, 0xD0    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0, signal success)
    mov #0x0, r4                           ! (delay slot) r4 = 0 (success code)
    mov.l @r15, r0                         ! r0 = final result from stack[0]

    /* --- function epilogue --- */
.L_return:
    .byte   0x91, 0x1E    /* mov.w .L_wpool_0603ADDE, r1 */  ! r1 = +0xF4 stack deallocation (cannot rename: mov.w pcrel)
    add r1, r15                            ! restore stack pointer
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return
    mov.l @r15+, r14                       ! (delay slot) restore r14
