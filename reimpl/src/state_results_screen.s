/* state_results_screen -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600955E - 0x060096DC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Results screen state handler — runs each frame during the post-race
 * results display. Manages the render pipeline, overlay drawing, and
 * state transitions for the results screen.
 *
 * Per-frame sequence:
 *   1. Check start button (status & 0x0800) → if pressed, set timer=0x1D,
 *      advance to game state 0x12 (post-results transition)
 *   2. Check race event bit 0 → if set, clear it, set state 0x14 (abort)
 *   3. If no active timer, increment frame counter
 *   4. If overlay active: call menu_overlay_render(0)
 *   5. race_update_ending() — update ending sequence logic
 *   6. camera_system() — update camera
 *   7. camera_orient_calc(yaw_ptr, pitch_ptr, params) — compute orientation
 *   8. scene_update() — update 3D scene
 *   9. Conditional: special render, geometry dispatch, HUD overlay
 *  10. frame_end_commit() — finalize frame
 *  11. Check race_complete_flag → if set, advance to state 0x11
 *
 * Persistent registers:
 *   r14 = game state pointer (g_game_state)
 *
 * Game state values written:
 *   0x11 = next state after results complete
 *   0x12 = start button skip (fast transition)
 *   0x14 = abort/cancel
 */

    .section .text.FUN_0600955E


    .global state_results_screen
    .type state_results_screen, @function
state_results_screen:
    mov.l r14, @-r15                        ! save r14 on stack
    sts.l pr, @-r15                         ! save return address on stack
    add #-0x4, r15                          ! allocate 4 bytes of local stack space
    .byte   0xDE, 0x0D    /* mov.l .L_game_state_ptr, r14 — game state dispatch */
    .byte   0xD3, 0x18    /* mov.l .L_status_word, r3 — input status word */
    mov.w @r3, r2                           ! r2 = read 16-bit input status
    extu.w r2, r2                           ! zero-extend to 32-bit
    mov.w   .L_start_button_mask, r3    /* 0x0800 = start button bit */
    and r3, r2                              ! isolate start button bit
    tst r2, r2                              ! test if start was pressed
    bt      .L_check_abort               /* start not pressed → skip */
    mov #0x1D, r3                           ! r3 = 0x1D (29 frames countdown)
    .byte   0xD2, 0x15    /* mov.l .L_timer_target, r2 — countdown timer */
    mov.l r3, @r2                           ! timer = 0x1D (29 frames)
    mov #0x12, r3                           ! r3 = state 0x12 (skip transition)
    mov.l r3, @r14                          ! game_state = 0x12
.L_check_abort:                             /* --- check race event abort --- */
    .byte   0xD4, 0x06    /* mov.l .L_race_event_flags, r4 — event bitfield */
    mov.l @r4, r0                           ! r0 = race event flags
    tst #0x1, r0                            ! test bit 0 (abort request)
    bt      .L_check_timer               /* not set → check timer */
    mov #-0x2, r3                           ! r3 = 0xFFFFFFFE (mask to clear bit 0)
    mov.l @r4, r2                           ! r2 = re-read event flags
    and r3, r2                              ! clear bit 0
    mov.l r2, @r4                           ! write back cleared flags
    mov #0x14, r3                           ! r3 = state 0x14 (abort)
    mov.l r3, @r14                          ! game_state = 0x14
    bra     .L_render_pipeline           /* → continue to render pipeline */
    nop                                     ! (branch delay slot)
.L_start_button_mask:
    .2byte  0x0800                        /* start button bit mask */
.L_race_event_flags:
    .4byte  sym_0607EBF4               /* race event bitfield (32-bit) */
.L_game_state_ptr:
    .4byte  g_game_state               /* current game state dispatch pointer */
    .4byte  sym_0607EAD0               /* (adjacent pool: race timer) */
    .4byte  sym_0607EBD0               /* (adjacent pool: frame counter) */
    .4byte  race_update_abort          /* (adjacent pool: abort handler) */
    .4byte  camera_system              /* (adjacent pool: camera system) */
    .4byte  sym_06063E24               /* (adjacent pool: camera yaw ptr) */
    .4byte  sym_06063EEC               /* (adjacent pool: camera pitch ptr) */
    .4byte  sym_06063EF8               /* (adjacent pool: camera params ptr) */
    .4byte  camera_orient_calc         /* (adjacent pool: camera orient fn) */
    .4byte  scene_update               /* (adjacent pool: scene update) */
    .4byte  frame_end_commit           /* (adjacent pool: frame commit) */
.L_status_word:
    .4byte  sym_06063D9A               /* input status word (16-bit) */
.L_timer_target:
    .4byte  sym_0607EACC               /* countdown timer target (32-bit) */
.L_check_timer:                             /* --- check timer / frame counter --- */
    .byte   0xD0, 0x2C    /* mov.l .L_race_timer, r0 — race timer */
    mov.l @r0, r0                           ! r0 = race timer value
    tst r0, r0                              ! test if timer is zero
    bf      .L_render_pipeline           /* timer active → skip increment */
    .byte   0xD4, 0x2B    /* mov.l .L_frame_counter, r4 — frame counter */
    mov.l @r4, r3                           ! r3 = current frame count
    add #0x1, r3                            ! increment frame count
    mov.l r3, @r4                           ! write back incremented counter
.L_render_pipeline:                         /* === Render pipeline === */
    .byte   0xD0, 0x2A    /* mov.l .L_overlay_active, r0 — overlay flag */
    mov.b @r0, r0                           ! r0 = overlay active flag (byte)
    tst r0, r0                              ! test if overlay is active
    bt      .L_call_race_ending          /* no overlay → skip */
    .byte   0xD3, 0x29    /* mov.l .L_fn_menu_overlay, r3 */
    jsr @r3                                 ! call menu_overlay_render(0)
    mov #0x0, r4                            ! arg0 = 0 (delay slot)
.L_call_race_ending:
    .byte   0xD3, 0x29    /* mov.l .L_fn_race_ending, r3 */
    jsr @r3                                 ! call race_update_ending()
    nop                                     ! (delay slot)
    .byte   0xD3, 0x28    /* mov.l .L_fn_camera_system, r3 */
    jsr @r3                                 ! call camera_system()
    nop                                     ! (delay slot)
    .byte   0xD6, 0x28    /* mov.l .L_camera_yaw_ptr, r6 */
    .byte   0xD5, 0x28    /* mov.l .L_camera_pitch_ptr, r5 */
    .byte   0xD4, 0x29    /* mov.l .L_camera_params_ptr, r4 */
    .byte   0xD3, 0x29    /* mov.l .L_fn_camera_orient, r3 */
    jsr @r3                                 ! call camera_orient_calc(yaw, pitch, params)
    mov.l @r6, r6                           ! r6 = dereference yaw pointer (delay slot)
    .byte   0xD3, 0x29    /* mov.l .L_fn_scene_update, r3 */
    jsr @r3                                 ! call scene_update()
    nop                                     ! (delay slot)
    .byte   0xD0, 0x28    /* mov.l .L_special_render_flag, r0 — check special render */
    mov.w @r0, r0                           ! r0 = special render flag (16-bit)
    extu.w r0, r0                           ! zero-extend to 32-bit
    tst r0, r0                              ! test if special render needed
    bt      .L_check_geom_render            ! not needed → skip
    .byte   0xD3, 0x27    /* mov.l .L_fn_special_render, r3 */
    jsr @r3                                 ! call special_render()
    nop                                     ! (delay slot)
.L_check_geom_render:                       /* --- conditional geometry render --- */
    .byte   0xD0, 0x26    /* mov.l .L_geom_render_flag, r0 — check geom flag */
    mov.b @r0, r0                           ! r0 = geometry render flag (byte)
    extu.b r0, r0                           ! zero-extend to 32-bit
    tst r0, r0                              ! test if geometry render needed
    bt      .L_check_car_timer              ! not needed → skip
    .byte   0xD7, 0x25    /* mov.l .L_geom_data_ptr, r7 — geometry data */
    .byte   0xD6, 0x25    /* mov.l .L_mask_nibble3, r6 — 0xF000 */
    mov.w   .L_tile_size, r5              ! r5 = 0x0082 (tile size parameter)
    .byte   0xD3, 0x25    /* mov.l .L_fn_geom_dispatch, r3 */
    jsr @r3                                 ! call geom_dispatch(8, 0x82, 0xF000, geom_data)
    mov #0x8, r4                            ! arg0 = 8 (delay slot)
.L_check_car_timer:                         /* --- check car timer for sub-call --- */
    .byte   0xD2, 0x25    /* mov.l .L_car_state_ptr, r2 — car state base */
    mov.w   .L_car_timer_offset, r0       ! r0 = 0x00BC (timer offset in car struct)
    mov.l @r2, r2                           ! r2 = dereference car state pointer
    mov.l @(r0, r2), r3                     ! r3 = car[+0xBC] (timer value)
    cmp/pl r3                               ! test if timer > 0
    bf      .L_frame_commit              /* timer <= 0 → skip */
    .byte   0xB5, 0x21    /* bsr 0x0600A084 (external sub-function) */
    nop                                     ! (delay slot)
.L_frame_commit:                            /* --- frame commit --- */
    .byte   0xD3, 0x22    /* mov.l .L_fn_frame_commit, r3 */
    jsr @r3                                 ! call frame_end_commit()
    nop                                     ! (delay slot)
    .byte   0xD0, 0x1F    /* mov.l .L_car_state_ptr, r0 */
    mov.w   .L_car_flags_offset, r1       ! r1 = 0x0214 (flags offset in car struct)
    mov.l @r0, r0                           ! r0 = dereference car state pointer
    mov.l @(r0, r1), r0                     ! r0 = car[+0x214] (flags word)
    tst #0xCC, r0                           ! test bits 7,6,3,2 (race status flags)
    bf      .L_check_race_complete       /* any set → skip layer setup */
    .byte   0xD3, 0x1E    /* mov.l .L_display_layer_data, r3 — layer params */
    mov.l r3, @r15                          ! store layer_data ptr in local stack var
    mov r3, r7                              ! r7 = layer_data (for +4 offset deref)
    mov r3, r5                              ! r5 = layer_data (for +0 offset deref)
    mov.w   .L_layer_priority, r6           ! r6 = 0x0900 (display priority)
    mov.l @(4, r7), r7                      ! r7 = layer_data[+4] (tile data)
    mov.l @r5, r5                           ! r5 = layer_data[+0] (source data)
    .byte   0xD3, 0x1C    /* mov.l .L_fn_layer_setup, r3 */
    jsr @r3                                 ! call layer_setup(4, src, tile, 0x0900)
    mov #0x4, r4                            ! arg0 = 4 (delay slot)
.L_check_race_complete:                     /* --- check race complete → advance state --- */
    .byte   0xD0, 0x1B    /* mov.l .L_race_complete_flag, r0 */
    mov.l @r0, r0                           ! r0 = race complete flag
    tst r0, r0                              ! test if race is complete
    bf      .L_epilogue                  /* not complete → return */
    mov #0x11, r3                           ! r3 = state 0x11 (results done)
    mov.l r3, @r14                          ! game_state = 0x11
.L_epilogue:
    add #0x4, r15                           ! deallocate local stack space
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_tile_size:
    .2byte  0x0082                        /* geometry tile size parameter */
.L_car_timer_offset:
    .2byte  0x00BC                        /* car struct offset: timer value */
.L_car_flags_offset:
    .2byte  0x0214                        /* car struct offset: flags word */
.L_layer_priority:
    .2byte  0x0900                        /* display layer priority value */
.L_race_timer:
    .4byte  sym_0607EAD0               /* race timer (32-bit) */
.L_frame_counter:
    .4byte  sym_0607EBD0               /* frame counter (32-bit) */
.L_overlay_active:
    .4byte  sym_0605AB18               /* overlay active flag (byte) */
.L_fn_menu_overlay:
    .4byte  menu_overlay_render        /* menu overlay render function */
.L_fn_race_ending:
    .4byte  race_update_ending         /* race ending update */
.L_fn_camera_system:
    .4byte  camera_system              /* camera system update */
.L_camera_yaw_ptr:
    .4byte  sym_06063E24               /* camera yaw data pointer */
.L_camera_pitch_ptr:
    .4byte  sym_06063EEC               /* camera pitch data pointer */
.L_camera_params_ptr:
    .4byte  sym_06063EF8               /* camera parameters pointer */
.L_fn_camera_orient:
    .4byte  camera_orient_calc         /* camera orientation calculation */
.L_fn_scene_update:
    .4byte  scene_update               /* 3D scene update */
.L_special_render_flag:
    .4byte  sym_0607ED8C               /* special render enable (16-bit) */
.L_fn_special_render:
    .4byte  sym_060033E6               /* special render function */
.L_geom_render_flag:
    .4byte  sym_06086030               /* geometry render enable (byte) */
.L_geom_data_ptr:
    .4byte  sym_0605A1C8               /* geometry data pointer */
.L_mask_nibble3:
    .4byte  0x0000F000                  /* nibble 3 mask */
.L_fn_geom_dispatch:
    .4byte  sym_060283E0               /* geometry render dispatch */
.L_car_state_ptr:
    .4byte  sym_0607E944               /* car state base pointer */
.L_fn_frame_commit:
    .4byte  frame_end_commit           /* frame end commit */
.L_display_layer_data:
    .4byte  sym_06063798               /* display layer parameters */
.L_fn_layer_setup:
    .4byte  sym_06028400               /* display layer setup */
.L_race_complete_flag:
    .4byte  sym_0605A1C4               /* race complete flag (32-bit) */
