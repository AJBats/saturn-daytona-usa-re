/* time_delta_format -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015C5E - 0x06015CAC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * time_delta_format(car_index):
 *   Initializes 8 time-delta HUD element slots for animation. Writes
 *   the initial animation counter value (0xFFFFE000) to offset 0x30
 *   of each 68-byte slot struct in the slot data array. After all
 *   slots are initialized, restores the car_index argument and
 *   tail-calls clear_vdp2_registers to reset display state.
 *
 * Slot struct: 68 bytes per slot (stride = idx*4 + idx*64)
 *   +0x30  animation counter (32-bit signed, initial = 0xFFFFE000)
 *
 * Persistent registers:
 *   r12 = slot data array base (sym_06084FC8)
 *   r13 = initial animation counter (0xFFFFE000)
 *   r14 = total slot count (0x8)
 *
 * Args: r4 = car_index (saved on stack, passed through to tail call)
 */

    .section .text.FUN_06015C5E


    .global time_delta_format
    .type time_delta_format, @function
time_delta_format:
    mov.l r14, @-r15                      ! save r14
    mov.l r13, @-r15                      ! save r13
    mov.l r12, @-r15                      ! save r12
    add #-0x4, r15                        ! allocate 4 bytes for car_index
    .byte   0xDC, 0x0E    /* mov.l .L_pool_slot_data_base, r12 */  ! r12 = slot data array base
    mov.w   .L_wpool_06015C9C, r13        ! r13 = 0xFFFFE000 (initial anim counter)
    mov #0x8, r14                         ! r14 = 0x8 (total slot count)
    mov.b r4, @r15                        ! save car_index on stack
    mov #0x0, r4                          ! r4 = 0x0 (loop index)
.L_slot_init_loop:
    extu.b r4, r3                         ! r3 = idx (zero-extended)
    mov r3, r2                            ! r2 = idx (copy for stride calc)
    add #0x1, r4                          ! idx++
    shll2 r3                              ! r3 = idx * 0x4
    shll2 r2                              ! r2 = idx * 0x4
    shll2 r2                              ! r2 = idx * 0x10
    shll2 r2                              ! r2 = idx * 0x40 (64)
    add r2, r3                            ! r3 = idx*0x40 + idx*0x4 = idx*0x44 (68-byte stride)
    exts.w r3, r3                         ! sign-extend stride offset to 32-bit
    add r12, r3                           ! r3 = &slot_data[idx] (struct base)
    mov.l r13, @(48, r3)                  ! slot[idx].anim_counter = 0xFFFFE000
    extu.b r4, r3                         ! r3 = next idx (zero-extended)
    cmp/ge r14, r3                        ! next idx >= 0x8?
    bf      .L_slot_init_loop             ! if not, continue loop
    mov.b @r15, r4                        ! restore car_index from stack
    extu.b r4, r4                         ! zero-extend car_index
    add #0x4, r15                         ! free stack slot
    mov.l @r15+, r12                      ! restore r12
    mov.l @r15+, r13                      ! restore r13
    .byte   0xD3, 0x04    /* mov.l .L_pool_clear_vdp2_regs, r3 */  ! r3 = clear_vdp2_registers addr
    jmp @r3                               ! tail-call clear_vdp2_registers
    mov.l @r15+, r14                      ! restore r14 (delay slot)
.L_wpool_06015C9C:
    .2byte  0xE000                        ! initial anim counter (sign-ext to 0xFFFFE000)
    .2byte  0xFFFF                        ! padding / alignment
.L_pool_slot_data_base:
    .4byte  sym_06084FC8                  ! slot data array base
    .4byte  sym_0605B8B0                  ! display handler fn ptr table (unused by this TU)
.L_pool_clear_vdp2_regs:
    .4byte  sym_060172E4                  ! clear_vdp2_registers function
