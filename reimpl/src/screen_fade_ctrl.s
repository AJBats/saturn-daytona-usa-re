/* screen_fade_ctrl -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602843A - 0x060284BA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains two entry points:
 *
 * screen_fade_ctrl (FUN_0602843A):
 *   Composites a tiled fade/effect overlay into a VRAM framebuffer. Looks up
 *   the target VRAM buffer from the VRAM pointer table (sym_06028614) indexed
 *   by the original r4, then calls a data lookup function (0x06028306) to
 *   obtain a tile index map pointer. Reads a 12-byte object template entry
 *   from the template table (sym_06063690) at the offset given in r6:
 *
 *   Template entry layout (12 bytes at sym_06063690 + r6):
 *     +0x00: .4byte  source pixel data base pointer
 *     +0x04: .2byte  color bias (added to each pixel word before writing)
 *     +0x06: .byte   tile width (words per row to copy per tile)
 *     +0x07: .byte   row count (number of source rows / outer iterations)
 *     +0x08: .byte   tile stride (bytes between tile starts in source)
 *     +0x09: .byte   tiles per row (number of tiles composited per row)
 *     +0x0A: .2byte  VRAM row skip (bytes added to dest ptr between rows)
 *
 *   For each row, reads tiles_per_row bytes from the tile index map. Each
 *   byte is multiplied by the tile stride to compute an offset into the
 *   source pixel data. Then tile_width words are copied from source to
 *   dest VRAM with the color bias added to each pixel.
 *
 *   NOTE: The callee-save prologue (r8, r9, r11, r12, r13) is in the
 *   previous TU (screen_flash_effect, sym_06028430). This function saves
 *   only r14 and PR, and the epilogue restores all seven registers.
 *
 *   Entry registers (at sym_06028430 prologue):
 *     r4  = VRAM pointer table index (selects framebuffer)
 *     r5  = destination offset within VRAM buffer
 *     r6  = byte offset into template table (selects template entry)
 *     r7  = parameter for tile index map lookup (passed to 0x06028306)
 *
 *   Returns: void (writes directly to VRAM)
 *
 * sym_060284AE (geom_dispatch_final prologue):
 *   Saves callee-saved registers r8-r13. Entry point for the geometry/text
 *   dispatch renderer whose body continues in the next TU (motion_blur_effect).
 */

    .section .text.FUN_0602843A


    .global screen_fade_ctrl
    .type screen_fade_ctrl, @function
screen_fade_ctrl:
    mov.l r14, @-r15                              ! save r14 (callee-saved)
    sts.l pr, @-r15                               ! save PR (return address)
    .byte   0xD0, 0x19    /* mov.l _pool_vram_ptr_table, r0 */ ! r0 = &vram_pointer_table (sym_06028614)
    mov.l @(r0, r4), r4                           ! r4 = vram_pointer_table[index] (ptr to VRAM base)
    mov.l @r4, r4                                 ! r4 = *ptr = VRAM base address
    add r4, r5                                    ! r5 = VRAM base + dest_offset = dest write pointer
    .byte   0xBF, 0x5E    /* bsr 0x06028306 (external) */ ! call tile_index_map_lookup(r4)
    mov r7, r4                                    ! (delay slot) r4 = lookup parameter (originally r7)
    .byte   0xD1, 0x17    /* mov.l _pool_template_base, r1 */ ! r1 = template table base (sym_06063690)
    add r1, r6                                    ! r6 = template_base + offset = template entry ptr
    mov.l @r6+, r1                                ! r1 = [+0x00] source pixel data base pointer
    mov.w @r6+, r2                                ! r2 = [+0x04] color bias (16-bit)
    mov.b @r6+, r3                                ! r3 = [+0x06] tile width (words per row per tile)
    mov.b @r6+, r4                                ! r4 = [+0x07] row count (outer loop iterations)
    mov.b @r6+, r11                               ! r11 = [+0x08] tile stride (bytes between tiles)
    mov.b @r6+, r8                                ! r8 = [+0x09] tiles per row
    mov.w @r6+, r12                               ! r12 = [+0x0A] VRAM row skip (dest stride padding)
    mov r8, r13                                   ! r13 = tiles_per_row
    add #-0xC, r13                                ! r13 = tiles_per_row - 12
    neg r13, r13                                  ! r13 = 12 - tiles_per_row (unused map bytes per row)
    add r13, r0                                   ! r0 = map_ptr + (12 - tiles_per_row) = adjusted start
    mov r12, r6                                   ! r6 = VRAM row skip (for use between row groups)
    mov r0, r14                                   ! r14 = adjusted tile index map pointer (saved)
.L_row_group:
    mov r8, r12                                   ! r12 = tiles_per_row (tile loop counter)
    mov r14, r0                                   ! r0 = tile index map read pointer (reset each row)
.L_tile_loop:
    mov r3, r13                                   ! r13 = tile_width (pixel loop counter)
    mov r1, r9                                    ! r9 = source pixel data base
    mov.b @r0+, r7                                ! r7 = tile index from map
    mulu.w r7, r11                                ! macl = tile_index * tile_stride
    sts macl, r7                                  ! r7 = source offset for this tile
    add r7, r9                                    ! r9 = source_base + offset = tile pixel pointer
.L_pixel_loop:
    mov.w @r9, r7                                 ! r7 = source pixel word
    add r2, r7                                    ! r7 += color_bias (apply fade/tint)
    mov.w r7, @r5                                 ! write biased pixel to dest VRAM
    add #0x2, r9                                  ! advance source pointer by one word
    dt r13                                        ! decrement pixel counter
    bf/s    .L_pixel_loop                         ! loop if more pixels in this tile
    add #0x2, r5                                  ! (delay slot) advance dest pointer by one word
    dt r12                                        ! decrement tile counter
    bf      .L_tile_loop                          ! loop if more tiles in this row
    add r3, r1                                    ! source_base += tile_width (advance by r3 bytes)
    add r3, r1                                    ! source_base += tile_width again (total: r3*2 = one row of words)
    dt r4                                         ! decrement row group counter
    bf/s    .L_row_group                          ! loop if more row groups
    add r6, r5                                    ! (delay slot) dest += VRAM row skip (pad to stride)
    lds.l @r15+, pr                               ! restore PR (return address)
    mov.l @r15+, r14                              ! restore r14
    mov.l @r15+, r13                              ! restore r13
    mov.l @r15+, r12                              ! restore r12
    mov.l @r15+, r11                              ! restore r11
    mov.l @r15+, r9                               ! restore r9
    rts                                           ! return to caller
    mov.l @r15+, r8                               ! (delay slot) restore r8
_pool_vram_ptr_table:
    .4byte  sym_06028614
_pool_template_base:
    .4byte  sym_06063690
    .2byte  0x0009

    .global sym_060284AE
sym_060284AE:
/* geom_dispatch_final prologue â€” saves callee-saved registers.
 * Function body continues in the next TU (motion_blur_effect).
 */
    mov.l r8, @-r15                               ! save r8
    mov.l r9, @-r15                               ! save r9
    mov.l r10, @-r15                              ! save r10
    mov.l r11, @-r15                              ! save r11
    mov.l r12, @-r15                              ! save r12
    mov.l r13, @-r15                              ! save r13
