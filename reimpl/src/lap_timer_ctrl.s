/* lap_timer_ctrl -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601228C - 0x060122F4
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0601228C


    .global lap_timer_ctrl
    .type lap_timer_ctrl, @function

/*
 * lap_timer_ctrl -- Lap progress state machine
 *
 * Frame-based threshold controller that drives lap transition visuals.
 * Reads a countdown/frame counter from sym_0607EBCC and dispatches to
 * different rendering paths based on the counter value:
 *
 *   counter >= threshold (r2 arg):  RACE FINISHING
 *     - Apply position/velocity limits (position_vel_limiter)
 *     - Render lightweight HUD lap indicator (hud_lap_gfx_update)
 *     - Tail-jump to race finish check
 *
 *   counter >= 100 (0x64):  LATE ANIMATION
 *     - Reset rotation angle to 0
 *     - Render lightweight HUD lap indicator (hud_lap_gfx_update)
 *     - Tail-jump to race finish check
 *
 *   counter >= 40 (0x28):  EARLY ANIMATION
 *     - Reset rotation angle to 0
 *     - Render full 3D lap display animation (lap_display_anim)
 *     - Tail-jump to race finish check
 *
 *   counter < 40:  INITIALIZE
 *     - Set counter to 1
 *     - Set display parameter to 0x10
 *     - Set replay mode flag to 1
 *     - Return (no tail-jump)
 *
 * Arguments:
 *   r2 = finishing threshold (counter value above which race is ending)
 *
 * Return value: none (tail-jumps to race finish check, or returns directly)
 */
lap_timer_ctrl:
    sts.l pr, @-r15                            ! save return address
    mov.l   .L_pool_frame_counter, r4          ! r4 = &frame_counter (sym_0607EBCC)
    mov.l @r4, r3                              ! r3 = current frame counter value
    cmp/ge r2, r3                              ! T = (counter >= finishing_threshold)?
    bf      .L_not_finishing                    ! if counter < threshold, skip finishing path
    .byte   0xB0, 0x2D    /* bsr 0x060122F4 (external) */  ! call position_vel_limiter — enforce min bounds
    nop                                        ! (delay slot)
    .byte   0xB1, 0x37    /* bsr 0x0601250C (external) */  ! call hud_lap_gfx_update — lightweight HUD render
    nop                                        ! (delay slot)
    .byte   0xA2, 0x37    /* bra 0x06012710 (external) */  ! tail-jump to race finish check
    lds.l @r15+, pr                            ! (delay slot) restore return address
.L_not_finishing:
    mov #0x64, r3                              ! r3 = 100 (late animation threshold)
    mov.l   .L_pool_rotation_angle, r6         ! r6 = &rotation_angle (sym_060788B2, 16-bit)
    mov.l @r4, r2                              ! r2 = frame counter (re-read from memory)
    cmp/ge r3, r2                              ! T = (counter >= 100)?
    bf/s    .L_below_100                       ! if counter < 100, check next threshold
    mov #0x0, r5                               ! (delay slot) r5 = 0 (rotation angle reset value)
    exts.w r5, r5                              ! sign-extend r5 to word (0x0000)
    .byte   0xB1, 0x2C    /* bsr 0x0601250C (external) */  ! call hud_lap_gfx_update — lightweight HUD render
    mov.w r5, @r6                              ! (delay slot) reset rotation angle to 0
    .byte   0xA2, 0x2C    /* bra 0x06012710 (external) */  ! tail-jump to race finish check
    lds.l @r15+, pr                            ! (delay slot) restore return address
.L_below_100:
    mov.l @r4, r2                              ! r2 = frame counter (re-read from memory)
    mov #0x28, r3                              ! r3 = 40 (early animation threshold)
    cmp/ge r3, r2                              ! T = (counter >= 40)?
    bf      .L_initialize                      ! if counter < 40, go to init path
    exts.w r5, r5                              ! sign-extend r5 to word (0x0000)
    .byte   0xB1, 0x85    /* bsr 0x060125D0 (external) */  ! call lap_display_anim — full 3D animation
    mov.w r5, @r6                              ! (delay slot) reset rotation angle to 0
    .byte   0xA2, 0x23    /* bra 0x06012710 (external) */  ! tail-jump to race finish check
    lds.l @r15+, pr                            ! (delay slot) restore return address
    .2byte  0xFFFF                             ! padding (unused)
    .4byte  sym_06078636                       ! pool: replay mode flag (byte)
    .4byte  0xAE110FFF                         ! pool: SCSP sound command ID
    .4byte  sound_cmd_dispatch                 ! pool: &sound_cmd_dispatch
.L_pool_frame_counter:
    .4byte  sym_0607EBCC                       ! pool: &frame counter (32-bit, WRAM High)
.L_pool_rotation_angle:
    .4byte  sym_060788B2                       ! pool: &rotation angle (16-bit, WRAM High)
.L_initialize:
    mov #0x1, r5                               ! r5 = 1 (init value for counter and flag)
    mov #0x10, r2                              ! r2 = 0x10 (display parameter value)
    mov.l r5, @r4                              ! *frame_counter = 1 (reset counter)
    exts.b r5, r5                              ! sign-extend r5 to byte (0x01)
    .byte   0xD3, 0x10    /* mov.l .L_pool_0601232C, r3 */  ! r3 = &game_state_dispatch (g_game_state, in next TU pool)
    mov.l r2, @r3                              ! *game_state_dispatch = 0x10 (set display parameter)
    .byte   0xD3, 0x10    /* mov.l .L_pool_06012330, r3 */  ! r3 = &replay_mode_flag (sym_06078636, in next TU pool)
    lds.l @r15+, pr                            ! restore return address
    rts                                        ! return to caller
    mov.b r5, @r3                              ! (delay slot) *replay_mode_flag = 1
