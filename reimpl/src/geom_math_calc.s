/* geom_math_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06018166 - 0x06018278
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track segment slot updater â€” per-frame maintenance of projection slot data.
 *
 * Called each frame to update two slot entries in the per-slot data table
 * (sym_06063F64) based on the current segment frame counter and car position:
 *
 *   1. Increments the segment frame counter (sym_0605BE2C, 16-bit)
 *   2. Reads the car struct position field (offset 0x021C) and compares
 *      against (max_lap_count - 1) to determine which projection config
 *      pointer to use:
 *        - position >= threshold: use proj_param_b (sym_06089E2C), flag=1
 *        - position <  threshold: use proj_config   (sym_06089E28), flag=0
 *   3. Looks up primary and secondary slot indices from the track data table
 *      (offsets 0x1618 and 0x1630 into sym_060684EC)
 *   4. If frame counter <= 5 (incremental mode):
 *        Adds +0x90 to both primary and secondary slot entries
 *   5. If frame counter > 5 (reset mode):
 *        Stores the projection pointer directly into primary slot,
 *        stores proj_param_a (sym_06089E30) into secondary slot,
 *        resets frame counter to 0
 *   6. If the flag was set (position >= threshold), writes 0x056C into
 *      offset 6 of the primary slot entry; otherwise writes 0x0035
 *   7. Checks game state flag bit 23 (0x00800000 in sym_0607EBC4):
 *        - Set:   tail-call track_utility_misc
 *        - Clear: tail-call vdp2_scroll_config
 */

    .section .text.FUN_06018166


    .global geom_math_calc
    .type geom_math_calc, @function
geom_math_calc:
    mov.l r14, @-r15                         ! save r14
    mov.l r13, @-r15                         ! save r13
    mov.l r12, @-r15                         ! save r12
    mov.l r11, @-r15                         ! save r11
    mov.w   DAT_06018212, r11                ! r11 = 0x1618 (primary slot index offset into track data)
    .byte   0xDC, 0x2C    /* mov.l .L_pool_seg_frame_ctr, r12 */  ! r12 = &seg_frame_ctr (sym_0605BE2C)
    .byte   0xDD, 0x2D    /* mov.l .L_pool_slot_table_base, r13 */  ! r13 = per-slot data table base (sym_06063F64)
    .byte   0xDE, 0x2D    /* mov.l .L_pool_track_data_base, r14 */  ! r14 = track data / index table (sym_060684EC)
    .byte   0xD4, 0x2E    /* mov.l .L_pool_car_array_ptr, r4 */  ! r4 = &car_array_base_ptr (sym_0607E944)
    mov.w @r12, r3                           ! r3 = seg_frame_ctr (16-bit)
    mov.l @r4, r4                            ! r4 = car_array_base (deref pointer)
    add #0x1, r3                             ! seg_frame_ctr++
    mov.w r3, @r12                           ! store incremented counter
    .byte   0xD2, 0x2C    /* mov.l .L_pool_max_lap_count, r2 */  ! r2 = &max_lap_count (sym_06063F28)
    mov.w   DAT_06018214, r0                 ! r0 = 0x021C (car struct position field offset)
    mov.l @r2, r2                            ! r2 = max_lap_count value
    mov.l @(r0, r4), r3                      ! r3 = car_array[0x021C] (current position)
    add #-0x1, r2                            ! r2 = max_lap_count - 1
    cmp/hs r2, r3                            ! T = (position >= threshold)?
    bf      .L_below_threshold               ! branch if position < threshold
    .byte   0xD4, 0x2A    /* mov.l .L_pool_proj_param_b, r4 */  ! r4 = &proj_param_b (sym_06089E2C)
    mov.l @r4, r4                            ! r4 = proj_param_b value
    bra     .L_config_chosen                 ! skip to common path
    mov #0x1, r5                             ! r5 = 1 (above-threshold flag)
.L_below_threshold:
    .byte   0xD4, 0x29    /* mov.l .L_pool_proj_config, r4 */  ! r4 = &proj_config (sym_06089E28)
    mov.l @r4, r4                            ! r4 = proj_config value
    mov #0x0, r5                             ! r5 = 0 (below-threshold flag)
.L_config_chosen:
    mov.w   DAT_06018216, r6                 ! r6 = 0x1630 (secondary slot index offset into track data)
    mov #0x5, r3                             ! r3 = 5 (frame counter threshold)
    mov.w @r12, r2                           ! r2 = seg_frame_ctr
    cmp/gt r3, r2                            ! T = (frame_ctr > 5)?
    bt      .L_reset_mode                    ! branch if counter > 5 (reset mode)
    mov.w   .L_wpool_slot_increment, r4      ! r4 = 0x0090 (per-frame slot increment)
    mov r14, r3                              ! r3 = track_data_base
    add r14, r6                              ! r6 = &track_data[0x1630] (secondary slot index addr)
    add r11, r3                              ! r3 = &track_data[0x1618] (primary slot index addr)
    mov.w @r3, r2                            ! r2 = primary slot index (16-bit)
    extu.w r2, r2                            ! zero-extend to 32-bit
    shll2 r2                                 ! r2 *= 4
    shll r2                                  ! r2 *= 2 (total: index * 8 = slot stride)
    add r13, r2                              ! r2 = &slot_table[primary]
    mov.l @r2, r3                            ! r3 = slot_table[primary].ptr
    add r4, r3                               ! r3 += 0x0090 (increment slot value)
    mov.l r3, @r2                            ! store updated slot_table[primary].ptr
    mov.w @r6, r2                            ! r2 = secondary slot index (16-bit)
    extu.w r2, r2                            ! zero-extend to 32-bit
    shll2 r2                                 ! r2 *= 4
    shll r2                                  ! r2 *= 2 (total: index * 8)
    add r13, r2                              ! r2 = &slot_table[secondary]
    mov.l @r2, r3                            ! r3 = slot_table[secondary].ptr
    add r4, r3                               ! r3 += 0x0090 (increment slot value)
    mov.l r3, @r2                            ! store updated slot_table[secondary].ptr
    bra     .L_check_flag                    ! jump to flag check
    nop                                      ! delay slot
.L_reset_mode:
    mov r14, r2                              ! r2 = track_data_base
    add r14, r6                              ! r6 = &track_data[0x1630] (secondary slot index addr)
    add r11, r2                              ! r2 = &track_data[0x1618] (primary slot index addr)
    mov.w @r2, r3                            ! r3 = primary slot index (16-bit)
    extu.w r3, r3                            ! zero-extend to 32-bit
    shll2 r3                                 ! r3 *= 4
    shll r3                                  ! r3 *= 2 (total: index * 8)
    add r13, r3                              ! r3 = &slot_table[primary]
    mov.l r4, @r3                            ! slot_table[primary].ptr = proj config (direct store)
    mov.w @r6, r2                            ! r2 = secondary slot index (16-bit)
    extu.w r2, r2                            ! zero-extend to 32-bit
    shll2 r2                                 ! r2 *= 4
    shll r2                                  ! r2 *= 2 (total: index * 8)
    add r13, r2                              ! r2 = &slot_table[secondary]
    .byte   0xD3, 0x14    /* mov.l .L_pool_proj_param_a, r3 */  ! r3 = &proj_param_a (sym_06089E30)
    mov.l @r3, r3                            ! r3 = proj_param_a value
    mov.l r3, @r2                            ! slot_table[secondary].ptr = proj_param_a
    mov #0x0, r2                             ! r2 = 0
    mov.w r2, @r12                           ! seg_frame_ctr = 0 (reset counter)
.L_check_flag:
    extu.w r5, r5                            ! zero-extend flag to 32-bit
    tst r5, r5                               ! test flag
    bt      .L_flag_clear                    ! branch if flag == 0 (below threshold)
    mov r14, r3                              ! r3 = track_data_base
    add r11, r3                              ! r3 = &track_data[0x1618] (primary slot index addr)
    mov.w @r3, r2                            ! r2 = primary slot index
    extu.w r2, r2                            ! zero-extend
    shll2 r2                                 ! r2 *= 4
    shll r2                                  ! r2 *= 2 (total: index * 8)
    add r13, r2                              ! r2 = &slot_table[primary]
    mov.w   DAT_0601821a, r0                 ! r0 = 0x056C (slot flag: above-threshold marker)
    bra     .L_write_slot_flag               ! jump to write flag + tail dispatch
    mov.w r0, @(6, r2)                       ! slot_table[primary].flag_w6 = 0x056C (delay slot)

    .global DAT_06018212
DAT_06018212:
    .2byte  0x1618                           /* track data offset: primary slot index */

    .global DAT_06018214
DAT_06018214:
    .2byte  0x021C                           /* car struct offset: position field */

    .global DAT_06018216
DAT_06018216:
    .2byte  0x1630                           /* track data offset: secondary slot index */
.L_wpool_slot_increment:
    .2byte  0x0090                           /* per-frame slot value increment */

    .global DAT_0601821a
DAT_0601821a:
    .2byte  0x056C                           /* slot flag value: above-threshold marker */
    .4byte  sym_06026DF8                     /* (out-of-TU pool) pop matrix frame cleanup */
    .4byte  obj_overlay_render               /* (out-of-TU pool) overlay render function */
.L_pool_seg_frame_ctr:
    .4byte  sym_0605BE2C                     /* segment frame counter (16-bit) */
.L_pool_slot_table_base:
    .4byte  sym_06063F64                     /* per-slot data table base (8-byte stride) */
.L_pool_track_data_base:
    .4byte  sym_060684EC                     /* track data / index mapping table */
.L_pool_car_array_ptr:
    .4byte  sym_0607E944                     /* car array base pointer */
.L_pool_max_lap_count:
    .4byte  sym_06063F28                     /* maximum lap count for current race */
.L_pool_proj_param_b:
    .4byte  sym_06089E2C                     /* projection param B (above-threshold config) */
.L_pool_proj_config:
    .4byte  sym_06089E28                     /* projection config (below-threshold config) */
.L_pool_proj_param_a:
    .4byte  sym_06089E30                     /* projection param A (reset target for secondary slot) */
.L_flag_clear:
    mov r14, r2                              ! r2 = track_data_base
    add r11, r2                              ! r2 = &track_data[0x1618] (primary slot index addr)
    mov.w @r2, r3                            ! r3 = primary slot index
    extu.w r3, r3                            ! zero-extend
    shll2 r3                                 ! r3 *= 4
    shll r3                                  ! r3 *= 2 (total: index * 8)
    add r13, r3                              ! r3 = &slot_table[primary]
    .byte   0x92, 0x4E    /* mov.w .L_wpool_060182F2, r2 */  ! r2 = 0x0035 (cross-TU: DAT_060182f2, slot flag: below-threshold)
    mov r2, r0                               ! r0 = 0x0035
    mov.w r0, @(6, r3)                       ! slot_table[primary].flag_w6 = 0x0035
.L_write_slot_flag:
    .byte   0xD3, 0x27    /* mov.l .L_pool_060182F8, r3 */  ! r3 = &game_state_flags (cross-TU: sym_0607EBC4)
    .byte   0xD2, 0x28    /* mov.l .L_pool_060182FC, r2 */  ! r2 = 0x00800000 (bit 23 mask)
    mov.l @r3, r3                            ! r3 = game_state_flags value
    and r2, r3                               ! r3 = flags & 0x00800000 (isolate bit 23)
    tst r3, r3                               ! test: is bit 23 set?
    bt      .L_scroll_config_path            ! branch if bit 23 clear
    mov.l @r15+, r11                         ! restore r11
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    .byte   0xA1, 0xB5    /* bra 0x060185D8 (external) */  ! tail-call track_utility_misc
    mov.l @r15+, r14                         ! restore r14 (delay slot)
.L_scroll_config_path:
    mov.l @r15+, r11                         ! restore r11
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    .byte   0xA0, 0x54    /* bra 0x06018320 (external) */  ! tail-call vdp2_scroll_config
    mov.l @r15+, r14                         ! restore r14 (delay slot)
