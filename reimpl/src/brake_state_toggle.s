/* brake_state_toggle -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060103B8 - 0x06010470
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Brake state toggle â€” updates the brake press counter based on input flags,
 * then triggers DMA transfers to load the appropriate brake light tile data.
 *
 * Input:
 *   r4 = input button flags (16-bit, zero-extended)
 *        bit 15 (0x8000) = brake pressed this frame
 *        bit 14 (0x4000) = brake released this frame
 *
 * Behavior:
 *   1. If brake-pressed flag is set AND press counter < 1, increment counter.
 *   2. If brake-released flag is set AND press counter > 0, decrement counter.
 *   3. Copy counter value to two output locations (display mirror + shadow).
 *   4. If counter != 0 (brake is on):
 *        DMA brake-on tile data from tile_table_on[idx] to dma_dst_a
 *        DMA brake-on tile data from tile_table_on_b[idx] to dma_dst_b
 *   5. If counter == 0 (brake is off):
 *        DMA brake-off tile data from tile_table_off[idx] to dma_dst_a
 *        DMA brake-off tile data from tile_table_off_b[idx] to dma_dst_b
 *
 * Symbols:
 *   sym_0607EADC = brake press counter (dword)
 *   sym_0607EAB8 = brake display mirror (dword, copy of counter)
 *   sym_06078868 = brake state shadow (dword, second copy)
 *   sym_06078884 = DMA destination A (tile slot A address, dword ptr)
 *   sym_06078880 = DMA destination B (tile slot B address, dword ptr)
 *   sym_0605D084 = brake-on tile source table A (array of pointers)
 *   sym_0605D060 = brake-on tile source table B (array of pointers)
 *   sym_0605D05C = brake-off tile source table A (array of pointers)
 *   sym_0605D088 = brake-off tile source table B (array of pointers)
 *   dma_transfer = DMA transfer function: dma_transfer(dst, src, size)
 */

    .section .text.FUN_060103B8


    .global brake_state_toggle
    .type brake_state_toggle, @function
brake_state_toggle:
    mov.l r14, @-r15                    ! save r14
    extu.w r4, r3                       ! r3 = input flags (zero-extend to 32-bit)
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_pool_press_counter, r14  ! r14 = &brake_press_counter
    mov.l   .L_fp_half, r2             ! r2 = 0x8000 (brake-pressed bit mask)
    and r2, r3                          ! r3 = flags & 0x8000
    tst r3, r3                          ! brake-pressed bit set?
    bt      .L_check_release            !   no -> skip increment, check release
    mov #0x1, r2                        ! r2 = 1 (threshold)
    mov.l   .L_pool_press_counter, r3   ! r3 = &brake_press_counter
    mov.l @r3, r3                       ! r3 = current counter value
    cmp/ge r2, r3                       ! counter >= 1?
    bt      .L_check_release            !   yes -> already pressed, skip increment
    mov.l @r14, r2                      ! r2 = counter value
    add #0x1, r2                        ! r2 = counter + 1
    mov.l r2, @r14                      ! store incremented counter
.L_check_release:
    extu.w r4, r4                       ! r4 = input flags (zero-extend)
    mov.w   DAT_0601043e, r3            ! r3 = 0x4000 (brake-released bit mask)
    and r3, r4                          ! r4 = flags & 0x4000
    tst r4, r4                          ! brake-released bit set?
    bt      .L_copy_counter             !   no -> skip decrement
    mov.l   .L_pool_press_counter, r3   ! r3 = &brake_press_counter
    mov.l @r3, r3                       ! r3 = current counter value
    cmp/pl r3                           ! counter > 0?
    bf      .L_copy_counter             !   no -> already zero, skip decrement
    mov.l @r14, r3                      ! r3 = counter value
    add #-0x1, r3                       ! r3 = counter - 1
    mov.l r3, @r14                      ! store decremented counter
.L_copy_counter:
    mov.l   .L_pool_display_mirror, r4  ! r4 = &brake_display_mirror
    mov.l @r14, r2                      ! r2 = counter value
    mov.l r2, @r4                       ! display_mirror = counter
    mov.l @r14, r3                      ! r3 = counter value
    mov.l   .L_pool_state_shadow, r2    ! r2 = &brake_state_shadow
    mov.l r3, @r2                       ! state_shadow = counter
    mov.l   .L_pool_fn_dma_transfer, r12 ! r12 = &dma_transfer
    mov.w   .L_wpool_dma_size, r13      ! r13 = 0xC0 (192 bytes, DMA transfer size)
    mov.l @r4, r0                       ! r0 = display_mirror (counter value)
    tst r0, r0                          ! counter == 0? (brake off?)
    bt      .L_brake_off                !   yes -> use brake-off tile tables
    mov r13, r6                         ! r6 = 0xC0 (DMA size)
    mov.l   .L_pool_tile_on_a, r5      ! r5 = &tile_table_on_a (src table ptr)
    mov.l   .L_pool_dma_dst_a, r4      ! r4 = &dma_dst_a (dest addr ptr)
    mov.l @r5, r5                       ! r5 = tile_table_on_a (source address)
    jsr @r12                            ! dma_transfer(dst_a, tile_on_a_src, 0xC0)
    mov.l @r4, r4                       ! (delay) r4 = dma_dst_a (dest address)
    mov.l   .L_pool_tile_on_b, r5      ! r5 = &tile_table_on_b (src table ptr)
    bra     .L_dma_second_tile          ! -> DMA second tile block
    mov r13, r6                         ! (delay) r6 = 0xC0 (DMA size)
.L_brake_off:
    mov r13, r6                         ! r6 = 0xC0 (DMA size)
    mov.l   .L_pool_tile_off_a, r5     ! r5 = &tile_table_off_a (src table ptr)
    mov.l   .L_pool_dma_dst_a, r4      ! r4 = &dma_dst_a (dest addr ptr)
    mov.l @r5, r5                       ! r5 = tile_table_off_a (source address)
    jsr @r12                            ! dma_transfer(dst_a, tile_off_a_src, 0xC0)
    mov.l @r4, r4                       ! (delay) r4 = dma_dst_a (dest address)
    mov r13, r6                         ! r6 = 0xC0 (DMA size)
    mov.l   .L_pool_tile_off_b, r5     ! r5 = &tile_table_off_b (src table ptr)
.L_dma_second_tile:
    mov.l @r5, r5                       ! r5 = tile source address (on_b or off_b)
    mov.l   .L_pool_dma_dst_b, r4      ! r4 = &dma_dst_b (dest addr ptr)
    jsr @r12                            ! dma_transfer(dst_b, tile_src, 0xC0)
    mov.l @r4, r4                       ! (delay) r4 = dma_dst_b (dest address)
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay) restore r14

    .global DAT_0601043e
DAT_0601043e:
    .2byte  0x4000
.L_wpool_dma_size:
    .2byte  0x00C0
    .2byte  0xFFFF
.L_pool_press_counter:
    .4byte  sym_0607EADC
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_display_mirror:
    .4byte  sym_0607EAB8
.L_pool_state_shadow:
    .4byte  sym_06078868
.L_pool_fn_dma_transfer:
    .4byte  dma_transfer
.L_pool_tile_on_a:
    .4byte  sym_0605D084
.L_pool_dma_dst_a:
    .4byte  sym_06078884
.L_pool_tile_on_b:
    .4byte  sym_0605D060
.L_pool_tile_off_a:
    .4byte  sym_0605D05C
.L_pool_tile_off_b:
    .4byte  sym_0605D088
.L_pool_dma_dst_b:
    .4byte  sym_06078880
