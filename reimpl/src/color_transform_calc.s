/* color_transform_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06039100 - 0x06039250
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Color Transform Calculator
 * ==========================
 * Applies VDP2 color offset / color transform values to the scene pipeline's
 * 32-byte color buffer (sym_060A3E48) and 8-byte color channel mask buffer
 * within it. Called during VBlank from the display command dispatch chain.
 *
 * The function dispatches on channel_type (r4):
 *   0 = Scene A — writes color offset words to buf[0..3] and buf[24..27],
 *       then applies channel mask bits via vblank_color_apply.
 *   1 = Scene B — writes color offset words to buf[8..11] and buf[28..31],
 *       then applies channel mask bits via vblank_color_apply.
 *   other = early exit (no-op).
 *
 * For each channel_type, it reads two pairs of 16-bit color values from
 * the caller's stack (pushed before the call):
 *   pair 1: offset_a, offset_b — the base color offset words
 *   pair 2: component_a, component_b — the color component words
 *
 * If the screen width (sym_060635AE) is 352 or less (normal resolution),
 * the base color offset and component words are doubled (left-shifted by 1)
 * before storing, which compensates for the lower pixel count. In hi-res
 * mode (width > 352), values are stored unmodified.
 *
 * After storing the color words, vblank_color_apply is called up to 3 times:
 *   1. If caller's r5 or r6 (masks) are non-zero, apply to scene A/B buffer
 *      with OR value 0x80 and AND mask 0x7F.
 *   2. If caller's r7 (mask) is non-zero, apply with the channel's specific
 *      AND mask (0xFD for ch0, 0xF7 for ch1) and OR value stored at sp+8.
 *   3. Always apply with channel mask = -1 (all channels), AND mask from sp+8.
 *
 * Finally, it checks a fixed-point flag (bit 16) in r13 to decide whether
 * to write 0x0003 or copy from sym_060A4C80 into sym_060A3E38 (the scene
 * enable flags), and ensures the scene-ready flag (sym_060635AC) is set to 1.
 *
 * Args:
 *   r4 = channel_type (0=scene A, 1=scene B)
 *   r5 = channel_mask_a (saved to stack, used as OR/AND enable mask)
 *   r6 = channel_mask_b (saved to r13, combined with r5 for enable tests)
 *   r7 = channel_mask_c (saved to stack, used as secondary enable mask)
 *   caller stack[0] = color_offset_a (16-bit, read at sp+0x2E)
 *   caller stack[1] = color_offset_b (16-bit, read at sp+0x32)
 *   caller stack[2] = color_component_a (16-bit, read at sp+0x36)
 *   caller stack[3] = color_component_b (16-bit, read at sp+0x3A)
 */

    .section .text.FUN_06039100


    .global color_transform_calc
    .type color_transform_calc, @function
color_transform_calc:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    mov.l r13, @-r15                        ! save r13 (callee-saved)
    mov.l r12, @-r15                        ! save r12 (callee-saved)
    mov.l r11, @-r15                        ! save r11 (callee-saved)
    mov.l r10, @-r15                        ! save r10 (callee-saved)
    mov.l r9, @-r15                         ! save r9 (callee-saved)
    mov.l r8, @-r15                         ! save r8 (callee-saved)
    sts.l pr, @-r15                         ! save return address
    add #-0xC, r15                          ! allocate 12 bytes of local stack
    mov.l   .L_fn_vblank_color_apply, r11   ! r11 = &vblank_color_apply (color channel mask function)
    mov.l   .L_color_buf_ptr, r14           ! r14 = &color_buf (sym_060A3E48 — 32-byte color transform buffer)
    mov.l r5, @(4, r15)                     ! local[4] = channel_mask_a (r5)
    mov r6, r13                             ! r13 = channel_mask_b
    mov.l r7, @r15                          ! local[0] = channel_mask_c (r7)
    mov #0x0, r5                            ! r5 = 0 (initial offset for buf pointer arithmetic)
    bra     .L_channel_dispatch             ! jump to channel_type dispatch
    extu.b r4, r0                           ! (delay) r0 = channel_type & 0xFF
.L_setup_scene_a:
    mov.l r5, @(24, r14)                    ! color_buf[24] = 0 (clear scene A secondary slot)
    mov r14, r4                             ! r4 = &color_buf[0] (scene A offset_dest)
    add r5, r4                              ! r4 += 0 (no offset for scene A)
    mov r14, r2                             ! r2 = &color_buf base
    add #0x4, r2                            ! r2 = &color_buf[4] (scene A component_dest)
    add r2, r5                              ! r5 = &color_buf[4] (absolute for component store)
    mov #0x2, r3                            ! r3 = 0x02 (channel bit mask for vblank_color_apply)
    mov r3, r0                              ! r0 = 0x02
    mov.b r0, @(8, r15)                     ! local[8] = 0x02 (channel OR value for third apply call)
    mov.w   DAT_0603918c, r8                ! r8 = 0x00FD (AND mask — clears bit 1, preserves rest)
    mov #0x1, r9                            ! r9 = 0x01 (OR value for second apply call)
    mov r8, r10                             ! r10 = 0x00FD
    bra     .L_store_color_words            ! jump to color word store logic
    add #0x1, r10                           ! (delay) r10 = 0x00FE (AND mask with bit 0 also clear)
.L_setup_scene_b:
    mov.l r5, @(28, r14)                    ! color_buf[28] = 0 (clear scene B secondary slot)
    mov r14, r4                             ! r4 = &color_buf base
    add #0x8, r4                            ! r4 = &color_buf[8] (scene B offset_dest)
    add r5, r4                              ! r4 += 0 (no additional offset)
    mov r14, r2                             ! r2 = &color_buf base
    add #0xC, r2                            ! r2 = &color_buf[12] (scene B component_dest)
    add r2, r5                              ! r5 = &color_buf[12] (absolute for component store)
    mov #0x8, r3                            ! r3 = 0x08 (channel bit mask for vblank_color_apply)
    mov r3, r0                              ! r0 = 0x08
    mov.b r0, @(8, r15)                     ! local[8] = 0x08 (channel OR value for third apply call)
    mov.w   DAT_0603918e, r8                ! r8 = 0x00F7 (AND mask — clears bit 3, preserves rest)
    mov #0x4, r9                            ! r9 = 0x04 (OR value for second apply call)
    mov r8, r10                             ! r10 = 0x00F7
    bra     .L_store_color_words            ! jump to color word store logic
    add #0x4, r10                           ! (delay) r10 = 0x00FB (AND mask with bit 2 also clear)
.L_early_exit:
    bra     .L_epilogue                     ! unknown channel_type — skip all processing
    nop                                     ! delay slot
.L_channel_dispatch:
    cmp/eq #0x0, r0                         ! channel_type == 0? (scene A)
    bt      .L_setup_scene_a                ! yes — set up scene A pointers and masks
    cmp/eq #0x1, r0                         ! channel_type == 1? (scene B)
    bt      .L_setup_scene_b                ! yes — set up scene B pointers and masks
    bra     .L_early_exit                   ! unrecognized channel_type — early exit
    nop                                     ! delay slot
.L_store_color_words:
    mov r14, r12                            ! r12 = &color_buf base (for vblank_color_apply buffer ptr)
    mov.l   .L_screen_width_ptr, r2         ! r2 = &screen_width (sym_060635AE)
    mov.w   .L_hires_threshold, r3          ! r3 = 0x0160 (352 — hi-res width threshold)
    mov.w @r2, r2                           ! r2 = current screen width (16-bit)
    extu.w r2, r2                           ! zero-extend screen width to 32-bit
    cmp/gt r3, r2                           ! screen_width > 352?
    bf/s    .L_normal_res_double            ! if width <= 352 (normal res), branch to double path
    add #0x10, r12                          ! (delay) r12 = &color_buf[16] (channel mask sub-buffer)
    mov #0x2E, r0                           ! r0 = 0x2E (stack offset for caller's color_offset_a)
    mov.w @(r0, r15), r3                    ! r3 = color_offset_a from caller's stack
    mov.w r3, @r4                           ! dest[0] = color_offset_a (store unmodified — hi-res)
    mov #0x36, r0                           ! r0 = 0x36 (stack offset for caller's color_component_a)
    mov.w @(r0, r15), r3                    ! r3 = color_component_a from caller's stack
    mov.w r3, @r5                           ! dest[0] = color_component_a (store unmodified — hi-res)
    bra     .L_store_second_pair            ! jump to store second pair of words
    nop                                     ! delay slot

    .global DAT_0603918c
DAT_0603918c:
    .2byte  0x00FD

    .global DAT_0603918e
DAT_0603918e:
    .2byte  0x00F7
.L_hires_threshold:
    .2byte  0x0160
    .2byte  0xFFFF
.L_fn_vblank_color_apply:
    .4byte  vblank_color_apply
.L_color_buf_ptr:
    .4byte  sym_060A3E48
.L_screen_width_ptr:
    .4byte  sym_060635AE
.L_normal_res_double:
    mov #0x2E, r0                           ! r0 = 0x2E (stack offset for caller's color_offset_a)
    mov.w @(r0, r15), r2                    ! r2 = color_offset_a from caller's stack
    mov #0x36, r0                           ! r0 = 0x36 (stack offset for caller's color_component_a)
    extu.w r2, r2                           ! zero-extend color_offset_a
    shll r2                                 ! r2 <<= 1 (double for normal-res compensation)
    extu.w r2, r2                           ! mask to 16 bits after shift
    mov.w r2, @r4                           ! dest[0] = doubled color_offset_a
    mov.w @(r0, r15), r3                    ! r3 = color_component_a from caller's stack
    extu.w r3, r3                           ! zero-extend color_component_a
    shll r3                                 ! r3 <<= 1 (double for normal-res compensation)
    extu.w r3, r3                           ! mask to 16 bits after shift
    mov.w r3, @r5                           ! dest[0] = doubled color_component_a
.L_store_second_pair:
    mov #0x32, r0                           ! r0 = 0x32 (stack offset for caller's color_offset_b)
    mov.w @(r0, r15), r0                    ! r0 = color_offset_b from caller's stack
    mov.w r0, @(2, r4)                      ! dest[2] = color_offset_b (second offset word)
    mov #0x3A, r0                           ! r0 = 0x3A (stack offset for caller's color_component_b)
    mov.w @(r0, r15), r0                    ! r0 = color_component_b from caller's stack
    mov.w r0, @(2, r5)                      ! dest[2] = color_component_b (second component word)
    mov.l @(4, r15), r3                     ! r3 = channel_mask_a (from local[4])
    or r13, r3                              ! r3 = channel_mask_a | channel_mask_b
    tst r3, r3                              ! (mask_a | mask_b) == 0?
    bt      .L_skip_first_apply             ! yes — skip first vblank_color_apply call
    mov #0x7F, r3                           ! r3 = 0x7F (AND mask — clears bit 7)
    mov r12, r6                             ! r6 = &color_buf[16] (channel mask sub-buffer)
    mov r13, r5                             ! r5 = channel_mask_b (channel enable mask)
    mov.l r3, @-r15                         ! push 0x7F onto stack (AND mask arg for vblank_color_apply)
    mov.w   .L_or_value_0x80, r7            ! r7 = 0x0080 (OR value — sets bit 7)
    jsr @r11                                ! call vblank_color_apply(mask_a, mask_b, buf+16, 0x80, [0x7F])
    mov.l @(8, r15), r4                     ! (delay) r4 = channel_mask_a (direction mask from local[4+4])
    add #0x4, r15                           ! pop the AND mask arg from stack
.L_skip_first_apply:
    mov.l @r15, r3                          ! r3 = channel_mask_c (from local[0])
    or r13, r3                              ! r3 = channel_mask_c | channel_mask_b
    tst r3, r3                              ! (mask_c | mask_b) == 0?
    bt      .L_skip_second_apply            ! yes — skip second vblank_color_apply call
    mov r9, r7                              ! r7 = OR value (0x01 for ch A, 0x04 for ch B)
    mov r12, r6                             ! r6 = &color_buf[16] (channel mask sub-buffer)
    mov r13, r5                             ! r5 = channel_mask_b (channel enable mask)
    mov.l r10, @-r15                        ! push AND mask (0xFE for ch A, 0xFB for ch B)
    jsr @r11                                ! call vblank_color_apply(mask_c, mask_b, buf+16, or_val, [and_mask])
    mov.l @(4, r15), r4                     ! (delay) r4 = channel_mask_c (direction mask from local[0+4])
    add #0x4, r15                           ! pop the AND mask arg from stack
.L_skip_second_apply:
    mov r12, r6                             ! r6 = &color_buf[16] (channel mask sub-buffer)
    mov #-0x1, r5                           ! r5 = 0xFFFFFFFF (all channels enabled)
    mov.l r8, @-r15                         ! push AND mask (0xFD for ch A, 0xF7 for ch B)
    mov.b @(12, r15), r0                    ! r0 = channel OR value from local[8] (0x02 or 0x08)
    mov r0, r7                              ! r7 = channel OR value
    jsr @r11                                ! call vblank_color_apply(mask_b, all_ch, buf+16, or_val, [and_mask])
    mov r13, r4                             ! (delay) r4 = channel_mask_b (direction mask)
    mov.l   .L_enable_flags_ptr, r4         ! r4 = &scene_enable_flags (sym_060A3E38)
    mov.l   .L_fp_one_mask, r3              ! r3 = 0x00010000 (bit 16 mask / 1.0 in 16.16 fp)
    and r3, r13                             ! r13 = channel_mask_b & 0x10000 (isolate bit 16)
    tst r13, r13                            ! bit 16 set in channel_mask_b?
    bt/s    .L_copy_enable_flags            ! no — copy from existing source
    add #0x4, r15                           ! (delay) pop the AND mask arg from stack
    mov #0x3, r3                            ! r3 = 0x0003 (both scene A and B enabled)
    mov.w r3, @r4                           ! scene_enable_flags[0] = 0x0003
    bra     .L_check_ready_flag             ! jump to ready flag check
    nop                                     ! delay slot
.L_copy_enable_flags:
    mov.l   .L_ctrl_config_ptr, r2          ! r2 = &ctrl_config (sym_060A4C80)
    mov.w @r2, r2                           ! r2 = ctrl_config value (16-bit)
    mov.w r2, @r4                           ! scene_enable_flags[0] = ctrl_config value
.L_check_ready_flag:
    mov.l   .L_scene_ready_flag_ptr, r4     ! r4 = &scene_ready_flag (sym_060635AC)
    mov.w @r4, r3                           ! r3 = scene_ready_flag (16-bit)
    extu.w r3, r3                           ! zero-extend to 32 bits
    tst r3, r3                              ! scene_ready_flag == 0?
    bf      .L_epilogue                     ! no (already non-zero) — skip, exit
    mov #0x1, r3                            ! r3 = 1 (scene data ready)
    mov.w r3, @r4                           ! scene_ready_flag = 1 (signal scene pipeline)
.L_epilogue:
    add #0xC, r15                           ! deallocate 12 bytes of local stack
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r8                         ! restore r8
    mov.l @r15+, r9                         ! restore r9
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! (delay) restore r14
.L_or_value_0x80:
    .2byte  0x0080
    .2byte  0xFFFF
.L_enable_flags_ptr:
    .4byte  sym_060A3E38
.L_fp_one_mask:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) / bit 16 mask */
.L_ctrl_config_ptr:
    .4byte  sym_060A4C80
.L_scene_ready_flag_ptr:
    .4byte  sym_060635AC
