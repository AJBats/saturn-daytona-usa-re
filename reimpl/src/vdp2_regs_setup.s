/* vdp2_regs_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603836C - 0x0603853C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP2 Shadow Register Initialization
 * ====================================
 * Initializes the game's VDP2 shadow register buffers in WRAM to safe defaults.
 * The Saturn VDP2 chip controls all 2D background scroll planes (NBG0-3, RBG0).
 * Rather than writing VDP2 hardware registers directly, the game maintains
 * shadow copies in RAM that get committed to hardware during VBlank.
 *
 * This function zeroes three shadow register blocks and one transform struct:
 *   Block A (sym_060A3D88, 40 bytes): TVMD through SFCODE shadows
 *     - Sets TVMD = 0x8000 (display enable, default mode)
 *     - Sets RAMCTL = 0x2000
 *     - Fills all 8 VRAM cycle pattern slots with 0xFFFF (no access)
 *     - Zeroes BGON, MZCTL, SFSEL, SFCODE
 *   Block B (sym_060A3DB0, 72 bytes): CHCTLA through map/scroll register shadows
 *     - Zeroes character control, pattern name, plane size, map offset regs
 *     - Zeroes all map plane assignment registers
 *     - Zeroes all scroll position registers
 *   Transform struct (sym_060A3DF8, 64 bytes): Rotation/zoom parameter table
 *     - Sets identity scaling (1.0 in fixed-point 16.16 for X/Y zoom)
 *     - Zeroes all translation and rotation parameters
 *   Enable flags (sym_060A3E38, 16 bytes): Scene enable/config flags
 *   Config block (sym_060A3E48, 32 bytes): Additional scene configuration
 *
 * Also stores the VDP2 TVMD hardware address (0x25F80000) into sym_060A3D84
 * for use by the VBlank register commit routine.
 *
 * Three small helper functions follow:
 *   sym_0603850C: Write command channel ID to command queue slot
 *   sym_06038520: Commit command (set ready flag to 1)
 *
 * Called from display_hw_init (FUN_06038300) during system initialization.
 */

    .section .text.FUN_0603836C


    .global vdp2_regs_setup
    .type vdp2_regs_setup, @function
vdp2_regs_setup:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    mov.l   .L_pool_cycle_fill_mask, r12 ! r12 = 0x0000FFFF (cycle pattern "no access" fill)
    mov #0x10, r13                      ! r13 = 16 (loop count for scroll registers)
    mov #0x8, r14                       ! r14 = 8 (loop count for cycle/map registers)
    mov.l   .L_pool_shadow_block_a, r7  ! r7 = &sym_060A3D88 (shadow block A: TVMD-SFCODE)
    mov.l   .L_pool_shadow_block_b, r5  ! r5 = &sym_060A3DB0 (shadow block B: CHCTLA-scroll)
    mov #0x0, r4                        ! r4 = 0 (zero constant used throughout)
    mov.l   .L_pool_vdp2_tvmd, r3      ! r3 = 0x25F80000 (VDP2 TVMD hardware address)
    mov.l   .L_pool_tvmd_addr_store, r2 ! r2 = &sym_060A3D84 (TVMD address storage)
    mov.l r3, @r2                       ! sym_060A3D84 = 0x25F80000 (store HW base for VBlank)
    mov.l   .L_pool_fp_half, r3        ! r3 = 0x00008000 (0.5 fixed-point 16.16)
    mov.w r3, @r7                       ! block_a[0x00] = 0x8000 (TVMD: display enable)
    extu.w r4, r2                       ! r2 = 0 (zero-extend)
    mov r2, r0                          ! r0 = 0
    mov.w r0, @(2, r7)                  ! block_a[0x02] = 0 (EXTEN: no external signals)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(6, r7)                  ! block_a[0x06] = 0 (VRSIZE: 4Mbit VRAM)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(12, r7)                 ! block_a[0x0C] = 0 (reserved/padding)
    shlr2 r3                            ! r3 = 0x00002000 (shift 0x8000 >> 2)
    mov r3, r0                          ! r0 = 0x2000
    mov.w r0, @(14, r7)                 ! block_a[0x0E] = 0x2000 (RAMCTL: VRAM access config)
    extu.w r4, r6                       ! r6 = 0 (loop counter init)
.L_cycle_pattern_loop:
    extu.w r6, r3                       ! r3 = loop index (zero-extended)
    mov r7, r2                          ! r2 = block_a base
    extu.w r12, r1                      ! r1 = 0xFFFF ("no access" cycle pattern)
    shll r3                             ! r3 *= 2 (word offset)
    add #0x1, r6                        ! loop counter++
    add #0x10, r2                       ! r2 = &block_a[0x10] (CYCA0L base)
    add r2, r3                          ! r3 = &block_a[0x10 + i*2]
    mov.w r1, @r3                       ! cycle_pattern[i] = 0xFFFF (no VDP2 VRAM access)
    extu.w r6, r3                       ! r3 = loop counter
    cmp/ge r14, r3                      ! i >= 8?
    bf      .L_cycle_pattern_loop       ! no: loop (fills CYCA0L..CYCB1U)
    mov #0x20, r0                       ! r0 = 0x20 (offset to BGON)
    mov.w r4, @(r0, r7)                 ! block_a[0x20] = 0 (BGON: all BG layers off)
    mov #0x22, r0                       ! r0 = 0x22 (offset to MZCTL)
    mov.w r4, @(r0, r7)                 ! block_a[0x22] = 0 (MZCTL: mosaic off)
    mov #0x24, r0                       ! r0 = 0x24 (offset to SFSEL)
    mov.w r4, @(r0, r7)                 ! block_a[0x24] = 0 (SFSEL: no special function)
    mov #0x26, r0                       ! r0 = 0x26 (offset to SFCODE)
    mov.w r4, @(r0, r7)                 ! block_a[0x26] = 0 (SFCODE: no special function code)
    mov.w r4, @r5                       ! block_b[0x00] = 0 (CHCTLA: char control A default)
    extu.w r4, r2                       ! r2 = 0
    mov r2, r0                          ! r0 = 0
    mov.w r0, @(2, r5)                  ! block_b[0x02] = 0 (CHCTLB: char control B default)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(4, r5)                  ! block_b[0x04] = 0 (BMPNA: bitmap palette A)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(6, r5)                  ! block_b[0x06] = 0 (BMPNB: bitmap palette B)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(8, r5)                  ! block_b[0x08] = 0 (PNCN0: pattern name NBG0)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(10, r5)                 ! block_b[0x0A] = 0 (PNCN1: pattern name NBG1)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(12, r5)                 ! block_b[0x0C] = 0 (PNCN2: pattern name NBG2)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(14, r5)                 ! block_b[0x0E] = 0 (PNCN3: pattern name NBG3)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(16, r5)                 ! block_b[0x10] = 0 (PNCR: pattern name RBG0)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(18, r5)                 ! block_b[0x12] = 0 (PLSZ: plane size)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(20, r5)                 ! block_b[0x14] = 0 (MPOFN: map offset NBG)
    extu.w r4, r3                       ! r3 = 0
    mov r3, r0                          ! r0 = 0
    mov.w r0, @(22, r5)                 ! block_b[0x16] = 0 (MPOFR: map offset RBG)
    extu.w r4, r6                       ! r6 = 0 (loop counter init)
.L_map_regs_loop:
    extu.w r6, r3                       ! r3 = loop index
    mov r5, r2                          ! r2 = block_b base
    extu.w r4, r1                       ! r1 = 0
    shll r3                             ! r3 *= 2 (word offset)
    add #0x1, r6                        ! loop counter++
    add #0x18, r2                       ! r2 = &block_b[0x18] (MPABN0 base)
    add r2, r3                          ! r3 = &block_b[0x18 + i*2]
    mov.w r1, @r3                       ! map_plane_reg[i] = 0 (clear map assignment)
    extu.w r6, r3                       ! r3 = loop counter
    cmp/ge r14, r3                      ! i >= 8?
    bf      .L_map_regs_loop            ! no: loop (clears MPABN0..MPGHRA)
    extu.w r4, r6                       ! r6 = 0 (loop counter init)
.L_scroll_regs_loop:
    extu.w r6, r3                       ! r3 = loop index
    mov r5, r2                          ! r2 = block_b base
    extu.w r4, r1                       ! r1 = 0
    shll r3                             ! r3 *= 2 (word offset)
    add #0x1, r6                        ! loop counter++
    add #0x28, r2                       ! r2 = &block_b[0x28] (scroll position base)
    add r2, r3                          ! r3 = &block_b[0x28 + i*2]
    mov.w r1, @r3                       ! scroll_reg[i] = 0 (clear scroll position)
    extu.w r6, r3                       ! r3 = loop counter
    cmp/ge r13, r3                      ! i >= 16?
    bf      .L_scroll_regs_loop         ! no: loop (clears 16 scroll registers)
    mov.l   .L_pool_transform_struct, r6 ! r6 = &sym_060A3DF8 (rotation parameter table)
    mov.l r4, @r6                       ! xform[0x00] = 0 (Xst: X start = 0)
    mov.l r4, @(4, r6)                  ! xform[0x04] = 0 (Yst: Y start = 0)
    mov.l   .L_pool_fp_one, r0         ! r0 = 0x00010000 (1.0 fixed-point 16.16)
    mov.l r0, @(8, r6)                  ! xform[0x08] = 1.0 (delta_Xst: X step per line = 1.0)
    mov.l r0, @(12, r6)                 ! xform[0x0C] = 1.0 (delta_Yst: Y step per line = 1.0)
    mov.l r4, @(16, r6)                 ! xform[0x10] = 0 (Zst: Z start = 0)
    mov.l r4, @(20, r6)                 ! xform[0x14] = 0 (reserved/padding)
    mov.l r0, @(24, r6)                 ! xform[0x18] = 1.0 (KxH: X zoom factor = 1.0)
    mov.l r0, @(28, r6)                 ! xform[0x1C] = 1.0 (KyV: Y zoom factor = 1.0)
    mov #0x20, r0                       ! r0 = 0x20 (offset 32)
    mov.w r4, @(r0, r6)                 ! xform[0x20] = 0 (Xp: screen X origin)
    mov #0x22, r0                       ! r0 = 0x22 (offset 34)
    mov.w r4, @(r0, r6)                 ! xform[0x22] = 0 (Yp: screen Y origin)
    mov #0x24, r0                       ! r0 = 0x24 (offset 36)
    mov.w r4, @(r0, r6)                 ! xform[0x24] = 0 (rotation angle A)
    mov #0x26, r0                       ! r0 = 0x26 (offset 38)
    mov.w r4, @(r0, r6)                 ! xform[0x26] = 0 (rotation angle B)
    mov #0x28, r0                       ! r0 = 0x28 (offset 40)
    mov.w r4, @(r0, r6)                 ! xform[0x28] = 0 (rotation angle C)
    mov #0x2A, r0                       ! r0 = 0x2A (offset 42)
    mov.w r4, @(r0, r6)                 ! xform[0x2A] = 0 (coefficient table offset)
    mov.l r4, @(44, r6)                 ! xform[0x2C] = 0 (line scroll table address)
    mov r6, r3                          ! r3 = xform base
    add #0x30, r3                       ! r3 = &xform[0x30]
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    mov.l r4, @r3                       ! xform[0x30] = 0 (line color table address)
    mov.l r4, @(52, r6)                 ! xform[0x34] = 0 (back screen table address)
    mov.l r4, @(56, r6)                 ! xform[0x38] = 0 (rotation param table address)
    mov.l r4, @(60, r6)                 ! xform[0x3C] = 0 (coefficient data address)
    mov.l   .L_pool_enable_flags, r6    ! r6 = &sym_060A3E38 (scene enable flags)
    mov.w r4, @r6                       ! enable[0x00] = 0 (scene 0 enable = off)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(2, r6)                  ! enable[0x02] = 0 (scene 0 mode = default)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(4, r6)                  ! enable[0x04] = 0 (scene 1 enable = off)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(6, r6)                  ! enable[0x06] = 0 (scene 1 mode = default)
    mov r6, r3                          ! r3 = enable base
    add #0x8, r3                        ! r3 = &enable[0x08]
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    mov.w r4, @r3                       ! enable[0x08] = 0 (priority/CC control)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(10, r6)                 ! enable[0x0A] = 0 (priority/CC control)
    mov.l r4, @(12, r6)                 ! enable[0x0C] = 0 (color offset enable)
    mov.l   .L_pool_config_block, r6    ! r6 = &sym_060A3E48 (scene config block)
    mov r6, r3                          ! r3 = config base
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    mov.w r4, @r3                       ! config[0x00] = 0 (window X start 0)
    bra     .L_config_block_cont        ! jump past constant pool
    nop                                 ! (delay slot)
.L_pool_cycle_fill_mask:
    .4byte  0x0000FFFF                  /* low 16-bit mask / 0xFFFF cycle pattern fill */
.L_pool_shadow_block_a:
    .4byte  sym_060A3D88                /* shadow block A (TVMD-SFCODE, 40 bytes) */
.L_pool_shadow_block_b:
    .4byte  sym_060A3DB0                /* shadow block B (CHCTLA-scroll, 72 bytes) */
.L_pool_vdp2_tvmd:
    .4byte  0x25F80000                  /* VDP2 TVMD â€” TV mode/display enable */
.L_pool_tvmd_addr_store:
    .4byte  sym_060A3D84                /* stores VDP2 TVMD HW address for VBlank */
.L_pool_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) / 0x8000 TVMD value */
.L_pool_transform_struct:
    .4byte  sym_060A3DF8                /* rotation parameter / transform struct (64 bytes) */
.L_pool_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_pool_enable_flags:
    .4byte  sym_060A3E38                /* scene enable flags (16 bytes) */
.L_pool_config_block:
    .4byte  sym_060A3E48                /* scene config block (32 bytes) */
.L_config_block_cont:
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(2, r6)                  ! config[0x02] = 0 (window Y start 0)
    mov r6, r3                          ! r3 = config base
    add #0x4, r3                        ! r3 = &config[0x04]
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    mov.w r4, @r3                       ! config[0x04] = 0 (window X end 0)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(6, r6)                  ! config[0x06] = 0 (window Y end 0)
    mov r6, r3                          ! r3 = config base
    add #0x8, r3                        ! r3 = &config[0x08]
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    mov.w r4, @r3                       ! config[0x08] = 0 (window X start 1)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(10, r6)                 ! config[0x0A] = 0 (window Y start 1)
    mov r6, r3                          ! r3 = config base
    add #0xC, r3                        ! r3 = &config[0x0C]
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    mov.w r4, @r3                       ! config[0x0C] = 0 (window X end 1)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(14, r6)                 ! config[0x0E] = 0 (window Y end 1)
    mov r6, r3                          ! r3 = config base
    add #0x10, r3                       ! r3 = &config[0x10]
    add r4, r3                          ! r3 += 0 (no-op, compiler artifact)
    extu.w r4, r2                       ! r2 = 0
    mov.w r2, @r3                       ! config[0x10] = 0 (window control A)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(18, r6)                 ! config[0x12] = 0 (window control B)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(20, r6)                 ! config[0x14] = 0 (window control C)
    extu.w r4, r0                       ! r0 = 0
    mov.w r0, @(22, r6)                 ! config[0x16] = 0 (window control D)
    mov.l r4, @(24, r6)                 ! config[0x18] = 0 (sprite control)
    mov.l r4, @(28, r6)                 ! config[0x1C] = 0 (shadow control)
    mov.l   .L_pool_ready_flag, r6      ! r6 = &sym_060635AC (command ready flag)
    mov.w @r6, r3                       ! r3 = ready_flag (16-bit read)
    extu.w r3, r3                       ! zero-extend to 32-bit
    tst r3, r3                          ! ready_flag == 0?
    bf      .L_skip_flag_init           ! nonzero: already initialized, skip
    mov #0x1, r3                        ! r3 = 1
    mov.w r3, @r6                       ! ready_flag = 1 (mark as initialized)
.L_skip_flag_init:
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay slot) restore r14

    .global sym_0603850C
sym_0603850C:
! ---- Command Queue: Write Channel ID (24 bytes, LEAF) ----
! Writes r4 (channel ID) to the command slot at sym_060635A8.
! If a previous command was pending (ready=1), clears the ready flag first.
! Called as first step of the display update sequence.
    mov.l   .L_pool_ready_flag, r5      ! r5 = &sym_060635AC (ready flag)
    mov.w @r5, r0                       ! r0 = ready_flag (16-bit)
    extu.w r0, r0                       ! zero-extend to 32-bit
    cmp/eq #0x1, r0                     ! previous command still pending?
    bf      .L_cmd_write_store          ! no: skip clear
    mov #0x0, r2                        ! r2 = 0
    mov.w r2, @r5                       ! ready_flag = 0 (consume stale command)
.L_cmd_write_store:
    mov.l   .L_pool_cmd_slot, r3        ! r3 = &sym_060635A8 (command slot)
    rts                                 ! return
    mov.l r4, @r3                       ! (delay slot) command_slot = r4 (channel ID)

    .global sym_06038520
sym_06038520:
! ---- Command Queue: Commit (18 bytes, LEAF) ----
! Sets the ready flag at sym_060635AC to 1, signaling a command is ready.
! Only sets if not already set (prevents double-commit).
! Called as final step of the display update sequence.
    mov.l   .L_pool_ready_flag, r4      ! r4 = &sym_060635AC (ready flag)
    mov.w @r4, r3                       ! r3 = ready_flag (16-bit)
    extu.w r3, r3                       ! zero-extend to 32-bit
    tst r3, r3                          ! ready_flag == 0? (idle)
    bf      .L_commit_done              ! already set: don't double-commit
    mov #0x1, r3                        ! r3 = 1
    mov.w r3, @r4                       ! ready_flag = 1 (command ready)
.L_commit_done:
    rts                                 ! return
    nop                                 ! (delay slot padding)
    .2byte  0xFFFF
.L_pool_ready_flag:
    .4byte  sym_060635AC                /* command ready flag */
.L_pool_cmd_slot:
    .4byte  sym_060635A8                /* command queue slot (channel ID) */
