/* hw_init_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060401FC - 0x060402BC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Two functions in this TU:
 *
 * hw_init_setup (0x060401FC):
 *   Initializes a hardware/event structure's capacity field. Saves a
 *   parameter into the struct, calls evt_cmd_enqueue with a max-value
 *   limit, clamps the result to non-negative, then computes a delta
 *   by subtracting a base size field. The delta is stored as the
 *   struct's available capacity (offset +0x24).
 *
 *   r4 = pointer to event/hw struct (saved in r14)
 *   r5 = value stored at struct+0x20 (size/limit parameter)
 *   Struct layout used:
 *     +0x18 (24): sub-struct pointer (passed to evt_cmd_enqueue)
 *     +0x20 (32): size/limit parameter (written by caller via r5)
 *     +0x24 (36): available capacity (computed result)
 *     sub-struct+0x10: base size (subtracted from query result)
 *
 * evt_field_extract (sym_06040220):
 *   Multi-field extraction from an event/command structure. Called by
 *   evt_cmd_enqueue, event_callback_dispatch, and save_data_serialize.
 *   Reads up to 7 fields from a source struct into caller-provided
 *   output pointers. Field[0] has special bit-masking: if bit 30 is
 *   set, the value is masked to 30 bits (clearing bit 30). Byte fields
 *   at offsets +0x1C and +0x1D are extracted as unsigned. The final
 *   output computes remaining time: field[3] - field[5], but only if
 *   status byte has specific flag bits set.
 *
 *   r4 = source event struct pointer
 *   r5 = output ptr for field[0] (long at src+0x00, bit-masked)
 *   r6 = output ptr for field[1] (long at src+0x04)
 *   r7 = output ptr for field[3] (long at src+0x0C)
 *   stack[0] = output ptr for field[4] (long at src+0x10)
 *   stack[4] = r1 saved = output ptr for remaining time
 *   stack[8] = output ptr for byte at src+0x1C
 *   stack[12] = output ptr for byte at src+0x1D
 */

    .section .text.FUN_060401FC


    .global hw_init_setup
    .type hw_init_setup, @function
hw_init_setup:
    sts.l pr, @-r15                     ! save return address
    mov r4, r14                         ! r14 = struct pointer (callee-saved)

    .global loc_06040200
loc_06040200:
    mov.l r5, @(32, r14)                ! struct[+0x20] = r5 (store size/limit param)
    mov.l   .Lpool_max_positive, r5     ! r5 = 0x7FFFFFFF (max positive signed int)
    mov.l   .Lpool_evt_cmd_enqueue, r3  ! r3 = &evt_cmd_enqueue
    jsr @r3                             ! call evt_cmd_enqueue(r4=sub_struct, r5=0x7FFFFFFF)
    mov.l @(24, r14), r4                ! r4 = struct[+0x18] (sub-struct ptr, delay slot)
    mov r0, r4                          ! r4 = return value from evt_cmd_enqueue
    cmp/pz r4                           ! is result >= 0?
    bt      .Lresult_nonneg             ! if so, skip clamping
    mov #0x0, r4                        ! clamp negative result to 0
.Lresult_nonneg:
    mov.l @(24, r14), r3                ! r3 = struct[+0x18] (sub-struct ptr)
    mov.l @(16, r3), r2                 ! r2 = sub_struct[+0x10] (base size)
    sub r2, r4                          ! r4 = clamped_result - base_size = available capacity
    mov.l r4, @(36, r14)                ! struct[+0x24] = available capacity
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)

    .global sym_06040220
sym_06040220:
/* evt_field_extract: */
    mov.l @(4, r15), r1                 ! r1 = stack arg: output ptr for remaining time
    tst r5, r5                          ! is field[0] output ptr NULL?
    bt      .Lcheck_field1              ! if NULL, skip field[0] extraction
    mov.l @r4, r3                       ! r3 = src[+0x00] (field[0] raw value)
    mov.l   .Lpool_bit30_mask, r2       ! r2 = 0x40000000 (bit 30 test mask)
    and r2, r3                          ! r3 = field[0] & 0x40000000
    tst r3, r3                          ! is bit 30 clear?
    bt      .Lfield0_no_mask            ! if clear, store raw value
    mov.l @r4, r3                       ! r3 = src[+0x00] (reload raw value)
    mov.l   .Lpool_bit30_clear, r2      ! r2 = 0x3FFFFFFF (mask to clear bit 30+31)
    and r2, r3                          ! r3 = field[0] & 0x3FFFFFFF (clear top 2 bits)
    mov.l r3, @r5                       ! *out_field0 = masked value
    bra     .Lcheck_field1              ! continue to field[1]
    nop                                 ! delay slot
.Lpool_max_positive:
    .4byte  0x7FFFFFFF                  /* max positive 16.16 */
.Lpool_evt_cmd_enqueue:
    .4byte  evt_cmd_enqueue
.Lpool_bit30_mask:
    .4byte  0x40000000                  /* 0.25 (2.30) or 16384.0 (16.16) */
.Lpool_bit30_clear:
    .4byte  0x3FFFFFFF
.Lfield0_no_mask:
    mov.l @r4, r2                       ! r2 = src[+0x00] (raw value, bit 30 clear)
    mov.l r2, @r5                       ! *out_field0 = raw value (no masking needed)
.Lcheck_field1:
    tst r6, r6                          ! is field[1] output ptr NULL?
    bt      .Lcheck_field1c             ! if NULL, skip field[1]
    mov.l @(4, r4), r3                  ! r3 = src[+0x04] (field[1])
    mov.l r3, @r6                       ! *out_field1 = src[+0x04]
.Lcheck_field1c:
    mov.l @(8, r15), r0                 ! r0 = stack arg: output ptr for byte at +0x1C
    tst r0, r0                          ! is byte[0x1C] output ptr NULL?
    bt      .Lcheck_field3              ! if NULL, skip
    mov.l @(8, r15), r3                 ! r3 = output ptr for byte at +0x1C
    mov #0x1C, r0                       ! r0 = byte offset 0x1C within src struct
    mov.b @(r0, r4), r2                 ! r2 = src[+0x1C] (signed byte read)
    extu.b r2, r2                       ! r2 = zero-extend byte to unsigned
    mov.l r2, @r3                       ! *out_byte_1c = unsigned byte value
.Lcheck_field3:
    tst r7, r7                          ! is field[3] output ptr NULL?
    bt      .Lcheck_field4              ! if NULL, skip field[3]
    mov.l @(12, r4), r3                 ! r3 = src[+0x0C] (field[3])
    mov.l r3, @r7                       ! *out_field3 = src[+0x0C]
.Lcheck_field4:
    mov.l @r15, r0                      ! r0 = stack arg[0]: output ptr for field[4]
    tst r0, r0                          ! is field[4] output ptr NULL?
    bt      .Lcheck_byte_1d             ! if NULL, skip field[4]
    mov.l @r15, r3                      ! r3 = output ptr for field[4]
    mov.l @(16, r4), r2                 ! r2 = src[+0x10] (field[4])
    mov.l r2, @r3                       ! *out_field4 = src[+0x10]
.Lcheck_byte_1d:
    mov.l @(12, r15), r0                ! r0 = stack arg: output ptr for byte at +0x1D
    tst r0, r0                          ! is byte[0x1D] output ptr NULL?
    bt      .Lcheck_remaining           ! if NULL, skip
    mov.l @(12, r15), r3                ! r3 = output ptr for byte at +0x1D
    mov #0x1D, r0                       ! r0 = byte offset 0x1D within src struct
    mov.b @(r0, r4), r2                 ! r2 = src[+0x1D] (signed byte read)
    extu.b r2, r2                       ! r2 = zero-extend byte to unsigned
    mov.l r2, @r3                       ! *out_byte_1d = unsigned byte value
.Lcheck_remaining:
    tst r1, r1                          ! is remaining-time output ptr NULL?
    bt      .Lreturn                    ! if NULL, skip remaining calc
    mov #0x1D, r0                       ! r0 = byte offset 0x1D (status flags)
    mov #0x8, r3                        ! r3 = 0x08 (bit 3 mask — active flag)
    mov.b @(r0, r4), r5                 ! r5 = src[+0x1D] (status byte, signed)
    extu.b r5, r5                       ! r5 = zero-extend status byte
    and r5, r3                          ! r3 = status & 0x08 (test active flag)
    tst r3, r3                          ! is active flag clear?
    bt      .Lcalc_elapsed              ! if clear, compute elapsed time normally
    bra     .Lcheck_complete_flag       ! if set, check completion flag
    nop                                 ! delay slot
.Lcheck_complete_flag:
    mov #0x4, r2                        ! r2 = 0x04 (bit 2 mask — complete flag)
    and r5, r2                          ! r2 = status & 0x04
    tst r2, r2                          ! is complete flag clear?
    bt      .Lcalc_elapsed              ! if clear, compute elapsed time
    mov #0x0, r2                        ! event fully complete: remaining = 0
    bra     .Lreturn                    ! return with remaining = 0
    mov.l r2, @r1                       ! *out_remaining = 0 (delay slot)
.Lcalc_elapsed:
    mov.l @(12, r4), r2                 ! r2 = src[+0x0C] (total duration / field[3])
    mov.l @(20, r4), r3                 ! r3 = src[+0x14] (elapsed time / field[5])
    sub r3, r2                          ! r2 = total - elapsed = remaining time
    mov.l r2, @r1                       ! *out_remaining = remaining time
.Lreturn:
    rts                                 ! return
    nop                                 ! delay slot
