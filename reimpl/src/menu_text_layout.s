/* menu_text_layout -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603AFDC - 0x0603B058
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Entity slot accessor and dispatch function for the save/command subsystem.
 *
 * Continuation of cmd_error_return (which pushes r14/r13/r12 and sets up
 * r0=byte_offset, r13=struct_ptr, r14=accumulator before falling through).
 *
 * Looks up an entity slot from the global command state table (sym_060A4D14).
 * Reads a byte index from r13[r0], computes entity_slot = state_base + 4 + index*16,
 * then dispatches based on mode (r6):
 *
 *   r6=1: Call slot[12](entity_struct) — width/metric callback. Accumulates
 *         return value into r14.
 *   r6=2: Read entity_struct[16] (precomputed metric). Accumulates into r14.
 *   r6=0: Finalize — if r14 >= 0, call slot[8](entity_struct, r14) and
 *         call save_checksum_calc(0) to commit. Return result.
 *   r6=other: Error — tail-call save_checksum_calc(-13).
 *
 * If r14 < 0 after accumulation or at finalize, tail-calls
 * save_checksum_calc(-15) as an error return.
 *
 * Register conventions (on entry, set up by cmd_error_return):
 *   r0  = byte offset into struct at r13 (entity index location)
 *   r6  = mode selector (0=finalize, 1=callback, 2=precomputed)
 *   r13 = entity struct pointer (callee-saved)
 *   r14 = accumulator for width/metric (callee-saved)
 *   r15 = stack with pr, r12, r13, r14 already pushed by caller
 *
 * Returns: r0 = result from slot callback (mode 0), or error code
 */

    .section .text.FUN_0603AFDC


    .global menu_text_layout
    .type menu_text_layout, @function
menu_text_layout:
    sts.l pr, @-r15                         ! save return address
    add #-0x4, r15                          ! allocate 4 bytes on stack (local var)
    mov.l   .L_pool_state_ptr, r12          ! r12 = &sym_060A4D14 (global command state pointer)
    mov.b @(r0, r13), r3                    ! r3 = struct[r0] — entity slot index byte
    mov.l @r12, r12                         ! r12 = *sym_060A4D14 (dereference to state base)
    extu.b r3, r3                           ! zero-extend index byte to 32-bit
    mov r6, r0                              ! r0 = mode selector
    add #0x4, r12                           ! r12 = state_base + 4 (skip header to slot table)
    shll2 r3                                ! r3 = index * 4
    shll2 r3                                ! r3 = index * 16 (each slot is 16 bytes)
    cmp/eq #0x1, r0                         ! mode == 1? (callback mode)
    bf/s    .L_check_mode_2                 ! branch if mode != 1
    add r3, r12                             ! delay: r12 = slot_table + index*16 (entity slot ptr)
    mov.l @(12, r12), r3                    ! r3 = slot[12] — width/metric callback function ptr
    jsr @r3                                 ! call callback(entity_struct)
    mov.l @r13, r4                          ! delay: r4 = *r13 (entity struct ptr, first arg)
    bra     .L_check_accumulator            ! proceed to accumulator check
    add r0, r14                             ! delay: r14 += callback result (accumulate width)
.L_check_mode_2:
    mov r6, r0                              ! r0 = mode selector (reload)
    cmp/eq #0x2, r0                         ! mode == 2? (precomputed metric mode)
    bf      .L_check_mode_other             ! branch if mode != 2
    mov.l @r13, r3                          ! r3 = *r13 (entity struct ptr)
    mov.l @(16, r3), r2                     ! r2 = entity_struct[16] — precomputed metric value
    bra     .L_check_accumulator            ! proceed to accumulator check
    add r2, r14                             ! delay: r14 += precomputed metric (accumulate)
.L_check_mode_other:
    tst r6, r6                              ! mode == 0? (finalize mode)
    bt      .L_check_accumulator            ! if mode 0, skip to accumulator check
    mov #-0xD, r4                           ! r4 = -13 (error code: invalid mode)
    add #0x4, r15                           ! deallocate local var
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    .byte   0xA4, 0x8E    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(-13)
    mov.l @r15+, r14                        ! delay: restore r14
.L_check_accumulator:
    cmp/pz r14                              ! r14 >= 0? (accumulated value non-negative?)
    bt      .L_finalize                     ! if positive, proceed to finalize
    mov #-0xF, r4                           ! r4 = -15 (error code: negative accumulator)
    add #0x4, r15                           ! deallocate local var
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    .byte   0xA4, 0x85    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(-15)
    mov.l @r15+, r14                        ! delay: restore r14
    .2byte  0xFFFF                          ! padding (alignment)
    .4byte  save_commit_write               ! pool: save_commit_write (unreferenced in this TU)
.L_pool_state_ptr:
    .4byte  sym_060A4D14                    ! pool: global command state pointer
.L_finalize:
    mov.l @(8, r12), r2                     ! r2 = slot[8] — finalize callback function ptr
    mov r14, r5                             ! r5 = accumulated value (second arg)
    jsr @r2                                 ! call finalize_callback(entity_struct, accumulated_value)
    mov.l @r13, r4                          ! delay: r4 = *r13 (entity struct ptr, first arg)
    mov.l r0, @r15                          ! save callback result on stack
    .byte   0xB4, 0x79    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(0) — commit/finalize
    mov #0x0, r4                            ! delay: r4 = 0 (success status)
    mov.l @r15, r0                          ! r0 = saved callback result (return value)
    add #0x4, r15                           ! deallocate local var
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return with r0 = callback result
    mov.l @r15+, r14                        ! delay: restore r14
