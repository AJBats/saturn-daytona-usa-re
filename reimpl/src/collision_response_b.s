/* collision_response_b -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602F270 - 0x0602F550
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains 4 sub-functions called from the render/physics orchestrator:
 *
 *   collision_response_b (0x0602F270)
 *     State-driven collision response with animation phase control.
 *     Manages gear_rotation decay (+0xD8), compares zone_timer fields
 *     (+0xDC vs +0xDE), interpolates drive_speed (+0xE0) via gear ratio
 *     table lookup and fixed-point divide. Clamps final result to
 *     collision limit table bounds. Writes error flag 0xFF on overflow.
 *
 *   damage_mac_core / sym_0602F3EC (0x0602F3EC)
 *     Fixed-point MAC damage modifier. Scales car.accel (+0x0C) by
 *     0x00480000, clamps to [0, 344], applies 3-stage attenuation
 *     to collision_speed (+0x48) and speed_copy (+0x50).
 *
 *   lighting_intensity_select / sym_0602F474 (0x0602F474)
 *     4-level lighting intensity from countdown timer at +0xD4.
 *     Indexes into intensity table at sym_060477D8.
 *
 *   distance_fog_calc / sym_0602F4B4 (0x0602F4B4)
 *     Distance-based fog attenuation. Skips if demo_mode_flag != 0.
 *     Computes |delta_x| + |delta_z| between car positions, compares
 *     against fog threshold.
 *
 * Car struct base in r14 (aliased to r0 for indexed access).
 * Stride: 0x268 bytes.
 */

    .section .text.FUN_0602F270


    .global collision_response_b
    .type collision_response_b, @function
collision_response_b:
    sts.l pr, @-r15
    mov.w   .L_off_gear_rotation, r1  ! r1 = 0xD8 (gear_rotation offset)
    mov.l @(r0, r1), r3              ! r3 = car.gear_rotation
    tst r3, r3                       ! ! state == 0?
    bt      .L_check_zone            ! skip decay if idle
    cmp/pz r3                        ! ! state > 0?
    bf      .L_state_negative        ! negative → increment toward 0
    add #-0x1, r3                    ! ! positive state: decrement
    bra     .L_check_zone
    mov.l r3, @(r0, r1)             ! ! store decremented state (delay slot)
.L_off_gear_rotation:
    .2byte  0x00D8                   /* car+0xD8: gear_rotation state */
.L_state_negative:
    add #0x1, r3                     ! ! negative state: increment toward 0
    mov.l r3, @(r0, r1)             ! ! store incremented state
    mov.w   .L_off_vel_rate, r2      ! r2 = 0xC4 (vel_rate offset)
    mov.w   .L_off_drive_speed_a, r1 ! r1 = 0xE0 (drive_speed offset)
    mov.l @(r0, r2), r3             ! ! r3 = car.vel_rate
    mov.l r3, @(r0, r1)             ! ! car.drive_speed = car.vel_rate
    mov.w   .L_off_force_aux, r4     ! r4 = 0xFA (force_aux offset)
    sub r4, r3                       ! ! r3 = vel_rate - force_aux
    mov.l r3, @(r0, r2)             ! ! car.vel_rate -= force_aux
.L_check_zone:
    mov.w   .L_off_zone_timer, r1   ! r1 = 0xDC (zone_timer offset)
    mov.w @(r0, r1), r2             ! r2 = car.zone_timer (current)
    mov.w   .L_off_zone_target, r5  ! r5 = 0xDE (zone_target offset)
    mov.w @(r0, r5), r6             ! r6 = car.zone_target
    cmp/eq r2, r6                   ! ! current == target?
    bt      .L_clamp_and_store      ! equal → skip interpolation
    cmp/gt r2, r6                   ! ! target > current?
    bt      .L_target_higher        ! target higher → path A
    bra     .L_target_lower          ! target lower → path B
    nop
.L_off_vel_rate:
    .2byte  0x00C4                   /* car+0xC4: velocity rate */
.L_off_drive_speed_a:
    .2byte  0x00E0                   /* car+0xE0: drive wheel speed */
.L_off_force_aux:
    .2byte  0x00FA                   /* car+0xFA: force auxiliary */
.L_off_zone_timer:
    .2byte  0x00DC                   /* car+0xDC: zone timer (16-bit) */
.L_off_zone_target:
    .2byte  0x00DE                   /* car+0xDE: zone target (16-bit) */
.L_target_higher:
    mov #0x3, r3                     ! ! max zone index
    cmp/eq r3, r2                    ! ! current == 3 (max)?
    bt      .L_clamp_and_store       ! already at max → skip
    mov.w r6, @(r0, r1)             ! ! car.zone_timer = target
    mov.w   .L_off_drive_speed_b, r3 ! r3 = 0xE0
    mov.l @(r0, r3), r4             ! ! r4 = car.drive_speed
    shll16 r4                        ! ! r4 <<= 16 (to 16.16 fixed-point dividend)
    mov r2, r5                       ! ! r5 = current zone index
    mov.l   .L_gear_ratio_table, r8  ! r8 = gear ratio table base
    mov r8, r9                       ! ! r9 = copy for divisor lookup
    shll2 r5                         ! ! r5 *= 4 (index to offset)
    add r5, r8                       ! ! r8 = &table[current]
    mov.l @r8, r7                    ! ! r7 = gear_ratio[current] (multiplier)
    mov r6, r5                       ! ! r5 = target zone index
    dmuls.l r7, r4                   ! ! MAC = gear_ratio[current] * drive_speed
    shll2 r5                         ! ! r5 *= 4
    add r5, r9                       ! ! r9 = &table[target]
    sts mach, r7                     ! ! extract 64-bit MAC result
    sts macl, r4
    mov.l @r9, r5                    ! ! r5 = gear_ratio[target] (divisor)
    xtrct r7, r4                     ! ! r4 = middle 32 bits of MAC
    mov.l   .L_fn_fpdiv_a, r0       ! ! call fpdiv_setup(r4, r5)
    jsr @r0                          ! ! r0 = (ratio[cur]*speed) / ratio[tgt]
    nop
    mov.w   .L_off_drive_speed_b, r3
    shlr16 r0                        ! ! r0 >>= 16 (back to integer)
    mov r0, r4
    mov r14, r0                      ! ! restore car base
    mov.l r4, @(r0, r3)             ! ! car.drive_speed = interpolated result
    mov #0x5, r5                     ! ! direction = +5 (upshift)
    mov.w   .L_off_gear_rotation_b, r1
    bra     .L_clamp_and_store
    mov.l r5, @(r0, r1)             ! ! car.gear_rotation = +5 (delay slot)
.L_off_drive_speed_b:
    .2byte  0x00E0                   /* car+0xE0: drive_speed (duplicate pool) */
.L_off_gear_rotation_b:
    .2byte  0x00D8                   /* car+0xD8: gear_rotation (duplicate pool) */
.L_gear_ratio_table:
    .4byte  sym_060477BC             /* gear ratio lookup table */
.L_fn_fpdiv_a:
    .4byte  fpdiv_setup              /* 16.16 fixed-point divide */
.L_target_lower:
    tst r2, r2                       ! ! current zone == 0?
    bt      .L_clamp_and_store       ! already at minimum → skip
    mov.w r6, @(r0, r1)             ! ! car.zone_timer = target
    mov.w   .L_off_drive_speed_c, r3
    mov.l @(r0, r3), r4             ! ! r4 = car.drive_speed
    shll16 r4                        ! ! r4 <<= 16 (16.16 dividend)
    mov r2, r5                       ! ! r5 = current zone index
    mov.l   .L_gear_ratio_table_b, r8
    mov r8, r9
    shll2 r5                         ! ! r5 *= 4
    add r5, r8                       ! ! r8 = &table[current]
    mov.l @r8, r7                    ! ! r7 = gear_ratio[current]
    mov r6, r5                       ! ! r5 = target zone index
    dmuls.l r7, r4                   ! ! MAC = ratio[current] * speed
    shll2 r5
    add r5, r9                       ! ! r9 = &table[target]
    sts mach, r7
    sts macl, r4
    mov.l @r9, r5                    ! ! r5 = gear_ratio[target] (divisor)
    xtrct r7, r4                     ! ! r4 = middle 32 bits
    mov.l   .L_fn_fpdiv_b, r0
    jsr @r0                          ! ! r0 = (ratio[cur]*speed) / ratio[tgt]
    nop
    mov.w   .L_off_drive_speed_c, r3
    shlr16 r0                        ! ! r0 >>= 16 (back to integer)
    mov r0, r4
    mov r14, r0                      ! ! restore car base
    mov.l r4, @(r0, r3)             ! ! car.drive_speed = interpolated result
    mov.w   .L_off_extended_speed, r5 ! r5 = 0x4E2 (extended speed bias)
    mov.w   .L_off_vel_rate_c, r1   ! r1 = 0xC4
    add r5, r4                       ! ! r4 = drive_speed + extended_bias
    mov.l r4, @(r0, r1)             ! ! car.vel_rate = drive_speed + bias
    mov #0x5, r4
    neg r4, r4                       ! ! r4 = -5 (downshift direction)
    mov.w   .L_off_gear_rotation_c, r3
    mov.l r4, @(r0, r3)             ! ! car.gear_rotation = -5
.L_clamp_and_store:
    mov.w   .L_max_drive_speed, r3   ! r3 = 0x2134 (max drive speed)
    mov.w   .L_off_drive_speed_c, r1 ! r1 = 0xE0
    mov.l @(r0, r1), r4             ! ! r4 = car.drive_speed
    cmp/gt r4, r3                    ! ! max > drive_speed?
    bt      .L_compute_delta         ! within bounds → skip clamp
    mov #-0x1, r4                    ! ! r4 = 0xFF (error/overflow flag)
    extu.b r4, r4                    ! ! zero-extend to 0x000000FF
    mov.w   .L_off_ext_check, r5    ! r5 = 0x84
    mov.l r3, @(r0, r1)             ! ! car.drive_speed = max (clamp)
    mov.l r4, @(r0, r5)             ! ! car.ext_check = 0xFF (overflow flag)
.L_compute_delta:
    mov.w   .L_off_projected_b, r6  ! r6 = 0xE4
    mov.w   .L_off_drag_flag, r2    ! r2 = 0xC0
    mov.l @(r0, r6), r3             ! ! r3 = car.projected_b (current value)
    mov.l @(r0, r1), r4             ! ! r4 = car.drive_speed
    mov.l @(r0, r2), r5             ! ! r5 = car.drag_flag
    add r5, r4                       ! ! r4 = drive_speed + drag
    sub r3, r4                       ! ! r4 = delta = (drive_speed + drag) - projected_b
    mov.w   .L_off_zone_timer_b, r1 ! r1 = 0xDC
    mov.l   .L_clamp_limit_table, r7 ! r7 = clamp table base
    mov.w @(r0, r1), r2             ! ! r2 = car.zone_timer
    shll2 r2                         ! ! r2 *= 4
    shll r2                          ! ! r2 *= 2 (total *= 8, entry stride)
    add r2, r7                       ! ! r7 = &clamp_table[zone_timer]
    mov.l @r7, r8                    ! ! r8 = min_delta (lower bound)
    mov.l @(4, r7), r9              ! ! r9 = max_delta (upper bound)
    cmp/gt r8, r4                    ! ! delta > min?
    bt      .L_check_upper_bound     ! yes → check upper
    mov r8, r4                       ! ! clamp to minimum
    bra     .L_apply_delta
    nop
.L_off_drive_speed_c:
    .2byte  0x00E0                   /* car+0xE0: drive_speed (duplicate pool) */
.L_off_extended_speed:
    .2byte  0x04E2                   /* extended speed bias constant */
.L_off_vel_rate_c:
    .2byte  0x00C4                   /* car+0xC4: vel_rate (duplicate pool) */
.L_off_gear_rotation_c:
    .2byte  0x00D8                   /* car+0xD8: gear_rotation (duplicate pool) */
.L_max_drive_speed:
    .2byte  0x2134                   /* maximum drive wheel speed */
.L_off_ext_check:
    .2byte  0x0084                   /* car+0x84: ext_check / overflow flag */
.L_off_projected_b:
    .2byte  0x00E4                   /* car+0xE4: projected value B */
.L_off_drag_flag:
    .2byte  0x00C0                   /* car+0xC0: drag override flag */
.L_off_zone_timer_b:
    .2byte  0x00DC                   /* car+0xDC: zone_timer (duplicate pool) */
    .2byte  0x0000                   /* alignment padding */
.L_gear_ratio_table_b:
    .4byte  sym_060477BC             /* gear ratio table (duplicate pool) */
.L_fn_fpdiv_b:
    .4byte  fpdiv_setup              /* 16.16 fixed-point divide (duplicate pool) */
.L_clamp_limit_table:
    .4byte  sym_0602F3CC             /* collision clamp limit table */
.L_check_upper_bound:
    cmp/ge r4, r9                    ! ! delta <= max?
    bt      .L_apply_delta           ! within bounds
    mov r9, r4                       ! ! clamp to maximum
.L_apply_delta:
    add r4, r3                       ! ! r3 = projected_b + clamped_delta
    mov #0x0, r8                     ! ! floor = 0
    mov.w   .L_max_drive_speed_b, r9 ! r9 = 0x2134 (max drive speed)
    cmp/gt r8, r3                    ! ! result > 0?
    bt      .L_check_max_clamp       ! yes → check upper bound
    mov r8, r3                       ! ! clamp to 0 (floor)
    bra     .L_store_and_return
    nop
.L_max_drive_speed_b:
    .2byte  0x2134                   /* max drive speed (duplicate pool) */
.L_check_max_clamp:
    cmp/ge r3, r9                    ! ! result <= max?
    bt      .L_store_and_return      ! within bounds
    mov r9, r3                       ! ! clamp to max
.L_store_and_return:
    lds.l @r15+, pr                  ! ! restore return address
    rts
    mov.l r3, @(r0, r6)             ! ! car.projected_b = clamped result (delay slot)

/* Collision clamp limit table — 4 entries of (min, max) 32-bit pairs.
 * Indexed by zone_timer value. Controls how much drive_speed can change
 * per frame during collision response animation.
 *   Entry 0: [-1200, +1200]  (widest range — early collision)
 *   Entry 1: [-600,  +600]   (medium)
 *   Entry 2: [-300,  +300]   (narrow — late collision)
 *   Entry 3: [-300,  +300]   (same as entry 2)
 */
    .global sym_0602F3CC
sym_0602F3CC:
    .word 0xFFFF              /* entry 0 min high: 0xFFFFFB50 = -1200 */
    .word 0xFB50              /* entry 0 min low */
    .word 0x0000              /* entry 0 max high: 0x000004B0 = +1200 */
    .word 0x04B0              /* entry 0 max low */
    .word 0xFFFF              /* entry 1 min high: 0xFFFFFDA8 = -600 */
    .word 0xFDA8              /* entry 1 min low */
    .word 0x0000              /* entry 1 max high: 0x00000258 = +600 */
    .word 0x0258              /* entry 1 max low */
    .word 0xFFFF              /* entry 2 min high: 0xFFFFFED4 = -300 */
    .word 0xFED4              /* entry 2 min low */
    .word 0x0000              /* entry 2 max high: 0x0000012C = +300 */
    mov.b @(r0, r2), r1      /* entry 2 max low (0x012C as instruction encoding) */
    .word 0xFFFF              /* entry 3 min high: 0xFFFFFED4 = -300 */
    .word 0xFED4              /* entry 3 min low */
    .word 0x0000              /* entry 3 max high: 0x0000012C = +300 */
    mov.b @(r0, r2), r1      /* entry 3 max low (0x012C as instruction encoding) */

/* damage_mac_core — fixed-point MAC damage modifier.
 * Input: r0 = car struct base.
 * Scales car.accel (+0x0C) by 0x00480000, clamps to [0, 0x158],
 * then applies 3-stage attenuation to collision_speed and speed_copy.
 */
    .global sym_0602F3EC
sym_0602F3EC:
    mov.l @(12, r0), r2             ! ! r2 = car.accel (+0x0C)
    mov.l   .L_damage_scale_factor, r3 ! r3 = 0x00480000
    dmuls.l r2, r3                   ! ! MAC = accel * 0x00480000
    mov.l   .L_max_raw_damage, r4   ! r4 = 0x158 (=344, max raw damage)
    sts mach, r3
    sts macl, r2
    xtrct r3, r2                     ! ! r2 = middle 32 bits of MAC
    shlr16 r2                        ! ! r2 >>= 16 (extract integer part)
    exts.w r2, r2                    ! ! sign-extend 16→32
    mov #0x0, r3
    cmp/gt r3, r2                    ! ! damage > 0?
    bt      .L_check_max_raw
    mov r3, r2                       ! ! clamp to 0 (floor)
    bra     .L_store_and_attenuate
    nop
    .2byte  0x0000                   /* alignment padding */
.L_damage_scale_factor:
    .4byte  0x00480000               /* damage scale: 72.0 in 16.16 */
.L_max_raw_damage:
    .4byte  0x00000158               /* max raw damage = 344 */
.L_check_max_raw:
    cmp/gt r2, r4                    ! ! damage < max (344)?
    bt      .L_store_and_attenuate   ! within bounds
    mov r4, r2                       ! ! clamp to max = 344
.L_store_and_attenuate:
    mov.l r2, @(8, r0)              ! ! car.speed (+0x08) = clamped damage
    shll8 r2                         ! ! r2 *= 256
    shlr2 r2                         ! ! r2 /= 4 → net *= 64 (attenuation scale)
    mov.l   .L_attn_floor, r4       ! r4 = 0 (attenuation floor)
    cmp/ge r4, r2                    ! ! attn >= 0?
    bt      .L_check_mid_clamp      ! yes → check mid clamp
    bra     .L_apply_attenuation
    mov r4, r2                       ! ! clamp to 0 (delay slot)
    .2byte  0x0000                   /* alignment padding */
.L_attn_floor:
    .4byte  0x00000000               /* attenuation floor = 0 */
.L_check_mid_clamp:
    mov.l   .L_attn_mid_max, r4     ! r4 = 0x2AAA (1/3 max attenuation)
    cmp/ge r2, r4                    ! ! attn <= 0x2AAA?
    bt      .L_check_fine_clamp      ! within bounds → check fine
    bra     .L_apply_attenuation
    mov r4, r2                       ! ! clamp to 0x2AAA (delay slot)
    .2byte  0x0000                   /* alignment padding */
.L_attn_mid_max:
    .4byte  0x00002AAA               /* mid-stage max = 10922 (1/3 of 0x7FFF) */
.L_check_fine_clamp:
    mov.l   .L_attn_fine_max, r4    ! r4 = 0x0AAA (fine detail max)
    cmp/ge r2, r4                    ! ! attn <= 0x0AAA?
    bt      .L_apply_attenuation     ! within bounds
    mov r4, r2                       ! ! clamp to 0x0AAA
.L_apply_attenuation:
    mov.w   DAT_0602f464, r3        ! r3 = 0x48 (collision_speed offset)
    mov.l @(r0, r3), r4             ! ! r4 = car.collision_speed
    sub r2, r4                       ! ! r4 -= attenuation
    mov.l r4, @(r0, r3)             ! ! car.collision_speed -= attn
    mov.w   DAT_0602f466, r3        ! r3 = 0xC0 (drag_flag offset)
    mov.l @(r0, r3), r4             ! ! r4 = car.drag_flag
    tst r4, r4                       ! ! drag_flag == 0?
    bt      .L_apply_speed_copy      ! no drag → use normal attn
    mov.l   .L_drag_attn_boost, r2  ! ! drag active: boost attn to 0x2AAA
.L_apply_speed_copy:
    mov.w   .L_off_speed_copy, r1   ! r1 = 0x50 (speed_copy offset)
    mov.l @(r0, r1), r4             ! ! r4 = car.speed_copy
    sub r2, r4                       ! ! r4 -= attenuation
    rts
    mov.l r4, @(r0, r1)             ! ! car.speed_copy -= attn (delay slot)

    .global DAT_0602f464
DAT_0602f464:
    .2byte  0x0048                   /* car+0x48: collision friction speed */

    .global DAT_0602f466
DAT_0602f466:
    .2byte  0x00C0                   /* car+0xC0: drag override flag */
.L_off_speed_copy:
    .2byte  0x0050                   /* car+0x50: speed copy */
    .2byte  0x0000                   /* alignment padding */
.L_attn_fine_max:
    .4byte  0x00000AAA               /* fine-stage max = 2730 (1/10 of 0x7FFF) */
.L_drag_attn_boost:
    .4byte  0x00002AAA               /* boosted attn when drag active */

/* lighting_intensity_select — 4-level intensity from countdown timer.
 * Input: r14 = car struct base.
 * Timer at +0xD4 counts down each frame; selects intensity level:
 *   timer >= 4: index=4 (brightest), timer=3: index=3, timer=2: index=2,
 *   timer=1: index=1, timer=0: index=0 (default/off).
 * Result stored at car+0x114.
 */
    .global sym_0602F474
sym_0602F474:
    mov r14, r0                      ! ! r0 = car base for indexed access
    mov #0x0, r5                     ! ! r5 = intensity index (starts at 0)
    mov.w   DAT_0602f4aa, r1        ! r1 = 0xD4 (mode field offset)
    mov.w @(r0, r1), r3             ! ! r3 = car.mode (countdown timer)
    tst r3, r3                       ! ! timer == 0?
    bt      .L_lookup_intensity      ! expired → use index 0
    mov #0x1, r6
    sub r6, r3                       ! ! r3 = timer - 1 (decrement)
    mov.w r3, @(r0, r1)             ! ! store decremented timer
    cmp/eq r5, r3                    ! ! timer == 0 after decrement?
    bt      .L_level_1               ! → index += 1 (level 1)
    cmp/eq r6, r3                    ! ! timer == 1?
    bt      .L_level_2               ! → index += 2 (level 2)
    mov #0x2, r7
    cmp/eq r7, r3                    ! ! timer == 2?
    bt      .L_level_3               ! → index += 3 (level 3)
    add #0x1, r5                     ! ! timer >= 3: index += 4 (brightest)
.L_level_3:
    add #0x1, r5                     ! ! cascading add for index selection
.L_level_2:
    add #0x1, r5
.L_level_1:
    add #0x1, r5
.L_lookup_intensity:
    mov.l   .L_intensity_table, r6  ! r6 = intensity table base
    shll2 r5                         ! ! r5 *= 4 (index to byte offset)
    add r5, r6                       ! ! r6 = &table[index]
    mov.l @r6, r3                    ! ! r3 = intensity value
    mov.w   .L_off_light_output, r1 ! r1 = 0x114 (light output offset)
    rts
    mov.l r3, @(r0, r1)             ! ! car.light_output = intensity (delay slot)

    .global DAT_0602f4aa
DAT_0602f4aa:
    .2byte  0x00D4                   /* car+0xD4: mode field (countdown timer) */
.L_off_light_output:
    .2byte  0x0114                   /* car+0x114: lighting output value */
    .2byte  0x0000                   /* alignment padding */
.L_intensity_table:
    .4byte  sym_060477D8             /* 4-entry intensity lookup table */

/* distance_fog_calc — distance-based fog/attenuation.
 * Input: r0 = car struct base, r14 = car base.
 * Skips entirely if demo_mode_flag (sym_0607EAE0) is nonzero.
 * Computes approximate Manhattan distance between this car and the
 * target car, with an octagonal correction: dist ~= max + min/2.
 * Continues into external code for fog application (past TU boundary).
 */
    .global sym_0602F4B4
sym_0602F4B4:
    mov.l   .L_demo_mode_flag, r1   ! r1 → sym_0607EAE0
    mov.l @r1, r3                    ! ! r3 = *demo_mode_flag
    mov #0x1, r6                     ! ! r6 = 1 (decrement constant)
    tst r3, r3                       ! ! demo mode active?
    bt      .L_fog_active            ! no → proceed with fog
    rts                              ! ! demo mode: skip fog entirely
    nop
    .2byte  0x0000                   /* alignment padding */
.L_demo_mode_flag:
    .4byte  sym_0607EAE0             /* demo_mode_flag (nonzero = skip) */
.L_fog_active:
    mov.w   DAT_0602f51a, r1        ! r1 = 0xD6 (fog countdown offset)
    mov.w @(r0, r1), r3             ! ! r3 = car.fog_countdown
    cmp/pl r3                        ! ! countdown > 0?
    bf      .L_load_car_positions    ! expired → skip decrement
    sub r6, r3                       ! ! decrement countdown
    mov.w r3, @(r0, r1)             ! ! store decremented countdown
.L_load_car_positions:
    mov.l   .L_car_iteration_base, r5
    mov.l @r5, r5                    ! ! r5 = *car_iteration_base (half car count)
    mov.l   .L_car_ptr_target, r3
    mov.l @r3, r6                    ! ! r6 = *car_ptr_target (target car base)
    mov.w   DAT_0602f51c, r2        ! r2 = 0x10 (CAR_X offset)
    mov.w   DAT_0602f51e, r4        ! r4 = 0x18 (CAR_Z offset)
    mov.l @(r0, r2), r7             ! ! r7 = this_car.x
    mov.l @(r0, r4), r8             ! ! r8 = this_car.z
    mov.w   DAT_0602f51c, r2        ! reload 0x10
    mov.w   DAT_0602f51e, r4        ! reload 0x18
    mov r2, r9
    add r6, r9                       ! ! r9 = target_car + 0x10
    mov.l @r9, r9                    ! ! r9 = target_car.x
    mov r4, r10
    add r6, r10                      ! ! r10 = target_car + 0x18
    mov.l @r10, r10                  ! ! r10 = target_car.z
    mov.l r0, @-r15                  ! ! save registers for distance calc
    mov.l r1, @-r15
    mov.l r4, @-r15
    mov.l r5, @-r15
    mov r7, r1
    sub r9, r1                       ! ! r1 = this_car.x - target_car.x
    cmp/pl r1                        ! ! dx > 0?
    bt      .L_dx_positive
    neg r1, r1                       ! ! r1 = |dx|
.L_dx_positive:
    mov r8, r4
    sub r10, r4                      ! ! r4 = this_car.z - target_car.z
    cmp/pl r4                        ! ! dz > 0?
    bt      .L_dz_positive
    neg r4, r4                       ! ! r4 = |dz|
.L_dz_positive:
    cmp/ge r4, r1                    ! ! |dx| >= |dz|?
    bt      .L_dx_dominant           ! dx is larger → octagonal approx
    shar r1                          ! ! r1 = |dx| / 2
    bra     .L_distance_computed
    add r1, r4                       ! ! dist = |dz| + |dx|/2 (delay slot)

    .global DAT_0602f51a
DAT_0602f51a:
    .2byte  0x00D6                   /* car+0xD6: fog countdown timer */

    .global DAT_0602f51c
DAT_0602f51c:
    .2byte  0x0010                   /* car+0x10: X position */

    .global DAT_0602f51e
DAT_0602f51e:
    .2byte  0x0018                   /* car+0x18: Z position */
.L_car_iteration_base:
    .4byte  sym_0607EA98             /* half car count for iteration */
.L_car_ptr_target:
    .4byte  sym_0607E948             /* target car struct pointer */
.L_dx_dominant:
    shar r4                          ! ! r4 = |dz| / 2
    add r1, r4                       ! ! dist = |dx| + |dz|/2
.L_distance_computed:
    mov r4, r2                       ! ! r2 = approx distance
    mov.l @r15+, r5                  ! ! restore saved registers
    mov.l @r15+, r4
    mov.l @r15+, r1
    mov.l @r15+, r0
    .byte   0xDC, 0x10    /* mov.l .L_pool_0602F578, r12 — fog threshold */
    cmp/ge r12, r2                   ! ! distance >= threshold?
    .byte   0x89, 0x35    /* bt 0x0602F5A8 — skip fog if far enough (external) */
    mov.l r1, @-r15                  ! ! save regs for fog application
    mov.l r5, @-r15
    mov.l r6, @-r15
    mov.l r7, @-r15
    mov.l r0, @-r15
    mov r9, r4                       ! ! r4 = target_car.x
    sub r7, r4                       ! ! r4 = target_car.x - this_car.x (signed dx)
    mov r10, r5                      ! ! r5 = target_car.z
    sub r8, r5                       ! ! r5 = target_car.z - this_car.z (signed dz)
    .byte   0xD0, 0x0B    /* mov.l .L_pool_0602F57C, r0 — continues in next TU */
