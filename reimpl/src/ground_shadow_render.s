/* ground_shadow_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036A5C - 0x06036A98
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ground_shadow_render -- Build a ground shadow display command
 *
 * Builds a display command struct on the stack:
 *   buf[0]   byte = 0x71 (ground shadow command opcode)
 *   buf[+4]  long = r14  (shadow parameter word)
 *   buf[+4]  byte = r13  (shadow sub-parameter, overwrites high byte)
 *
 * Calls input_proc_analog to initialize the struct base, writes
 * the command opcode and parameters, then dispatches through
 * input_proc_buttons with port mask 0x0200 and the struct pointer.
 *
 * Args:
 *   r13 = sub-parameter byte (callee-saved, zero-extended)
 *   r14 = shadow parameter word (callee-saved, stored at buf+4)
 *
 * Returns:
 *   r0 = result from input_proc_buttons
 *
 * Calls:
 *   input_proc_analog    -- initialize command struct base
 *   input_proc_buttons   -- dispatch with port mask + struct
 *
 * Pool references:
 *   .L_fn_input_proc_analog   -- input_proc_analog function pointer
 *   .L_fn_input_proc_buttons  -- input_proc_buttons function pointer
 *   .L_periph_port_mask       -- 0x0200: peripheral port A digital mask
 */

    .section .text.FUN_06036A5C


    .global ground_shadow_render
    .type ground_shadow_render, @function
ground_shadow_render:
    sts.l pr, @-r15                     ! save return address
    add #-0x8, r15                      ! allocate 0x8-byte stack frame for command struct
    mov.l   .L_fn_input_proc_analog, r3 ! r3 = &input_proc_analog
    jsr @r3                             ! call input_proc_analog(r4=buf)
    mov r15, r4                         ! r4 = stack buffer (delay slot)
    mov r15, r2                         ! r2 -> stack buffer base
    mov #0x71, r3                       ! r3 = 0x71 (ground shadow command opcode)
    extu.b r13, r13                     ! zero-extend r13 to byte (sub-parameter)
    mov.b r3, @r2                       ! buf[0] = 0x71 (command opcode)
    mov r13, r0                         ! r0 = sub-parameter byte
    mov r15, r2                         ! r2 -> stack buffer (longword store target)
    mov r15, r3                         ! r3 -> stack buffer (byte store target)
    mov.l r14, @(4, r2)                 ! buf[+4] = r14 (shadow parameter word)
    mov.b r0, @(4, r3)                  ! buf[+4] byte 0 = r13 (sub-param overwrites high byte)
    mov.w   .L_periph_port_mask, r4     ! r4 = 0x0200 (port A digital mask)
    mov.l   .L_fn_input_proc_buttons, r3 ! r3 = &input_proc_buttons
    jsr @r3                             ! call input_proc_buttons(r4=0x0200, r5=buf)
    mov r15, r5                         ! r5 = stack buffer (delay slot)
    mov r0, r4                          ! r4 = result from input_proc_buttons
    add #0x8, r15                       ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_periph_port_mask:
    .2byte  0x0200                      /* [HIGH] peripheral port A digital mask -- same value as ai_master_update */
    .2byte  0xFFFF                      /* alignment padding between word and longword pools */
.L_fn_input_proc_analog:
    .4byte  input_proc_analog           /* [HIGH] -> SMPC analog axis reader / command struct initializer */
.L_fn_input_proc_buttons:
    .4byte  input_proc_buttons          /* [HIGH] -> SMPC digital button reader / command dispatcher */
