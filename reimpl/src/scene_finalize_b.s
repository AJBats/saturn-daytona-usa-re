/* scene_finalize_b -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06025148 - 0x06025224
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06025148


    .global scene_finalize_b
    .type scene_finalize_b, @function
scene_finalize_b:
    mov.l r14, @-r15                    ! push r14 (callee-save)
    mov.l r13, @-r15                    ! push r13 (callee-save)
    mov.l r12, @-r15                    ! push r12 (callee-save)
    mov.l r11, @-r15                    ! push r11 (callee-save)
    mov.l r10, @-r15                    ! push r10 (callee-save)
    mov.l r9, @-r15                     ! push r9 (callee-save)
    mov.l r8, @-r15                     ! push r8 (callee-save)
    mov.l   .L_pool_render_channel_desc, r10    ! r10 = sym_060610BC: render channel descriptor table (12-byte entries)
    mov.l   .L_pool_render_state_table, r11     ! r11 = sym_0606107C: render state/attribute table (8-byte entries)
    mov.l   .L_pool_render_bitmask_array, r12   ! r12 = sym_060590A8: render enable bitmask array
    mov #0x8, r7                        ! r7 = 8 (inner loop limit — 8 render slots)
    mov #0x0, r4                        ! r4 = 0 (initial value / zero to write)
    extu.w r4, r5                       ! r5 = 0 (zero-extend: inner slot index, starts at 0)
.L_init_slot_loop:                      ! --- init loop: clear 8 render-state table slots ---
    extu.w r5, r6                       ! r6 = r5 (slot index, zero-extended)
    extu.w r4, r0                       ! r0 = 0 (zero-extended r4)
    extu.b r5, r3                       ! r3 = r5 & 0xFF (low byte of slot index)
    shll2 r6                            ! r6 = slot * 4
    mov r3, r2                          ! r2 = slot index (byte) copy for separate shift chain
    add #0x1, r5                        ! r5++ (advance slot index)
    shll r6                             ! r6 = slot * 8 (byte offset into 8-byte-stride table)
    shll2 r3                            ! r3 = slot * 4
    shll2 r2                            ! r2 = slot * 4
    add r11, r6                         ! r6 = &render_state_table[slot] (base + offset)
    shll r2                             ! r2 = slot * 8
    mov.l r4, @r6                       ! render_state_table[slot].field0 = 0 (clear longword)
    add r2, r3                          ! r3 = slot * 12 (byte offset into 12-byte descriptor table)
    mov.w r0, @(4, r6)                  ! render_state_table[slot].mask = 0 (clear word at +4)
    extu.b r3, r3                       ! r3 = (slot * 12) & 0xFF (keep low byte — wraps for index)
    extu.w r4, r2                       ! r2 = 0 (zero-extend r4)
    mov.w   .L_wpool_default_render_attr, r0       ! r0 = 0x00B4 (default attribute value)
    add r10, r3                         ! r3 = &render_channel_desc[slot] (base + offset)
    mov.w r0, @(6, r6)                  ! render_state_table[slot].attr = 0x00B4 (default attr at +6)
    mov.l @(4, r3), r3                  ! r3 = render_channel_desc[slot].state_ptr (pointer at +4)
    mov.w r2, @r3                       ! *state_ptr = 0 (clear the channel's state word)
    extu.w r5, r3                       ! r3 = r5 (current slot index, zero-extended, after increment)
    cmp/ge r7, r3                       ! if r3 >= 8: done with init loop
    bf      .L_init_slot_loop           ! branch if r3 < 8 (continue init loop)
    bra     .L_outer_loop_test          ! jump to outer loop test (skip body first time)
    extu.w r4, r13                      ! (delay slot) r13 = 0 (outer loop index, channel 0)
.L_outer_loop_body:                     ! --- outer loop body: process one render channel (r13) ---
    extu.w r4, r5                       ! r5 = 0 (reset inner slot index for this channel)
    extu.w r13, r8                      ! r8 = r13 (channel index, zero-extended)
    extu.b r13, r14                     ! r14 = r13 & 0xFF (channel index low byte)
    mov.l   .L_pool_channel_ptr_table, r3   ! r3 = sym_06060D7C: channel pointer table
    shll2 r8                            ! r8 = channel * 4
    mov r14, r2                         ! r2 = channel index (byte) copy
    shll r8                             ! r8 = channel * 8 (8-byte entries)
    shll2 r14                           ! r14 = channel * 4
    shll2 r2                            ! r2 = channel * 4
    add r3, r8                          ! r8 = &channel_ptr_table[channel]
    add #0x4, r8                        ! r8 += 4 (point to +4 field: data pointer within entry)
    shll r2                             ! r2 = channel * 8
    add r2, r14                         ! r14 = channel * 12 (12-byte descriptor stride)
    extu.b r14, r14                     ! r14 = (channel * 12) & 0xFF (low byte)
    add r10, r14                        ! r14 = &render_channel_desc[channel]
.L_inner_slot_loop:                     ! --- inner loop: test 8 slots against channel bitmask ---
    extu.w r5, r0                       ! r0 = r5 (slot index, zero-extended)
    mov.l @r8, r2                       ! r2 = channel_ptr_table[channel].data_ptr (load pointer)
    shll r0                             ! r0 = slot * 2 (word index into bitmask array)
    mov.w @r2, r1                       ! r1 = *data_ptr (channel's current state word)
    mov.w @(r0, r12), r3               ! r3 = render_bitmask_array[slot] (slot's enable bitmask)
    extu.w r1, r1                       ! r1 = r1 zero-extended (unsigned state word)
    extu.w r3, r3                       ! r3 = r3 zero-extended (unsigned bitmask)
    and r1, r3                          ! r3 = state & bitmask (test if slot enabled for this channel)
    tst r3, r3                          ! test if any enabled bits set
    bt      .L_skip_slot_copy          ! if zero (not enabled): skip this slot
    extu.w r5, r6                       ! r6 = r5 (slot index, zero-extended)
    mov.l @(4, r14), r3                 ! r3 = render_channel_desc[channel].field4 (source data ptr)
    extu.w r5, r9                       ! r9 = r5 (slot index, zero-extended) for bitmask addr
    shll2 r6                            ! r6 = slot * 4
    shll r6                             ! r6 = slot * 8 (offset in render state table)
    add r11, r6                         ! r6 = &render_state_table[slot]
    mov.l r3, @r6                       ! render_state_table[slot].field0 = channel desc field4 ptr
    shll r9                             ! r9 = slot * 2 (word offset for bitmask)
    add r12, r9                         ! r9 = &render_bitmask_array[slot]
    mov.w @r9, r0                       ! r0 = render_bitmask_array[slot] (slot's bitmask)
    mov.w r0, @(4, r6)                  ! render_state_table[slot].mask = bitmask (store at +4)
    mov.w @(8, r14), r0                 ! r0 = render_channel_desc[channel].field8 (attr/palette)
    mov.w r0, @(6, r6)                  ! render_state_table[slot].attr = channel attr (store at +6)
    mov.l @r6, r3                       ! r3 = render_state_table[slot].field0 (reload dest ptr)
    mov.w @r9, r2                       ! r2 = render_bitmask_array[slot] (reload bitmask)
    extu.w r2, r2                       ! r2 = r2 zero-extended
    mov.w @r3, r1                       ! r1 = *dest_ptr (current word at destination)
    or r2, r1                           ! r1 = current | bitmask (OR-in the slot's bit)
    mov.w r1, @r3                       ! *dest_ptr = r1 (write back with bit set)
.L_skip_slot_copy:                      ! --- slot skipped (not enabled for this channel) ---
    add #0x1, r5                        ! r5++ (advance slot index)
    extu.w r5, r3                       ! r3 = r5 (slot index, zero-extended)
    cmp/ge r7, r3                       ! if r3 >= 8: done with inner loop
    bf      .L_inner_slot_loop          ! branch if r3 < 8 (continue inner loop)
    add #0x1, r13                       ! r13++ (advance channel index)
.L_outer_loop_test:                     ! --- outer loop test: check if all 14 channels done ---
    extu.w r13, r3                      ! r3 = r13 (channel index, zero-extended)
    mov #0xE, r2                        ! r2 = 14 (number of render channels)
    cmp/ge r2, r3                       ! if r3 >= 14: done with outer loop
    bf      .L_outer_loop_body          ! branch if r3 < 14 (process next channel)
    mov.l @r15+, r8                     ! pop r8 (callee-restore)
    mov.l @r15+, r9                     ! pop r9 (callee-restore)
    mov.l @r15+, r10                    ! pop r10 (callee-restore)
    mov.l @r15+, r11                    ! pop r11 (callee-restore)
    mov.l @r15+, r12                    ! pop r12 (callee-restore)
    mov.l @r15+, r13                    ! pop r13 (callee-restore)
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay slot) pop r14 (callee-restore)
.L_wpool_default_render_attr:
    .2byte  0x00B4                      /* [MEDIUM] default render attribute value (init slot attr field) */
    .2byte  0xFFFF                      ! padding / alignment word
.L_pool_render_channel_desc:
    .4byte  sym_060610BC                ! render channel descriptor table: 14 entries x 12 bytes (ptr, state_ptr, attr, pad)
.L_pool_render_state_table:
    .4byte  sym_0606107C                ! render state/attribute table: 8 slots x 8 bytes (field0, mask, attr)
.L_pool_render_bitmask_array:
    .4byte  sym_060590A8                ! render enable bitmask array: 8 x 2-byte slot enable masks
.L_pool_channel_ptr_table:
    .4byte  sym_06060D7C                ! channel pointer table: 14 entries x 8 bytes (ptr_a, data_ptr)
