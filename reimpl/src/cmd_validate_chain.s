/* cmd_validate_chain -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603B1B6 - 0x0603B21C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * CD command chain validator: processes a queue entry, sets up
 * the transfer context, computes the adjusted transfer size,
 * dispatches through multi-stage validation, and stores the result.
 *
 * Args:
 *   r4 = queue entry index
 *   r5 = flags (passed to cmd_error_return)
 *   r6 = destination buffer address
 *   r7 = transfer size (-1 = use block's full capacity)
 *
 * Returns:
 *   r0 = result from cmd_multi_validate (negative = error)
 *
 * Register allocation:
 *   r14 = queue handle (from cmd_queue_process)
 *   r13 = transfer size / multiplier / final result
 *   @(0,r15) = saved flags (r5)
 *   @(4,r15) = saved destination buffer (r6)
 *
 * Calls (external):
 *   cmd_queue_process     0x0603AEE8  process queue entry, returns handle
 *   cmd_error_return      0x0603AFD0  set up transfer error context
 *   cmd_result_store      0x0603AF94  finalise and store transfer result
 *   cmd_multi_validate    0x0603B21C  multi-stage block validation + dispatch
 *   save_checksum_calc    0x0603B93C  set status/error code
 */

    .section .text.FUN_0603B1B6


    .global cmd_validate_chain
    .type cmd_validate_chain, @function
cmd_validate_chain:
    mov.l r14, @-r15            ! save r14 (callee-saved)
    mov.l r13, @-r15            ! save r13 (callee-saved)
    sts.l pr, @-r15             ! save return address
    sts.l macl, @-r15           ! save MAC-low register
    add #-0x8, r15              ! allocate 8 bytes of stack locals
    mov.l r5, @r15              ! local[0] = r5 (flags)
    mov.l r6, @(4, r15)         ! local[4] = r6 (destination buffer)
    .byte   0xBE, 0x90    /* bsr 0x0603AEE8 (external) */  ! call cmd_queue_process(r4=index)
    mov r7, r13                 ! delay: r13 = transfer size arg
    mov r0, r14                 ! r14 = queue handle (NULL on failure)
    tst r14, r14                ! did queue processing succeed?
    bf      .L_setup_transfer   ! if nonzero (success), proceed to transfer setup
    mov #-0x9, r4               ! r4 = -9 (error: queue process failed)
    add #0x8, r15               ! free stack locals
    lds.l @r15+, macl           ! restore MAC-low
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r13            ! restore r13
    .byte   0xA3, 0xB0    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(-9)
    mov.l @r15+, r14            ! delay: restore r14
.L_setup_transfer:
    mov #0x0, r6                ! r6 = 0 (clear flags for error context)
    mov.l @r15, r5              ! r5 = flags from local[0]
    .byte   0xBE, 0xF6    /* bsr 0x0603AFD0 (external) */  ! call cmd_error_return(r4=handle, r5=flags, r6=0)
    mov r14, r4                 ! delay: r4 = queue handle
    mov.l @r14, r5              ! r5 = handle->data (inner block pointer)
    mov r13, r0                 ! r0 = transfer size arg
    mov.l @r15, r3              ! r3 = flags from local[0]
    mov.l @(16, r5), r5         ! r5 = data[0x10] (block capacity field)
    cmp/eq #-0x1, r0            ! is transfer size == -1? (use full capacity?)
    bf/s    .L_dispatch         ! if size != -1, skip capacity adjustment
    sub r3, r5                  ! delay: r5 = capacity - flags (adjusted capacity)
    .byte   0x9D, 0x3D    /* mov.w .L_wpool_0603B270, r13 */  ! r13 = size multiplier from cross-TU word pool
    mul.l r13, r5               ! multiply adjusted capacity by size multiplier
    sts macl, r13               ! r13 = adjusted transfer size
.L_dispatch:
    mov r13, r7                 ! r7 = transfer size (4th arg)
    mov.l @(4, r15), r6         ! r6 = destination buffer from local[4] (3rd arg)
    .byte   0xB0, 0x0E    /* bsr 0x0603B21C (external) */  ! call cmd_multi_validate(r4=handle, ..., r6=dest, r7=size)
    mov r14, r4                 ! delay: r4 = queue handle
    mov r0, r13                 ! r13 = validation result
    .byte   0xBE, 0xC7    /* bsr 0x0603AF94 (external) */  ! call cmd_result_store(r4=handle)
    mov r14, r4                 ! delay: r4 = queue handle
    cmp/pz r13                  ! is validation result >= 0? (success?)
    bf      .L_return           ! if negative (error), skip success report
    .byte   0xB3, 0x97    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(0) â€” report success
    mov #0x0, r4                ! delay: r4 = 0 (success code)
.L_return:
    mov r13, r0                 ! r0 = validation result (return value)
    add #0x8, r15               ! free stack locals
    lds.l @r15+, macl           ! restore MAC-low
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r13            ! restore r13
    rts                         ! return to caller
    mov.l @r15+, r14            ! delay: restore r14
