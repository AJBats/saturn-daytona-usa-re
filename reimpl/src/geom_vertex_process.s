/* geom_vertex_process -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E958 - 0x0601EAA0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Geometry vertex processing dispatcher -- decides how to update the HUD
 * geometry pipeline for the current frame based on element priority state.
 *
 * Flow:
 *   1. Check output dirty flag (sym_0605E05D); if set, clear it and exit
 *      (previous frame's output is still pending).
 *   2. Call hud_overlay_render to refresh the overlay layer.
 *   3. Call hud_state_machine to scan HUD elements and get a priority code:
 *        0..2 = element changed (highest priority)
 *        3..5 = element needs update
 *        6    = (unused threshold)
 *        7+   = no element needs attention (idle)
 *        8    = fully idle
 *   4. If priority >= 7 (idle): call geom_normal_compute, clear player
 *      status flag, set dirty state = 4, call RTS stub, exit.
 *   5. If priority < 7 but >= 3: store (priority - 3) as element state,
 *      call geom_normal_compute, tail-call geom_output_handler.
 *   6. If priority < 3: store element state, call hud_render_stage with
 *      geometry buffers. If render reports changes, set dirty state = 8
 *      and call RTS stub (early exit).
 *   7. If render reports no changes AND geom busy flag is clear:
 *      compare current vs reference vertex data (16 bytes). On any
 *      mismatch, set dirty state = 8 and call RTS stub.
 *   8. If all 16 bytes match: tail-call geom_vertex_compute (full unpack).
 *
 * Key symbols:
 *   sym_0605E098 = geometry output buffer pointer (deref'd)
 *   sym_0601F8BC = RTS stub (no-op function)
 *   sym_0605E05C = output dirty flag byte
 *   sym_0605E05D = output pending flag byte (dirty flag + 1)
 *   sym_060877D8 = current player/car index (byte)
 *   sym_0604A57C = course name string table (12 bytes per entry)
 *   sym_060877DD = player status flags array (indexed by player)
 *   sym_060877D9 = player element state array (indexed by player)
 *
 * Called functions:
 *   hud_overlay_render  (0x0601E2B4) -- refresh overlay layer
 *   hud_state_machine   (0x0601E4D4) -- scan HUD element priorities
 *   geom_normal_compute (0x0601EB70) -- compute geometry normals
 *   hud_render_stage    (0x0601E764) -- render single HUD element
 *   geom_output_handler (0x0601F40C) -- output pipeline entry
 *   geom_vertex_compute (0x0601EBDA) -- full vertex data unpack
 */

    .section .text.FUN_0601E958


    .global geom_vertex_process
    .type geom_vertex_process, @function
geom_vertex_process:
    mov.l r14, @-r15                   ! save r14
    mov.l r13, @-r15                   ! save r13
    mov.l r12, @-r15                   ! save r12
    mov.l r11, @-r15                   ! save r11
    mov.l r10, @-r15                   ! save r10
    mov #0x8, r11                      ! r11 = 8 (dirty state: "needs full refresh")
    mov.l r9, @-r15                    ! save r9
    mov #0x10, r10                     ! r10 = 16 (vertex compare byte count)
    mov.l r8, @-r15                    ! save r8
    sts.l pr, @-r15                    ! save return address
    mov.l   .L_pool_geom_output_ptr, r9 ! r9 = &geom_output_buf_ptr (sym_0605E098)
    mov.l   .L_pool_rts_stub, r12      ! r12 = RTS stub function (sym_0601F8BC)
    mov.l   .L_pool_dirty_flag, r13    ! r13 = &output_dirty_flag (sym_0605E05C)
    mov.l   .L_pool_pending_flag, r0   ! r0 = &output_pending_flag (sym_0605E05D)
    mov.b @r0, r0                      ! r0 = pending_flag value
    tst r0, r0                         ! pending_flag == 0?
    bt/s    .L_not_pending             ! yes: proceed with normal processing
    mov #0x0, r8                       ! r8 = 0 (loop counter init, delay slot)
    bra     .L_epilogue_return         ! pending: skip processing
    mov.b r8, @r13                     ! clear dirty flag to 0 (delay slot)
.L_not_pending:
    .byte   0xBC, 0x98    /* bsr 0x0601E2B4 (hud_overlay_render) */
    nop                                ! (delay slot)
    mov.l   .L_pool_player_index, r14  ! r14 = &player_index (sym_060877D8)
    mov.l   .L_pool_course_name_table, r2 ! r2 = course_name_table base (sym_0604A57C)
    mov.b @r14, r4                     ! r4 = current player index (byte)
    extu.b r4, r4                      ! zero-extend player index
    mov r4, r3                         ! r3 = player_index (copy for stride calc)
    shll2 r4                           ! r4 = player_index * 4
    shll2 r3                           ! r3 = player_index * 4
    shll r3                            ! r3 = player_index * 8
    add r3, r4                         ! r4 = player_index * 12 (course name stride)
    .byte   0xBD, 0x9D    /* bsr 0x0601E4D4 (hud_state_machine) */
    add r2, r4                         ! r4 = &course_name[player] (delay slot, arg)
    extu.b r0, r4                      ! r4 = hud_state_machine result (priority code)
    mov #0x7, r2                       ! r2 = 7 (idle threshold)
    cmp/ge r2, r4                      ! priority >= 7?
    bf      .L_not_idle                ! no: element needs processing
    .byte   0xB0, 0xE5    /* bsr 0x0601EB70 (geom_normal_compute) */
    nop                                ! (delay slot)
    mov.b @r14, r2                     ! r2 = player_index
    mov.l   .L_pool_player_status, r3  ! r3 = player_status_flags base (sym_060877DD)
    extu.b r2, r2                      ! zero-extend player_index
    add r3, r2                         ! r2 = &player_status_flags[player]
    mov.b r8, @r2                      ! player_status_flags[player] = 0 (clear)
    mov #0x4, r2                       ! r2 = 4
    jsr @r12                           ! call RTS stub (no-op)
    mov.b r2, @r13                     ! dirty_flag = 4 (delay slot, "idle refresh done")
    bra     .L_epilogue_return         ! exit
    nop                                ! (delay slot)
.L_not_idle:
    mov #0x1, r1                       ! r1 = 1 (status: active)
    mov.b @r14, r2                     ! r2 = player_index
    mov.l   .L_pool_player_status, r3  ! r3 = player_status_flags base (sym_060877DD)
    extu.b r2, r2                      ! zero-extend player_index
    add r3, r2                         ! r2 = &player_status_flags[player]
    mov.b r1, @r2                      ! player_status_flags[player] = 1 (mark active)
    mov #0x3, r3                       ! r3 = 3 (update threshold)
    cmp/ge r3, r4                      ! priority >= 3? (element needs update path)
    bf      .L_element_changed         ! no: element changed path (priority 0..2)
    add #-0x3, r4                      ! r4 = priority - 3 (normalize to 0..2 range)
    mov.b @r14, r3                     ! r3 = player_index
    mov.l   .L_pool_player_elem_state, r2 ! r2 = player_elem_state base (sym_060877D9)
    extu.b r4, r4                      ! zero-extend normalized priority
    extu.b r3, r3                      ! zero-extend player_index
    add r2, r3                         ! r3 = &player_elem_state[player]
    mov.b r4, @r3                      ! player_elem_state[player] = normalized priority
    .byte   0xB0, 0xC9    /* bsr 0x0601EB70 (geom_normal_compute) */
    nop                                ! (delay slot)
    lds.l @r15+, pr                    ! restore return address
    mov.l @r15+, r8                    ! restore r8
    mov.l @r15+, r9                    ! restore r9
    mov.l @r15+, r10                   ! restore r10
    mov.l @r15+, r11                   ! restore r11
    mov.l @r15+, r12                   ! restore r12
    mov.l @r15+, r13                   ! restore r13
    .byte   0xA5, 0x0E    /* bra 0x0601F40C (geom_output_handler) — tail call */
    mov.l @r15+, r14                   ! restore r14 (delay slot)
    .4byte  0x2010001F
.L_pool_geom_output_ptr:
    .4byte  sym_0605E098               ! geometry output buffer pointer (deref'd)
.L_pool_rts_stub:
    .4byte  sym_0601F8BC               ! RTS stub (no-op function)
.L_pool_dirty_flag:
    .4byte  sym_0605E05C               ! output dirty flag byte
.L_pool_pending_flag:
    .4byte  sym_0605E05D               ! output pending flag byte
.L_pool_player_index:
    .4byte  sym_060877D8               ! current player/car index (byte)
.L_pool_course_name_table:
    .4byte  sym_0604A57C               ! course name string table (12 bytes per entry)
.L_pool_player_status:
    .4byte  sym_060877DD               ! player status flags array (per-player)
.L_pool_player_elem_state:
    .4byte  sym_060877D9               ! player element state array (per-player)
.L_element_changed:
    mov.b @r14, r2                     ! r2 = player_index
    .byte   0xD3, 0x2F    /* mov.l @(0xBC,PC), r3 — out-of-TU: sym_060877D9 (player_elem_state) */
    extu.b r2, r2                      ! zero-extend player_index
    add r3, r2                         ! r2 = &player_elem_state[player]
    mov.b r4, @r2                      ! player_elem_state[player] = priority (0..2)
    mov.l @r9, r6                      ! r6 = *geom_output_buf_ptr (actual buffer addr)
    mov.b @r14, r5                     ! r5 = player_index (for stride calc)
    .byte   0xD2, 0x2D    /* mov.l @(0xB4,PC), r2 — out-of-TU: sym_0604A57C (course_name_table) */
    mov.b @r14, r4                     ! r4 = player_index (for state lookup)
    extu.b r5, r5                      ! zero-extend r5
    extu.b r4, r4                      ! zero-extend r4
    mov r5, r3                         ! r3 = player_index (copy for stride)
    shll2 r5                           ! r5 = player_index * 4
    shll2 r3                           ! r3 = player_index * 4
    shll r3                            ! r3 = player_index * 8
    add r3, r5                         ! r5 = player_index * 12 (course name stride)
    add r2, r5                         ! r5 = &course_name[player]
    .byte   0xD3, 0x27    /* mov.l @(0x9C,PC), r3 — out-of-TU: sym_060877D9 (player_elem_state) */
    add r3, r4                         ! r4 = &player_elem_state[player]
    mov.b @r4, r4                      ! r4 = player_elem_state[player] (element ID)
    .byte   0xBE, 0x92    /* bsr 0x0601E764 (hud_render_stage) */
    extu.b r4, r4                      ! zero-extend element ID (delay slot, arg)
    mov r0, r4                         ! r4 = hud_render_stage result (render changed?)
    tst r4, r4                         ! result == 0?
    bt      .L_render_unchanged        ! yes: no render changes, check vertex data
    jsr @r12                           ! call RTS stub (no-op)
    mov.b r11, @r13                    ! dirty_flag = 8 ("needs full refresh", delay slot)
    bra     .L_epilogue_return         ! exit
    nop                                ! (delay slot)
.L_render_unchanged:
    .byte   0xD2, 0x23    /* mov.l @(0x8C,PC), r2 — out-of-TU: sym_06087080 (geom_busy_flag) */
    mov.b @r2, r2                      ! r2 = geom_busy_flag value
    extu.b r2, r2                      ! zero-extend
    tst r2, r2                         ! busy_flag == 0?
    bf      .L_epilogue_return         ! no: geometry busy, skip comparison
    mov r8, r4                         ! r4 = 0 (byte comparison loop index)
.L_compare_loop:
    mov.l @r9, r3                      ! r3 = *geom_output_buf_ptr (current buffer)
    add r4, r3                         ! r3 = &current_buf[index]
    mov.b @r3, r2                      ! r2 = current_buf[index] (current vertex byte)
    .byte   0xD3, 0x1F    /* mov.l @(0x7C,PC), r3 — out-of-TU: sym_0604A5AC (reference table) */
    extu.b r2, r2                      ! zero-extend current byte
    add r4, r3                         ! r3 = &reference_table[index]
    mov.b @r3, r1                      ! r1 = reference_table[index] (expected byte)
    extu.b r1, r1                      ! zero-extend expected byte
    cmp/eq r1, r2                      ! current == expected?
    bt      .L_bytes_match             ! yes: check next byte
    jsr @r12                           ! call RTS stub (no-op)
    mov.b r11, @r13                    ! dirty_flag = 8 ("needs full refresh", delay slot)
    bra     .L_epilogue_return         ! exit (mismatch found)
    nop                                ! (delay slot)
.L_bytes_match:
    add #0x1, r4                       ! r4++ (next byte index)
    cmp/ge r10, r4                     ! index >= 16? (all bytes compared)
    bf      .L_compare_loop            ! no: continue comparing
    lds.l @r15+, pr                    ! restore return address
    mov.l @r15+, r8                    ! restore r8
    mov.l @r15+, r9                    ! restore r9
    mov.l @r15+, r10                   ! restore r10
    mov.l @r15+, r11                   ! restore r11
    mov.l @r15+, r12                   ! restore r12
    mov.l @r15+, r13                   ! restore r13
    .byte   0xA0, 0xA6    /* bra 0x0601EBDA (geom_vertex_compute) — tail call */
    mov.l @r15+, r14                   ! restore r14 (delay slot)
.L_epilogue_return:
    lds.l @r15+, pr                    ! restore return address
    mov.l @r15+, r8                    ! restore r8
    mov.l @r15+, r9                    ! restore r9
    mov.l @r15+, r10                   ! restore r10
    mov.l @r15+, r11                   ! restore r11
    mov.l @r15+, r12                   ! restore r12
    mov.l @r15+, r13                   ! restore r13
    rts                                ! return to caller
    mov.l @r15+, r14                   ! restore r14 (delay slot)
