/* camera_system -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600BB94 - 0x0600BFFC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Camera state machine — controls eye/target/up vectors for the game camera.
 *
 * Functions:
 *   camera_system (0x0600BB94):
 *     Main camera update dispatcher. Reads camera mode byte and branches:
 *       Mode 0: no-op (idle/reset)
 *       Mode 1: follow mode — tracks player car with optional eye offset
 *       Mode 4: speed-dependent camera — adjusts Y offset based on speed,
 *               transitions to cinematic on gear 7/8
 *       Mode 6: sets state to 3 (drift/transition trigger)
 *       Mode 7: cinematic mode — speed-based eye height with gear 7/8 transition
 *     After mode dispatch, computes final eye position using:
 *       - Direction flip (sym_06078663) for positive/negative Y offset
 *       - Alternate camera path with XZ adjustments (sym_06082A30 flag)
 *       - sincos_pair + fpmul for heading-relative offset
 *       - Heading smoothing subroutine for target tracking
 *
 *   .L_0600BF70 (heading_smooth subroutine):
 *     Exponential smoothing of camera heading toward player car heading.
 *     Reads car heading (word at car+28), scales by 0x0384 (900),
 *     blends with current value: (old × 800 + new × 224) >> 10.
 *     Only blends when camera_state_a == camera_state_b (steady state);
 *     otherwise snaps directly.
 *
 * Key data:
 *   DAT_0600bc2c = 0x2C00 — eye Y base offset (fixed-point)
 *   DAT_0600bc2e = 0x01D8 — car struct offset for height field
 *   DAT_0600bcee = 0x01BC — car struct offset for gear/speed state
 *   DAT_0600bdac = 0x01BC — same gear/speed offset (mode 4 pool copy)
 *   DAT_0600bdae = 0x0244 — car struct offset for look-ahead distance
 *   DAT_0600bf3c = 0x6666 — alternate camera zoom factor
 *   DAT_0600bfe2 = 0x0384 — heading scale factor (900)
 */

    .section .text.FUN_0600BB94


    .global camera_system
    .type camera_system, @function
camera_system:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x8, r15
    mov.l   .L_fn_cmd_queue_commit, r8      ! r8 = cmd_queue_commit function
    mov.l   .L_camera_heading_ptr, r9       ! r9 = &camera_heading (sym_06063E28)
    mov.l   .L_camera_z_offset_ptr, r10     ! r10 = &camera_z_offset (sym_06063E30)
    mov.l   .L_camera_up_vec, r11           ! r11 = camera up vector (sym_06063EF8)
    mov.l   .L_camera_target_ptr, r12       ! r12 = camera target vector (sym_06063EEC)
    mov.l   .L_player_car_ptr, r14          ! r14 = &player_car_ptr
    mov.l @r14, r14                         ! r14 = player car struct base
    mov.l   .L_camera_state_b, r7           ! r7 = &camera_state_b (sym_06063E20)
    mov #0x2, r6                            ! r6 = constant 2
    mov.w   DAT_0600bc2c, r5                 ! r5 = 0x2C00 (eye Y base offset)
    mov #0x1, r4                            ! r4 = constant 1
    mov.l   .L_camera_eye_pos, r13          ! r13 = camera eye Y position ptr (sym_06063E24)
    mov.l   .L_camera_mode_ptr, r0          ! r0 = &camera_mode byte
    mov.b @r0, r0                           ! read camera mode
    bra     .L_mode_dispatch
    extu.b r0, r0                           ! zero-extend mode byte
! --- Mode 1: follow camera ---
.L_mode1_entry:
    mov.l   .L_scene_active_flag, r0        ! check if scene is active
    mov.l @r0, r0
    tst r0, r0
    bt      .L_mode1_idle                   ! if not active, do follow logic
    bra     .L_camera_exit
    nop
.L_mode1_idle:
    mov.l @r7, r3                           ! r3 = camera_state_b
    cmp/hi r4, r3                           ! state_b > 1?
    bt      .L_mode1_update                 ! yes: skip height adjustment
    mov.l @(32, r14), r3                    ! r3 = car.pos_y (word 8)
    mov.w   DAT_0600bc2e, r0                 ! r0 = 0x01D8 (car struct height offset)
    mov.l @(r0, r14), r2                    ! r2 = car.height
    add r2, r3                              ! r3 = pos_y + height
    mov.l r3, @(4, r12)                     ! camera_target.y = pos_y + height
.L_mode1_update:
    mov.l   .L_camera_scroll_val, r4        ! r4 = &camera scroll value
    .byte   0xB3, 0xE0    /* bsr 0x0600C3A8 (external) */
    mov.w @r4, r4                           ! r4 = scroll value (delay slot)
    bra     .L_camera_exit
    nop
! --- Mode 7: cinematic camera (speed-based eye height) ---
.L_mode7_entry:
    mov.w   .L_gear_state_offset_a, r0      ! r0 = 0x01BC (gear/speed offset)
    mov #0x30, r3                           ! threshold = 48
    mov.l @(r0, r14), r2                    ! r2 = car.gear_speed_state
    cmp/gt r3, r2                           ! speed > 48?
    bf      .L_mode7_check_28               ! no: check lower threshold
    bra     .L_mode7_apply                  ! yes: use current eye height
    nop
.L_mode7_check_28:
    mov #0x28, r3                           ! threshold = 40
    mov.w   .L_gear_state_offset_a, r0
    mov.l @(r0, r14), r2
    cmp/gt r3, r2                           ! speed > 40?
    bf      .L_mode7_check_10              ! no: check next threshold
    mov.l @r13, r2                          ! r2 = current eye.y
    sub r5, r2                              ! eye.y -= height_offset (lower camera)
    bra     .L_mode7_apply
    mov.l r2, @r13                          ! store adjusted eye.y
.L_mode7_check_10:
    mov.w   .L_gear_state_offset_a, r0
    mov #0x10, r3                           ! threshold = 16
    mov.l @(r0, r14), r2
    cmp/gt r3, r2                           ! speed > 16?
    bf      .L_mode7_check_8               ! no: check lowest threshold
    bra     .L_mode7_apply                  ! yes: keep current height
    nop
.L_mode7_check_8:
    mov #0x8, r3                            ! threshold = 8
    mov.w   .L_gear_state_offset_a, r0
    mov.l @(r0, r14), r2
    cmp/gt r3, r2                           ! speed > 8?
    bf      .L_mode7_gear_check            ! no: check for gear transition
    mov.l @r13, r2                          ! r2 = current eye.y
    add r5, r2                              ! eye.y += height_offset (raise camera)
    bra     .L_mode7_apply
    mov.l r2, @r13                          ! store adjusted eye.y

    .global DAT_0600bc2c
DAT_0600bc2c:
    .2byte  0x2C00

    .global DAT_0600bc2e
DAT_0600bc2e:
    .2byte  0x01D8
.L_gear_state_offset_a:
    .2byte  0x01BC
    .2byte  0xFFFF
.L_fn_cmd_queue_commit:
    .4byte  sym_06038520
.L_camera_heading_ptr:
    .4byte  sym_06063E28
.L_camera_z_offset_ptr:
    .4byte  sym_06063E30
.L_camera_up_vec:
    .4byte  sym_06063EF8
.L_camera_target_ptr:
    .4byte  sym_06063EEC
.L_player_car_ptr:
    .4byte  sym_0607E944
.L_camera_state_b:
    .4byte  sym_06063E20
.L_camera_eye_pos:
    .4byte  sym_06063E24
.L_camera_mode_ptr:
    .4byte  sym_06078654
.L_scene_active_flag:
    .4byte  sym_0605A1C4
.L_camera_scroll_val:
    .4byte  sym_06063D9A
! --- Mode 7: gear 7/8 transition to cinematic ---
.L_mode7_gear_check:
    mov.w   DAT_0600bcee, r0               ! r0 = 0x01BC
    mov.l @(r0, r14), r5                   ! r5 = car.gear_state
    mov r5, r0
    cmp/eq #0x8, r0                        ! gear == 8?
    bt      .L_mode7_cinematic_init        ! yes: init cinematic
    mov r5, r0
    cmp/eq #0x7, r0                        ! gear == 7?
    bf      .L_mode7_apply                 ! no: just apply current
.L_mode7_cinematic_init:
    mov.l   .L_camera_state_a, r3          ! r3 = &camera_state_a
    mov #0x0, r5
    mov.l r6, @r3                          ! camera_state_a = 2
    mov.l   .L_cinematic_config_a, r3      ! r3 = &cinematic config A
    mov.l r4, @r3                          ! config_a = 1
    mov.l   .L_fn_channel_nibble, r3
    jsr @r3                                ! channel_nibble_config(8)
    mov #0x8, r4
    mov.l   .L_cinematic_eye_y, r2         ! r2 = 0x00058000 (5.5 in 16.16)
    mov.l r2, @r13                         ! eye.y = 5.5
    mov.l   .L_cinematic_heading_val, r3   ! r3 = 0x0000F300
    mov.l   .L_camera_heading_store, r2    ! r2 = &heading store
    mov.l r3, @r2                          ! heading_store = 0xF300
    mov.l   .L_cinematic_base_offset, r3   ! r3 = 0x006E0000 (110.0)
    mov.l r3, @r9                          ! camera_heading = 110.0
    mov.l   .L_fp_sixteen, r2              ! r2 = 0x00100000 (16.0)
    mov.l   .L_camera_zoom_factor, r3      ! r3 = &zoom factor
    mov.l r2, @r3                          ! zoom = 16.0
    mov #0x0, r2
    mov.l r2, @r10                         ! camera_z_offset = 0
.L_mode7_apply:
    mov.l   .L_camera_scroll_val_b, r4     ! r4 = &scroll value
    .byte   0xB3, 0x85    /* bsr 0x0600C3A8 (external) */
    mov.w @r4, r4                          ! r4 = scroll value (delay slot)
    bra     .L_camera_exit
    nop
! --- Mode 4: speed-dependent camera ---
.L_mode4_entry:
    mov.w   DAT_0600bcee, r0               ! r0 = 0x01BC
    mov.l @(r0, r14), r0                   ! r0 = car.gear_state
    tst r0, r0                             ! gear == 0?
    bf      .L_mode4_speed_check           ! no: check speed thresholds
    bra     .L_mode4_finalize              ! yes: go to finalize
    mov.l r6, @r7                          ! camera_state_b = 2 (delay slot)
.L_mode4_speed_check:
    mov #0x30, r3                          ! threshold = 48
    mov.w   DAT_0600bcee, r0
    mov.l @(r0, r14), r2
    cmp/gt r3, r2                          ! speed > 48?
    bf      .L_mode4_check_28             ! no
    bra     .L_mode4_finalize             ! yes: keep current
    nop
.L_mode4_check_28:
    mov.w   DAT_0600bcee, r0
    mov #0x28, r3                          ! threshold = 40
    mov.l @(r0, r14), r2
    cmp/gt r3, r2                          ! speed > 40?
    bf      .L_mode4_check_10
    mov.l @r13, r2                         ! eye.y
    sub r5, r2                             ! lower camera
    bra     .L_mode4_finalize
    mov.l r2, @r13
.L_mode4_check_10:
    mov #0x10, r3                          ! threshold = 16
    mov.w   DAT_0600bcee, r0
    mov.l @(r0, r14), r2
    cmp/gt r3, r2
    bf      .L_mode4_check_8
    bra     .L_mode4_finalize             ! keep current
    nop
.L_mode4_check_8:
    mov.w   DAT_0600bcee, r0
    mov #0x8, r3                           ! threshold = 8
    mov.l @(r0, r14), r2
    cmp/gt r3, r2
    bf      .L_mode4_gear_check           ! below 8: check gear
    mov.l @r13, r2
    add r5, r2                             ! raise camera
    bra     .L_mode4_finalize
    mov.l r2, @r13

    .global DAT_0600bcee
DAT_0600bcee:
    .2byte  0x01BC
.L_camera_state_a:
    .4byte  sym_06063E1C
.L_cinematic_config_a:
    .4byte  sym_06059F30
.L_fn_channel_nibble:
    .4byte  channel_nibble_config
.L_cinematic_eye_y:
    .4byte  0x00058000
.L_cinematic_heading_val:
    .4byte  0x0000F300
.L_camera_heading_store:
    .4byte  sym_06063E34
.L_cinematic_base_offset:
    .4byte  0x006E0000
.L_fp_sixteen:
    .4byte  0x00100000                  /* 16.0 (16.16 fixed-point) */
.L_camera_zoom_factor:
    .4byte  sym_06063E2C
.L_camera_scroll_val_b:
    .4byte  sym_06063D9A
! --- Mode 4: gear 7/8 → cinematic transition ---
.L_mode4_gear_check:
    mov.w   DAT_0600bdac, r0               ! r0 = 0x01BC
    mov.l @(r0, r14), r5                   ! r5 = car.gear_state
    mov r5, r0
    cmp/eq #0x8, r0                        ! gear == 8?
    bt      .L_mode4_cinematic_init
    mov r5, r0
    cmp/eq #0x7, r0                        ! gear == 7?
    bf      .L_mode4_finalize
.L_mode4_cinematic_init:
    mov.l   .L_camera_state_a_b, r3
    mov #0x0, r5
    mov.l r6, @r3                          ! camera_state_a = 2
    mov.l   .L_cinematic_config_a_b, r3
    mov.l r4, @r3                          ! cinematic_config = 1
    mov.l   .L_fn_channel_nibble_b, r3
    jsr @r3                                ! channel_nibble_config(8)
    mov #0x8, r4
    mov.l   .L_cinematic_eye_y_b, r2       ! eye.y = 5.5
    mov.l r2, @r13
    mov.l   .L_cinematic_heading_b, r3     ! heading = 0xF300
    mov.l   .L_camera_heading_store_b, r2
    mov.l r3, @r2
    mov.l   .L_cinematic_offset_b, r3      ! base offset = 110.0
    mov.l r3, @r9
    mov.l   .L_fp_sixteen_b, r2            ! zoom = 16.0
    mov.l   .L_camera_zoom_b, r3
    mov.l r2, @r3
    mov #0x0, r2
    mov.l r2, @r10                         ! z_offset = 0
.L_mode4_finalize:
    mov.l @(32, r14), r3                   ! r3 = car.pos_y
    mov.w   DAT_0600bdae, r0               ! r0 = 0x0244 (look-ahead offset)
    mov.l @(r0, r14), r2                   ! r2 = car.look_ahead
    sub r2, r3                             ! target.y = pos_y - look_ahead
    mov.l r3, @(4, r12)                    ! store camera target Y
    mov.l @(r0, r14), r3                   ! r3 = look_ahead
    mov.l   .L_fp_half, r2                 ! r2 = 0.5 (16.16)
    neg r3, r3                             ! r3 = -look_ahead
    add r2, r3                             ! r3 = 0.5 - look_ahead
    shar r3                                ! exponential decay: >>4
    shar r3
    shar r3
    shar r3
    mov.l @(r0, r14), r1                   ! r1 = look_ahead
    add r3, r1                             ! look_ahead += (0.5 - look_ahead) >> 4
    bra     .L_camera_exit
    mov.l r1, @(r0, r14)                   ! store updated look_ahead
! --- Mode 6: drift trigger ---
.L_mode6_entry:
    mov #0x3, r2
    mov.l r2, @r7                          ! camera_state_b = 3
.L_mode0_nop:
    bra     .L_camera_exit
    nop
! --- Mode dispatch jump table ---
.L_mode_dispatch:
    cmp/eq #0x0, r0
    bt      .L_mode0_nop                   ! mode 0: idle
    cmp/eq #0x1, r0
    bf      .L_mode_not_1
    bra     .L_mode1_entry                 ! mode 1: follow
    nop
.L_mode_not_1:
    cmp/eq #0x4, r0
    bt      .L_mode4_entry                 ! mode 4: speed-dependent
    cmp/eq #0x6, r0
    bt      .L_mode6_entry                 ! mode 6: drift trigger
    cmp/eq #0x7, r0
    bf      .L_camera_exit
    bra     .L_mode7_entry                 ! mode 7: cinematic
    nop
! === Post-mode: compute final eye position ===
.L_camera_exit:
    mov.l   .L_camera_dir_flip, r0         ! r0 = &direction_flip byte
    mov.b @r0, r0
    tst r0, r0                             ! flip == 0?
    bt      .L_dir_negative                ! yes: negative Y offset
    mov.l @(4, r12), r13                   ! r13 = target.y
    shll8 r13                              ! r13 <<= 10 (scale to world units)
    shll2 r13
    mov.l   .L_positive_y_base, r3         ! r3 = 0x01A00000 (positive offset)
    add r3, r13                            ! r13 = target.y * 1024 + positive_base
    bra     .L_apply_camera_path
    nop

    .global DAT_0600bdac
DAT_0600bdac:
    .2byte  0x01BC

    .global DAT_0600bdae
DAT_0600bdae:
    .2byte  0x0244
.L_camera_state_a_b:
    .4byte  sym_06063E1C
.L_cinematic_config_a_b:
    .4byte  sym_06059F30
.L_fn_channel_nibble_b:
    .4byte  channel_nibble_config
.L_cinematic_eye_y_b:
    .4byte  0x00058000
.L_cinematic_heading_b:
    .4byte  0x0000F300
.L_camera_heading_store_b:
    .4byte  sym_06063E34
.L_cinematic_offset_b:
    .4byte  0x006E0000
.L_fp_sixteen_b:
    .4byte  0x00100000                  /* 16.0 (16.16 fixed-point) */
.L_camera_zoom_b:
    .4byte  sym_06063E2C
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_camera_dir_flip:
    .4byte  sym_06078663
.L_positive_y_base:
    .4byte  0x01A00000
.L_dir_negative:
    mov.l @(4, r12), r13                   ! r13 = target.y
    shll8 r13                              ! scale to world units
    shll2 r13
    neg r13, r13                           ! negate for negative direction
    mov.l   .L_negative_y_base, r3         ! r3 = 0xFFA00000 (negative offset)
    add r3, r13
.L_apply_camera_path:
    mov.l   .L_alt_camera_flag, r0         ! check alternate camera path
    mov.l @r0, r0
    tst r0, r0
    bt      .L_standard_camera             ! flag == 0: use standard path
    ! --- Alternate camera path (with XZ adjustments) ---
    mov.l   .L_fn_cmd_queue_write, r3
    jsr @r3                                ! cmd_queue_write(4)
    mov #0x4, r4
    mov #0x0, r6                           ! z component = 0
    mov.l @r9, r5                          ! r5 = camera_heading
    mov.l   .L_fn_scene_data_write, r3
    jsr @r3                                ! scene_data_write_abs(r13, heading, 0)
    mov r13, r4
    jsr @r8                                ! cmd_queue_commit()
    nop
    mov r15, r6                            ! r6 = &sin_result (sp+4)
    mov r15, r5                            ! r5 = &cos_result (sp+0)
    mov.l   .L_fn_sincos_pair, r3
    add #0x4, r6
    jsr @r3                                ! sincos_pair(target.y, &cos, &sin)
    mov.l @(4, r12), r4                    ! r4 = target.y
    mov.l @(16, r14), r2                   ! r2 = car.pos_x
    mov.l @r15, r3                         ! r3 = cos_result
    sub r3, r2                             ! eye.x = pos_x - cos
    mov.l   .L_xz_adjust_x, r1            ! r1 = &xz_adjust_x
    mov.l @r1, r1
    add r1, r2                             ! eye.x += xz_adjust_x
    mov.l r2, @r11                         ! camera_up.x = eye.x (eye pos)
    mov.l @(20, r14), r3                   ! r3 = car.pos_y
    mov.l @r10, r2                         ! r2 = z_offset
    add r2, r3
    mov.l r3, @(4, r11)                    ! eye.y = pos_y + z_offset
    mov.l @(24, r14), r3                   ! r3 = car.pos_z
    mov.l @(4, r15), r2                    ! r2 = sin_result
    add r2, r3
    mov.l   .L_xz_adjust_z, r1            ! r1 = &xz_adjust_z
    mov.l @r1, r1
    add r1, r3                             ! eye.z += xz_adjust_z
    bra     .L_camera_return
    mov.l r3, @(8, r11)                    ! store eye.z
! --- Standard camera path ---
.L_standard_camera:
    mov.w   .L_car_gear_offset_c, r0       ! r0 = 0x01BC
    mov.l @(r0, r14), r0                   ! r0 = car.gear_state
    tst r0, r0                             ! gear == 0?
    bf      .L_standard_with_scroll        ! no: use scroll-based camera
    mov.l   .L_fn_scene_fallback, r3
    jsr @r3                                ! scene_fallback_render()
    nop
    bra     .L_standard_render
    nop
.L_car_gear_offset_c:
    .2byte  0x01BC
    .2byte  0xFFFF
.L_negative_y_base:
    .4byte  0xFFA00000
.L_alt_camera_flag:
    .4byte  sym_06082A30
.L_fn_cmd_queue_write:
    .4byte  sym_0603850C
.L_fn_scene_data_write:
    .4byte  scene_data_write_abs
.L_fn_sincos_pair:
    .4byte  sincos_pair
.L_xz_adjust_x:
    .4byte  sym_06082A70
.L_xz_adjust_z:
    .4byte  sym_06082A78
.L_fn_scene_fallback:
    .4byte  scene_fallback_render
.L_standard_with_scroll:
    mov.w   DAT_0600bf3c, r4               ! r4 = 0x6666 (zoom factor)
    mov.l   .L_zoom_store_x, r3
    mov.l r4, @r3                          ! zoom_x = 0x6666
    mov.l   .L_zoom_store_y, r3
    mov.l r4, @r3                          ! zoom_y = 0x6666
.L_standard_render:
    mov.l   .L_fn_cmd_queue_write_b, r3
    jsr @r3                                ! cmd_queue_write(4)
    mov #0x4, r4
    mov #0x0, r6                           ! z = 0
    mov.l @r9, r5                          ! r5 = camera_heading
    mov.l   .L_fn_scene_data_write_b, r3
    jsr @r3                                ! scene_data_write_abs(eye_y, heading, 0)
    mov r13, r4
    jsr @r8                                ! cmd_queue_commit()
    nop
    ! --- Compute view-relative car offset ---
    mov.l @(28, r14), r13                  ! r13 = car.forward_speed (word 7)
    shll8 r13                              ! scale speed
    cmp/pz r13                             ! positive speed?
    bt      .L_speed_scaled
    shll r13                               ! negative: double the scale
.L_speed_scaled:
    mov.l   .L_fn_cmd_queue_write_b, r3
    jsr @r3                                ! cmd_queue_write(8) — second command
    mov #0x8, r4
    mov #0x0, r6
    mov.l   .L_scroll_plane_sel, r0        ! r0 = &scroll_plane_selector
    mov.l   .L_scroll_table_base, r3       ! r3 = scroll table base
    mov.l   .L_camera_zoom_ref, r2         ! r2 = &camera_zoom
    mov.w @r0, r0                          ! r0 = selector value
    mov.l @r2, r2                          ! r2 = zoom value
    extu.w r0, r0
    add r13, r2                            ! zoom += scaled speed
    and #0xC, r0                           ! mask to scroll plane index (0,4,8,12)
    mov r0, r5
    shll2 r5                               ! r5 = index * 4
    add r3, r5                             ! r5 = &table[index]
    mov.l @r5, r5                          ! r5 = table entry
    shll8 r5                               ! scale table value
    shll r5
    add r2, r5                             ! r5 = final scroll position
    mov.l   .L_fn_scene_data_write_b, r2
    jsr @r2                                ! scene_data_write_abs(0, scroll_pos)
    mov r6, r4                             ! r4 = 0
    jsr @r8                                ! cmd_queue_commit()
    nop
    mov.l   .L_fn_obj_state_mgr, r3
    jsr @r3                                ! obj_state_manager()
    nop
    ! --- Compute eye position from heading ---
    mov r15, r6                            ! r6 = &sin_result
    mov r15, r5                            ! r5 = &cos_result
    mov.l   .L_fn_sincos_pair_b, r3
    add #0x4, r6
    jsr @r3                                ! sincos_pair(target.y, &cos, &sin)
    mov.l @(4, r12), r4
    mov.l @(16, r14), r2                   ! car.pos_x
    mov.l @r15, r3                         ! cos
    sub r3, r2                             ! eye.x = pos_x - cos
    mov.l r2, @r11                         ! store eye.x
    mov.l @(20, r14), r3                   ! car.pos_y
    mov.l @r10, r2                         ! z_offset
    add r2, r3
    mov.l r3, @(4, r11)                    ! eye.y = pos_y + z_offset
    mov.l @(24, r14), r3                   ! car.pos_z
    mov.l @(4, r15), r2                    ! sin
    add r2, r3
    mov.l r3, @(8, r11)                    ! eye.z = pos_z + sin
    ! --- Heading smoothing ---
    bsr     .L_heading_smooth
    nop
    ! --- Compute look-ahead correction ---
    mov.l @(4, r12), r4                    ! r4 = target.y
    mov.l @(32, r14), r2                   ! r2 = car.pos_y
    mov.l   .L_fn_cos_lookup, r3
    jsr @r3                                ! cos_lookup(target.y - pos_y)
    sub r2, r4
    mov r0, r5                             ! r5 = cos(delta_y)
    mov r0, r2
    mov.l   .L_smooth_factor_store, r3     ! r3 = &smooth_factor
    shar r2                                ! r2 = cos >> 7
    shar r2
    shar r2
    shar r2
    shar r2
    shar r2
    shar r2
    neg r2, r2                             ! negate
    mov.l r2, @r3                          ! smooth_factor = -(cos >> 7)
    mov.l   .L_fn_fpmul, r3
    jsr @r3                                ! fpmul(car.lateral_accel, cos)
    mov.l @(36, r14), r4                   ! r4 = car.lateral_accel
    mov r0, r4                             ! r4 = fpmul result
    mov.l @(8, r12), r2                    ! r2 = target.z
    add r2, r4                             ! target.z += correction
    shar r4                                ! average with current
    mov.l r4, @(8, r12)                    ! store target.z
.L_camera_return:
    add #0x8, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14

    .global DAT_0600bf3c
DAT_0600bf3c:
    .2byte  0x6666
    .2byte  0xFFFF
.L_zoom_store_x:
    .4byte  sym_06063F04
.L_zoom_store_y:
    .4byte  sym_06063F08
.L_fn_cmd_queue_write_b:
    .4byte  sym_0603850C
.L_fn_scene_data_write_b:
    .4byte  scene_data_write_abs
.L_scroll_plane_sel:
    .4byte  sym_06063F46
.L_scroll_table_base:
    .4byte  sym_0605BDCC
.L_camera_zoom_ref:
    .4byte  sym_06063E2C
.L_fn_obj_state_mgr:
    .4byte  obj_state_manager
.L_fn_sincos_pair_b:
    .4byte  sincos_pair
.L_fn_cos_lookup:
    .4byte  cos_lookup
.L_smooth_factor_store:
    .4byte  sym_06078668
.L_fn_fpmul:
    .4byte  fpmul
! === Heading smoothing subroutine ===
! Exponentially blends camera heading toward player car heading.
! Blend ratio: (old × 800 + new × 224) >> 10
! Snaps directly when camera_state_a != camera_state_b (transition).
.L_heading_smooth:
    sts.l macl, @-r15
    mov.l   .L_hs_player_car_ptr, r4       ! r4 = &player_car_ptr
    mov.w   DAT_0600bfe2, r3               ! r3 = 0x0384 (heading scale = 900)
    mov.l   .L_hs_heading_store, r2        ! r2 = &heading store
    mov.l   .L_hs_target_heading, r5       ! r5 = &camera target heading
    mov.l @r4, r4                          ! r4 = player car base
    mov.l @r2, r2                          ! r2 = current heading value
    mov.l @(28, r4), r4                    ! r4 = car.heading (word 7)
    exts.w r4, r4                          ! sign-extend heading
    mul.l r3, r4                           ! r4 * 900
    exts.w r2, r3                          ! r3 = current heading (sign-ext)
    sts macl, r4                           ! r4 = car.heading * 900
    mov.l   .L_hs_state_a, r2             ! r2 = &camera_state_a
    shar r4                                ! r4 >>= 10 (divide by 1024)
    mov.l @r2, r2                          ! r2 = camera_state_a
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    shar r4
    add r3, r4                             ! r4 = heading_store + (car_heading * 900 >> 10)
    mov.l   .L_hs_state_b, r3             ! r3 = &camera_state_b
    mov.l @r3, r3                          ! r3 = camera_state_b
    cmp/eq r3, r2                          ! state_a == state_b? (steady state)
    bf/s    .L_hs_snap                     ! no: snap directly
    exts.w r4, r4
    ! --- Exponential blend: (old × 800 + new × 224) >> 10 ---
    mov.l @r5, r3                          ! r3 = current target heading
    exts.w r4, r4
    mov.w   .L_hs_blend_old, r1            ! r1 = 224 (new weight)
    mov.w   .L_hs_blend_new, r2            ! r2 = 800 (old weight)
    exts.w r3, r3
    mul.l r2, r3                           ! old * 800
    sts macl, r3
    mul.l r1, r4                           ! new * 224
    sts macl, r4
    add r4, r3                             ! blended = old*800 + new*224
    shar r3                                ! >>10 (divide by 1024)
    shar r3
    shar r3
    shar r3
    shar r3
    shar r3
    shar r3
    shar r3
    shar r3
    shar r3
    mov.l r3, @r5                          ! store blended heading
    bra     .L_hs_done
    nop
.L_hs_snap:
    exts.w r4, r4                          ! snap: target_heading = new value
    mov.l r4, @r5
.L_hs_done:
    rts
    lds.l @r15+, macl

    .global DAT_0600bfe2
DAT_0600bfe2:
    .2byte  0x0384
.L_hs_blend_new:
    .2byte  0x0320
.L_hs_blend_old:
    .2byte  0x00E0
.L_hs_player_car_ptr:
    .4byte  sym_0607E944
.L_hs_heading_store:
    .4byte  sym_06063E34
.L_hs_target_heading:
    .4byte  sym_06063EEC
.L_hs_state_a:
    .4byte  sym_06063E1C
.L_hs_state_b:
    .4byte  sym_06063E20
