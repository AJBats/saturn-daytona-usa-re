/* anim_frame_transform -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06005DD4 - 0x06005ECC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Converts a centisecond frame count into a 9-byte digit buffer for
 * HUD time display in the format  M'SS"CC\0  (minutes, seconds, centiseconds).
 *
 * Uses the SH-2 hardware division unit at 0xFFFFFF00 to extract
 * decimal digits via repeated division by 10 (and by 6 for tens-of-seconds).
 *
 * Digit values are +1 offset (tile indices: 1=0, 2=1, ..., 10=9).
 * Special values: 0x0B = blank (leading zero suppression),
 *                 0x0C = tick separator ('), 0x0D = double-tick separator (").
 *                 0x00 = null terminator.
 *
 * Output buffer layout (sym_06063E14, 9 bytes):
 *   [0] tens-of-minutes (or 0x0B=blank if zero)
 *   [1] ones-of-minutes
 *   [2] 0x0C (')
 *   [3] tens-of-seconds (0-5)
 *   [4] ones-of-seconds
 *   [5] 0x0D (")
 *   [6] tens-of-centiseconds
 *   [7] ones-of-centiseconds
 *   [8] 0x00 (terminator)
 *
 * Input:  r4 = frame count in centiseconds (0..599999)
 * Output: r0 = pointer to digit buffer (sym_06063E14)
 */

    .section .text.FUN_06005DD4


    .global anim_frame_transform
    .type anim_frame_transform, @function
anim_frame_transform:
    mov.l r14, @-r15                ! save r14
    mov.l r13, @-r15                ! save r13
    mov.l r12, @-r15                ! save r12
    add #-0x8, r15                  ! allocate 8 bytes on stack (frame[0]=dividend, frame[4]=saved remainder)
    mov.l   .L_pool_digit_buf, r5   ! r5 = &digit_buffer (sym_06063E14)
    mov.l r4, @r15                  ! stack[0] = frame_count (input argument)
    mov #0xA, r12                   ! r12 = 10 (decimal divisor, reused across iterations)
    mov.w   .L_divu_DVDNT, r14      ! r14 = 0xFFFFFF04 (DVDNT — dividend register, triggers 32/32 division)
    mov r14, r7                     ! r7 = DVDNT address
    add #0x4, r7                    ! r7 = 0xFFFFFF08 (DVCR — division control register)
    mov.w   .L_divu_DVSR, r6        ! r6 = 0xFFFFFF00 (DVSR — divisor register)
    mov #0x0, r4                    ! r4 = 0 (used to clear DVCR and as initial digit value)

    /* === Division 1: frame_count / 10 — extract ones of centiseconds === */
    mov.l r12, @r6                  ! DVSR = 10
    mov.l r4, @r7                   ! DVCR = 0 (clear overflow flag)
    mov.l @r15, r3                  ! r3 = frame_count
    mov.l r3, @r14                  ! DVDNT = frame_count (triggers division)
    extu.b r4, r0                   ! r0 = 0
    mov.b r0, @(8, r5)             ! digit_buf[8] = 0x00 (null terminator)
    mov.w   .L_divu_DVDNTH_S, r13   ! r13 = 0xFFFFFF18 (DVDNTH_S — remainder register)
    mov.l @r13, r3                  ! r3 = frame_count % 10 (ones of centiseconds)
    extu.b r3, r3                   ! mask to byte
    mov.b r3, @r15                  ! stack[0].lo = ones_cs (save for later: becomes +1 digit)
    mov.w   .L_divu_DVDNTL_S, r1    ! r1 = 0xFFFFFF1C (DVDNTL_S — quotient result register)
    mov.l @r1, r2                   ! r2 = frame_count / 10 (total deciseconds)
    mov.l r2, @(4, r15)             ! stack[4] = quotient (next dividend)

    /* === Division 2: deciseconds / 10 — extract tens of centiseconds === */
    mov.l r12, @r6                  ! DVSR = 10
    mov.l r4, @r7                   ! DVCR = 0
    mov.l @(4, r15), r3             ! r3 = quotient from div1 (deciseconds)
    mov.l r3, @r14                  ! DVDNT = deciseconds (triggers division)
    mov.b @r15, r3                  ! r3 = saved ones_cs remainder
    extu.b r3, r3                   ! mask to byte
    add #0x1, r3                    ! +1 tile index offset (0→1, 1→2, ..., 9→10)
    extu.b r3, r0                   ! mask to byte
    mov.b r0, @(7, r5)             ! digit_buf[7] = ones_cs + 1
    mov.l @r13, r3                  ! r3 = deciseconds % 10 (tens of centiseconds)
    extu.b r3, r3                   ! mask to byte
    mov.b r3, @r15                  ! stack[0].lo = tens_cs
    mov.l @r1, r2                   ! r2 = deciseconds / 10 (total seconds)
    mov.l r2, @(4, r15)             ! stack[4] = quotient (total seconds)

    /* === Division 3: seconds / 10 — extract ones of seconds === */
    mov.l r12, @r6                  ! DVSR = 10
    mov.l r4, @r7                   ! DVCR = 0
    mov.l @(4, r15), r3             ! r3 = total seconds
    mov.l r3, @r14                  ! DVDNT = total_seconds (triggers division)
    mov.b @r15, r3                  ! r3 = saved tens_cs remainder
    extu.b r3, r3                   ! mask to byte
    add #0x1, r3                    ! +1 tile index offset
    extu.b r3, r0                   ! mask to byte
    mov.b r0, @(6, r5)             ! digit_buf[6] = tens_cs + 1
    mov.l @r13, r3                  ! r3 = total_seconds % 10 (ones of seconds)
    extu.b r3, r3                   ! mask to byte
    mov.b r3, @r15                  ! stack[0].lo = ones_sec
    mov.l @r1, r2                   ! r2 = total_seconds / 10 (tens-of-seconds groups)
    mov.l r2, @(4, r15)             ! stack[4] = quotient

    /* === Division 4: (seconds/10) / 6 — extract tens of seconds (0-5) === */
    mov #0x6, r2                    ! r2 = 6 (seconds tens digit wraps at 60)
    mov.l r2, @r6                   ! DVSR = 6
    mov.l r4, @r7                   ! DVCR = 0
    mov.l @(4, r15), r3             ! r3 = tens-of-seconds groups
    mov.l r3, @r14                  ! DVDNT = tens_sec_groups (triggers division)
    mov #0xD, r3                    ! r3 = 0x0D (double-tick separator: ")
    mov r3, r0                      ! r0 = 0x0D
    mov.b r0, @(5, r5)             ! digit_buf[5] = 0x0D (") — seconds/centiseconds separator
    mov.b @r15, r3                  ! r3 = saved ones_sec remainder
    extu.b r3, r3                   ! mask to byte
    add #0x1, r3                    ! +1 tile index offset
    extu.b r3, r0                   ! mask to byte
    mov.b r0, @(4, r5)             ! digit_buf[4] = ones_sec + 1
    mov.l @r13, r3                  ! r3 = tens_sec_groups % 6 (tens of seconds: 0-5)
    extu.b r3, r3                   ! mask to byte
    mov r3, r0                      ! r0 = tens_sec
    mov.b r0, @(4, r15)             ! stack[4].lo = tens_sec
    mov.l @r1, r2                   ! r2 = tens_sec_groups / 6 (total minutes)
    mov.l r2, @r15                  ! stack[0] = quotient (total minutes)

    /* === Division 5: minutes / 10 — extract ones of minutes === */
    mov.l r12, @r6                  ! DVSR = 10
    mov.l r4, @r7                   ! DVCR = 0
    mov.l @r15, r3                  ! r3 = total minutes
    mov.l r3, @r14                  ! DVDNT = total_minutes (triggers division)
    mov.b @(4, r15), r0             ! r0 = saved tens_sec
    mov r0, r3                      ! r3 = tens_sec
    extu.b r3, r3                   ! mask to byte
    add #0x1, r3                    ! +1 tile index offset
    extu.b r3, r0                   ! mask to byte
    mov.b r0, @(3, r5)             ! digit_buf[3] = tens_sec + 1
    mov.l @r13, r3                  ! r3 = total_minutes % 10 (ones of minutes)
    extu.b r3, r3                   ! mask to byte
    mov.b r3, @r15                  ! stack[0].lo = ones_min
    mov.l @r1, r2                   ! r2 = total_minutes / 10 (tens of minutes)
    mov.l r2, @(4, r15)             ! stack[4] = quotient (tens of minutes)

    /* === Division 6: (minutes/10) / 10 — extract tens of minutes === */
    mov.l r12, @r6                  ! DVSR = 10
    mov.l r4, @r7                   ! DVCR = 0
    mov.l @(4, r15), r3             ! r3 = tens of minutes
    mov.l r3, @r14                  ! DVDNT = tens_min (triggers division; quotient unused)
    mov #0xC, r3                    ! r3 = 0x0C (tick separator: ')
    mov r3, r0                      ! r0 = 0x0C
    mov.b r0, @(2, r5)             ! digit_buf[2] = 0x0C (') — minutes/seconds separator
    mov.b @r15, r3                  ! r3 = saved ones_min
    extu.b r3, r3                   ! mask to byte
    add #0x1, r3                    ! +1 tile index offset
    extu.b r3, r3                   ! mask to byte (defensive, already clean)
    mov r3, r0                      ! r0 = ones_min + 1
    mov.b r0, @(1, r5)             ! digit_buf[1] = ones_min + 1
    mov.l @r13, r4                  ! r4 = tens_min remainder (final digit)
    extu.b r4, r4                   ! mask to byte
    tst r4, r4                      ! test tens_min == 0
    bt      .L_tens_min_blank       ! if zero: suppress leading digit (use blank)
    extu.b r4, r3                   ! r3 = tens_min (non-zero)
    add #0x1, r3                    ! +1 tile index offset
    extu.b r3, r4                   ! r4 = tens_min + 1 (tile index)
    bra     .L_store_tens_min       ! skip blank path
    nop                             ! delay slot

    /* --- Word constant pool (PC-relative mov.w targets) --- */
.L_divu_DVDNT:
    .2byte  0xFF04                  /* 0xFFFFFF04 = DVDNT — dividend reg, triggers 32/32 div [HIGH] */
.L_divu_DVSR:
    .2byte  0xFF00                  /* 0xFFFFFF00 = DVSR — divisor register [HIGH] */
.L_divu_DVDNTH_S:
    .2byte  0xFF18                  /* 0xFFFFFF18 = DVDNTH_S — remainder after 32/32 division [HIGH] */
.L_divu_DVDNTL_S:
    .2byte  0xFF1C                  /* 0xFFFFFF1C = DVDNTL_S — quotient after 32/32 division [HIGH] */
    .2byte  0xFFFF                  /* pool alignment padding */

    /* --- Longword constant pool (PC-relative mov.l targets) --- */
.L_pool_digit_buf:
    .4byte  sym_06063E14            /* &digit_buffer — 9-byte HUD time display buffer [HIGH] */

.L_tens_min_blank:
    mov #0xB, r4                    ! r4 = 0x0B (blank tile — leading zero suppression)
.L_store_tens_min:
    mov r5, r0                      ! r0 = &digit_buffer (return value)
    mov.b r4, @r5                   ! digit_buf[0] = tens_min tile index (or blank)
    add #0x8, r15                   ! deallocate stack frame
    mov.l @r15+, r12                ! restore r12
    mov.l @r15+, r13                ! restore r13
    rts                             ! return to caller
    mov.l @r15+, r14                ! restore r14 (delay slot)
