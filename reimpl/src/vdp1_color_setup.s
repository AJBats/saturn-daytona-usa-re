/* vdp1_color_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602C8E2 - 0x0602CA84
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP1 color parameter computation for per-car rendering.
 * Called as step 13 of the render orchestrator (render_orchestrator.s)
 * after vdp1_display_list_setup and before vdp1_coord_setup.
 *
 * r0 = car/render state base pointer (preserved across call).
 * r14 = car pointer (set by caller, preserved).
 *
 * vdp1_color_setup (0x0602C8E2):
 *   Computes VDP1 color rendering parameters based on car physics state.
 *   Two major phases:
 *
 *   Phase 1 — Color intensity calculation (0x0602C8E2..0x0602C9F8):
 *     1. Detect sign disagreement between obj_data (car+0x40) and lateral
 *        velocity (car+0x5C). If same sign, compute abs(obj_data) as
 *        drift magnitude.
 *     2. If speed (car+0x08) >= 0x46 and angular vel components
 *        (car+0x60, car+0x64) have opposite signs, and yaw deflection
 *        (car+0xD0) is within [-0x1000, +0x1000], write 0xA (trigger)
 *        to render mode (car+0x16C).
 *     3. If speed >= 0x64 and drift magnitude >= 0x0E00, set color
 *        boost flag (r12=1).
 *     4. If mode timer (car+0xD4) is non-zero, write 0x10 to secondary
 *        mode (car+0x170).
 *     5. If car+0x1C (vertical position) > 0x0500, check activation
 *        flags (car+0x128 and car+0x12C) for bit 0x4 plus sign of
 *        obj_data; if conditions met, write 0x14 to render mode.
 *     6. Decrement color timer (car+0x16A). If boost flag set,
 *        increment first. While timer >= 0, compute color intensity:
 *        - Square three velocity components (car+0x144, car+0x64,
 *          car+0x11C), sum upper halves as magnitude estimate
 *        - Call hw_divide (sym_0602ECCC) for normalization
 *        - Multiply result by decel coeff (car+0x11C), extract 16.16
 *        - Clamp to [0, decel_coeff] and store back to car+0x11C
 *
 *   Phase 2 — Timer-driven decay effects (0x0602C9F8..0x0602CA6C):
 *     Walks 5 consecutive 16-bit timer slots starting at car+0x16C:
 *       Timer A (car+0x16C): if >= 0, decrement; zero draw_count (car+0x168)
 *       Timer B (car+0x16E): if > 0, decrement; decay intensity (car+0x144)
 *           by multiplying with 0x00011999 (~1.1 in 16.16 FP)
 *       Timer C (car+0x170): if > 0, decrement; reset intensity to
 *           0x09D80000 (full bright)
 *       Timer D (car+0x172): if > 0, decrement; halve intensity (shar),
 *           zero force_aux (car+0xF4)
 *       Timer E (car+0x174): if > 0, decrement; if decel_coeff (car+0x11C)
 *           >= 0, negate it and store to force_aux (car+0xF4)
 */

    .section .text.FUN_0602C8E2


    .global vdp1_color_setup
    .type vdp1_color_setup, @function
vdp1_color_setup:
    sts.l pr, @-r15              ! save return address
    mov #0x0, r12                ! r12 = 0 (color boost flag, default off)
    mov #0x0, r6                 ! r6 = 0 (drift magnitude, default 0)
    mov.w   .L_off_obj_data, r1  ! r1 = 0x0040 (obj_data ptr offset)
    mov.w   .L_off_lateral_vel, r2  ! r2 = 0x005C (lateral velocity offset)
    mov.l @(r0, r1), r3          ! r3 = car->obj_data
    mov.l @(r0, r2), r4          ! r4 = car->lateral_vel
    xor r3, r4                   ! r4 = obj_data XOR lateral_vel (sign test)
    cmp/pz r4                    ! same sign? (XOR >= 0 means same sign)
    bf      .L_drift_mag_done    ! different signs: skip drift calc
    mov r3, r6                   ! r6 = obj_data (used as drift magnitude)
    cmp/pz r6                    ! is drift magnitude >= 0?
    bt      .L_drift_mag_done    ! yes: keep as-is
    neg r6, r6                   ! no: negate to get abs(obj_data)
.L_drift_mag_done:
    mov.l @(8, r0), r1           ! r1 = car->speed (at car+0x08)
    mov #0x46, r7                ! r7 = 0x46 (speed threshold for spin detect)
    cmp/ge r1, r7                ! 0x46 >= speed? (i.e. speed < 0x46?)
    bt      .L_skip_spin_detect  ! yes: too slow, skip spin detection
    mov.w   .L_off_angular_vel_a, r2  ! r2 = 0x0060 (angular velocity A offset)
    mov.w   .L_off_angular_vel_b, r3  ! r3 = 0x0064 (angular velocity B offset)
    mov.l @(r0, r2), r4          ! r4 = car->angular_vel_a
    mov.l @(r0, r3), r5          ! r5 = car->angular_vel_b
    xor r4, r5                   ! r5 = vel_a XOR vel_b (sign comparison)
    cmp/pz r5                    ! same sign? (XOR >= 0)
    bt      .L_skip_spin_detect  ! same sign: no spin, skip
    mov.w   .L_off_yaw_deflect, r2  ! r2 = 0x00D0 (yaw deflection offset)
    mov.w   .L_yaw_threshold, r4  ! r4 = 0x1000 (yaw threshold)
    mov.l @(r0, r2), r3          ! r3 = car->yaw_deflection
    cmp/ge r4, r3                ! yaw_deflect >= 0x1000?
    bt      .L_set_spin_mode     ! yes: large yaw, trigger spin mode
    neg r4, r4                   ! r4 = -0x1000 (negative threshold)
    cmp/ge r3, r4                ! -0x1000 >= yaw_deflect?
    bt      .L_skip_spin_detect  ! yes: yaw in dead zone, skip
.L_set_spin_mode:
    mov.w   .L_off_render_mode, r2  ! r2 = 0x016C (render mode offset)
    mov #0xA, r3                 ! r3 = 0xA (spin mode trigger value)
    mov.w r3, @(r0, r2)          ! car->render_mode = 0xA
.L_skip_spin_detect:
    mov #0x64, r2                ! r2 = 0x64 (high speed threshold)
    mov.w   .L_drift_threshold, r3  ! r3 = 0x0E00 (drift magnitude threshold)
    cmp/gt r1, r2                ! 0x64 > speed? (i.e. speed <= 0x64?)
    bt      .L_no_color_boost    ! yes: too slow for color boost
    cmp/gt r6, r3                ! 0x0E00 > drift_mag? (drift too small?)
    bt      .L_no_color_boost    ! yes: drift too small
    mov #0x1, r12                ! r12 = 1 (enable color boost)
.L_no_color_boost:
    mov.w   .L_off_mode_timer, r3  ! r3 = 0x00D4 (mode timer offset)
    mov.w @(r0, r3), r2          ! r2 = car->mode_timer (16-bit)
    tst r2, r2                   ! mode_timer == 0?
    bt      .L_skip_secondary_mode  ! yes: skip secondary mode write
    mov.w   .L_off_secondary_mode, r3  ! r3 = 0x0170 (secondary mode offset)
    mov #0x10, r2                ! r2 = 0x10 (secondary mode trigger)
    mov.w r2, @(r0, r3)          ! car->secondary_mode = 0x10
.L_skip_secondary_mode:
    mov.l @(28, r0), r3          ! r3 = car+0x1C (vertical position)
    mov.w   .L_vert_threshold, r2  ! r2 = 0x0500 (vertical threshold)
    cmp/ge r3, r2                ! 0x0500 >= vert_pos? (i.e. vert_pos <= 0x0500?)
    bt      .L_skip_airborne_mode  ! yes: not airborne, skip
    mov.w   .L_off_activate_a, r2  ! r2 = 0x0128 (activation flags A offset)
    mov #0x4, r3                 ! r3 = 0x4 (test bit 2)
    mov.l @(r0, r2), r1          ! r1 = car->activate_flags_a
    add #0x4, r2                 ! r2 = 0x012C (activation flags B offset)
    tst r1, r3                   ! bit 2 clear in flags_a?
    bt      .L_check_flags_b     ! yes: check flags_b instead
    mov.w   .L_off_obj_data, r3  ! r3 = 0x0040 (obj_data offset)
    mov.l @(r0, r3), r1          ! r1 = car->obj_data
    cmp/pz r1                    ! obj_data >= 0?
    bf      .L_set_airborne_mode ! obj_data negative: set airborne mode
.L_check_flags_b:
    mov #0x4, r3                 ! r3 = 0x4 (test bit 2)
    mov.l @(r0, r2), r1          ! r1 = car->activate_flags_b
    tst r1, r3                   ! bit 2 clear in flags_b?
    bt      .L_skip_airborne_mode  ! yes: no activation, skip
    mov.w   .L_off_obj_data, r3  ! r3 = 0x0040 (obj_data offset)
    mov.l @(r0, r3), r1          ! r1 = car->obj_data
    cmp/pz r1                    ! obj_data >= 0?
    bf      .L_skip_airborne_mode  ! obj_data negative: skip (wrong direction)
.L_set_airborne_mode:
    mov.w   .L_off_render_mode, r3  ! r3 = 0x016C (render mode offset)
    mov #0x14, r2                ! r2 = 0x14 (airborne mode trigger)
    mov.w r2, @(r0, r3)          ! car->render_mode = 0x14
.L_skip_airborne_mode:
    mov.w   .L_off_color_timer, r8  ! r8 = 0x016A (color timer offset)
    mov.w @(r0, r8), r2          ! r2 = car->color_timer (16-bit)
    tst r12, r12                 ! color boost flag set?
    bt      .L_no_boost_inc      ! no: skip increment
    add #0x1, r2                 ! yes: extend color timer by 1
.L_no_boost_inc:
    cmp/pz r2                    ! color_timer >= 0?
    bf      .L_phase2_timers     ! negative: skip to phase 2
    add #-0x1, r2                ! decrement color timer
    mov.w r2, @(r0, r8)          ! store decremented timer
    mov.w   .L_off_intensity, r3  ! r3 = 0x0144 (color intensity offset)
    mov.w   .L_off_angular_vel_b, r2  ! r2 = 0x0064 (angular velocity B offset)
    mov.l @(r0, r3), r6          ! r6 = car->intensity
    mov.w   .L_off_decel_coeff, r1  ! r1 = 0x011C (decel coeff offset)
    dmuls.l r6, r6               ! MAC = intensity^2
    mov.l @(r0, r2), r5          ! r5 = car->angular_vel_b
    mov.l @(r0, r1), r4          ! r4 = car->decel_coeff
    sts mach, r6                 ! r6 = high word of intensity^2
    dmuls.l r5, r5               ! MAC = angular_vel_b^2
    sts mach, r0                 ! r0 = high word of vel_b^2
    dmuls.l r4, r4               ! MAC = decel_coeff^2
    .byte   0xDD, 0x12    /* mov.l .L_fn_hw_divide, r13 */  ! r13 = hw_divide (sym_0602ECCC)
    sts mach, r1                 ! r1 = high word of decel^2
    jsr @r13                     ! call hw_divide: r0 = (r0+r6) / r1
    add r6, r0                   ! (delay) r0 = vel_b_sq_hi + intensity_sq_hi (dividend)
    shll16 r0                    ! r0 <<= 16 (scale result to 16.16 FP)
    mov r0, r3                   ! r3 = scaled magnitude
    mov.w   .L_off_decel_coeff, r1  ! r1 = 0x011C (decel coeff offset)
    mov r14, r0                  ! r0 = car base pointer (restore)
    mov.l @(r0, r1), r5          ! r5 = car->decel_coeff
    dmuls.l r3, r5               ! MAC = magnitude * decel_coeff
    mov #0x0, r4                 ! r4 = 0 (lower clamp bound)
    sts mach, r6                 ! } extract 16.16 product
    sts macl, r3                 ! }
    xtrct r6, r3                 ! r3 = (mach:macl) >> 16 (color value)
    cmp/pz r3                    ! color_value >= 0?
    bt      .L_color_positive    ! yes: keep it
    mov r4, r3                   ! no: clamp to 0
.L_color_positive:
    cmp/gt r4, r5                ! decel_coeff > 0?
    bt      .L_clamp_upper       ! yes: go clamp against upper bound
    mov r4, r5                   ! no: decel_coeff <= 0, set to 0
    bra     .L_store_color       ! store zero
    nop

    .global DAT_0602c9cc
.L_off_obj_data:
DAT_0602c9cc:
    .2byte  0x0040

    .global DAT_0602c9ce
.L_off_lateral_vel:
DAT_0602c9ce:
    .2byte  0x005C

    .global DAT_0602c9d0
.L_off_angular_vel_a:
DAT_0602c9d0:
    .2byte  0x0060

    .global DAT_0602c9d2
.L_off_angular_vel_b:
DAT_0602c9d2:
    .2byte  0x0064

    .global DAT_0602c9d4
.L_off_yaw_deflect:
DAT_0602c9d4:
    .2byte  0x00D0

    .global DAT_0602c9d6
.L_yaw_threshold:
DAT_0602c9d6:
    .2byte  0x1000

    .global DAT_0602c9d8
.L_off_render_mode:
DAT_0602c9d8:
    .2byte  0x016C
.L_drift_threshold:
    .2byte  0x0E00

    .global DAT_0602c9dc
.L_off_mode_timer:
DAT_0602c9dc:
    .2byte  0x00D4

    .global DAT_0602c9de
.L_off_secondary_mode:
DAT_0602c9de:
    .2byte  0x0170
.L_vert_threshold:
    .2byte  0x0500

    .global DAT_0602c9e2
.L_off_activate_a:
DAT_0602c9e2:
    .2byte  0x0128
.L_off_color_timer:
    .2byte  0x016A

    .global DAT_0602c9e6
.L_off_intensity:
DAT_0602c9e6:
    .2byte  0x0144
.L_off_decel_coeff:
    .2byte  0x011C
    .2byte  0x0000
.L_fn_hw_divide:
    .4byte  sym_0602ECCC
.L_clamp_upper:
    cmp/ge r5, r3                ! color_value >= decel_coeff?
    bt      .L_store_color       ! yes: clamp to decel_coeff (use r5)
    mov r3, r5                   ! no: use color_value as final
.L_store_color:
    mov.l r5, @(r0, r1)          ! car->decel_coeff = clamped color value
.L_phase2_timers:
    add #0x2, r8                 ! r8 = offset 0x016C (timer A = render_mode)
    mov.w @(r0, r8), r2          ! r2 = car->timer_a (render_mode, 16-bit)
    cmp/pz r2                    ! timer_a >= 0?
    bf      .L_timer_b           ! negative: skip timer A
    add #-0x1, r2                ! decrement timer_a
    mov.w r2, @(r0, r8)          ! store decremented value
    mov.w   .L_off_draw_count, r3  ! r3 = 0x0168 (draw count offset)
    mov #0x0, r4                 ! r4 = 0
    mov.w r4, @(r0, r3)          ! car->draw_count = 0 (reset draw count)
.L_timer_b:
    add #0x2, r8                 ! r8 = offset 0x016E (timer B)
    mov.w @(r0, r8), r5          ! r5 = car->timer_b (16-bit)
    cmp/pl r5                    ! timer_b > 0?
    bf      .L_timer_c           ! not positive: skip timer B
    add #-0x1, r5                ! decrement timer_b
    mov.w r5, @(r0, r8)          ! store decremented value
    mov.w   .L_off_intensity_b, r2  ! r2 = 0x0144 (intensity offset)
    .byte   0xD4, 0x18    /* mov.l .L_decay_factor, r4 */  ! r4 = 0x00011999 (~1.1 in 16.16 FP)
    mov.l @(r0, r2), r3          ! r3 = car->intensity
    dmuls.l r3, r4               ! MAC = intensity * 1.1 (decay toward zero)
    sts mach, r3                 ! } extract 16.16 product
    sts macl, r4                 ! }
    xtrct r3, r4                 ! r4 = decayed intensity
    mov.w r4, @(r0, r2)          ! car->intensity = decayed (16-bit store)
.L_timer_c:
    add #0x2, r8                 ! r8 = offset 0x0170 (timer C = secondary_mode)
    mov.w @(r0, r8), r5          ! r5 = car->timer_c (16-bit)
    cmp/pl r5                    ! timer_c > 0?
    bf      .L_timer_d           ! not positive: skip timer C
    add #-0x1, r5                ! decrement timer_c
    mov.w r5, @(r0, r8)          ! store decremented value
    mov.w   .L_off_intensity_b, r2  ! r2 = 0x0144 (intensity offset)
    .byte   0xD3, 0x12    /* mov.l .L_full_bright, r3 */  ! r3 = 0x09D80000 (full bright)
    mov.l r3, @(r0, r2)          ! car->intensity = full bright (32-bit)
.L_timer_d:
    add #0x2, r8                 ! r8 = offset 0x0172 (timer D)
    mov.w @(r0, r8), r5          ! r5 = car->timer_d (16-bit)
    cmp/pl r5                    ! timer_d > 0?
    bf      .L_timer_e           ! not positive: skip timer D
    add #-0x1, r5                ! decrement timer_d
    mov.w r5, @(r0, r8)          ! store decremented value
    mov.w   .L_off_intensity_b, r1  ! r1 = 0x0144 (intensity offset)
    mov.l @(r0, r1), r2          ! r2 = car->intensity (32-bit)
    shar r2                      ! r2 >>= 1 (halve intensity, arithmetic)
    mov.l r2, @(r0, r1)          ! car->intensity = halved value
    mov.w   .L_off_force_aux, r5  ! r5 = 0x00F4 (force_aux offset)
    mov #0x0, r3                 ! r3 = 0
    mov.l r3, @(r0, r5)          ! car->force_aux = 0 (clear)
.L_timer_e:
    add #0x2, r8                 ! r8 = offset 0x0174 (timer E)
    mov.w @(r0, r8), r5          ! r5 = car->timer_e (16-bit)
    cmp/pl r5                    ! timer_e > 0?
    bf      .L_return            ! not positive: skip timer E
    add #-0x1, r5                ! decrement timer_e
    mov.w r5, @(r0, r8)          ! store decremented value
    mov.w   .L_off_decel_coeff_b, r1  ! r1 = 0x011C (decel coeff offset)
    mov.l @(r0, r1), r3          ! r3 = car->decel_coeff
    cmp/pz r3                    ! decel_coeff >= 0?
    bf      .L_return            ! negative: skip (already negated or zero)
    neg r3, r3                   ! r3 = -decel_coeff
    mov.w   .L_off_force_aux, r1  ! r1 = 0x00F4 (force_aux offset)
    mov.l r3, @(r0, r1)          ! car->force_aux = -decel_coeff
.L_return:
    lds.l @r15+, pr              ! restore return address
    rts                          ! return
    mov #0x0, r1                 ! (delay) r1 = 0 (clear for caller)

    .global DAT_0602ca72
.L_off_draw_count:
DAT_0602ca72:
    .2byte  0x0168

    .global DAT_0602ca74
.L_off_intensity_b:
DAT_0602ca74:
    .2byte  0x0144

    .global DAT_0602ca76
.L_off_force_aux:
DAT_0602ca76:
    .2byte  0x00F4
.L_off_decel_coeff_b:
    .2byte  0x011C
    .2byte  0x0000
.L_decay_factor:
    .4byte  0x00011999
.L_full_bright:
    .4byte  0x09D80000
