/* track_shadow_test -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060415C8 - 0x06041648
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track shadow ground test — queries ground properties beneath an object
 * and, if valid, performs a shadow shape lookup and writes the surface
 * type byte into a global game structure.
 *
 * Called from obj_init_validate when populating shadow/ground data for
 * a game object.
 *
 * Arguments:
 *   r4 = object type / position flags (passed to sub-queries)
 *   r5 = output buffer pointer (passed to track_shadow_shape)
 *
 * Returns:
 *   r0 =  0  on success (shadow data written to game struct)
 *   r0 = -11 on failure (ground query failed, type mismatch,
 *             range check failed, or shape query failed)
 *
 * Stack frame (0x20 = 32 bytes):
 *   sp+0x00: ground query output [0] — ground type
 *   sp+0x04: ground query output [1] — ground value
 *   sp+0x08: saved r4 (object type/flags)
 *   sp+0x0C: ground query output [2] — auxiliary ground data
 *   sp+0x10: saved r5 (output buffer pointer)
 *   sp+0x14: checkpoint validate output (surface type byte)
 *
 * Flow:
 *   1. Call track_shadow_ground(sp, sp+4, sp+12) to query ground info.
 *   2. If ground query fails (nonzero), return -11.
 *   3. Check ground type == 2 (shadow-castable surface).
 *      If not type 2, return -11.
 *   4. Range check: if input flags >= (ground_type + ground_value),
 *      return -11 (object is above shadow threshold).
 *   5. Call track_shadow_shape(saved_type, saved_buffer) for shape data.
 *      If shape query fails, return -11.
 *   6. Call ai_checkpoint_validate(sp+0x14) to get surface type byte.
 *   7. Write surface type byte to game_struct[0x40] via sym_060A5400.
 *   8. Return 0 (success).
 */

    .section .text.FUN_060415C8


    .global track_shadow_test
    .type track_shadow_test, @function
track_shadow_test:
    sts.l pr, @-r15                     ! save return address
    add #-0x20, r15                     ! allocate 32-byte stack frame
    mov.l r4, @(8, r15)                 ! sp[0x08] = r4 (save object type/flags)
    mov r15, r6                         ! r6 = sp (will become 3rd output ptr)
    mov.l r5, @(16, r15)               ! sp[0x10] = r5 (save output buffer ptr)
    add #0xC, r6                        ! r6 = sp+0x0C (3rd output: aux ground data)
    mov r15, r5                         ! r5 = sp (will become 2nd output ptr)
    mov.l   .L_pool_fn_shadow_ground, r3 ! r3 = &track_shadow_ground
    add #0x4, r5                        ! r5 = sp+0x04 (2nd output: ground value)
    jsr @r3                             ! call track_shadow_ground(sp, sp+4, sp+12)
    mov r15, r4                         ! (delay) r4 = sp+0x00 (1st output: ground type)
    mov r0, r4                          ! r4 = ground query return value
    tst r4, r4                          ! did ground query succeed (== 0)?
    bt      .L_ground_query_ok          ! yes -> check ground type
    add #0x20, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov #-0xB, r0                       ! (delay) r0 = -11 (ground query failed)
    .2byte  0x01E0                      ! padding / embedded data

    .global DAT_060415ee
DAT_060415ee:
    mov.b r14, @(r0, r1)               ! embedded data (not executed)
    mov.b @(r0, r13), r1               ! embedded data (not executed)
    .word 0xFFFF /* UNKNOWN */          ! embedded data sentinel
.L_pool_fn_shadow_ground:
    .4byte  track_shadow_ground         ! pool: ground query function pointer
.L_ground_query_ok:
    mov.l @r15, r0                      ! r0 = sp[0x00] (ground type)
    cmp/eq #0x2, r0                     ! is ground type == 2 (shadow-castable)?
    bf      .L_return_fail              ! no -> return -11 (type mismatch)
    mov.l @r15, r2                      ! r2 = sp[0x00] (ground type = 2)
    mov.l @(4, r15), r3                 ! r3 = sp[0x04] (ground value)
    mov.l @(8, r15), r1                 ! r1 = sp[0x08] (saved object type/flags)
    add r3, r2                          ! r2 = ground_type + ground_value (threshold)
    cmp/ge r2, r1                       ! is object_flags >= threshold?
    bf      .L_do_shape_query           ! no -> within range, proceed to shape query
.L_return_fail:
    add #0x20, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov #-0xB, r0                       ! (delay) r0 = -11 (failure)
.L_do_shape_query:
    mov.l @(16, r15), r5               ! r5 = saved output buffer ptr
    .byte   0xD3, 0x14    /* mov.l .L_pool_06041668, r3 */  ! r3 = &track_shadow_shape (cross-TU pool)
    jsr @r3                             ! call track_shadow_shape(type, buffer)
    mov.l @(8, r15), r4                 ! (delay) r4 = saved object type/flags
    mov r0, r4                          ! r4 = shape query return value
    tst r4, r4                          ! did shape query succeed (== 0)?
    bt      .L_shape_query_ok           ! yes -> proceed to surface type write
    add #0x20, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov #-0xB, r0                       ! (delay) r0 = -11 (shape query failed)
.L_shape_query_ok:
    mov r15, r4                         ! r4 = sp (output location for validate)
    .byte   0xD3, 0x10    /* mov.l .L_pool_0604166C, r3 */  ! r3 = &ai_checkpoint_validate (cross-TU pool)
    jsr @r3                             ! call ai_checkpoint_validate(sp+0x14)
    add #0x14, r4                       ! (delay) r4 = sp+0x14 (validate output slot)
    .byte   0xD2, 0x0F    /* mov.l .L_pool_06041670, r2 */  ! r2 = &sym_060A5400 (game struct pointer)
    mov.l @r2, r2                       ! r2 = game struct base address
    mov r15, r3                         ! r3 = sp
    add #0x14, r3                       ! r3 = sp+0x14 (validate result)
    mov.b @r3, r1                       ! r1 = surface type byte from validate
    mov #0x40, r0                       ! r0 = 0x40 (offset into game struct)
    mov.b r1, @(r0, r2)                 ! game_struct[0x40] = surface type byte
    mov #0x0, r0                        ! r0 = 0 (success)
    add #0x20, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    nop                                 ! (delay) padding
