/* scene_color_intensity -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06038794 - 0x060388C0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Scene Color/Intensity Processor
 * ================================
 * Processes two intensity scale values (r4, r5) in 16.16 fixed-point and
 * writes the results to per-channel scene color fields. Used for day/night
 * transitions, tunnel dimming, zoom/fade effects, and weather tinting.
 *
 * Channels 1 and 2 map to scene viewports A and B respectively. Channels 4
 * and 8 map to transform color slots A and B in the scene transform struct.
 *
 * For channels 4/8, intensity values are clamped to [0.25, 255.0] before
 * processing. A zero value is replaced with 1.0 (full intensity default).
 * Channels 1/2 skip clamping and process directly.
 *
 * Color processing calls fpdiv(1.0, value) for each intensity, which
 * computes a reciprocal scale factor. After processing, results are stored
 * to channel-specific fields:
 *   Channel 1: scene_view_A[0x4C/0x50] + render dirty check/tail-call
 *   Channel 2: scene_view_B[0x4C/0x50] + render dirty check/tail-call
 *   Channel 4: scene_transform[8/12]
 *   Channel 8: scene_transform[24/28]
 *
 * For channels 1 and 2, after storing the colors, the function checks the
 * scene enable flags. If the relevant viewport is enabled, it tail-calls
 * scene_color_matrix(0, 0, 0) to trigger a downstream render invalidation.
 *
 * Args: r4 = intensity_x (16.16 fixed-point scale)
 *       r5 = intensity_y (16.16 fixed-point scale)
 * Clobbers: r0-r3, r9-r14
 * Returns: void (stores results to scene structs)
 */

    .section .text.FUN_06038794


    .global scene_color_intensity
    .type scene_color_intensity, @function
scene_color_intensity:
    mov.l r14, @-r15                            ! save r14 (callee-saved)
    mov.l r13, @-r15                            ! save r13 (callee-saved)
    mov.l r12, @-r15                            ! save r12 (callee-saved)
    mov.l r11, @-r15                            ! save r11 (callee-saved)
    mov.l r10, @-r15                            ! save r10 (callee-saved)
    mov.l r9, @-r15                             ! save r9 (callee-saved)
    sts.l pr, @-r15                             ! save return address
    mov.l   .L_clamp_max, r9                    ! r9 = 0x00FF0000 (255.0 fp16.16 — clamp ceiling)
    mov.l   .L_fn_fpdiv, r10                    ! r10 = &fpdiv (fixed-point divide function)
    mov.w   DAT_0603881a, r11                   ! r11 = 0x4000 (0.25 fp16.16 — clamp floor)
    mov.l   .L_fp_one, r12                      ! r12 = 0x00010000 (1.0 fp16.16 — default/divisor)
    mov r4, r14                                 ! r14 = intensity_x (first value to process)
    mov r5, r13                                 ! r13 = intensity_y (second value to process)
    mov.l   .L_cmd_slot_ptr, r0                 ! r0 = &cmd_slot (display command queue slot)
    bra     .L_clamp_dispatch                   ! jump to channel-based clamp decision
    mov.l @r0, r0                               ! (delay) r0 = channel_id from command slot
! ---- Clamp intensity_x (channels 4/8 only) ----
.L_clamp_intensity_x:
    cmp/gt r9, r14                              ! intensity_x > 255.0? (over max)
    bf      .L_check_x_min                      ! no, check minimum
    bra     .L_clamp_intensity_y                ! yes, clamp to max and proceed to y
    mov r9, r14                                 ! (delay) intensity_x = 255.0
.L_check_x_min:
    cmp/ge r11, r14                             ! intensity_x >= 0.25? (above floor)
    bt      .L_check_x_zero                     ! yes, check if exactly zero
    bra     .L_clamp_intensity_y                ! below floor, clamp to min
    mov r11, r14                                ! (delay) intensity_x = 0.25
.L_check_x_zero:
    tst r14, r14                                ! intensity_x == 0?
    bf      .L_clamp_intensity_y                ! no, value is valid in range
    mov r12, r14                                ! zero -> replace with 1.0 (full intensity)
! ---- Clamp intensity_y (same logic) ----
.L_clamp_intensity_y:
    cmp/gt r9, r13                              ! intensity_y > 255.0?
    bf      .L_check_y_min                      ! no, check minimum
    bra     .L_color_process                    ! clamp to max
    mov r9, r13                                 ! (delay) intensity_y = 255.0
.L_check_y_min:
    cmp/ge r11, r13                             ! intensity_y >= 0.25?
    bt      .L_check_y_zero                     ! yes, check zero case
    bra     .L_color_process                    ! below floor, clamp to min
    mov r11, r13                                ! (delay) intensity_y = 0.25
.L_check_y_zero:
    tst r13, r13                                ! intensity_y == 0?
    bf      .L_color_process                    ! no, value is valid
    mov r12, r13                                ! zero -> replace with 1.0
! ---- Process both values through fixed-point divide ----
.L_color_process:
    mov r14, r5                                 ! r5 = intensity_x (divisor arg)
    jsr @r10                                    ! r0 = fpdiv(1.0, intensity_x) — reciprocal scale
    mov r12, r4                                 ! (delay) r4 = 1.0 (dividend)
    mov r0, r14                                 ! r14 = processed color_x result
    mov r13, r5                                 ! r5 = intensity_y (divisor arg)
    jsr @r10                                    ! r0 = fpdiv(1.0, intensity_y) — reciprocal scale
    mov r12, r4                                 ! (delay) r4 = 1.0 (dividend)
    bra     .L_store_setup                      ! go to per-channel store dispatch
    mov r0, r13                                 ! (delay) r13 = processed color_y result
! ---- First dispatch: decide whether to clamp based on channel ----
.L_clamp_dispatch:
    cmp/eq #0x1, r0                             ! channel 1 (scene A)? skip clamping
    bt      .L_color_process                    ! -> process directly
    cmp/eq #0x2, r0                             ! channel 2 (scene B)? skip clamping
    bt      .L_color_process                    ! -> process directly
    cmp/eq #0x4, r0                             ! channel 4 (transform A)? clamp first
    bt      .L_clamp_intensity_x                ! -> clamp then process
    cmp/eq #0x8, r0                             ! channel 8 (transform B)? clamp first
    bt      .L_clamp_intensity_x                ! -> clamp then process
! ---- Load struct pointers for per-channel store ----
.L_store_setup:
    mov.l   .L_enable_flags_ptr, r6             ! r6 = &scene_enable_flags (render dirty bits)
    mov.l   .L_scene_view_a_ptr, r5             ! r5 = &scene_view_A (viewport A struct)
    mov.l   .L_scene_transform_ptr, r4          ! r4 = &scene_transform (transform struct)
    mov.l   .L_cmd_slot_ptr, r0                 ! r0 = &cmd_slot
    bra     .L_store_dispatch                   ! jump to store dispatch
    mov.l @r0, r0                               ! (delay) r0 = channel_id
! ---- Channel 4: store to transform color slot A ----
.L_store_ch4:
    mov.l r14, @(8, r4)                         ! scene_transform[8] = color_x
    bra     .L_epilogue                         ! done, return
    mov.l r13, @(12, r4)                        ! (delay) scene_transform[12] = color_y
! ---- Channel 8: store to transform color slot B ----
.L_store_ch8:
    mov.l r14, @(24, r4)                        ! scene_transform[24] = color_x
    bra     .L_epilogue                         ! done, return
    mov.l r13, @(28, r4)                        ! (delay) scene_transform[28] = color_y

    .global DAT_0603881a
DAT_0603881a:
    .2byte  0x4000                              /* 0.25 in 16.16 fixed-point (clamp floor) */
.L_clamp_max:
    .4byte  0x00FF0000                          /* 255.0 in 16.16 fp (clamp ceiling) */
.L_fn_fpdiv:
    .4byte  sym_0603C0A0                        /* fpdiv: fixed-point divide r4/r5 */
.L_fp_one:
    .4byte  0x00010000                          /* 1.0 (16.16 fixed-point) */
.L_cmd_slot_ptr:
    .4byte  sym_060635A8                        /* display cmd queue slot (channel ID) */
.L_enable_flags_ptr:
    .4byte  sym_060A3E38                        /* scene enable flags (render dirty bits) */
.L_scene_view_a_ptr:
    .4byte  sym_060A3E68                        /* scene view struct A (viewport A) */
.L_scene_transform_ptr:
    .4byte  sym_060A3DF8                        /* scene transform struct (color slots) */
! ---- Channel 1: store to scene A view color + render dirty check ----
.L_store_ch1:
    mov r5, r4                                  ! r4 = &scene_view_A
    mov #0x4C, r0                               ! offset 0x4C (76) = view color_x field
    mov.l r14, @(r0, r4)                        ! scene_view_A[0x4C] = color_x
    mov #0x50, r0                               ! offset 0x50 (80) = view color_y field
    mov.l r13, @(r0, r4)                        ! scene_view_A[0x50] = color_y
    mov.w @(4, r6), r0                          ! r0 = enable_flags word at offset 4
    extu.w r0, r0                               ! zero-extend to 32 bits
    tst #0xFF, r0                               ! test low byte: scene A enable bits set?
    bt      .L_epilogue                         ! all zero -> no render invalidation needed
    mov #0x0, r6                                ! r6 = 0 (arg3 for scene_color_matrix)
    mov r6, r5                                  ! r5 = 0 (arg2)
    mov r6, r4                                  ! r4 = 0 (arg1)
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r9                             ! restore r9
    mov.l @r15+, r10                            ! restore r10
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    mov.l   .L_fn_scene_color_matrix, r3        ! r3 = &scene_color_matrix
    jmp @r3                                     ! tail-call scene_color_matrix(0, 0, 0)
    mov.l @r15+, r14                            ! (delay) restore r14
! ---- Channel 2: store to scene B view color + render dirty check ----
.L_store_ch2:
    mov #0x4C, r0                               ! offset 0x4C (76) = view color_x field
    mov.w   .L_scene_b_offset, r4               ! r4 = 0x80 (scene B offset from view A base)
    add r5, r4                                  ! r4 = scene_view_A + 0x80 = &scene_view_B
    mov.l r14, @(r0, r4)                        ! scene_view_B[0x4C] = color_x
    mov #0x50, r0                               ! offset 0x50 (80) = view color_y field
    mov.l r13, @(r0, r4)                        ! scene_view_B[0x50] = color_y
    mov.w @(4, r6), r0                          ! r0 = enable_flags word at offset 4
    mov.l   .L_scene_b_enable_mask, r2          ! r2 = 0x0000FF00 (high byte mask)
    mov r0, r3                                  ! r3 = enable_flags (copy for masking)
    extu.w r3, r3                               ! zero-extend to 32 bits
    and r2, r3                                  ! isolate high byte: scene B enable bits
    tst r3, r3                                  ! any scene B enable bits set?
    bt      .L_epilogue                         ! no -> skip render invalidation
    mov #0x0, r6                                ! r6 = 0 (arg3 for scene_color_matrix)
    mov r6, r5                                  ! r5 = 0 (arg2)
    mov r6, r4                                  ! r4 = 0 (arg1)
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r9                             ! restore r9
    mov.l @r15+, r10                            ! restore r10
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    mov.l   .L_fn_scene_color_matrix, r3        ! r3 = &scene_color_matrix
    jmp @r3                                     ! tail-call scene_color_matrix(0, 0, 0)
    mov.l @r15+, r14                            ! (delay) restore r14
! ---- Second dispatch: choose store target by channel ----
.L_store_dispatch:
    cmp/eq #0x1, r0                             ! channel 1? -> scene A view color
    bt      .L_store_ch1                        ! -> store to viewport A + dirty check
    cmp/eq #0x2, r0                             ! channel 2? -> scene B view color
    bt      .L_store_ch2                        ! -> store to viewport B + dirty check
    cmp/eq #0x4, r0                             ! channel 4? -> transform color A
    bt      .L_store_ch4                        ! -> store to transform slot A
    cmp/eq #0x8, r0                             ! channel 8? -> transform color B
    bt      .L_store_ch8                        ! -> store to transform slot B
! ---- Normal return (no tail-call needed) ----
.L_epilogue:
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r9                             ! restore r9
    mov.l @r15+, r10                            ! restore r10
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return to caller
    mov.l @r15+, r14                            ! (delay) restore r14
.L_scene_b_offset:
    .2byte  0x0080                              /* 128-byte offset: scene_view_B = view_A + 0x80 */
    .2byte  0xFFFF                              /* padding (unused) */
.L_fn_scene_color_matrix:
    .4byte  scene_color_matrix                  /* scene color matrix setup + render trigger */
.L_scene_b_enable_mask:
    .4byte  0x0000FF00                          /* high byte mask for scene B enable bits */
