/* track_surface_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041648 - 0x06041698
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Queries the track surface type at the current position and writes the
 * resulting surface byte into the game state structure at offset +0x40.
 *
 * Returns:
 *   r0 = -10  if surface query failed (track_surface_type_b returned nonzero)
 *   r0 = surface type value from stack[0] on success
 *
 * Stack frame (0x18 = 24 bytes):
 *   sp+0x00: surface query output [0] — surface type (returned in r0)
 *   sp+0x04: surface query output [1] — passed as r4 to type_b
 *   sp+0x08: surface query output [2] — passed as r5 to type_b
 *   sp+0x0C: section transition output — surface byte written to state[+0x40]
 *
 * Flow:
 *   1. Call track_surface_type_b(sp+4, sp+8, sp) to query surface info.
 *   2. If query fails (nonzero), return -10.
 *   3. Call cd_block_read_safe(sp+0xC) via cross-TU pool.
 *   4. Load game state base from sym_060A5400, copy surface byte
 *      from sp+0xC into state[+0x40].
 *   5. Return sp[0] (surface type value).
 */

    .section .text.FUN_06041648


    .global track_surface_check
    .type track_surface_check, @function
track_surface_check:
    sts.l pr, @-r15                          ! save return address
    add #-0x18, r15                          ! allocate 24-byte stack frame
    mov r15, r6                              ! r6 = sp+0x00 (3rd arg: output slot 0)
    mov r15, r5                              ! r5 = sp (will become sp+0x08)
    mov r15, r4                              ! r4 = sp (will become sp+0x04)
    mov.l   .L_fn_surface_type_b, r3         ! r3 = &track_surface_type_b
    add #0x8, r5                             ! r5 = sp+0x08 (2nd arg: output slot 2)
    jsr @r3                                  ! call track_surface_type_b(sp+4, sp+8, sp)
    add #0x4, r4                             ! (delay) r4 = sp+0x04 (1st arg: output slot 1)
    mov r0, r4                               ! r4 = query return value
    tst r4, r4                               ! did query succeed (== 0)?
    bt      .L_query_ok                      ! yes -> proceed to section transition
    add #0x18, r15                           ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return
    mov #-0xA, r0                            ! (delay) r0 = -10 (surface query failed)
    .4byte  track_shadow_shape               ! cross-TU pool (used by track_shadow_test)
    .4byte  ai_checkpoint_validate           ! cross-TU pool (used by track_shadow_test)
    .4byte  sym_060A5400                     ! cross-TU pool (used by track_shadow_test)
.L_fn_surface_type_b:
    .4byte  track_surface_type_b             ! pool: surface type query function
.L_query_ok:
    mov r15, r4                              ! r4 = sp base
    .byte   0xD3, 0x2C    /* mov.l .L_pool_0604172C, r3 */  ! r3 = &cd_block_read_safe (cross-TU pool)
    jsr @r3                                  ! call cd_block_read_safe(sp+0xC)
    add #0xC, r4                             ! (delay) r4 = sp+0x0C (section output slot)
    .byte   0xD2, 0x2B    /* mov.l .L_pool_06041730, r2 */  ! r2 = &game_state_base (cross-TU pool)
    mov.l @r2, r2                            ! r2 = game state base address
    mov r15, r3                              ! r3 = sp base
    add #0xC, r3                             ! r3 = sp+0x0C (section transition result)
    mov.b @r3, r1                            ! r1 = surface byte from section transition
    mov #0x40, r0                            ! r0 = 0x40 (offset into game state struct)
    mov.b r1, @(r0, r2)                      ! state[+0x40] = surface byte
    mov.l @r15, r0                           ! r0 = sp[0x00] (surface type result)
    add #0x18, r15                           ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return r0 = surface type
    nop                                      ! (delay) padding
