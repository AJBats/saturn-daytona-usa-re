/* slave_sh2_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603F148 - 0x0603F202
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Functions in this TU:
 *
 * slave_sh2_setup (0x0603F148):
 *   Directory entry lookup by name. Searches an array of 0x18-byte directory
 *   entries for one whose 12-byte name field matches a given string.
 *   First checks for the special ISO 9660 names "." (current dir, index 0)
 *   and ".." (parent dir, index 1) using strcmp. For all other entries
 *   (index 2..max_entries-1), compares the 12-byte name at entry offset +0xC
 *   using memcmp. Stops early if the entry's flag byte (offset +0xB) has
 *   bit 7 set (end-of-directory marker).
 *
 *   Input:  r4 = base pointer to directory entry array
 *           r5 = search name string
 *           r6 = max number of entries
 *   Output: r0 = entry index (0 for ".", 1 for ".."), or -1 if not found
 *
 * sym_0603F1E0 (index_mul12):
 *   Computes r4 * 12 + r5. Used to index into 12-byte record arrays.
 *   Input:  r4 = index, r5 = base address
 *   Output: r0 = r4 * 12 + r5
 *
 * sym_0603F1F0 (index_mul24):
 *   Computes r4 * 24 + r5. Used to index into 24-byte record arrays.
 *   Input:  r4 = index, r5 = base address
 *   Output: r0 = r4 * 24 + r5
 */

    .section .text.FUN_0603F148


    .global slave_sh2_setup
    .type slave_sh2_setup, @function
slave_sh2_setup:
    mov.l r14, @-r15                    ! save r14 (loop index)
    mov.l r13, @-r15                    ! save r13 (entry pointer)
    mov.l r12, @-r15                    ! save r12 (search name)
    mov r4, r13                         ! r13 = base ptr to directory entries
    mov.l r11, @-r15                    ! save r11 (flag mask)
    mov r5, r12                         ! r12 = search name string
    mov.l r10, @-r15                    ! save r10 (max entries)
    mov r6, r10                         ! r10 = max number of entries
    mov.l r9, @-r15                     ! save r9 (memcmp ptr)
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_ptr_memcmp, r9          ! r9 = memcmp function pointer
    mov.w   .L_flag_mask, r11          ! r11 = 0x0080 (end-of-dir flag mask)
    mov.l   .L_ptr_str_dot, r0        ! r0 = ptr to "." string
    mov.l   .L_ptr_strcmp, r3          ! r3 = strcmp function pointer
    jsr @r3                             ! strcmp(r0=".", r1=search_name)
    mov r5, r1                          ! r1 = search name (delay slot)
    tst r0, r0                          ! strcmp returned 0 (match)?
    bf      .L_dot_no_match            ! no → try ".."
    bra     .L_return                  ! match → return index 0
    mov #0x0, r0                        ! r0 = 0 ("." entry index, delay slot)
.L_dot_no_match:
    mov.l   .L_ptr_str_dotdot, r0     ! r0 = ptr to ".." string
    mov.l   .L_ptr_strcmp, r3          ! r3 = strcmp function pointer
    jsr @r3                             ! strcmp(r0="..", r1=search_name)
    mov r12, r1                         ! r1 = search name (delay slot)
    tst r0, r0                          ! strcmp returned 0 (match)?
    bf      .L_search_entries          ! no → search remaining entries
    bra     .L_return                  ! match → return index 1
    mov #0x1, r0                        ! r0 = 1 (".." entry index, delay slot)
.L_flag_mask:
    .2byte  0x0080                      ! word pool: end-of-dir flag mask (bit 7)
    .2byte  0xFFFF                      ! alignment pad
    .4byte  cmd_dispatch_main           ! pool: ptr to cmd_dispatch_main (0x0603B424)
    .4byte  menu_state_handler          ! pool: ptr to menu_state_handler (0x0603B31C)
.L_ptr_memcmp:
    .4byte  sym_06036D94                ! pool: ptr to memcmp
.L_ptr_str_dot:
    .4byte  sym_06059CB8                ! pool: ptr to "." string (current dir)
.L_ptr_strcmp:
    .4byte  sym_06036D14                ! pool: ptr to strcmp
.L_ptr_str_dotdot:
    .4byte  sym_06059CBC                ! pool: ptr to ".." string (parent dir)
.L_search_entries:
    mov #0x2, r14                       ! r14 = 2 (start index, skip "." and "..")
    cmp/ge r10, r14                     ! index >= max_entries?
    bt/s    .L_not_found               ! yes → not found
    add #0x30, r13                      ! r13 += 0x30 (skip entries 0+1, delay slot)
.L_compare_entry:
    mov #0xC, r6                        ! r6 = 12 (name field length)
    mov r13, r5                         ! r5 = current entry ptr
    add #0xC, r5                        ! r5 = entry + 0xC (name field offset)
    jsr @r9                             ! memcmp(r4=search_name, r5=entry_name, r6=12)
    mov r12, r4                         ! r4 = search name (delay slot)
    tst r0, r0                          ! memcmp returned 0 (match)?
    bf      .L_check_end_flag          ! no match → check if end of directory
    bra     .L_return                  ! match → return current index
    mov r14, r0                         ! r0 = entry index (delay slot)
.L_check_end_flag:
    mov.b @(11, r13), r0               ! r0 = entry flags byte at offset +0xB
    mov r0, r3                          ! r3 = flags byte (sign-extended)
    extu.b r3, r3                       ! r3 = flags byte (zero-extended)
    and r11, r3                         ! r3 = flags & 0x80 (end-of-dir bit)
    tst r3, r3                          ! end-of-dir flag set?
    bt      .L_next_entry              ! no → try next entry
    bra     .L_not_found               ! yes → stop searching
    nop                                 ! delay slot
.L_next_entry:
    add #0x1, r14                       ! r14++ (next entry index)
    cmp/ge r10, r14                     ! index >= max_entries?
    bf/s    .L_compare_entry           ! no → compare next entry
    add #0x18, r13                      ! r13 += 0x18 (advance to next entry, delay slot)
.L_not_found:
    mov #-0x1, r0                       ! r0 = -1 (not found)
.L_return:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return (r0 = entry index or -1)
    mov.l @r15+, r14                    ! restore r14 (delay slot)

    .global sym_0603F1E0
sym_0603F1E0:                           ! index_mul12: compute r4 * 12 + r5
    mov r4, r0                          ! r0 = index
    mov r4, r3                          ! r3 = index
    shll2 r0                            ! r0 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r3                             ! r3 = index * 8
    add r3, r0                          ! r0 = index*4 + index*8 = index*12
    rts                                 ! return
    add r5, r0                          ! r0 = index*12 + base (delay slot)

    .global sym_0603F1F0
sym_0603F1F0:                           ! index_mul24: compute r4 * 24 + r5
    mov r4, r0                          ! r0 = index
    mov r4, r3                          ! r3 = index
    shll2 r0                            ! r0 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r0                             ! r0 = index * 8
    shll2 r3                            ! r3 = index * 16
    add r3, r0                          ! r0 = index*8 + index*16 = index*24
    rts                                 ! return
    add r5, r0                          ! r0 = index*24 + base (delay slot)
