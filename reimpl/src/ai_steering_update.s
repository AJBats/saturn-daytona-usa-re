/* ai_steering_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600C7D8 - 0x0600C8CC
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0600C7D8


/* ============================================================================
 * ai_steering_update
 * ============================================================================
 * Updates the AI car's heading with speed-based damping, then converts the
 * heading to X/Z velocity components and integrates position.
 *
 * Speed-based damping reduces steering response at higher speeds:
 *   speed > 280: shar x3 (heavy damping, sluggish steering)
 *   speed > 250: shar x2 (medium damping)
 *   speed > 220: shar x1 (light damping)
 *   speed <= 220: no damping (full steering response)
 *
 * After computing heading, also:
 *   - Computes lateral offset from track center (state[0x30])
 *   - Blends course heading components into state[0x1C] and state[0x24]
 *   - Copies X/Z positions to state[0x38] and state[0x3C]
 *   - Calls sincos_pair to convert heading to sin/cos components
 *   - Calls fpmul to compute velocity = heading_component * speed
 *   - Integrates X and Z positions
 *
 * Arguments:
 *   r14 = AI car state struct base pointer (set by heading_speed_damping)
 *   r5  = course/waypoint data pointer
 *
 * Returns: void (updates AI state in-place)
 * ============================================================================
 */
    .global ai_steering_update
    .type ai_steering_update, @function
ai_steering_update:
    sts.l pr, @-r15                        ! save return address

    /* --- Copy current heading to backup slot --- */
    mov.l @(32, r14), r3                   ! r3 = state[0x20] = current heading
    mov.w   DAT_0600c8b6, r0              ! r0 = 0x01B0 (heading backup offset)
    mov.l r3, @(r0, r14)                   ! state[0x1B0] = heading backup

    /* --- Compute heading delta = target - current --- */
    mov.l @(40, r14), r4                   ! r4 = state[0x28] = target heading
    mov.l @(32, r14), r3                   ! r3 = state[0x20] = current heading
    mov.l @(8, r14), r2                    ! r2 = state[0x08] = current speed
    extu.w r4, r4                          ! zero-extend target heading to 16-bit
    neg r3, r3                             ! negate current heading
    extu.w r3, r3                          ! zero-extend negated heading
    add r3, r4                             ! r4 = (target - current) as unsigned delta

    /* --- Speed-based damping: check highest threshold first --- */
    mov.w   .L_wpool_speed_thresh_heavy, r3         ! r3 = 0x0118 = 280 (heavy damping threshold)
    cmp/gt r3, r2                          ! speed > 280?
    bf/s    .check_speed_250               ! if not, check next threshold
    exts.w r4, r4                          ! (delay) sign-extend heading delta
    shar r4                                ! delta >>= 1
    shar r4                                ! delta >>= 2
    bra     .apply_heading                 ! apply heavily damped delta
    shar r4                                ! (delay) delta >>= 3 (heavy: /8)

.check_speed_250:
    mov.l @(8, r14), r2                    ! r2 = speed (re-read)
    mov.w   .L_wpool_speed_thresh_medium, r3         ! r3 = 0x00FA = 250 (medium damping threshold)
    cmp/gt r3, r2                          ! speed > 250?
    bf      .check_speed_220               ! if not, check next threshold
    shar r4                                ! delta >>= 1
    bra     .apply_heading                 ! apply medium damped delta
    shar r4                                ! (delay) delta >>= 2 (medium: /4)

.check_speed_220:
    mov.l @(8, r14), r2                    ! r2 = speed (re-read)
    mov.w   DAT_0600c8bc, r3              ! r3 = 0x00DC = 220 (light damping threshold)
    cmp/gt r3, r2                          ! speed > 220?
    bf      .apply_heading                 ! if not, no damping (full steering)
    shar r4                                ! delta >>= 1 (light: /2)

.apply_heading:
    /* --- Add damped delta to current heading --- */
    extu.w r4, r4                          ! zero-extend adjusted delta
    mov.l @(32, r14), r3                   ! r3 = current heading
    extu.w r3, r3                          ! zero-extend current heading
    add r4, r3                             ! r3 = heading + damped delta
    exts.w r3, r3                          ! sign-extend result
    mov.l r3, @(32, r14)                   ! state[0x20] = new heading

    /* --- Compute lateral offset from track center --- */
    mov r3, r2                             ! r2 = new heading
    mov.w   DAT_0600c8be, r0              ! r0 = 0x01D8 (track center heading offset)
    extu.w r2, r2                          ! zero-extend new heading
    mov.l @(r0, r14), r3                   ! r3 = state[0x1D8] = track center heading
    neg r3, r3                             ! negate track center heading
    mov.w @(18, r5), r0                    ! r0 = course_data[0x12] = course heading
    extu.w r3, r3                          ! zero-extend negated track center
    add r3, r2                             ! r2 = heading - track_center
    mov r0, r3                             ! r3 = course heading
    neg r3, r3                             ! negate course heading
    extu.w r3, r3                          ! zero-extend negated course heading
    add r3, r2                             ! r2 -= course heading offset
    exts.w r2, r2                          ! sign-extend lateral offset
    mov.l r2, @(48, r14)                   ! state[0x30] = lateral offset from track

    /* --- Blend course heading X component --- */
    mov.w @(12, r5), r0                    ! r0 = course_data[0x0C] = course heading X
    mov.l @(28, r14), r2                   ! r2 = state[0x1C] = current X heading
    mov r0, r3                             ! r3 = course heading X
    extu.w r2, r2                          ! zero-extend current X heading
    extu.w r3, r3                          ! zero-extend course heading X
    add r2, r3                             ! r3 = current_X + course_X
    exts.w r3, r3                          ! sign-extend sum
    shar r3                                ! r3 = (current + course) / 2 (blend)
    mov.l r3, @(28, r14)                   ! state[0x1C] = blended X heading

    /* --- Blend course heading Z component --- */
    mov.w @(16, r5), r0                    ! r0 = course_data[0x10] = course heading Z
    mov.l @(36, r14), r2                   ! r2 = state[0x24] = current Z heading
    mov r0, r3                             ! r3 = course heading Z
    extu.w r2, r2                          ! zero-extend current Z heading
    extu.w r3, r3                          ! zero-extend course heading Z
    add r2, r3                             ! r3 = current_Z + course_Z
    exts.w r3, r3                          ! sign-extend sum
    shar r3                                ! r3 = (current + course) / 2 (blend)
    mov.l r3, @(36, r14)                   ! state[0x24] = blended Z heading

    /* --- Copy current X/Z positions to backup slots --- */
    mov.l @(16, r14), r3                   ! r3 = state[0x10] = X position
    mov.l r3, @(56, r14)                   ! state[0x38] = X position backup
    mov.l @(24, r14), r2                   ! r2 = state[0x18] = Z position
    mov.l r2, @(60, r14)                   ! state[0x3C] = Z position backup

    /* --- Apply heading correction toward course center --- */
    mov.l @(32, r14), r3                   ! r3 = current heading
    mov.w @(18, r5), r0                    ! r0 = course_data[0x12] = course heading
    extu.w r3, r3                          ! zero-extend heading
    mov r0, r2                             ! r2 = course heading
    neg r2, r2                             ! negate course heading
    shar r2                                ! -course_heading / 2
    shar r2                                ! -course_heading / 4
    extu.w r2, r2                          ! zero-extend correction
    add r2, r3                             ! heading += (-course_heading / 4)
    exts.w r3, r3                          ! sign-extend adjusted heading
    mov.l r3, @(32, r14)                   ! state[0x20] = corrected heading

    /* --- Convert heading to sin/cos via sincos_pair --- */
    mov.w   DAT_0600c8c0, r6              ! r6 = 0x0190 (cos output offset in state)
    mov.w   DAT_0600c8c2, r5              ! r5 = 0x018C (sin output offset in state)
    mov.l @(40, r14), r4                   ! r4 = state[0x28] = target heading angle
    mov.l   .pool_sincos_pair, r3         ! r3 = sincos_pair function address
    add r14, r6                            ! r6 = &state[0x190] (cos output pointer)
    add r14, r5                            ! r5 = &state[0x18C] (sin output pointer)
    jsr @r3                                ! sincos_pair(-heading, &sin_out, &cos_out)
    neg r4, r4                             ! (delay) negate heading for direction

    /* --- Compute X velocity = sin(heading) * speed --- */
    mov.w   DAT_0600c8c2, r0              ! r0 = 0x018C (sin result offset)
    mov.l   .pool_fpmul, r3               ! r3 = fpmul function address
    mov.l @(r0, r14), r5                   ! r5 = state[0x18C] = sin component
    jsr @r3                                ! r0 = fpmul(speed, sin)
    mov.l @(12, r14), r4                   ! (delay) r4 = state[0x0C] = speed/distance

    /* --- Integrate X position --- */
    mov.l @(16, r14), r2                   ! r2 = state[0x10] = current X position
    add r0, r2                             ! X += velocity_X
    mov.l r2, @(16, r14)                   ! state[0x10] = updated X position

    /* --- Compute Z velocity = cos(heading) * speed --- */
    mov.w   DAT_0600c8c0, r0              ! r0 = 0x0190 (cos result offset)
    mov.l   .pool_fpmul, r3               ! r3 = fpmul function address
    mov.l @(r0, r14), r5                   ! r5 = state[0x190] = cos component
    jsr @r3                                ! r0 = fpmul(speed, cos)
    mov.l @(12, r14), r4                   ! (delay) r4 = state[0x0C] = speed/distance

    /* --- Integrate Z position --- */
    mov.l @(24, r14), r2                   ! r2 = state[0x18] = current Z position
    add r0, r2                             ! Z += velocity_Z
    mov.l r2, @(24, r14)                   ! state[0x18] = updated Z position

    lds.l @r15+, pr                        ! restore return address
    rts                                    ! return
    mov.l @r15+, r14                       ! (delay) restore r14 (AI state pointer)

/* --- Constant pool --- */
    .global DAT_0600c8b6
DAT_0600c8b6:
    .2byte  0x01B0                         ! offset: heading backup in AI state
.L_wpool_speed_thresh_heavy:
    .2byte  0x0118                         /* [HIGH] speed threshold: 280 (heavy damping) */
.L_wpool_speed_thresh_medium:
    .2byte  0x00FA                         /* [HIGH] speed threshold: 250 (medium damping) */

    .global DAT_0600c8bc
DAT_0600c8bc:
    .2byte  0x00DC                         ! speed threshold: 220 (light damping)

    .global DAT_0600c8be
DAT_0600c8be:
    .2byte  0x01D8                         ! offset: track center heading in AI state

    .global DAT_0600c8c0
DAT_0600c8c0:
    .2byte  0x0190                         ! offset: cos output in AI state

    .global DAT_0600c8c2
DAT_0600c8c2:
    .2byte  0x018C                         ! offset: sin output in AI state
.pool_sincos_pair:
    .4byte  sincos_pair                    ! sin/cos lookup function
.pool_fpmul:
    .4byte  fpmul                          ! fixed-point multiply function
