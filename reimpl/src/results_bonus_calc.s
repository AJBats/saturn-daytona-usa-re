/* results_bonus_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06016410 - 0x06016468
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Advances the bonus accumulator at struct[+0x30] toward zero by
 * adding 0x800 each call.  The accumulator starts negative (set
 * elsewhere); once it reaches or exceeds zero, it is clamped to
 * zero (countdown complete).  Always tail-calls
 * hud_sprite_vertex_project to update the display.
 * Returns immediately if the results-active flag is clear.
 */

    .section .text.FUN_06016410


    .global results_bonus_calc
    .type results_bonus_calc, @function
results_bonus_calc:
    mov.l r14, @-r15                          ! save r14 on stack
    mov.l   .L_pool_results_active_flag, r0   ! r0 = &results_active_flag
    mov.b @r0, r0                             ! r0 = results_active_flag (byte)
    tst r0, r0                                ! test if flag is zero
    bt/s    .L_early_return                   ! if zero, nothing to do — return
    mov r4, r14                               ! r14 = car_slot_index arg (delay slot)
    mov.l   .L_pool_slot_data_base, r5        ! r5 = slot data array base
    extu.b r14, r4                            ! r4 = slot_index (zero-extend byte)
    mov.w   .L_wpool_0601645A, r2             ! r2 = 0x0800 (countdown step)
    mov r4, r3                                ! r3 = slot_index (copy for stride calc)
    shll2 r4                                  ! r4 = slot_index * 4
    shll2 r3                                  ! r3 = slot_index * 4
    shll2 r3                                  ! r3 = slot_index * 16
    shll2 r3                                  ! r3 = slot_index * 64
    add r3, r4                                ! r4 = slot_index * 68 (struct stride)
    exts.w r4, r4                             ! sign-extend offset to 32-bit
    add r5, r4                                ! r4 = &slot_data[slot_index]
    mov.l @(48, r4), r3                       ! r3 = struct[+0x30] bonus accumulator
    add r2, r3                                ! r3 += 0x800 (advance toward zero)
    mov r3, r2                                ! r2 = updated accumulator
    mov.l r3, @(48, r4)                       ! store updated accumulator
    cmp/pz r2                                 ! has accumulator reached zero or above?
    bf      .L_commit_display                 ! still negative — skip clamp, just update display
    extu.b r14, r2                            ! r2 = slot_index (recompute struct ptr)
    mov r2, r3                                ! r3 = slot_index (copy for stride calc)
    shll2 r2                                  ! r2 = slot_index * 4
    shll2 r3                                  ! r3 = slot_index * 4
    shll2 r3                                  ! r3 = slot_index * 16
    shll2 r3                                  ! r3 = slot_index * 64
    add r3, r2                                ! r2 = slot_index * 68
    exts.w r2, r2                             ! sign-extend offset to 32-bit
    add r5, r2                                ! r2 = &slot_data[slot_index]
    mov #0x0, r1                              ! r1 = 0
    mov.l r1, @(48, r2)                       ! struct[+0x30] = 0 (clamp at zero)
.L_commit_display:
    extu.b r14, r4                            ! r4 = slot_index arg for tail call
    .byte   0xA4, 0xBF    /* bra 0x06016DD8 (external: hud_sprite_vertex_project) */
    mov.l @r15+, r14                          ! restore r14 (delay slot)
.L_wpool_0601645A:
    .2byte  0x0800
.L_pool_results_active_flag:
    .4byte  sym_06085F89
.L_pool_slot_data_base:
    .4byte  sym_06084FC8
.L_early_return:
    rts                                       ! return — results not active
    mov.l @r15+, r14                          ! restore r14 (delay slot)
