/* scene_data_dispatch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060389A6 - 0x06038A64
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Scene data top-level orchestrator — per-frame dispatch that publishes
 * internal scene state into the rendering pipeline's working buffers.
 *
 * Reads the scene-ready flag (sym_060635AC) and dispatches:
 *   flag==1: Call scene_data_block_copy to publish all scene buffers,
 *            then clear the flag and tail-call display_extra_config.
 *   flag==2: First, perform an indexed copy of scene A data —
 *            entry_count_a (sym_060635A0) × 12 bytes from scene A
 *            source (sym_060A3D70) to scene A dest (sym_060A3D74).
 *            Then copy scene B data — entry_count_b (sym_060635A2) × 4
 *            bytes from scene B source (sym_060A3D78) to scene B dest
 *            (sym_060A3D7C). Finally call scene_data_block_copy,
 *            clear the flag, and tail-call display_extra_config.
 *   flag==3..7 or 0: No copy needed — tail-call display_extra_config.
 *
 * The word_copy_helper (sym_06038A48) copies r6/2 words (r6 bytes)
 * from source r5 to destination r4.
 *
 * Between the code and pool, there are spill entries from
 * scene_data_block_copy's constant pool (2 word-pool offsets + 6
 * longword buffer pointers) that physically reside in this TU's
 * address range.
 */

    .section .text.FUN_060389A6


    .global scene_data_dispatch
    .type scene_data_dispatch, @function
scene_data_dispatch:
    mov.l r14, @-r15                            ! save r14 (callee-save)
    sts.l pr, @-r15                             ! save return address
    .byte   0xDE, 0x18    /* mov.l .Lpool_ready_flag_ptr, r14 */  ! r14 = &scene_ready_flag (sym_060635AC)
    mov.w @r14, r0                              ! r0 = scene_ready_flag value (word)
    bra     .Ldispatch_switch                   ! jump to dispatch table
    extu.w r0, r0                               ! zero-extend flag to 32 bits (delay slot)
.Lflag_1_block_copy:
    .byte   0xBF, 0x85    /* bsr 0x060388C0 (external) */  ! call scene_data_block_copy
    nop                                         ! delay slot
    bra     .Lclear_flag_and_return             ! done — clear flag and exit
    nop                                         ! delay slot
.Lflag_2_indexed_copy:
    .byte   0xD6, 0x15    /* mov.l .Lpool_entry_count_a_ptr, r6 */  ! r6 = &entry_count_a (sym_060635A0)
    .byte   0xD5, 0x15    /* mov.l .Lpool_scene_a_src, r5 */       ! r5 = &scene_a_source_ptr (sym_060A3D74)
    .byte   0xD4, 0x16    /* mov.l .Lpool_scene_a_dst, r4 */       ! r4 = &scene_a_dest_ptr (sym_060A3D70)
    mov.w @r6, r6                               ! r6 = entry_count_a (word)
    mov.l @r5, r5                               ! r5 = scene A source address
    extu.w r6, r6                               ! zero-extend count to 32 bits
    mov r6, r3                                  ! r3 = entry_count_a (copy for stride calc)
    shll2 r6                                    ! r6 = count × 4
    shll2 r3                                    ! r3 = count × 4
    shll r3                                     ! r3 = count × 8
    add r3, r6                                  ! r6 = count×4 + count×8 = count × 12 bytes total
    bsr     sym_06038A48                        ! copy scene A entries (r6 bytes from r5 to r4)
    mov.l @r4, r4                               ! r4 = scene A dest address (delay slot)
    .byte   0xD6, 0x11    /* mov.l .Lpool_entry_count_b_ptr, r6 */ ! r6 = &entry_count_b (sym_060635A2)
    .byte   0xD5, 0x12    /* mov.l .Lpool_scene_b_src, r5 */      ! r5 = &scene_b_source_ptr (sym_060A3D7C)
    .byte   0xD4, 0x12    /* mov.l .Lpool_scene_b_dst, r4 */      ! r4 = &scene_b_dest_ptr (sym_060A3D78)
    mov.w @r6, r6                               ! r6 = entry_count_b (word)
    mov.l @r5, r5                               ! r5 = scene B source address
    extu.w r6, r6                               ! zero-extend count to 32 bits
    shll2 r6                                    ! r6 = count × 4 bytes total
    bsr     sym_06038A48                        ! copy scene B entries (r6 bytes from r5 to r4)
    mov.l @r4, r4                               ! r4 = scene B dest address (delay slot)
    .byte   0xBF, 0x6B    /* bsr 0x060388C0 (external) */  ! call scene_data_block_copy
    nop                                         ! delay slot
.Lclear_flag_and_return:
    mov #0x0, r2                                ! r2 = 0 (clear value)
    bra     .Lepilog_return                     ! jump to epilog
    mov.w r2, @r14                              ! clear scene_ready_flag to 0 (delay slot)
    .4byte  0x00B000C0
    .4byte  sym_060A3D84
    .4byte  sym_060A3D88
    .4byte  sym_060A3DB0
    .4byte  sym_060A3DF8
    .4byte  sym_060A3E38
    .4byte  sym_060A3E48
.Lpool_ready_flag_ptr:
    .4byte  sym_060635AC
.Lpool_entry_count_a_ptr:
    .4byte  sym_060635A0
.Lpool_scene_a_src:
    .4byte  sym_060A3D74
.Lpool_scene_a_dst:
    .4byte  sym_060A3D70
.Lpool_entry_count_b_ptr:
    .4byte  sym_060635A2
.Lpool_scene_b_src:
    .4byte  sym_060A3D7C
.Lpool_scene_b_dst:
    .4byte  sym_060A3D78
.Ldispatch_switch:
    cmp/eq #0x1, r0                             ! is flag == 1?
    bt      .Lflag_1_block_copy                 ! yes — do block copy only
    cmp/eq #0x2, r0                             ! is flag == 2?
    bt      .Lflag_2_indexed_copy               ! yes — indexed copy + block copy
    cmp/eq #0x3, r0                             ! is flag == 3?
    bt      .Lepilog_return                     ! yes — no-op, just return
    cmp/eq #0x4, r0                             ! is flag == 4?
    bt      .Lepilog_return                     ! yes — no-op, just return
    cmp/eq #0x5, r0                             ! is flag == 5?
    bt      .Lepilog_return                     ! yes — no-op, just return
    cmp/eq #0x6, r0                             ! is flag == 6?
    bt      .Lepilog_return                     ! yes — no-op, just return
    cmp/eq #0x7, r0                             ! is flag == 7? (falls through regardless)
.Lepilog_return:
    lds.l @r15+, pr                             ! restore return address
    .byte   0xA0, 0x40    /* bra 0x06038AC8 (external) */  ! tail-call display_extra_config
    mov.l @r15+, r14                            ! restore r14 (delay slot)

    .global sym_06038A48
sym_06038A48:                                   /* word_copy_helper — copies r6 bytes (r6/2 words) from r5 to r4 */
    shlr r6                                     ! r6 = byte_count / 2 (convert to word count)
    mov #0x0, r7                                ! r7 = 0 (loop counter)
    mov r7, r3                                  ! r3 = 0 (for initial comparison)
    cmp/hs r6, r3                               ! is counter >= word_count? (0 >= count?)
    bt      .Lcopy_done                         ! yes — nothing to copy, return
.Lcopy_loop:
    add #0x1, r7                                ! counter++
    mov.w @r5, r3                               ! r3 = *src (read word from source)
    mov.w r3, @r4                               ! *dst = r3 (write word to destination)
    add #0x2, r4                                ! dst += 2 (advance destination pointer)
    cmp/hs r6, r7                               ! is counter >= word_count?
    bf/s    .Lcopy_loop                         ! no — loop again
    add #0x2, r5                                ! src += 2 (advance source pointer, delay slot)
.Lcopy_done:
    rts                                         ! return to caller
    nop                                         ! delay slot
