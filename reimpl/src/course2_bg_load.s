/* course2_bg_load -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06018938 - 0x06018A3C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Course 2 (Dinosaur Canyon) background data loader — copies palette,
 * tile, and map data to Work RAM Low and VDP2 VRAM, then patches offset
 * tables for the rendering pipeline.
 *
 * Data copies (via memcpy_long_idx):
 *   1. Palette data → WRAM Low (0x10A0 bytes)
 *   2. Tile set A → WRAM Low + 0x10A0 (0xF800 bytes)
 *   3. Base BG data → WRAM Low + 0x108A0 (0x17A00 bytes)
 *   4. Map data → 0x240000 (0x19000 bytes)
 *   5. Tile set B → 0x240000 + 0x1C598 (0x3000 bytes)
 *   6. Tile set C → 0x240000 + 0x18598 (0x4000 bytes)
 *   7. Data block D → 0x240000 + 0x1EEA0 (0x3000 bytes)
 *
 * After copying: patches offset tables (4 entries), calls
 * sound_init_sequence(race_end_state), tail-calls render_stage_c.
 *
 * Persistent registers:
 *   r9  = WRAM Low base (0x200000) / then VDP VRAM base (0x240000)
 *   r10 = loop limit (8 entries)
 *   r11 = offset table A (sym_0605D21C)
 *   r12 = offset table B (sym_06085FD0)
 *   r13 = memcpy_long_idx function
 *   r14 = BG data base address (sym_060D6900)
 */

    .section .text.FUN_06018938


    .global course2_bg_load
    .type course2_bg_load, @function
course2_bg_load:
    mov.l r14, @-r15                     ! save r14
    mov.l r13, @-r15                     ! save r13
    mov.l r12, @-r15                     ! save r12
    mov.l r11, @-r15                     ! save r11
    mov.l r10, @-r15                     ! save r10
    mov #0x8, r10                        ! loop limit = 8 (4 pairs)
    mov.l r9, @-r15                      ! save r9
    sts.l pr, @-r15                      ! save return address
    mov.l   .L_offset_table_a, r11     ! r11 = offset source table
    mov.l   .L_offset_table_b, r12     ! r12 = offset dest table
    mov.l   .L_bg_data_base, r14       ! r14 = BG data base
    mov.l   .L_fn_memcpy_long, r13     ! r13 = memcpy function
    mov.w   .L_palette_size, r6         ! r6 = 0x10A0 (palette size)
    mov.l   .L_wram_low, r9            ! r9 = 0x200000 (WRAM Low)
    mov.l   .L_palette_src, r4          ! r4 = palette source addr
    jsr @r13                             ! memcpy(palette_src, WRAM_Low, 0x10A0)
    mov r9, r5                           ! (delay) r5 = WRAM Low dest
    mov.l   .L_tile_a_size, r6          ! r6 = 0xF800 (tile A size)
    mov.w   .L_palette_size, r5         ! r5 = 0x10A0 (dest offset)
    mov.l   .L_tile_a_src, r4           ! r4 = tile A source addr
    jsr @r13                             ! memcpy(tile_a, WRAM+0x10A0, 0xF800)
    add r9, r5                           ! (delay) r5 = WRAM + 0x10A0
    mov.l   .L_bg_base_size, r6        ! r6 = 0x17A00 (base BG size)
    mov.l   .L_bg_base_offset, r5      ! r5 = 0x108A0 (dest offset)
    add r9, r5                           ! r5 = WRAM + 0x108A0
    jsr @r13                             ! memcpy(bg_data, WRAM+0x108A0, 0x17A00)
    mov r14, r4                          ! (delay) r4 = BG data base (source)
    mov.l   .L_map_size, r6            ! r6 = 0x19000 (map data size)
    mov.l   .L_vram_dest_base, r9      ! r9 = 0x240000 (VRAM dest base)
    mov.l   .L_map_src, r4              ! r4 = map data source addr
    jsr @r13                             ! memcpy(map_src, 0x240000, 0x19000)
    mov r9, r5                           ! (delay) r5 = VRAM dest base
    mov.w   .L_tile_b_size, r6          ! r6 = 0x3000 (tile B size)
    mov.l   .L_tile_b_offset, r5       ! r5 = 0x1C598 (VRAM offset)
    mov.l   .L_tile_b_src, r4           ! r4 = tile B source addr
    jsr @r13                             ! memcpy(tile_b, 0x240000+0x1C598, 0x3000)
    add r9, r5                           ! (delay) r5 = VRAM + 0x1C598
    mov.w   .L_tile_c_size, r6          ! r6 = 0x4000 (tile C size)
    mov.l   .L_tile_c_offset, r5       ! r5 = 0x18598 (VRAM offset)
    mov.l   .L_tile_c_src, r4           ! r4 = tile C source addr
    jsr @r13                             ! memcpy(tile_c, 0x240000+0x18598, 0x4000)
    add r9, r5                           ! (delay) r5 = VRAM + 0x18598
    mov.w   .L_tile_b_size, r6          ! r6 = 0x3000 (data D size, same as tile B)
    mov.l   .L_data_d_offset, r5       ! r5 = 0x1EEA0 (VRAM offset)
    mov.l   .L_data_d_src, r4           ! r4 = data block D source addr
    jsr @r13                             ! memcpy(data_d, 0x240000+0x1EEA0, 0x3000)
    add r9, r5                           ! (delay) r5 = VRAM + 0x1EEA0
    mov #0x0, r6                         ! === Patch offset tables ===
    mov r6, r5                           ! pair_idx = 0
    mov r6, r4                           ! table_offset = 0
.L_patch_loop:                              ! --- loop: 4 pairs ---
    mov r4, r2                           ! r2 = table_offset
    mov r4, r3                           ! r3 = table_offset
    add #0x2, r5                         ! pair_idx += 2
    add r11, r2                          ! r2 = &offset_table_a[offset]
    add r12, r3                          ! r3 = &offset_table_b[offset]
    add #0x4, r4                         ! table_offset += 4 (advance to next entry)
    mov.l @r2, r1                        ! r1 = raw offset from table A
    mov r4, r6                           ! r6 = updated table_offset (unused)
    add r14, r1                          ! r1 += BG data base
    mov r4, r2                           ! r2 = table_offset (for next entry)
    mov.l r1, @r3                        ! offset_table_b[i] = base + offset
    add r11, r2                          ! r2 = &offset_table_a[offset+4]
    mov r4, r3                           ! r3 = table_offset
    mov.l @r2, r1                        ! r1 = next raw offset
    add r12, r3                          ! r3 = &offset_table_b[offset+4]
    add r14, r1                          ! r1 += BG data base
    mov.l r1, @r3                        ! offset_table_b[i+1] = base + offset
    cmp/ge r10, r5                       ! pair_idx >= 8?
    bf/s    .L_patch_loop                ! loop if not done
    add #0x4, r4                         ! (delay) table_offset += 4
    mov.l   .L_race_end_state, r4      ! === Sound + render ===
    mov.l   .L_fn_sound_init, r3       ! r3 = sound_init_sequence
    jsr @r3                              ! sound_init_sequence(race_end_state)
    mov.l @r4, r4                        ! (delay) r4 = *race_end_state
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    mov.l   .L_fn_render_stage, r3     ! r3 = render_stage_c
    jmp @r3                              ! tail call render_stage_c()
    mov.l @r15+, r14                     ! (delay) restore r14
.L_palette_size:
    .2byte  0x10A0                        /* palette data: 4256 bytes */
.L_tile_b_size:
    .2byte  0x3000                        /* tile set B/D: 12288 bytes */
.L_tile_c_size:
    .2byte  0x4000                        /* tile set C: 16384 bytes */
.L_offset_table_a:
    .4byte  sym_0605D21C               /* BG offset source table */
.L_offset_table_b:
    .4byte  sym_06085FD0               /* BG offset dest table */
.L_bg_data_base:
    .4byte  sym_060D6900               /* BG data base address (course 2) */
.L_fn_memcpy_long:
    .4byte  memcpy_long_idx            /* long-indexed memory copy */
.L_wram_low:
    .4byte  0x00200000                  /* Work RAM Low base */
.L_palette_src:
    .4byte  sym_060D5840               /* palette source data */
.L_tile_a_size:
    .4byte  0x0000F800                  /* tile set A: 63488 bytes */
.L_tile_a_src:
    .4byte  sym_060C6000               /* tile set A source */
.L_bg_base_size:
    .4byte  0x00017A00                  /* base BG data: 97792 bytes */
.L_bg_base_offset:
    .4byte  0x000108A0                  /* WRAM offset for base BG */
.L_map_size:
    .4byte  0x00019000                  /* map data: 100KB */
.L_vram_dest_base:
    .4byte  0x00240000                  /* VRAM destination base */
.L_map_src:
    .4byte  sym_060A6000               /* map data source */
.L_tile_b_offset:
    .4byte  0x0001C598                  /* VRAM offset for tile set B */
.L_tile_b_src:
    .4byte  sym_060BF000               /* tile set B source */
.L_tile_c_offset:
    .4byte  0x00018598                  /* VRAM offset for tile set C */
.L_tile_c_src:
    .4byte  sym_060C2000               /* tile set C source */
.L_data_d_offset:
    .4byte  0x0001EEA0                  /* VRAM offset for data block D */
.L_data_d_src:
    .4byte  0x002F8000                  /* data block D source address */
.L_race_end_state:
    .4byte  sym_0607EAD8               /* race end state variable */
.L_fn_sound_init:
    .4byte  sound_init_sequence        /* sound initialization for course */
.L_fn_render_stage:
    .4byte  render_stage_c             /* render stage C entry point */
