/* world_camera_update -- Per-frame lap time display list submission
 * Translation unit: 0x06005C98 - 0x06005DD4
 *
 * Builds display list entries for lap time digits on the HUD. Two paths:
 *
 * Path A (race countdown state == 0x28, i.e. active racing):
 *   Iterates over a window of recent laps (up to 7 behind current lap),
 *   converting each lap's recorded time from the per-lap time array
 *   (sym_0607EBF8) via anim_frame_transform, then writing two display
 *   list commands per lap:
 *     - geom_dispatch_final (r4=0x8, r5=slot*2, r6=value, r7=data)
 *     - display_list_cmd_writer (r4=0x8, r5=slot*2, r6=0x3C, r7=index+1)
 *   The "current lap" entry uses r6=0x54; all others use r6=0x48.
 *
 * Path B (any other countdown state, non-active):
 *   Single-pass: computes elapsed time as frame_counter*5 - lap_start_time,
 *   clamps to max_frame (0x927BF), calls anim_frame_transform, and submits
 *   one pair of display list commands for the current lap.
 *
 * Symbols:
 *   sym_06028430 = display_list_cmd_writer (r4=mode, r5=slot, r6=value, r7=data)
 *   sym_060284AE = geom_dispatch_final (r4=mode, r5=slot, r6=value, r7=data)
 *   sym_0607E944 = car_state_ptr (pointer to car state struct)
 *   sym_06063F28 = max_car_count (dword, total car entries)
 *   sym_0607EAC0 = race_countdown_state (dword, 0x28 = active racing)
 *   sym_0607EBF8 = per_lap_time_array (4 bytes per lap, indexed by lap)
 *   sym_0607EBD0 = global_frame_counter (dword, increments per frame)
 *   0x000927BF   = 599,999 (max frame index, ~10 min at 60fps)
 *   anim_frame_transform (BSR target at 0x06005DD4) = converts frame count
 *     to displayable time components, returns result in r0
 *
 * Car state struct offsets:
 *   +0x021C = current frame counter (lap progress)
 *   +0x0240 = target frame / current lap entry in time table
 *   +0x022C = lap start timestamp
 *
 * Auto-generated by tools/generate_l3_tu.py, then manually annotated.
 */

    .section .text.FUN_06005C98


    .global world_camera_update
    .type world_camera_update, @function
world_camera_update:
    mov.l r14, @-r15                            ! save r14 (callee-saved)
    mov.l r13, @-r15                            ! save r13 (callee-saved)
    mov.l r12, @-r15                            ! save r12 (callee-saved)
    mov.l r11, @-r15                            ! save r11 (callee-saved)
    mov.l r10, @-r15                            ! save r10 (callee-saved)
    mov.l r9, @-r15                             ! save r9 (callee-saved)
    mov.l r8, @-r15                             ! save r8 (callee-saved)
    sts.l pr, @-r15                             ! save pr (return address)
    add #-0x8, r15                              ! allocate 8 bytes on stack (2 local vars)
    mov.l   _pool_dlist_cmd_writer, r8          ! r8 = &display_list_cmd_writer (sym_06028430)
    mov.l   _pool_geom_dispatch, r10            ! r10 = &geom_dispatch_final (sym_060284AE)
    mov.l   _pool_max_frame, r14                ! r14 = 0x000927BF (max frame = 599,999)
    mov.l   _pool_car_state_ptr, r4             ! r4 = &car_state_ptr (sym_0607E944)
    mov.l   _pool_max_car_count, r6             ! r6 = &max_car_count (sym_06063F28)
    mov.w   DAT_06005d3e, r0                    ! r0 = 0x021C (car struct: frame counter offset)
    mov.l @r4, r4                               ! r4 = *car_state_ptr (deref to car struct base)
    mov.l @r6, r5                               ! r5 = max_car_count value
    mov.l @(r0, r4), r3                         ! r3 = car_state[+0x021C] (current frame counter)
    add #-0x1, r5                               ! r5 = max_car_count - 1 (last valid index)
    cmp/hs r5, r3                               ! T = (frame_counter >= max_index)?
    bt      .L_clamp_to_max                     ! if frame >= max: clamp
    mov.w   DAT_06005d3e, r0                    ! r0 = 0x021C (reload offset for delay slot)
    bra     .L_after_clamp                      ! skip clamp, use actual value
    mov.l @(r0, r4), r11                        ! (delay) r11 = car_state[+0x021C] (unclamped)
.L_clamp_to_max:
    mov r5, r11                                 ! r11 = max_index (clamped frame counter)
.L_after_clamp:
    mov.l   _pool_countdown_state, r0           ! r0 = &race_countdown_state (sym_0607EAC0)
    mov.l @r0, r0                               ! r0 = race_countdown_state value
    cmp/eq #0x28, r0                            ! T = (state == 0x28)? (active racing)
    bf      .L_nonrace_path                     ! if not active racing: take single-pass path
    /* --- Path A: Active race — iterate over recent laps --- */
    mov.w   _wpool_target_frame_ofs, r0         ! r0 = 0x0240 (car struct: target frame offset)
    mov.l @(r0, r4), r3                         ! r3 = car_state[+0x0240] (current lap time entry)
    mov r11, r4                                 ! r4 = clamped frame counter (= current lap index)
    add #-0x7, r4                               ! r4 = current_lap - 7 (window start)
    cmp/pz r4                                   ! T = (window_start >= 0)?
    bt/s    .L_window_start_valid               ! if non-negative: use computed start
    mov.l r3, @r15                              ! (delay) stack[0] = target_frame (current lap entry)
    bra     .L_window_start_set                 ! window_start < 0: clamp to 0
    mov #0x0, r13                               ! (delay) r13 = 0 (start from lap 0)
.L_window_start_valid:
    mov r4, r13                                 ! r13 = current_lap - 7 (valid window start)
.L_window_start_set:
    cmp/gt r11, r13                             ! T = (loop_index > current_lap)?
    bt/s    .L_epilogue                         ! if already past end: skip loop entirely
    mov #0x0, r9                                ! (delay) r9 = 0 (display slot counter)
    /* --- Lap iteration loop --- */
.L_lap_loop:
    mov r13, r12                                ! r12 = current lap index in loop
    mov.l   _pool_lap_time_array, r3            ! r3 = &per_lap_time_array (sym_0607EBF8)
    shll2 r12                                   ! r12 = lap_index * 4 (byte offset into array)
    add r3, r12                                 ! r12 = &lap_time_array[lap_index]
    mov.l @r12, r12                             ! r12 = lap_time_array[lap_index] (raw frame count)
    cmp/gt r14, r12                             ! T = (lap_time > max_frame)?
    bf      .L_lap_time_ok                      ! if lap_time <= max: no clamp needed
    mov r14, r12                                ! r12 = max_frame (clamp to 599,999)
.L_lap_time_ok:
    .byte   0xB0, 0x6A    /* bsr 0x06005DD4 (anim_frame_transform) */
    mov r12, r4                                 ! (delay) r4 = lap time (arg to transform)
    mov r0, r7                                  ! r7 = transform result (display data)
    mov.l @r15, r2                              ! r2 = stack[0] (target_frame = current lap entry)
    cmp/eq r2, r12                              ! T = (this_lap_time == current_lap_entry)?
    bf      .L_use_normal_slot                  ! if not current lap: use normal display value
    bra     .L_slot_value_set                   ! current lap: use highlighted value
    mov #0x54, r6                               ! (delay) r6 = 0x54 (highlighted slot value)
.L_use_normal_slot:
    mov #0x48, r6                               ! r6 = 0x48 (normal slot value)
.L_slot_value_set:
    mov r9, r5                                  ! r5 = display_slot_counter
    add #0x5, r5                                ! r5 = slot + 5 (base display offset)
    shll2 r5                                    ! r5 *= 4
    shll2 r5                                    ! r5 *= 4  (total: slot * 16)
    shll2 r5                                    ! r5 *= 4  (total: slot * 64)
    mov.l r5, @(4, r15)                         ! stack[4] = slot * 64 (save for cmd_writer)
    add #0x3, r5                                ! r5 = slot*64 + 3
    shll r5                                     ! r5 = (slot*64 + 3) * 2 (display list index)
    jsr @r10                                    ! call geom_dispatch_final(r4=0x8, r5, r6, r7)
    mov #0x8, r4                                ! (delay) r4 = 0x8 (VDP command mode)
    mov r13, r7                                 ! r7 = current lap index
    mov #0x3C, r6                               ! r6 = 0x3C (lap number display slot)
    mov.l @(4, r15), r5                         ! r5 = slot * 64 (reload saved value)
    add #0x1, r7                                ! r7 = lap_index + 1 (1-based lap number)
    add #0x1, r5                                ! r5 = slot*64 + 1
    shll r5                                     ! r5 = (slot*64 + 1) * 2 (command slot index)
    jsr @r8                                     ! call display_list_cmd_writer(r4=0x8, r5, r6=0x3C, r7=lap+1)
    mov #0x8, r4                                ! (delay) r4 = 0x8 (VDP command mode)
    add #0x1, r13                               ! r13++ (advance to next lap)
    cmp/gt r11, r13                             ! T = (loop_index > current_lap)?
    bf/s    .L_lap_loop                         ! if not past end: continue loop
    add #0x1, r9                                ! (delay) r9++ (advance display slot counter)
    bra     .L_epilogue                         ! loop done: exit
    nop                                         ! delay slot (alignment)

    .global DAT_06005d3e
DAT_06005d3e:
    .2byte  0x021C                              /* car struct offset: current frame counter */
_wpool_target_frame_ofs:
    .2byte  0x0240                              /* car struct offset: target frame / lap entry */
    .2byte  0xFFFF                              /* pool alignment padding */
_pool_dlist_cmd_writer:
    .4byte  sym_06028430                        /* display_list_cmd_writer function */
_pool_geom_dispatch:
    .4byte  sym_060284AE                        /* geom_dispatch_final function */
_pool_max_frame:
    .4byte  0x000927BF                          /* max frame index (599,999 = ~10 min at 60fps) */
_pool_car_state_ptr:
    .4byte  sym_0607E944                        /* car state struct pointer */
_pool_max_car_count:
    .4byte  sym_06063F28                        /* max car/frame count variable */
_pool_countdown_state:
    .4byte  sym_0607EAC0                        /* race countdown state variable */
_pool_lap_time_array:
    .4byte  sym_0607EBF8                        /* per-lap time array (4 bytes per entry) */
    /* --- Path B: Non-race state — single-pass current lap display --- */
.L_nonrace_path:
    mov.w   DAT_06005dcc, r0                    ! r0 = 0x021C (car struct: frame counter offset)
    mov.l @r6, r3                               ! r3 = max_car_count value (r6 still loaded)
    mov.l @(r0, r4), r2                         ! r2 = car_state[+0x021C] (current frame counter)
    cmp/eq r3, r2                               ! T = (frame_counter == max_car_count)?
    bt      .L_epilogue                         ! if at max: nothing to display, exit
    mov #0x7, r5                                ! r5 = 7 (max laps to show)
    cmp/ge r5, r11                              ! T = (clamped_index >= 7)?
    bt      .L_use_max_laps                     ! if >= 7: cap display at 7 laps
    bra     .L_laps_set                         ! use actual count
    mov.l r11, @r15                             ! (delay) stack[0] = clamped frame counter
.L_use_max_laps:
    mov.l r5, @r15                              ! stack[0] = 7 (cap at 7 laps)
.L_laps_set:
    mov.l   _pool_frame_counter, r13            ! r13 = &global_frame_counter (sym_0607EBD0)
    mov.w   DAT_06005dce, r0                    ! r0 = 0x022C (car struct: lap start timestamp ofs)
    mov.l @r13, r13                             ! r13 = global_frame_counter value
    mov.l @(r0, r4), r2                         ! r2 = car_state[+0x022C] (lap start timestamp)
    mov r13, r3                                 ! r3 = frame_counter (copy for multiply)
    shll2 r13                                   ! r13 = frame_counter * 4
    add r3, r13                                 ! r13 = frame_counter * 5
    sub r2, r13                                 ! r13 = frame_counter*5 - lap_start (elapsed time)
    cmp/gt r14, r13                             ! T = (elapsed > max_frame)?
    bf      .L_elapsed_ok                       ! if elapsed <= max: no clamp needed
    mov r14, r13                                ! r13 = max_frame (clamp to 599,999)
.L_elapsed_ok:
    .byte   0xB0, 0x22    /* bsr 0x06005DD4 (anim_frame_transform) */
    mov r13, r4                                 ! (delay) r4 = elapsed time (arg to transform)
    mov r0, r7                                  ! r7 = transform result (display data)
    mov #0x48, r6                               ! r6 = 0x48 (normal display slot value)
    mov.l @r15, r5                              ! r5 = stack[0] (lap count for display)
    add #0x5, r5                                ! r5 = laps + 5 (base display offset)
    shll2 r5                                    ! r5 *= 4
    shll2 r5                                    ! r5 *= 4  (total: * 16)
    shll2 r5                                    ! r5 *= 4  (total: * 64)
    mov.l r5, @(4, r15)                         ! stack[4] = slot * 64 (save for cmd_writer)
    add #0x3, r5                                ! r5 = slot*64 + 3
    shll r5                                     ! r5 = (slot*64 + 3) * 2 (display list index)
    jsr @r10                                    ! call geom_dispatch_final(r4=0x8, r5, r6=0x48, r7)
    mov #0x8, r4                                ! (delay) r4 = 0x8 (VDP command mode)
    mov r11, r7                                 ! r7 = clamped frame counter (current lap index)
    mov #0x3C, r6                               ! r6 = 0x3C (lap number display slot)
    mov.l @(4, r15), r5                         ! r5 = slot * 64 (reload saved value)
    add #0x1, r7                                ! r7 = lap_index + 1 (1-based lap number)
    add #0x1, r5                                ! r5 = slot*64 + 1
    shll r5                                     ! r5 = (slot*64 + 1) * 2 (command slot index)
    jsr @r8                                     ! call display_list_cmd_writer(r4=0x8, r5, r6=0x3C, r7=lap+1)
    mov #0x8, r4                                ! (delay) r4 = 0x8 (VDP command mode)
    /* --- Epilogue: restore registers and return --- */
.L_epilogue:
    add #0x8, r15                               ! deallocate stack frame (8 bytes)
    lds.l @r15+, pr                             ! restore pr (return address)
    mov.l @r15+, r8                             ! restore r8
    mov.l @r15+, r9                             ! restore r9
    mov.l @r15+, r10                            ! restore r10
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return to caller
    mov.l @r15+, r14                            ! (delay) restore r14

    .global DAT_06005dcc
DAT_06005dcc:
    .2byte  0x021C                              /* car struct offset: frame counter (re-read) */

    .global DAT_06005dce
DAT_06005dce:
    .2byte  0x022C                              /* car struct offset: lap start timestamp */
_pool_frame_counter:
    .4byte  sym_0607EBD0                        /* global frame counter (32-bit) */
