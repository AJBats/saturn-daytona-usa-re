/* track_road_validate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060418BE - 0x06041AA0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Road segment multi-phase validation for AI car track following.
 * Iterates over an array of road segment entries and applies up to
 * 3 sequential validation phases per segment:
 *
 *   Phase 1 (state==1): Road width check — calls track_road_width_main
 *     with byte params from entry[+0] and entry[+1]. On success, writes
 *     checkpoint and advances to phase 2.
 *
 *   Phase 2 (state==2): Bank angle check — calls track_bank_calc with
 *     byte param from entry[+0] and entry[+2]. On success, writes
 *     checkpoint, then checks entry[+0xC] (extra-segment flag). If
 *     nonzero, advances to phase 3; otherwise resets to phase 1.
 *
 *   Phase 3 (state==3): Segment interpolation — calls track_seg_interpolate
 *     with entry[+0], entry[+8], and entry[+0xC]. On success, writes
 *     checkpoint and resets to phase 1.
 *
 * If any phase returns nonzero (error), the loop exits immediately.
 * After all segments are processed or an error occurs, the function
 * copies remaining segments forward (compaction) using memcpy_long,
 * then checks SMPC input status bit 6 (0x40) to determine whether
 * the caller needs re-invocation.
 *
 * Parameters:
 *   r4 = iteration counter pointer (incremented per validation step)
 *
 * Returns:
 *   r0 = segment_count value at exit (from state[+0x54])
 *
 * Persistent registers:
 *   r8  = constant 3 (phase 3 value)
 *   r9  = constant 0 (reset value)
 *   r10 = iteration counter pointer
 *   r11 = constant 1 (phase 1 value)
 *   r12 = ai_checkpoint_validate function pointer
 *   r13 = current segment index (loop variable)
 *   r14 = car state base indirect pointer (sym_060A5400)
 *
 * Car state struct offsets:
 *   +0x40 = checkpoint byte (written from validation result)
 *   +0x54 = total segment count
 *   +0x58 = current validation phase (1=width, 2=bank, 3=interpolate)
 *   +0x5C = base of 16-byte segment entry array
 *
 * Segment entry layout (16 bytes each):
 *   +0x00 = byte: first param (segment ID / type)
 *   +0x01 = byte: second param (width data)
 *   +0x02 = byte: bank param
 *   +0x08 = long: interpolation param B
 *   +0x0C = long: interpolation param C / extra-segment flag
 */

    .section .text.FUN_060418BE


    .global track_road_validate
    .type track_road_validate, @function
track_road_validate:
    mov.l r14, @-r15                         ! save r14 (callee-saved)
    mov.l r13, @-r15                         ! save r13 (callee-saved)
    mov.l r12, @-r15                         ! save r12 (callee-saved)
    mov.l r11, @-r15                         ! save r11 (callee-saved)
    mov.l r10, @-r15                         ! save r10 (callee-saved)
    mov.l r9, @-r15                          ! save r9 (callee-saved)
    mov.l r8, @-r15                          ! save r8 (callee-saved)
    sts.l pr, @-r15                          ! save return address
    add #-0x10, r15                          ! allocate 16 bytes of stack frame
    mov #0x3, r8                             ! r8 = 3 (constant: phase 3 / interpolation)
    mov #0x0, r9                             ! r9 = 0 (constant: reset/clear value)
    mov #0x1, r11                            ! r11 = 1 (constant: phase 1 / width check)
    .byte   0xDC, 0x22    /* mov.l .L_fn_checkpoint_validate, r12 */  ! r12 = ai_checkpoint_validate
    .byte   0xDE, 0x20    /* mov.l .L_car_state_base, r14 */          ! r14 = &car_state_base (indirect ptr)
    mov r4, r10                              ! r10 = iteration counter pointer
    bra     .L_loop_condition                ! jump to loop condition check
    mov r9, r13                              ! r13 = 0 (segment index, delay slot)
.L_loop_body:                                    ! === Main loop: process segment [r13] ===
    mov.l @r14, r0                           ! r0 = car_state (dereference base ptr)
    mov #0x58, r1                            ! r1 = 0x58 (validation phase offset)
    mov.l @(r0, r1), r0                      ! r0 = state[+0x58] = current phase
    cmp/eq #0x1, r0                          ! === Phase 1: road width check ===
    bf      .L_check_phase2                  ! not phase 1 -> check phase 2
    mov.l @r14, r5                           ! r5 = car_state
    mov r13, r3                              ! r3 = segment index
    add #0x5C, r5                            ! r5 -> segment entry array base
    shll2 r3                                 ! r3 = index * 4
    shll2 r3                                 ! r3 = index * 16 (entry size)
    add r3, r5                               ! r5 -> current segment entry
    mov.l r5, @r15                           ! stack[0] = entry pointer (save)
    mov.b @(1, r5), r0                       ! r0 = entry[+1] (width param byte)
    mov.l @r15, r4                           ! r4 = entry pointer (reload)
    .byte   0xD3, 0x19    /* mov.l .L_fn_road_width, r3 */  ! r3 = track_road_width_main
    mov r0, r5                               ! r5 = width param (entry[+1])
    jsr @r3                                  ! track_road_width_main(entry[+0], entry[+1])
    mov.b @r4, r4                            ! r4 = entry[+0] (segment ID, delay slot)
    mov r0, r4                               ! r4 = width check result
    tst r4, r4                               ! result == 0 (success)?
    bt      .L_width_ok                      ! yes -> checkpoint and advance
    bra     .L_loop_exit                     ! no -> width check failed, exit loop
    nop                                      ! (delay slot)
.L_width_ok:                                     ! --- width passed: checkpoint + advance ---
    mov r15, r4                              ! r4 = &stack[1] (checkpoint output buffer)
    jsr @r12                                 ! ai_checkpoint_validate(stack+4)
    add #0x4, r4                             ! adjust to checkpoint area (delay slot)
    mov.l @r14, r2                           ! r2 = car_state
    mov r15, r3                              ! r3 = stack pointer
    add #0x4, r3                             ! r3 -> stack[4] (checkpoint result byte)
    mov.b @r3, r1                            ! r1 = checkpoint validation byte
    mov #0x40, r0                            ! r0 = 0x40 (checkpoint byte offset)
    mov.b r1, @(r0, r2)                      ! state[+0x40] = checkpoint byte
    mov.l @r10, r3                           ! r3 = *counter
    add #0x1, r3                             ! counter++
    mov.l r3, @r10                           ! store incremented counter
    mov.l @r14, r2                           ! r2 = car_state
    mov #0x2, r3                             ! r3 = 2 (next phase: bank check)
    mov #0x58, r0                            ! r0 = 0x58 (phase offset)
    mov.l r3, @(r0, r2)                      ! state[+0x58] = 2 (advance to phase 2)
.L_check_phase2:                                 ! === Phase 2: bank angle check ===
    mov #0x58, r1                            ! r1 = 0x58 (phase offset)
    mov.l @r14, r0                           ! r0 = car_state
    mov.l @(r0, r1), r0                      ! r0 = state[+0x58] = current phase
    cmp/eq #0x2, r0                          ! phase == 2?
    bf      .L_check_phase3                  ! no -> check phase 3
    mov r13, r3                              ! r3 = segment index
    mov.l @r14, r5                           ! r5 = car_state
    shll2 r3                                 ! r3 = index * 4
    add #0x5C, r5                            ! r5 -> segment entry array base
    shll2 r3                                 ! r3 = index * 16 (entry size)
    add r3, r5                               ! r5 -> current segment entry
    mov.l r5, @r15                           ! stack[0] = entry pointer (save)
    add #0x2, r5                             ! r5 -> entry[+2] (bank param)
    mov.l @r15, r4                           ! r4 = entry pointer (reload)
    .byte   0xD3, 0x07    /* mov.l .L_fn_bank_calc, r3 */  ! r3 = track_bank_calc
    jsr @r3                                  ! track_bank_calc(entry[+0], entry[+2])
    mov.b @r4, r4                            ! r4 = entry[+0] (segment ID, delay slot)
    mov r0, r4                               ! r4 = bank calc result
    tst r4, r4                               ! result == 0 (success)?
    bt      .L_bank_ok                       ! yes -> checkpoint and check extra flag
    bra     .L_loop_exit                     ! no -> bank calc failed, exit loop
    nop                                      ! (delay slot)
    .2byte  0xFFFF                           ! alignment padding
.L_car_state_base:
    .4byte  sym_060A5400                     ! car state base pointer (indirect)
.L_fn_checkpoint_validate:
    .4byte  ai_checkpoint_validate           ! AI checkpoint validation function
.L_fn_road_width:
    .4byte  track_road_width_main            ! road width validation function
.L_fn_bank_calc:
    .4byte  track_bank_calc                  ! bank angle calculation function
.L_bank_ok:                                      ! --- bank passed: checkpoint + check extra ---
    mov r15, r4                              ! r4 = &stack[1] (checkpoint output buffer)
    jsr @r12                                 ! ai_checkpoint_validate(stack+4)
    add #0x4, r4                             ! adjust to checkpoint area (delay slot)
    mov r15, r3                              ! r3 = stack pointer
    mov #0x40, r0                            ! r0 = 0x40 (checkpoint byte offset)
    mov.l @r14, r2                           ! r2 = car_state
    add #0x4, r3                             ! r3 -> stack[4] (checkpoint result byte)
    mov.b @r3, r1                            ! r1 = checkpoint validation byte
    mov.b r1, @(r0, r2)                      ! state[+0x40] = checkpoint byte
    mov.l @r10, r3                           ! r3 = *counter
    add #0x1, r3                             ! counter++
    mov.l r3, @r10                           ! store incremented counter
    mov.l @r14, r2                           ! r2 = car_state
    mov r13, r3                              ! r3 = segment index
    add #0x5C, r2                            ! r2 -> segment entry array base
    shll2 r3                                 ! r3 = index * 4
    shll2 r3                                 ! r3 = index * 16 (entry size)
    add r2, r3                               ! r3 -> current segment entry
    mov.l @(12, r3), r0                      ! r0 = entry[+0xC] (extra-segment flag)
    tst r0, r0                               ! extra-segment flag == 0?
    bt      .L_no_extra_segment              ! yes -> reset to phase 1
    mov.l @r14, r3                           ! r3 = car_state
    mov #0x58, r0                            ! r0 = 0x58 (phase offset)
    mov.l r8, @(r0, r3)                      ! state[+0x58] = 3 (advance to phase 3)
    bra     .L_check_phase3                  ! proceed to phase 3 check
    nop                                      ! (delay slot)
.L_no_extra_segment:                             ! --- no extra data: reset to phase 1 ---
    mov.l @r14, r2                           ! r2 = car_state
    mov #0x58, r0                            ! r0 = 0x58 (phase offset)
    mov.l r11, @(r0, r2)                     ! state[+0x58] = 1 (reset to phase 1)
.L_check_phase3:                                 ! === Phase 3: segment interpolation ===
    mov #0x58, r1                            ! r1 = 0x58 (phase offset)
    mov.l @r14, r0                           ! r0 = car_state
    mov.l @(r0, r1), r0                      ! r0 = state[+0x58] = current phase
    cmp/eq #0x3, r0                          ! phase == 3?
    bf      .L_advance_segment               ! no -> move to next segment
    mov r13, r3                              ! r3 = segment index
    mov.l @r14, r6                           ! r6 = car_state
    shll2 r3                                 ! r3 = index * 4
    add #0x5C, r6                            ! r6 -> segment entry array base
    shll2 r3                                 ! r3 = index * 16 (entry size)
    add r3, r6                               ! r6 -> current segment entry
    mov.l r6, @r15                           ! stack[0] = entry pointer (save)
    mov.l @(12, r6), r6                      ! r6 = entry[+0xC] (interpolation param C)
    mov.l @r15, r5                           ! r5 = entry pointer (reload)
    mov.l @r15, r4                           ! r4 = entry pointer (reload)
    .byte   0xD3, 0x27    /* mov.l .L_fn_seg_interpolate, r3 */  ! r3 = track_seg_interpolate
    mov.l @(8, r5), r5                       ! r5 = entry[+8] (interpolation param B)
    jsr @r3                                  ! track_seg_interpolate(entry[+0], param_B, param_C)
    mov.b @r4, r4                            ! r4 = entry[+0] (segment ID, delay slot)
    mov r0, r4                               ! r4 = interpolation result
    tst r4, r4                               ! result == 0 (success)?
    bt      .L_interp_ok                     ! yes -> checkpoint and reset
    bra     .L_loop_exit                     ! no -> interpolation failed, exit loop
    nop                                      ! (delay slot)
.L_interp_ok:                                    ! --- interpolation passed: checkpoint + reset ---
    mov r15, r4                              ! r4 = &stack[1] (checkpoint output buffer)
    jsr @r12                                 ! ai_checkpoint_validate(stack+4)
    add #0x4, r4                             ! adjust to checkpoint area (delay slot)
    mov.l @r14, r2                           ! r2 = car_state
    mov r15, r3                              ! r3 = stack pointer
    add #0x4, r3                             ! r3 -> stack[4] (checkpoint result byte)
    mov.b @r3, r1                            ! r1 = checkpoint validation byte
    mov #0x40, r0                            ! r0 = 0x40 (checkpoint byte offset)
    mov.b r1, @(r0, r2)                      ! state[+0x40] = checkpoint byte
    mov.l @r10, r3                           ! r3 = *counter
    add #0x1, r3                             ! counter++
    mov.l r3, @r10                           ! store incremented counter
    mov.l @r14, r2                           ! r2 = car_state
    mov #0x58, r0                            ! r0 = 0x58 (phase offset)
    mov.l r11, @(r0, r2)                     ! state[+0x58] = 1 (reset to phase 1)
.L_advance_segment:                              ! --- move to next segment ---
    add #0x1, r13                            ! segment index++
.L_loop_condition:                               ! --- loop condition: index < count? ---
    mov #0x54, r0                            ! r0 = 0x54 (segment count offset)
    mov.l @r14, r3                           ! r3 = car_state
    mov.l @(r0, r3), r2                      ! r2 = state[+0x54] = total segment count
    cmp/ge r2, r13                           ! index >= count?
    bt      .L_loop_exit                     ! yes -> done processing all segments
    bra     .L_loop_body                     ! no -> process next segment
    nop                                      ! (delay slot)
.L_loop_exit:                                    ! === Post-loop: compaction + input check ===
    mov.l @r14, r2                           ! r2 = car_state
    mov #0x54, r0                            ! r0 = 0x54 (segment count offset)
    mov.l @(r0, r2), r3                      ! r3 = total segment count
    cmp/ge r3, r13                           ! index >= count? (all segments processed?)
    bf      .L_compact_remaining             ! no -> compact remaining entries forward
    mov.l @r14, r2                           ! r2 = car_state (all segments done)
    mov #0x54, r0                            ! r0 = 0x54 (segment count offset)
    bra     .L_input_status_check            ! -> clear count and check input status
    mov.l r9, @(r0, r2)                      ! state[+0x54] = 0 (clear count, delay slot)
.L_compact_remaining:                            ! --- copy unprocessed entries forward ---
    bra     .L_compact_condition             ! jump to compaction loop condition
    mov r9, r4                               ! r4 = 0 (destination index, delay slot)
.L_compact_copy:                                 ! --- copy entry[src] -> entry[dst] ---
    mov r4, r1                               ! r1 = destination index
    mov r13, r2                              ! r2 = source index (current segment)
    mov.l @r14, r5                           ! r5 = car_state
    .byte   0xD3, 0x11    /* mov.l .L_fn_memcpy_long, r3 */  ! r3 = memcpy_long (sym_06035168)
    shll2 r1                                 ! r1 = dst_index * 4
    shll2 r2                                 ! r2 = src_index * 4
    add #0x5C, r5                            ! r5 -> segment entry array base
    shll2 r1                                 ! r1 = dst_index * 16 (entry offset)
    shll2 r2                                 ! r2 = src_index * 16 (entry offset)
    add r5, r1                               ! r1 = &entries[dst] (destination)
    add r5, r2                               ! r2 = &entries[src] (source)
    jsr @r3                                  ! memcpy_long(16, &entries[dst], &entries[src])
    mov #0x10, r0                            ! r0 = 16 bytes per entry (delay slot)
    add #0x1, r13                            ! source index++
    add #0x1, r4                             ! destination index++
.L_compact_condition:                            ! --- compaction loop condition ---
    mov.l @r14, r2                           ! r2 = car_state
    mov #0x54, r0                            ! r0 = 0x54 (segment count offset)
    mov.l @(r0, r2), r3                      ! r3 = total segment count
    cmp/ge r3, r13                           ! source >= count?
    bf      .L_compact_copy                  ! no -> copy next entry
    mov.l @r14, r2                           ! r2 = car_state (compaction done)
    mov #0x54, r0                            ! r0 = 0x54 (segment count offset)
    mov.l r4, @(r0, r2)                      ! state[+0x54] = dst index (new count)
.L_input_status_check:                           ! === SMPC input status check (bit 6) ===
    mov #0x40, r3                            ! r3 = 0x40 (input bit 6 mask)
    mov.l r3, @r15                           ! stack[0] = mask (save for later)
    .byte   0xD3, 0x07    /* mov.l .L_fn_smpc_status, r3 */  ! r3 = smpc_status_read (sym_06035C4E)
    jsr @r3                                  ! r0 = smpc_status_read()
    nop                                      ! (delay slot)
    mov r0, r5                               ! r5 = raw status word
    mov.l @r15, r3                           ! r3 = 0x40 (reload mask)
    exts.w r5, r4                            ! r4 = status sign-extended to 32 bits
    and r3, r4                               ! r4 = status & 0x40 (bit 6 = active flag)
    tst r4, r4                               ! bit 6 clear?
    bt      .L_input_bit_clear               ! yes -> r4 = 0
    bra     .L_input_bit_set                 ! no -> r4 = 1
    mov #0x1, r4                             ! (delay slot)
    .2byte  0xFFFF                           ! alignment padding
.L_fn_seg_interpolate:
    .4byte  track_seg_interpolate            ! segment interpolation function
.L_fn_memcpy_long:
    .4byte  sym_06035168                     ! memcpy_long(r0=count, r1=dst, r2=src)
.L_fn_smpc_status:
    .4byte  sym_06035C4E                     ! SMPC/input status word reader
.L_input_bit_clear:                              ! --- input bit 6 not set ---
    mov #0x0, r4                             ! r4 = 0 (no re-invocation needed)
.L_input_bit_set:                                ! --- check if re-invocation needed ---
    tst r4, r4                               ! input flag set?
    bt      .L_read_final_count              ! no -> skip state reset
    mov.l @r14, r3                           ! r3 = car_state
    mov #0x54, r0                            ! r0 = 0x54 (segment count offset)
    mov.l @(r0, r3), r0                      ! r0 = segment count
    tst r0, r0                               ! count == 0?
    bf      .L_read_final_count              ! no -> segments remain, skip reset
    mov.l @r14, r3                           ! r3 = car_state (count==0 + input active)
    mov #0x58, r0                            ! r0 = 0x58 (phase offset)
    mov.l r9, @(r0, r3)                      ! state[+0x58] = 0 (reset phase to idle)
.L_read_final_count:                             ! === Epilogue: return segment count ===
    mov #0x54, r1                            ! r1 = 0x54 (segment count offset)
    mov.l @r14, r0                           ! r0 = car_state
    mov.l @(r0, r1), r0                      ! r0 = state[+0x54] (return value)
    add #0x10, r15                           ! deallocate 16-byte stack frame
    lds.l @r15+, pr                          ! restore return address
    mov.l @r15+, r8                          ! restore r8
    mov.l @r15+, r9                          ! restore r9
    mov.l @r15+, r10                         ! restore r10
    mov.l @r15+, r11                         ! restore r11
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    rts                                      ! return to caller
    mov.l @r15+, r14                         ! restore r14 (delay slot)
