/* hud_priority_sort -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601550C - 0x060155A4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Iterates 4 HUD elements, loads priority config from a table
 * (sym_0605B838, 8 bytes per entry), and writes priority fields
 * into each element's 68-byte slot struct (sym_06084FC8).
 * Offsets 28/32 get table values; offset 36 gets a draw priority
 * (0x60 default, overridden to 0x50 for elements 1 and 2).
 * Finally increments a counter byte at offset 2 in slot[r4].
 */

    .section .text.FUN_0601550C


    .global hud_priority_sort
    .type hud_priority_sort, @function
hud_priority_sort:
    mov.l r14, @-r15                  ! save r14
    mov.l r12, @-r15                  ! save r12
    mov.l r11, @-r15                  ! save r11
    mov.l r10, @-r15                  ! save r10
    mov.l   .L_pool_priority_table, r10 ! r10 = priority config table base
    mov #0x4, r11                     ! r11 = 4 (element count)
    mov #0x50, r12                    ! r12 = 0x50 (high priority value)
    mov #0x60, r14                    ! r14 = 0x60 (default priority value)
    mov.l   .L_pool_slot_base, r6     ! r6 = slot data array base
    mov #0x0, r5                      ! r5 = loop index (0..3)
.L_loop_top:
    extu.b r5, r7                     ! r7 = index (zero-extended)
    extu.b r5, r0                     ! r0 = index (zero-extended)
    mov r7, r3                        ! r3 = index (for struct offset calc)
    shll r0                           ! r0 = index * 2
    shll2 r7                          ! r7 = index * 4
    shll2 r3                          ! r3 = index * 4
    shll2 r0                          ! r0 = index * 8 (table entry offset)
    shll2 r3                          ! r3 = index * 16
    add r10, r0                       ! r0 = &priority_table[index] (8 bytes per entry)
    shll2 r3                          ! r3 = index * 64
    add r3, r7                        ! r7 = index * 68 (struct size)
    exts.w r7, r7                     ! sign-extend struct offset to 32 bits
    mov.l @r0, r3                     ! r3 = priority_table[index].field_0
    add r6, r7                        ! r7 = &slot[index]
    mov.l r3, @(28, r7)              ! slot[index].priority_a = field_0
    mov.l @(4, r0), r2               ! r2 = priority_table[index].field_4
    mov.l r2, @(32, r7)              ! slot[index].priority_b = field_4
    mov.l r14, @(36, r7)             ! slot[index].draw_order = 0x60 (default)
    extu.b r5, r7                     ! r7 = index (zero-extended)
    mov r7, r0                        ! r0 = index
    cmp/eq #0x1, r0                   ! T = (index == 1)?
    .word 0x0029 /* movt r0 */        ! r0 = T bit (1 if index==1, else 0)
    mov r0, r3                        ! r3 = (index == 1) flag
    mov r7, r0                        ! r0 = index
    cmp/eq #0x2, r0                   ! T = (index == 2)?
    .word 0x0129 /* movt r1 */        ! r1 = T bit (1 if index==2, else 0)
    or r1, r3                         ! r3 = (index==1 || index==2)
    tst r3, r3                        ! test if either flag set
    bt      .L_skip_override          ! if neither, keep default priority
    extu.b r5, r3                     ! r3 = index (zero-extended)
    mov r3, r2                        ! r2 = index
    shll2 r3                          ! r3 = index * 4
    shll2 r2                          ! r2 = index * 4
    shll2 r2                          ! r2 = index * 16
    shll2 r2                          ! r2 = index * 64
    add r2, r3                        ! r3 = index * 68
    exts.w r3, r3                     ! sign-extend struct offset
    add r6, r3                        ! r3 = &slot[index]
    mov.l r12, @(36, r3)             ! slot[index].draw_order = 0x50 (high priority)
.L_skip_override:
    add #0x1, r5                      ! r5++ (next element)
    extu.b r5, r3                     ! r3 = index (zero-extended)
    cmp/ge r11, r3                    ! r3 >= 4?
    bf      .L_loop_top               ! loop if more elements
    extu.b r4, r4                     ! r4 = arg element index (zero-extended)
    mov r4, r3                        ! r3 = element index
    shll2 r4                          ! r4 = index * 4
    shll2 r3                          ! r3 = index * 4
    shll2 r3                          ! r3 = index * 16
    shll2 r3                          ! r3 = index * 64
    add r3, r4                        ! r4 = index * 68
    exts.w r4, r4                     ! sign-extend struct offset
    add r6, r4                        ! r4 = &slot[arg_index]
    mov.b @(2, r4), r0               ! r0 = slot[arg_index].counter
    mov r0, r2                        ! r2 = counter value
    add #0x1, r2                      ! r2 = counter + 1
    mov r2, r0                        ! r0 = incremented counter
    mov.b r0, @(2, r4)               ! slot[arg_index].counter = counter + 1
    mov.l @r15+, r10                  ! restore r10
    mov.l @r15+, r11                  ! restore r11
    mov.l @r15+, r12                  ! restore r12
    rts                               ! return
    mov.l @r15+, r14                  ! restore r14 (delay slot)
.L_pool_priority_table:
    .4byte  sym_0605B838              ! HUD priority config table (8 bytes per element)
.L_pool_slot_base:
    .4byte  sym_06084FC8              ! slot data array base (68-byte structs)
