/* obj_position_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06004F28 - 0x0600508C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Queues a VDP2 tilemap transfer into the display command table.
 *
 * This function is the body of the obj_transform_cache entry point
 * (which pushes r8-r14 then falls through here). It manages a ring of
 * 8-byte command table entries at sym_06063750. Each entry is:
 *   [+0] source data pointer (r8)
 *   [+4] word count / VRAM tile offset
 *
 * Depending on flags (r9 bits 0-1 and bit 3), data is either:
 *   - Copied via memcpy_word_idx (CPU word copy) into the heap, or
 *   - Transferred via dma_memory_transfer (DMA) to VDP2 VRAM.
 *
 * Two sets of counters track commands for table-A (sym_06059F18)
 * and table-B (sym_06059F1C). The heap write cursor (sym_06063D90)
 * and a secondary cursor (sym_06063D94) advance by the byte count
 * of the copied data.
 *
 * Register inputs (set by obj_transform_cache preamble):
 *   r3 = data_present flag  (0 = no new data to copy)
 *   r4 = object descriptor pointer (has .w fields: tile_count@+0, row_width@+2)
 *   r5 = flags (saved in r9 by preamble: bits 0-1 = table select, bit 3 = DMA flag)
 *   r6 = transfer word count
 *   r7 = extra tile offset (for VRAM destination calc)
 *   r9 = flags (copied from r5 by preamble)
 */

    .section .text.FUN_06004F28


    .global obj_position_update
    .type obj_position_update, @function
obj_position_update:
    sts.l pr, @-r15                      ! save return address
    sts.l macl, @-r15                    ! save macl (used by mulu.w)
    add #-0xC, r15                       ! allocate 12 bytes of local stack
    mov.l   .L_cmd_table_base, r10       ! r10 = &cmd_table[0] (sym_06063750)
    mov.l   .L_counter_b_ptr, r11        ! r11 = &counter_B (sym_06059F1C)
    mov.l   .L_counter_a_ptr, r12        ! r12 = &counter_A (sym_06059F18)
    mov.l   .L_mode_flag_ptr, r14        ! r14 = &mode_flag (sym_06059F10)
    mov.l r4, @(4, r15)                  ! local[4] = obj_desc (r4)
    mov.l r7, @r15                       ! local[0] = tile_offset (r7)
    tst r3, r3                           ! test data_present flag
    bt/s    .L_no_data_copy              ! if zero, skip data copy entirely
    mov r6, r13                          ! r13 = word_count (delay slot)
    /* --- Data copy path: compute byte count from object descriptor --- */
    mov.l @(4, r15), r4                  ! r4 = obj_desc pointer
    mov.w @(2, r4), r0                   ! r0 = obj_desc.row_width (halfword at +2)
    mov.w @r4, r2                        ! r2 = obj_desc.tile_count (halfword at +0)
    mov r0, r3                           ! r3 = row_width
    mulu.w r2, r3                        ! macl = tile_count * row_width
    sts macl, r3                         ! r3 = product (total tiles)
    add #0x2, r3                         ! r3 += 2 (header words)
    shll r3                              ! r3 *= 2 (convert words to bytes)
    extu.w r3, r3                        ! zero-extend to 16-bit byte count
    mov r3, r0                           ! r0 = byte_count (for stack save)
    extu.w r3, r6                        ! r6 = byte_count (memcpy size arg)
    mov.w r0, @(8, r15)                  ! local[8] = byte_count (halfword)
    mov.l   .L_heap_cursor_ptr, r8       ! r8 = &heap_cursor (sym_06063D90)
    mov.l @(4, r15), r5                  ! r5 = obj_desc (source for memcpy)
    mov.l   .L_fn_memcpy_word, r2        ! r2 = &memcpy_word_idx
    mov.l @r8, r8                        ! r8 = heap_cursor value (dest addr)
    jsr @r2                              ! memcpy_word_idx(dest=r4, src=r5, size=r6)
    mov r8, r4                           ! r4 = heap dest address (delay slot)
    /* --- Advance heap cursors by byte_count --- */
    mov.w @(8, r15), r0                  ! r0 = byte_count from stack
    mov r0, r4                           ! r4 = byte_count
    extu.w r4, r4                        ! zero-extend byte_count
    mov.l   .L_heap_cursor_ptr, r3       ! r3 = &heap_cursor
    mov.l @r3, r3                        ! r3 = current heap_cursor value
    add r4, r3                           ! r3 = heap_cursor + byte_count
    mov.l   .L_heap_cursor_ptr, r2       ! r2 = &heap_cursor
    mov.l r3, @r2                        ! store advanced heap_cursor
    mov.l   .L_heap_cursor_b_ptr, r5     ! r5 = &heap_cursor_B (sym_06063D94)
    mov.l @r5, r1                        ! r1 = current heap_cursor_B value
    add r4, r1                           ! r1 = heap_cursor_B + byte_count
    bra     .L_check_word_count          ! continue to word_count check
    mov.l r1, @r5                        ! store advanced heap_cursor_B (delay slot)
.L_no_data_copy:
    mov.l @(4, r15), r8                  ! r8 = obj_desc (use as source pointer directly)
.L_check_word_count:
    tst r13, r13                         ! test word_count
    bt      .L_no_vram_transfer          ! if zero, skip VRAM transfer
    /* --- Determine which table (A or B) based on flags bits 0-1 --- */
    mov #0x3, r3                         ! r3 = 0x3 (mask for bits 0-1)
    and r9, r3                           ! r3 = flags & 0x3
    tst r3, r3                           ! test table select bits
    bf/s    .L_use_table_b               ! if nonzero, use table B (counter_B / sym_06059F1C)
    mov #0x8, r4                         ! r4 = 0x8 (DMA flag mask, delay slot)
    /* --- Table A path (counter_A / sym_06059F18) --- */
    mov.l @r14, r3                       ! r3 = mode_flag (entry index)
    and r4, r9                           ! r9 = flags & 0x8 (isolate DMA bit)
    mov.l @r12, r2                       ! r2 = counter_A value (tile offset)
    shll2 r3                             ! r3 *= 4
    shll r3                              ! r3 *= 2 (total: index * 8)
    add r10, r3                          ! r3 = &cmd_table[mode_flag]
    tst r9, r9                           ! test DMA flag
    bt/s    .L_table_a_memcpy            ! if zero, use CPU memcpy
    mov.l r2, @(4, r3)                   ! cmd_table[idx].tile_offset = counter_A (delay slot)
    /* --- Table A, DMA path --- */
    mov.l @r12, r5                       ! r5 = counter_A (tile offset for VRAM)
    mov.l   .L_vdp2_vram_base, r3        ! r3 = 0x25E00000 (VDP2 VRAM base)
    shll2 r5                             ! r5 *= 4
    shll2 r5                             ! r5 *= 4 (total: *= 16)
    shll r5                              ! r5 *= 2 (total: *= 32 = tile_offset * 32)
    add r3, r5                           ! r5 = VDP2_VRAM + tile_offset * 32 (DMA dest)
    mov.l   .L_fn_dma_transfer, r3       ! r3 = &dma_memory_transfer
    jsr @r3                              ! dma_memory_transfer(src=r4, dest=r5) [r4=r13=word_count]
    mov r13, r4                          ! r4 = word_count (delay slot)
    bra     .L_advance_counter_a         ! skip memcpy path
    nop                                  ! (delay slot)
.L_table_a_memcpy:
    /* --- Table A, CPU memcpy path --- */
    mov.l @r15, r6                       ! r6 = tile_offset from stack (local[0])
    mov.l @r12, r4                       ! r4 = counter_A (tile offset)
    mov.l   .L_vdp2_vram_base, r3        ! r3 = 0x25E00000 (VDP2 VRAM base)
    shll2 r6                             ! r6 *= 4
    shll2 r4                             ! r4 *= 4
    shll2 r6                             ! r6 *= 4 (total: *= 16)
    shll2 r4                             ! r4 *= 4 (total: *= 16)
    shll r6                              ! r6 *= 2 (total: tile_offset * 32)
    shll r4                              ! r4 *= 2 (total: counter_A * 32)
    add r3, r4                           ! r4 = VDP2_VRAM + counter_A * 32 (dest)
    mov.l   .L_fn_memcpy_word, r3        ! r3 = &memcpy_word_idx
    jsr @r3                              ! memcpy_word_idx(dest=r4, src=r5=r13, size=r6)
    mov r13, r5                          ! r5 = word_count (delay slot)
.L_advance_counter_a:
    /* --- Advance counter_A by tile_offset delta --- */
    mov.l @r15, r2                       ! r2 = tile_offset from stack
    mov.l @r12, r3                       ! r3 = counter_A current value
    add r2, r3                           ! r3 = counter_A + tile_offset
    mov.l r3, @r12                       ! store updated counter_A
    bra     .L_finalize_entry            ! go to common finalization
    nop                                  ! (delay slot)
/* ---- Pool constants (first half) ---- */
.L_cmd_table_base:
    .4byte  sym_06063750                 /* display command table base */
.L_counter_b_ptr:
    .4byte  sym_06059F1C                 /* counter B (init_counter) */
.L_counter_a_ptr:
    .4byte  sym_06059F18                 /* counter A (dispatch_flags) */
.L_mode_flag_ptr:
    .4byte  sym_06059F10                 /* mode flag / entry index */
.L_heap_cursor_ptr:
    .4byte  sym_06063D90                 /* heap write cursor */
.L_fn_memcpy_word:
    .4byte  memcpy_word_idx              /* CPU word-copy function */
.L_heap_cursor_b_ptr:
    .4byte  sym_06063D94                 /* secondary heap cursor */
.L_vdp2_vram_base:
    .4byte  0x25E00000                   /* VDP2 VRAM +0x00000 */
.L_fn_dma_transfer:
    .4byte  dma_memory_transfer          /* DMA transfer function */
.L_use_table_b:
    /* --- Table B path (counter_B / sym_06059F1C) --- */
    mov.l @r14, r2                       ! r2 = mode_flag (entry index)
    and r4, r9                           ! r9 = flags & 0x8 (isolate DMA bit)
    mov.l @r11, r3                       ! r3 = counter_B value (tile offset)
    shll2 r2                             ! r2 *= 4
    shll r2                              ! r2 *= 2 (total: index * 8)
    add r10, r2                          ! r2 = &cmd_table[mode_flag]
    tst r9, r9                           ! test DMA flag
    bt/s    .L_table_b_memcpy            ! if zero, use CPU memcpy
    mov.l r3, @(4, r2)                   ! cmd_table[idx].tile_offset = counter_B (delay slot)
    /* --- Table B, DMA path --- */
    mov.l @r11, r5                       ! r5 = counter_B (tile offset for VRAM)
    .byte   0xD3, 0x30    /* mov.l .L_pool_060050D8, r3 -- cross-TU: VDP2 VRAM 0x25E00000 */
    shll2 r5                             ! r5 *= 4
    shll2 r5                             ! r5 *= 4 (total: *= 16)
    shll r5                              ! r5 *= 2 (total: tile_offset * 32)
    add r3, r5                           ! r5 = VDP2_VRAM + tile_offset * 32 (DMA dest)
    .byte   0xD3, 0x2F    /* mov.l .L_pool_060050DC, r3 -- cross-TU: dma_memory_transfer */
    jsr @r3                              ! dma_memory_transfer(src=r4, dest=r5)
    mov r13, r4                          ! r4 = word_count (delay slot)
    bra     .L_advance_counter_b         ! skip memcpy path
    nop                                  ! (delay slot)
.L_table_b_memcpy:
    /* --- Table B, CPU memcpy path --- */
    mov.l @r15, r6                       ! r6 = tile_offset from stack (local[0])
    mov.l @r11, r4                       ! r4 = counter_B (tile offset)
    .byte   0xD3, 0x2A    /* mov.l .L_pool_060050D8, r3 -- cross-TU: VDP2 VRAM 0x25E00000 */
    shll2 r6                             ! r6 *= 4
    shll2 r4                             ! r4 *= 4
    shll2 r6                             ! r6 *= 4 (total: *= 16)
    shll2 r4                             ! r4 *= 4 (total: *= 16)
    shll r6                              ! r6 *= 2 (total: tile_offset * 32)
    shll r4                              ! r4 *= 2 (total: counter_B * 32)
    add r3, r4                           ! r4 = VDP2_VRAM + counter_B * 32 (dest)
    .byte   0xD3, 0x28    /* mov.l .L_pool_060050E0, r3 -- cross-TU: memcpy_word_idx */
    jsr @r3                              ! memcpy_word_idx(dest=r4, src=r5=r13, size=r6)
    mov r13, r5                          ! r5 = word_count (delay slot)
.L_advance_counter_b:
    /* --- Advance counter_B by tile_offset delta --- */
    mov.l @r15, r2                       ! r2 = tile_offset from stack
    mov.l @r11, r3                       ! r3 = counter_B current value
    add r2, r3                           ! r3 = counter_B + tile_offset
    mov.l r3, @r11                       ! store updated counter_B
    bra     .L_finalize_entry            ! go to common finalization
    nop                                  ! (delay slot)
.L_no_vram_transfer:
    /* --- No transfer: copy previous entry's tile_offset into current entry --- */
    mov.l @r14, r2                       ! r2 = mode_flag (current entry index)
    mov.l @r14, r3                       ! r3 = mode_flag (same)
    shll2 r2                             ! r2 *= 4
    add #-0x1, r3                        ! r3 = index - 1 (previous entry)
    shll r2                              ! r2 *= 2 (total: current_index * 8)
    shll2 r3                             ! r3 *= 4
    add r10, r2                          ! r2 = &cmd_table[current_index]
    shll r3                              ! r3 *= 2 (total: prev_index * 8)
    add r10, r3                          ! r3 = &cmd_table[prev_index]
    mov.l @(4, r3), r1                   ! r1 = cmd_table[prev].tile_offset
    mov.l r1, @(4, r2)                   ! cmd_table[current].tile_offset = prev value
.L_finalize_entry:
    /* --- Write source pointer and advance mode_flag --- */
    mov.l @r14, r3                       ! r3 = mode_flag (entry index)
    shll2 r3                             ! r3 *= 4
    shll r3                              ! r3 *= 2 (total: index * 8)
    add r10, r3                          ! r3 = &cmd_table[mode_flag]
    mov.l r8, @r3                        ! cmd_table[idx].source_ptr = r8
    mov.l @r14, r2                       ! r2 = mode_flag
    add #0x1, r2                         ! r2 = mode_flag + 1
    mov.l r2, @r14                       ! store incremented mode_flag
    /* --- Epilogue: deallocate locals and restore callee-saved regs --- */
    add #0xC, r15                        ! free 12 bytes of locals
    lds.l @r15+, macl                    ! restore macl
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r8                      ! restore r8
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return to caller
    mov.l @r15+, r14                     ! restore r14 (delay slot)

    .global sym_0600508A
sym_0600508A:
    mov #0x4, r3                         ! r3 = 4 (used as mask by next TU's preamble)
