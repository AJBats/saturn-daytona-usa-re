/* save_field_write -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BA2C - 0x0603BAC6
 * Auto-generated by tools/generate_l3_tu.py
 *
 * save_field_write: Initialize a save block by serializing its data
 * and populating event descriptor fields.
 *
 * Takes a block pointer (r4), a result/output pointer (r5), and an
 * init parameter (r6). First calls attract_state_change on the block's
 * state area (+0x40) to obtain a state handle. If the block pointer is
 * NULL, returns 0. Otherwise calls save_serialize to serialize the
 * block data. On failure returns 0. On success, builds a 6-field
 * command descriptor at block+0x90 via cmd_desc_init (cross-TU pool),
 * commits via attract_replay_loader, then stores the serialize result
 * at block[+4], clears status bytes at block[+0x11] and block[+0x12],
 * and stores the state handle at block[+8]. Returns block pointer.
 *
 * Args:
 *   r4 = block_ptr    -- save block to initialize
 *   r5 = result_ptr   -- output pointer (passed through to serialize)
 *   r6 = init_param   -- initialization parameter
 *
 * Returns:
 *   r0 = block pointer on success, 0 on failure
 *
 * Register usage:
 *   r14 = block_ptr alias (after .L_serialize_ok)
 *   r13 = block_ptr (preserved original arg)
 *   r12 = state handle from attract_state_change
 *   r11 = serialize result from save_serialize
 *   r10 = serialize result (duplicate, for NULL check)
 *
 * Calls:
 *   attract_state_change  (pool)       -- obtain state handle
 *   save_serialize        (BSR cross-TU 0x0603BC86) -- serialize block
 *   cmd_desc_init         (cross-TU pool at 0x0603BB00) -- build descriptor
 *   attract_replay_loader (cross-TU pool at 0x0603BB04) -- commit
 */

    .section .text.FUN_0603BA2C


    .global save_field_write
    .type save_field_write, @function
save_field_write:
    mov.l r14, @-r15                            ! push r14 (callee-save, will hold block alias)
    mov.l r13, @-r15                            ! push r13 (callee-save, will hold block_ptr)
    mov.l r12, @-r15                            ! push r12 (callee-save, will hold state handle)
    mov r4, r13                                 ! r13 = block_ptr (preserve original arg)
    mov.l r11, @-r15                            ! push r11 (callee-save, will hold serialize result)
    mov r13, r4                                 ! r4 = block_ptr (arg for attract_state_change)
    mov.l r10, @-r15                            ! push r10 (callee-save, will hold serialize result copy)
    sts.l pr, @-r15                             ! push return address
    add #-0x8, r15                              ! allocate 8 bytes on stack (2 local slots)
    mov.l r5, @r15                              ! sp[0] = result_ptr (output pointer, saved for serialize)
    mov.l r6, @(4, r15)                         ! sp[4] = init_param (saved for serialize)
    mov.l   .L_pool_attract_state_change, r3    ! r3 = &attract_state_change
    jsr @r3                                     ! call attract_state_change(block_ptr + 0x40)
    add #0x40, r4                               ! (delay) r4 = block_ptr + 0x40 (state area)
    mov r0, r12                                 ! r12 = state handle from attract_state_change
    tst r13, r13                                ! block_ptr == NULL?
    bf      .L_block_valid                      ! if nonzero, block is valid -- continue
    bra     .L_epilogue                         ! block is NULL -- return failure
    mov #0x0, r0                                ! (delay) r0 = 0 (return failure)
.L_block_valid:
    mov r13, r14                                ! r14 = block_ptr (alias for field stores later)
    mov.l @r15, r7                              ! r7 = result_ptr (from sp[0], arg for serialize)
    mov r13, r5                                 ! r5 = block_ptr (arg for serialize)
    mov.l @(4, r15), r6                         ! r6 = init_param (from sp[4], arg for serialize)
    .byte   0xB1, 0x14    /* bsr 0x0603BC86 (external) */  ! call save_serialize(block, block, init_param, result_ptr)
    mov r13, r4                                 ! (delay) r4 = block_ptr (arg for serialize)
    mov r0, r10                                 ! r10 = serialize result
    tst r10, r10                                ! serialize returned NULL?
    bf      .L_serialize_ok                     ! if nonzero, serialize succeeded -- continue
    bra     .L_epilogue                         ! serialize failed -- return failure
    mov #0x0, r0                                ! (delay) r0 = 0 (return failure)
    .4byte  sym_060A4D14                        ! pool: global state base pointer (cross-TU data)
.L_pool_attract_state_change:
    .4byte  attract_state_change                ! pool: attract_state_change function address
.L_serialize_ok:
    mov #-0x1, r6                               ! r6 = 0xFFFFFFFF (callback arg: all-bits-set flag)
    mov #0x0, r5                                ! r5 = 0 (callback arg: no extra data)
    .byte   0x94, 0x37    /* mov.w .L_wpool_0603BAE6, r4 */  ! r4 = word offset for obj_init_validate (cross-TU pool)
    .byte   0xD3, 0x1C    /* mov.l .L_pool_0603BAE8, r3 */   ! r3 = obj_init_validate (cross-TU pool: sym_0603EF34)
    jsr @r3                                     ! call obj_init_validate(block+offset, 0, -1)
    add r13, r4                                 ! (delay) r4 = block_ptr + offset (object area)
    mov r0, r11                                 ! r11 = init result (object pointer)
    mov r13, r4                                 ! r4 = block_ptr (base for descriptor build)
    .byte   0xD2, 0x1A    /* mov.l .L_pool_0603BAEC, r2 */   ! r2 = sym_0603F070 (cross-TU pool, descriptor field 5)
    mov r11, r5                                 ! r5 = init result (descriptor field 0)
    add #0x78, r4                               ! r4 = block_ptr + 0x78 (descriptor base)
    mov.l r2, @-r15                             ! push descriptor field 5 (stack arg 2 for cmd_desc_init)
    .byte   0xD3, 0x19    /* mov.l .L_pool_0603BAF0, r3 */   ! r3 = sym_0603F036 (cross-TU pool, descriptor field 4)
    mov.l r3, @-r15                             ! push descriptor field 4 (stack arg 1 for cmd_desc_init)
    .byte   0xD2, 0x19    /* mov.l .L_pool_0603BAF4, r2 */   ! r2 = sym_0603EFE6 (cross-TU pool, descriptor field 3)
    mov.l r2, @-r15                             ! push descriptor field 3 (stack arg 0 for cmd_desc_init)
    .byte   0xD7, 0x19    /* mov.l .L_pool_0603BAF8, r7 */   ! r7 = sym_0603EFD4 (cross-TU pool, descriptor field 2)
    .byte   0xD6, 0x1A    /* mov.l .L_pool_0603BAFC, r6 */   ! r6 = attract_init_setup (cross-TU pool, descriptor field 1)
    .byte   0xD3, 0x1A    /* mov.l .L_pool_0603BB00, r3 */   ! r3 = cmd_desc_init (cross-TU pool: sym_0603F8B8)
    jsr @r3                                     ! call cmd_desc_init(block+0x90, init_result, fields...)
    add #0x18, r4                               ! (delay) r4 = block_ptr + 0x78 + 0x18 = block + 0x90
    mov r0, r6                                  ! r6 = cmd_desc_init result (descriptor ptr)
    mov r10, r5                                 ! r5 = serialize result (arg for commit)
    add #0xC, r15                               ! pop 3 stack args (12 bytes)
    .byte   0xD3, 0x18    /* mov.l .L_pool_0603BB04, r3 */   ! r3 = attract_replay_loader (cross-TU pool)
    jsr @r3                                     ! call attract_replay_loader(state_handle, serialize, descriptor)
    mov r12, r4                                 ! (delay) r4 = state handle from attract_state_change
    mov.l r11, @(4, r14)                        ! block[+4] = init result (object pointer)
    mov #0x0, r4                                ! r4 = 0 (clear value)
    mov #0x11, r0                               ! r0 = 0x11 (status byte offset A)
    mov.b r4, @(r0, r14)                        ! block[+0x11] = 0 (clear status byte A)
    mov #0x12, r0                               ! r0 = 0x12 (status byte offset B)
    mov.b r4, @(r0, r14)                        ! block[+0x12] = 0 (clear status byte B)
    mov.l r12, @(8, r14)                        ! block[+8] = state handle from attract_state_change
    mov r14, r0                                 ! r0 = block_ptr (return success: the block itself)
.L_epilogue:
    add #0x8, r15                               ! free 8 bytes of stack locals
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r10                            ! restore r10
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return to caller
    mov.l @r15+, r14                            ! (delay) restore r14
