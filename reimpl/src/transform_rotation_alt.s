/* transform_rotation_alt -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602648E - 0x06026518
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Iterates 8 render slots in slot data table B (sym_0606107C) and
 * dispatches each slot's rotation transform based on its render_type
 * field (+6 offset).  Mirror of transform_rotation_apply which
 * operates on table A (sym_06060F2C, 10 slots).
 *
 * The dispatch table maps render_type values 0x008A..0x00A1 (12 entries)
 * to embedded handler paths via braf-relative offsets.  Types outside
 * that range are skipped.  Handlers execute inline byte-data segments
 * then fall through to the next-slot loop increment.
 *
 * Register layout on entry:
 *   (no explicit arguments -- operates on global tables)
 *
 * Persistent registers:
 *   r12 = slot_data_table_b base (sym_0606107C, 8-byte stride)
 *   r13 = 0x8 (slot count for table B)
 *   r14 = &rotation_state_a (sym_06060D2A, word)
 *   r7  = &rotation_state_b (sym_06060D34, word)
 *   r5  = 0.5 fixed-point constant (0x00008000)
 *   r6  = current slot index (loop counter)
 */

    .section .text.FUN_0602648E


    .global transform_rotation_alt
    .type transform_rotation_alt, @function
transform_rotation_alt:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    mov.l r13, @-r15                        ! save r13 (callee-saved)
    mov.l r12, @-r15                        ! save r12 (callee-saved)
    .byte   0xDC, 0x0C    /* mov.l .L_pool_slot_data_table_b, r12 */
    mov #0x8, r13                           ! r13 = 8 (slot count for table B)
    .byte   0xDE, 0x0C    /* mov.l .L_pool_rotation_state_a, r14 */
    .byte   0xD7, 0x0D    /* mov.l .L_pool_rotation_state_b, r7 */
    .byte   0xD5, 0x0D    /* mov.l .L_pool_fp_half, r5 */
    mov #0x0, r4                            ! r4 = 0 (initial slot index)
    extu.w r4, r6                           ! r6 = 0 (slot index, zero-extended)
.L_loop_body:
    extu.w r6, r0                           ! r0 = slot_index (zero-extend word)
    shll2 r0                                ! r0 = slot_index * 4
    shll r0                                 ! r0 = slot_index * 8 (8-byte stride)
    add r12, r0                             ! r0 -> slot_data_table_b[slot_index]
    mov.w @(6, r0), r0                      ! r0 = slot.render_type (word at offset +6)
    bra     .L_dispatch_setup               ! jump past embedded dispatch byte-data
    extu.w r0, r0                           ! r0 = render_type (zero-extend, delay slot)
    .4byte  0xA001624D                      /* embedded dispatch path bytes */
    .4byte  0x625DA027                      /* embedded dispatch path bytes */
    .4byte  0x2E21A001                      /* embedded dispatch path bytes */
    .4byte  0x624D625D                      /* embedded dispatch path bytes */
    .4byte  0xA0222721                      /* embedded dispatch path bytes */
.L_dispatch_out_of_range:
    bra     .L_next_slot                    ! render_type out of range -> skip slot
    nop                                     ! (delay slot)
.L_pool_slot_data_table_b:
    .4byte  sym_0606107C                    /* slot data table B (8-byte stride, 8 slots) */
.L_pool_rotation_state_a:
    .4byte  sym_06060D2A                    /* &rotation_state_a (word) */
.L_pool_rotation_state_b:
    .4byte  sym_06060D34                    /* &rotation_state_b (word) */
.L_pool_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_dispatch_setup:
    mov.w   .L_wpool_060264EE, r1           ! r1 = 0x008A (dispatch base: lowest valid render_type)
    sub r1, r0                              ! r0 = render_type - 0x008A (relative index)
    mov #0xC, r1                            ! r1 = 12 (number of dispatch entries)
    cmp/hs r1, r0                           ! (unsigned) render_type_rel >= 12?
    bt      .L_dispatch_out_of_range        ! yes -> out of range, skip slot
    shll r0                                 ! r0 = relative_index * 2 (word table index)
    mov r0, r1                              ! r1 = word table index (base for indexed load)
    .word 0xC702 /* UNKNOWN */              /* mova: load PC-relative address of dispatch table into r0 */
    mov.w @(r0, r1), r0                     ! r0 = dispatch_table[rel_idx] (PC-relative offset)
    braf r0                                 ! dispatch: PC + r0 (relative jump to handler)
    nop                                     ! (delay slot)
.L_wpool_060264EE:
    .2byte  0x008A                          /* dispatch base: lowest valid render_type */
    .4byte  0xFFC2FFC2                      /* dispatch offsets for render_type 0x008A and 0x008B */
    .4byte  0xFFCCFFCC                      /* dispatch offsets for render_type 0x008C and 0x008D */
    .4byte  0xFFC6FFC6                      /* dispatch offsets for render_type 0x008E and 0x008F */
    .4byte  0xFFC6FFC6                      /* dispatch offsets for render_type 0x0090 and 0x0091 */
    .4byte  0xFFD0FFD0                      /* dispatch offsets for render_type 0x0092 and 0x0093 */
    .4byte  0xFFD0FFD0                      /* dispatch offsets for render_type 0x0094 and 0x0095 */
.L_next_slot:
    add #0x1, r6                            ! slot_index++
    extu.w r6, r2                           ! r2 = slot_index (zero-extend word)
    cmp/ge r13, r2                          ! (signed) slot_index >= 8?
    bf      .L_loop_body                    ! no -> process next slot
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
