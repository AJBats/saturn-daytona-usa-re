/* sound_channel_alloc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601D478 - 0x0601D5F4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Display channel transition state machine — five handler functions indexed
 * by game_state byte (0-4) through the jump table at sym_0605DF80.  Called
 * from render_setup_dispatch during mode-select / loading screen transitions.
 *
 * State 0 (sound_cmd_queue_write):
 *   Initial setup — sets display_config_word = 2, loads a fixed-point scroll
 *   offset (0x01500000) into display_slot_ptr, enables display channel 32 via
 *   display_channel_b, sets transition_state_word = 0x2A (42 = frame count for
 *   scroll animation), calls camera_view_update to propagate entries,
 *   then increments game_state.
 *
 * State 1 (sound_channel_alloc):
 *   Scroll animation loop — while transition_state_word > 0, subtracts 16.0
 *   (16.16 fixed-point) from display_slot_ptr each frame, calls
 *   display_channel_b to update channel 32, decrements the countdown by 2,
 *   and tail-calls camera_view_update.  When countdown reaches 0,
 *   does one final subtract, increments game_state, and returns.
 *
 * State 2 (display_channel_fade_out):
 *   Fade-out — reads mode_config_flags bit 0 to decide whether to halve
 *   (round toward zero) or negate display_slot_ptr, then tail-calls
 *   display_channel_b.  When display_slot_ptr reaches 0, increments
 *   game_state and returns.
 *
 * State 3 (display_channel_dlist_select):
 *   Dispatches to dlist_slot_select (sym_0600338C) with countdown timer
 *   value and slot index 0x17 (23).
 *
 * State 4 (display_channel_timer_check):
 *   Checks if state countdown timer >= 1.  If so, returns (still waiting).
 *   Otherwise sets game_state_dispatch_value = 6 (advance to next major
 *   game phase).
 *
 * camera_view_update (display channel table copy):
 *   Copies 28 (0x1C) channel entries — 4 bytes each — from the source
 *   channel table (sym_06094FAC, indexed by a mode word) to the destination
 *   table (sym_0605AAA6), then tail-calls the display list loader
 *   (sym_06028400) with mode 0xC.
 *
 * Key data:
 *   sym_0605AAA2 = display_config_word (16-bit)
 *   sym_0605AAA6 = display_channel_dest_table (28 x 4-byte entries)
 *   sym_0607885C = display_slot_ptr (32-bit, 16.16 fixed-point scroll offset)
 *   sym_0607886E = transition_state_word (16-bit countdown, decremented by 2)
 *   sym_0607887F = game_state byte (8-bit, jump table index 0-4)
 *   sym_0607EBC8 = mode_config_flags (32-bit, bit 0 used for fade direction)
 *   sym_0607EBCC = state_countdown_timer (32-bit, checked against >= 1)
 *   sym_06094FAC = display_channel_src_table (source entries, mode-indexed)
 *   0x00100000  = 16.0 in 16.16 fixed-point (scroll step per frame)
 */

    .section .text.FUN_0601D478


    .global sound_cmd_queue_write
    .type sound_cmd_queue_write, @function
sound_cmd_queue_write:
    sts.l pr, @-r15                             ! save return address
    mov #0x2, r2                                ! r2 = 2 (display config mode: transition)
    mov #0x0, r6                                ! r6 = 0 (arg3 for display_channel_b: clear)
    mov.l   _pool_display_config_word, r3       ! r3 = &display_config_word
    mov.w r2, @r3                               ! display_config_word = 2
    mov.l   _pool_initial_scroll_offset, r3     ! r3 = 0x01500000 (initial scroll position, 16.16 fp)
    mov.l   _pool_display_slot_ptr, r2          ! r2 = &display_slot_ptr
    mov.l r3, @r2                               ! display_slot_ptr = 0x01500000
    mov r2, r5                                  ! r5 = &display_slot_ptr (for deref below)
    mov.l   _pool_fn_display_channel_b, r3      ! r3 = &display_channel_b
    mov.l @r5, r5                               ! r5 = *display_slot_ptr = 0x01500000 (arg2: offset)
    jsr @r3                                     ! display_channel_b(0x20, 0x01500000, 0)
    mov #0x20, r4                               ! (delay) r4 = 0x20 (arg1: channel 32)
    mov #0x2A, r2                               ! r2 = 0x2A (42 frames for scroll animation)
    mov.l   _pool_transition_state_word, r3     ! r3 = &transition_state_word
    mov.w r2, @r3                               ! transition_state_word = 42
    bsr     camera_view_update                  ! copy source channel table to dest, flush display
    mov r2, r4                                  ! (delay) r4 = 0x2A (mode word passed to table copy)
    mov.l   _pool_game_state_byte, r4           ! r4 = &game_state byte
    lds.l @r15+, pr                             ! restore return address
    mov.b @r4, r2                               ! r2 = game_state (current value)
    add #0x1, r2                                ! r2 = game_state + 1 (advance to next state)
    rts                                         ! return
    mov.b r2, @r4                               ! (delay) game_state++ (write back)

    .global sound_channel_alloc
    .type sound_channel_alloc, @function
sound_channel_alloc:
    mov.l r14, @-r15                            ! save r14 (callee-saved)
    mov.l r13, @-r15                            ! save r13 (callee-saved)
    sts.l pr, @-r15                             ! save return address
    mov.l   _pool_fp_sixteen, r4                ! r4 = 0x00100000 (16.0 in 16.16 fixed-point)
    mov.l   _pool_transition_state_word, r13    ! r13 = &transition_state_word (kept across calls)
    mov.l   _pool_display_slot_ptr, r14         ! r14 = &display_slot_ptr (kept across calls)
    mov.w @r13, r0                              ! r0 = transition_state_word (16-bit countdown)
    extu.w r0, r0                               ! zero-extend to 32-bit
    tst r0, r0                                  ! is countdown == 0?
    bt      .L_countdown_done                   ! yes: animation finished, skip to final step
    mov #0x0, r6                                ! r6 = 0 (arg3 for display_channel_b)
    mov.l @r14, r3                              ! r3 = display_slot_ptr (current scroll offset)
    sub r4, r3                                  ! r3 -= 16.0 (scroll toward zero)
    mov.l r3, @r14                              ! display_slot_ptr = updated scroll offset
    mov r3, r5                                  ! r5 = new scroll offset (arg2)
    mov.l   _pool_fn_display_channel_b, r3      ! r3 = &display_channel_b
    jsr @r3                                     ! display_channel_b(0x20, new_offset, 0)
    mov #0x20, r4                               ! (delay) r4 = 0x20 (arg1: channel 32)
    mov.w @r13, r4                              ! r4 = transition_state_word (current countdown)
    add #-0x2, r4                               ! r4 -= 2 (decrement countdown by 2 per frame)
    mov.w r4, @r13                              ! transition_state_word = updated countdown
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r13                            ! restore r13
    bra     camera_view_update                  ! tail-call: copy channel table + flush display
    mov.l @r15+, r14                            ! (delay) restore r14
.L_countdown_done:
    mov.l   _pool_game_state_byte, r5           ! r5 = &game_state byte
    mov.b @r5, r2                               ! r2 = game_state (current value)
    add #0x1, r2                                ! r2 = game_state + 1 (advance to next state)
    mov.b r2, @r5                               ! game_state++ (write back)
    mov.l @r14, r3                              ! r3 = display_slot_ptr (current scroll offset)
    sub r4, r3                                  ! r3 -= 16.0 (one final scroll step)
    mov.l r3, @r14                              ! display_slot_ptr = final scroll offset
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return (no table copy on final frame)
    mov.l @r15+, r14                            ! (delay) restore r14
_pool_display_config_word:
    .4byte  sym_0605AAA2                        /* &display_config_word (16-bit) */
_pool_initial_scroll_offset:
    .4byte  0x01500000                          /* initial scroll offset (16.16 fp: 336.0) */
_pool_display_slot_ptr:
    .4byte  sym_0607885C                        /* &display_slot_ptr (32-bit, 16.16 fp scroll) */
_pool_fn_display_channel_b:
    .4byte  display_channel_b                   /* display channel setup function */
_pool_transition_state_word:
    .4byte  sym_0607886E                        /* &transition_state_word (16-bit countdown) */
_pool_game_state_byte:
    .4byte  sym_0607887F                        /* &game_state byte (8-bit, 0-4 index) */
_pool_fp_sixteen:
    .4byte  0x00100000                  /* 16.0 (16.16 fixed-point) */

    .global loc_0601D50C
loc_0601D50C:
    mov.l   _pool2_display_slot_ptr, r0         ! r0 = &display_slot_ptr
    mov.l @r0, r0                               ! r0 = display_slot_ptr value (scroll offset)
    tst r0, r0                                  ! is scroll offset == 0?
    bt      .L_fade_done                        ! yes: fade complete, advance state
    mov.l   _pool2_mode_config_flags, r0        ! r0 = &mode_config_flags
    mov.l @r0, r0                               ! r0 = mode_config_flags (32-bit)
    tst #0x1, r0                                ! test bit 0 (fade direction flag)
    bt/s    .L_negate_offset                    ! bit 0 clear: negate offset (hard flip)
    mov #0x0, r6                                ! (delay) r6 = 0 (arg3 for display_channel_b)
    mov.l   _pool2_display_slot_ptr, r5         ! r5 = &display_slot_ptr
    mov #0x0, r3                                ! r3 = 0 (for arithmetic rounding below)
    mov.l @r5, r5                               ! r5 = display_slot_ptr value
    cmp/gt r5, r3                               ! is 0 > offset? (i.e. is offset negative?)
    addc r3, r5                                 ! r5 += carry (round toward zero if negative)
    shar r5                                     ! r5 >>= 1 (arithmetic shift: halve, preserving sign)
    mov.l   _pool2_display_slot_ptr, r3         ! r3 = &display_slot_ptr
    bra     .L_commit_fade                      ! go commit the halved value
    mov.l r5, @r3                               ! (delay) display_slot_ptr = halved offset
.L_negate_offset:
    mov.l   _pool2_display_slot_ptr, r5         ! r5 = &display_slot_ptr
    mov.l @r5, r5                               ! r5 = display_slot_ptr value
    neg r5, r5                                  ! r5 = -offset (flip sign for reverse scroll)
.L_commit_fade:
    mov.l   _pool2_fn_display_channel_b, r3     ! r3 = &display_channel_b
    jmp @r3                                     ! tail-call display_channel_b(0x20, offset, 0)
    mov #0x20, r4                               ! (delay) r4 = 0x20 (arg1: channel 32)
.L_fade_done:
    mov.l   _pool2_game_state_byte, r4          ! r4 = &game_state byte
    mov.b @r4, r2                               ! r2 = game_state (current value)
    add #0x1, r2                                ! r2 = game_state + 1 (advance to next state)
    rts                                         ! return
    mov.b r2, @r4                               ! (delay) game_state++ (write back)

    .global loc_0601D546
loc_0601D546:
    mov #0x17, r5                               ! r5 = 0x17 (23: display list slot index)
    mov.l   _pool3_countdown_timer, r4          ! r4 = &state_countdown_timer
    mov.l   _pool3_fn_dlist_slot_select, r3     ! r3 = &dlist_slot_select (sym_0600338C)
    jmp @r3                                     ! tail-call dlist_slot_select(*timer, 23)
    mov.l @r4, r4                               ! (delay) r4 = *state_countdown_timer (arg1)
_pool2_display_slot_ptr:
    .4byte  sym_0607885C                        /* &display_slot_ptr (32-bit scroll offset) */
_pool2_mode_config_flags:
    .4byte  sym_0607EBC8                        /* &mode_config_flags (bit 0 = fade dir) */
_pool2_fn_display_channel_b:
    .4byte  display_channel_b                   /* display channel setup function */
_pool2_game_state_byte:
    .4byte  sym_0607887F                        /* &game_state byte (8-bit) */
_pool3_countdown_timer:
    .4byte  sym_0607EBCC                        /* &state_countdown_timer (32-bit) */
_pool3_fn_dlist_slot_select:
    .4byte  sym_0600338C                        /* dlist_slot_select function */

    .global loc_0601D568
loc_0601D568:
    mov.l   _pool4_countdown_timer, r3          ! r3 = &state_countdown_timer
    mov #0x1, r2                                ! r2 = 1 (comparison threshold)
    mov.l @r3, r3                               ! r3 = state_countdown_timer value
    cmp/ge r2, r3                               ! is timer >= 1? (still counting down?)
    bt      .L_timer_still_active               ! yes: nothing to do, return
    mov #0x6, r2                                ! r2 = 6 (next game phase: advance past loading)
    mov.l   _pool4_game_state_dispatch, r3      ! r3 = &game_state_dispatch_value (sym_0605AD10)
    mov.l r2, @r3                               ! game_state_dispatch_value = 6 (trigger transition)
.L_timer_still_active:
    rts                                         ! return
    nop                                         ! (delay slot: no-op)

    .global camera_view_update
    .type camera_view_update, @function
camera_view_update:                                     /* display channel table copy */
    mov.l r14, @-r15                            ! save r14 (callee-saved)
    mov #0x1C, r14                              ! r14 = 28 (number of channel entries to copy)
    mov.l r13, @-r15                            ! save r13 (callee-saved)
    mov #0x2C, r13                              ! r13 = 44 (stride: bytes per source row = 11 entries * 4)
    mov.l r12, @-r15                            ! save r12 (callee-saved)
    sts.l macl, @-r15                           ! save MACL (used by mul.l below)
    add #-0x4, r15                              ! allocate 4 bytes on stack for local
    mov.w r4, @r15                              ! stack[0] = mode_word (r4 arg, 16-bit)
    mov.l   _pool5_src_table_base, r12          ! r12 = &display_channel_src_table (sym_06094FAC)
    mov #0x0, r4                                ! r4 = 0 (loop counter i)
    mov.w @r15, r1                              ! r1 = mode_word (reload from stack)
    mov.l   _pool5_dest_table_base, r7          ! r7 = &display_channel_dest_table (sym_0605AAA6)
    extu.w r1, r1                               ! zero-extend mode_word to 32-bit
    shll r1                                     ! r1 *= 2 (mode_word as 2-byte column offset)
.L_copy_loop:
    extu.w r4, r5                               ! r5 = i (zero-extended, used for dest index)
    extu.w r4, r6                               ! r6 = i (zero-extended, used for src row index)
    shll r5                                     ! r5 *= 2 (dest entry offset step 1)
    mul.l r13, r6                               ! MACL = i * 44 (source row byte offset)
    add #0x1, r4                                ! i++ (increment loop counter)
    shll r5                                     ! r5 *= 2 (dest entry = i * 4 bytes)
    sts macl, r6                                ! r6 = i * 44 (source row offset)
    add r7, r5                                  ! r5 = &dest_table[i] (dest entry address)
    shll r6                                     ! r6 *= 2 (source row offset * 2 = i * 88)
    add r1, r6                                  ! r6 += mode_column_offset (select column in src)
    add r12, r6                                 ! r6 = &src_table[i * 88 + column] (source entry addr)
    mov.w @r6, r3                               ! r3 = src_entry.lo (first 16 bits)
    mov.w r3, @r5                               ! dest_table[i].lo = src_entry.lo
    extu.w r4, r3                               ! r3 = i+1 (for loop bound check)
    mov.w @(2, r6), r0                          ! r0 = src_entry.hi (second 16 bits, at offset +2)
    cmp/ge r14, r3                              ! is (i+1) >= 28? (loop bound)
    bf/s    .L_copy_loop                        ! no: continue loop
    mov.w r0, @(2, r5)                          ! (delay) dest_table[i].hi = src_entry.hi
    mov #0x0, r7                                ! r7 = 0 (arg4 for display_list_loader: texture = 0)
    mov.w @r15, r0                              ! r0 = mode_word (reload from stack)
    extu.w r0, r0                               ! zero-extend mode_word to 32-bit
    and #0x3F, r0                               ! r0 = mode_word & 0x3F (mask to 6-bit index)
    mov r0, r6                                  ! r6 = masked mode index (arg3: display list index)
    shll r6                                     ! r6 *= 2 (index to 16-bit table offset)
    mov.l   _pool5_display_config_word, r5      ! r5 = &display_config_word (arg2: config base)
    mov #0xC, r4                                ! r4 = 0xC (arg1: mode = 12, tilemap load)
    add #0x4, r15                               ! free stack local
    lds.l @r15+, macl                           ! restore MACL
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    mov.l   _pool5_fn_display_list_loader, r3   ! r3 = &display_list_loader (sym_06028400)
    jmp @r3                                     ! tail-call display_list_loader(0xC, config, idx, 0)
    mov.l @r15+, r14                            ! (delay) restore r14
    .2byte  0xFFFF                              /* alignment padding */
_pool4_countdown_timer:
    .4byte  sym_0607EBCC                        /* &state_countdown_timer (32-bit) */
_pool4_game_state_dispatch:
    .4byte  sym_0605AD10                        /* &game_state_dispatch_value (32-bit) */
_pool5_src_table_base:
    .4byte  sym_06094FAC                        /* &display_channel_src_table (source entries) */
_pool5_dest_table_base:
    .4byte  sym_0605AAA6                        /* &display_channel_dest_table (28 x 4-byte dest) */
_pool5_display_config_word:
    .4byte  sym_0605AAA2                        /* &display_config_word (16-bit) */
_pool5_fn_display_list_loader:
    .4byte  sym_06028400                        /* display_list_loader function */
