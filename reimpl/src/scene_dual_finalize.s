/* scene_dual_finalize -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06026110 - 0x060262C0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Finalizes dual-scene rendering by merging two render passes (A and B).
 *
 * Called after scene_finalize_a has populated scene output table A with
 * per-slot render results. This function:
 *
 *   1. Checks a "dual finalize active" flag — if already set, skips to
 *      the second-pass merge (output table B -> data table A via +4 ptr).
 *   2. Otherwise, sets the flag and initializes 14 slot element entries:
 *      clears the priority word at each element's pointer, and clears the
 *      count word via the element's +4 pointer.
 *   3. Scans data table A entries 0..13 looking for the first non-zero
 *      priority word. If found, calls scene_finalize_a to rebuild the
 *      scene output from data table A, then falls through to merge pass 1.
 *      If all entries are zero, skips directly to merge pass 2.
 *   4. Merge pass 1 (output table A -> data table A): for each of the 14
 *      data table A entries (outer loop), iterates 10 scene output A slots.
 *      If the output slot's render type (+6) matches the element's type (+8),
 *      copies the output slot's priority value (+4) into the data entry's
 *      write pointer.
 *   5. Scans data table A entries 0..13 via +4 pointers for the first
 *      non-zero priority word. If found, tail-calls scene_finalize_b to
 *      rebuild scene output B. If all zero, skips to merge pass 2.
 *   6. Merge pass 2 (output table B -> data table A via +4 ptr): same
 *      structure as pass 1, but reads from output table B and writes
 *      through data table A's +4 pointers. Iterates 8 output slots
 *      (not 10).
 *
 * Persistent registers:
 *   r8  = 0x8 (output table B slot count)
 *   r9  = scene_output_table_a base (sym_06060F2C, 8-byte stride)
 *   r10 = scene_output_table_b base (sym_0606107C, 8-byte stride)
 *   r11 = slot_element_table base (sym_060610BC, 12-byte stride)
 *   r12 = scene_data_table_a base (sym_06060D7C, 8-byte stride)
 *   r13 = 0xE (14 = number of data table entries)
 *   r14 = 0 (zero constant / outer loop counter)
 */

    .section .text.FUN_06026110


    .global scene_dual_finalize
    .type scene_dual_finalize, @function
scene_dual_finalize:
    mov.l r14, @-r15                    ! save r14
    mov #0x0, r14                       ! r14 = 0 (zero constant)
    mov.l r13, @-r15                    ! save r13
    extu.b r14, r3                      ! r3 = 0 (for clearing flag byte)
    extu.b r14, r1                      ! r1 = 0 (for clearing flag byte)
    mov.l r12, @-r15                    ! save r12
    mov.l r11, @-r15                    ! save r11
    mov.l r10, @-r15                    ! save r10
    mov.l r9, @-r15                     ! save r9
    mov.l r8, @-r15                     ! save r8
    sts.l pr, @-r15                     ! save return address
    mov #0x8, r8                        ! r8 = 8 (output table B slot count)
    mov.l   .L_scene_output_table_a, r9 ! r9 = scene output table A base
    mov.l   .L_scene_output_table_b, r10 ! r10 = scene output table B base
    mov.l   .L_slot_element_table, r11  ! r11 = slot element table base (12-byte stride)
    mov.l   .L_scene_data_table_a, r12  ! r12 = scene data table A base (8-byte stride)
    mov.l   .L_render_phase_byte, r2    ! r2 -> render_phase byte (sym_06061198)
    mov.b r3, @r2                       ! render_phase = 0 (clear)
    mov.l   .L_variant_active_byte, r2  ! r2 -> variant_active flag (sym_06061199)
    mov.b r1, @r2                       ! variant_active = 0 (clear)
    mov.l   .L_dual_finalize_flag, r4   ! r4 -> dual finalize active flag (sym_06060D78)
    mov.b @r4, r0                       ! r0 = dual finalize flag
    extu.b r0, r0                       ! zero-extend byte
    tst r0, r0                          ! flag == 0? (first call)
    bt/s    .L_first_pass_init          ! yes -> initialize slot elements
    mov #0xE, r13                       ! r13 = 14 (entry count) [delay slot]
    bra     .L_epilogue                 ! already active -> skip to epilogue (return)
    nop
.L_first_pass_init:
    mov #0x1, r3                        ! r3 = 1
    mov.b r3, @r4                       ! dual_finalize_flag = 1 (mark as active)
    extu.w r14, r4                      ! r4 = 0 (slot init loop counter)
.L_slot_init_loop:
    extu.b r4, r5                       ! r5 = slot index (byte)
    mov r5, r3                          ! r3 = slot index copy
    add #0x1, r4                        ! loop counter++
    shll2 r5                            ! r5 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r3                             ! r3 = index * 8
    add r3, r5                          ! r5 = index * 4 + index * 8 = index * 12
    extu.b r5, r5                       ! mask to byte (wraps at 256, ok for 14 entries)
    extu.w r14, r3                      ! r3 = 0
    add r11, r5                         ! r5 -> slot_element_table[index] (12-byte entry)
    mov.l @r5, r2                       ! r2 = element[index].ptr (+0) — priority word dest
    mov.w r14, @r2                      ! *element[index].ptr = 0 (clear priority)
    mov.l @(4, r5), r2                  ! r2 = element[index].count_ptr (+4)
    mov.w r3, @r2                       ! *element[index].count_ptr = 0 (clear count)
    extu.w r4, r2                       ! r2 = loop counter
    cmp/ge r13, r2                      ! counter >= 14?
    bf      .L_slot_init_loop           ! no -> continue init loop
    extu.w r14, r4                      ! r4 = 0 (scan loop counter)
.L_scan_data_a_priority:
    extu.w r4, r2                       ! r2 = scan index
    shll2 r2                            ! r2 = index * 4
    shll r2                             ! r2 = index * 8
    add r12, r2                         ! r2 -> data_table_a[index] (8-byte entry)
    mov.l @r2, r3                       ! r3 = data_table_a[index].ptr (+0)
    mov.w @r3, r2                       ! r2 = *data_entry.ptr (priority word)
    extu.w r2, r2                       ! zero-extend word
    tst r2, r2                          ! priority == 0?
    bt      .L_scan_data_a_next         ! yes -> check next entry
    bra     .L_scan_data_a_found        ! no -> found non-zero, proceed to finalize_a
    nop
.L_scan_data_a_next:
    add #0x1, r4                        ! scan index++
    extu.w r4, r2                       ! r2 = scan index
    cmp/ge r13, r2                      ! index >= 14?
    bf      .L_scan_data_a_priority     ! no -> keep scanning
.L_scan_data_a_found:
    extu.w r4, r4                       ! r4 = first non-zero index (or 14 if all zero)
    cmp/ge r13, r4                      ! all entries zero? (index >= 14)
    bt      .L_skip_to_pass2            ! yes -> skip finalize_a, go to pass 2 scan
    mov.l   .L_fn_scene_finalize_a, r3  ! r3 = scene_finalize_a
    jsr @r3                             ! call scene_finalize_a (rebuild output table A)
    nop
    bra     .L_merge_pass1_start        ! proceed to merge pass 1
    nop
.L_skip_to_pass2:
    bra     .L_pass2_outer_loop_check   ! skip directly to pass 2 (all A entries zero)
    extu.w r14, r5                      ! r5 = 0 (outer loop counter) [delay slot]
.L_scene_output_table_a:
    .4byte  sym_06060F2C                /* scene output table A (8-byte stride) */
.L_scene_output_table_b:
    .4byte  sym_0606107C                /* scene output table B (8-byte stride) */
.L_slot_element_table:
    .4byte  sym_060610BC                /* slot element table (12-byte stride) */
.L_scene_data_table_a:
    .4byte  sym_06060D7C                /* scene data table A (8-byte stride) */
.L_render_phase_byte:
    .4byte  sym_06061198                /* render phase state byte */
.L_variant_active_byte:
    .4byte  sym_06061199                /* variant active flag byte */
.L_dual_finalize_flag:
    .4byte  sym_06060D78                /* dual finalize active flag byte */
.L_fn_scene_finalize_a:
    .4byte  scene_finalize_a            /* rebuilds scene output from data table A */
.L_pass1_outer_body:
    extu.w r14, r4                      ! r4 = 0 (inner loop counter)
    extu.b r5, r7                       ! r7 = data entry index (byte)
    extu.w r5, r6                       ! r6 = data entry index (word)
    mov r7, r3                          ! r3 = data entry index
    shll2 r6                            ! r6 = index * 4
    shll2 r7                            ! r7 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r3                             ! r3 = index * 8
    add r3, r7                          ! r7 = index * 4 + index * 8 = index * 12
    extu.b r7, r7                       ! mask to byte
    add r11, r7                         ! r7 -> slot_element_table[index] (12-byte entry)
    shll r6                             ! r6 = index * 8
    add r12, r6                         ! r6 -> data_table_a[index] (8-byte entry)
.L_pass1_inner_loop:
    extu.w r4, r3                       ! r3 = inner index (output slot)
    shll2 r3                            ! r3 = slot * 4
    shll r3                             ! r3 = slot * 8
    add r9, r3                          ! r3 -> output_table_a[slot] (8-byte entry)
    mov.w @(6, r3), r0                  ! r0 = output_a[slot].render_type (+6)
    mov r0, r2                          ! r2 = render_type
    extu.w r2, r2                       ! zero-extend
    mov.w @(8, r7), r0                  ! r0 = element[data_idx].type (+8)
    mov r0, r3                          ! r3 = element type
    extu.w r3, r3                       ! zero-extend
    cmp/eq r3, r2                       ! output render_type == element type?
    bf      .L_pass1_no_match           ! no match -> skip this slot
    mov.l @r6, r2                       ! r2 = data_table_a[index].write_ptr (+0)
    extu.w r4, r3                       ! r3 = inner index
    shll2 r3                            ! r3 = slot * 4
    shll r3                             ! r3 = slot * 8
    add r9, r3                          ! r3 -> output_table_a[slot]
    mov.w @(4, r3), r0                  ! r0 = output_a[slot].priority (+4)
    mov r0, r1                          ! r1 = priority value
    mov.w r1, @r2                       ! *data_entry.write_ptr = priority (merge A->data)
.L_pass1_no_match:
    add #0x1, r4                        ! inner slot index++
    mov #0xA, r2                        ! r2 = 10 (output table A has 10 slots)
    extu.w r4, r3                       ! r3 = inner index
    cmp/ge r2, r3                       ! slot >= 10?
    bf      .L_pass1_inner_loop         ! no -> next output slot
    add #0x1, r5                        ! outer data entry index++
.L_pass2_outer_loop_check:
    extu.w r5, r2                       ! r2 = data entry index
    cmp/ge r13, r2                      ! index >= 14?
    bf      .L_pass1_outer_body         ! no -> next data entry
.L_merge_pass1_start:
    extu.w r14, r4                      ! r4 = 0 (scan loop counter)
.L_scan_data_a_count:
    extu.w r4, r2                       ! r2 = scan index
    shll2 r2                            ! r2 = index * 4
    shll r2                             ! r2 = index * 8
    add r12, r2                         ! r2 -> data_table_a[index]
    mov.l @(4, r2), r3                  ! r3 = data_table_a[index].count_ptr (+4)
    mov.w @r3, r2                       ! r2 = *count_ptr (count word)
    extu.w r2, r2                       ! zero-extend
    tst r2, r2                          ! count == 0?
    bt      .L_scan_data_a_count_next   ! yes -> check next
    bra     .L_scan_data_a_count_found  ! no -> found non-zero, proceed to finalize_b
    nop
.L_scan_data_a_count_next:
    add #0x1, r4                        ! scan index++
    extu.w r4, r2                       ! r2 = scan index
    cmp/ge r13, r2                      ! index >= 14?
    bf      .L_scan_data_a_count        ! no -> keep scanning
.L_scan_data_a_count_found:
    extu.w r4, r4                       ! r4 = first non-zero index (or 14 if all zero)
    cmp/ge r13, r4                      ! all count entries zero? (index >= 14)
    bt      .L_all_counts_zero          ! yes -> skip finalize_b, go to epilogue
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    mov.l   .L_fn_scene_finalize_b, r3  ! r3 = scene_finalize_b
    jmp @r3                             ! tail-call scene_finalize_b (rebuild output B, then merge pass 2)
    mov.l @r15+, r14                    ! restore r14 [delay slot]
.L_all_counts_zero:
    bra     .L_pass2_outer_check        ! all B counts zero -> skip to pass 2 loop (which exits immediately)
    extu.w r14, r5                      ! r5 = 0 (outer loop counter) [delay slot]
.L_pass2_outer_body:
    extu.w r14, r4                      ! r4 = 0 (inner loop counter)
    extu.b r5, r7                       ! r7 = data entry index (byte)
    extu.w r5, r6                       ! r6 = data entry index (word)
    mov r7, r3                          ! r3 = data entry index
    shll2 r6                            ! r6 = index * 4
    shll2 r7                            ! r7 = index * 4
    shll2 r3                            ! r3 = index * 4
    shll r3                             ! r3 = index * 8
    add r3, r7                          ! r7 = index * 4 + index * 8 = index * 12
    extu.b r7, r7                       ! mask to byte
    add r11, r7                         ! r7 -> slot_element_table[index] (12-byte entry)
    shll r6                             ! r6 = index * 8
    add r12, r6                         ! r6 -> data_table_a[index] (8-byte entry)
    add #0x4, r6                        ! r6 -> data_table_a[index].count_ptr (+4)
.L_pass2_inner_loop:
    extu.w r4, r3                       ! r3 = inner index (output slot)
    shll2 r3                            ! r3 = slot * 4
    shll r3                             ! r3 = slot * 8
    add r10, r3                         ! r3 -> output_table_b[slot] (8-byte entry)
    mov.w @(6, r3), r0                  ! r0 = output_b[slot].render_type (+6)
    mov r0, r2                          ! r2 = render_type
    extu.w r2, r2                       ! zero-extend
    mov.w @(8, r7), r0                  ! r0 = element[data_idx].type (+8)
    mov r0, r3                          ! r3 = element type
    extu.w r3, r3                       ! zero-extend
    cmp/eq r3, r2                       ! output render_type == element type?
    bf      .L_pass2_no_match           ! no match -> skip this slot
    mov.l @r6, r2                       ! r2 = *data_table_a[index].count_ptr (write dest)
    extu.w r4, r3                       ! r3 = inner index
    shll2 r3                            ! r3 = slot * 4
    shll r3                             ! r3 = slot * 8
    add r10, r3                         ! r3 -> output_table_b[slot]
    mov.w @(4, r3), r0                  ! r0 = output_b[slot].priority (+4)
    mov r0, r1                          ! r1 = priority value
    mov.w r1, @r2                       ! *count_ptr = priority (merge B->data)
.L_pass2_no_match:
    add #0x1, r4                        ! inner slot index++
    extu.w r4, r3                       ! r3 = inner index
    cmp/ge r8, r3                       ! slot >= 8? (output table B has 8 slots)
    bf      .L_pass2_inner_loop         ! no -> next output slot
    add #0x1, r5                        ! outer data entry index++
.L_pass2_outer_check:
    extu.w r5, r3                       ! r3 = data entry index
    cmp/ge r13, r3                      ! index >= 14?
    bf      .L_pass2_outer_body         ! no -> next data entry
.L_epilogue:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 [delay slot]
.L_fn_scene_finalize_b:
    .4byte  scene_finalize_b            /* rebuilds scene output from data table B */
