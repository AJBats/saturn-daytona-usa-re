/* track_shadow_validate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06042088 - 0x06042134
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Shadow validation state machine — advances the shadow projection lifecycle
 * through two phases driven by the AI state structure at sym_060A5400.
 *
 * Phase 1 (check_type == 1):
 *   Call track_shadow_project(state[+0x364], state[+0x368]).
 *   If it returns non-zero, return 1 immediately (projection not ready).
 *   Otherwise call ai_checkpoint_validate(r15+4) to finalise the checkpoint,
 *   store the result byte at state[+0x40], increment state[state[+0x368]],
 *   and advance check_type to 2.
 *
 * Phase 2 (check_type == 2):
 *   Call sym_06035C4E (read HIRQ status word).
 *   AND result with mask 0x0200 (CSCT bit).
 *   If the bit is set (non-zero), reset check_type to 0 (idle).
 *
 * Returns r0 = check_type (0/1/2) after all state transitions complete.
 *
 * Key symbols:
 *   sym_060A5400         -- indirect pointer to AI/game state base structure
 *   .L_wpool_0604211E    -- word constant 0x0360 = offset of check_type field
 *   DAT_06042120         -- word constant 0x0364 = offset of input param field
 *   DAT_06042122         -- word constant 0x0200 = CSCT status bitmask
 *   track_shadow_project -- project shadow geometry (FUN_06036A1C)
 *   ai_checkpoint_validate -- validate and commit checkpoint result
 *   sym_06035C4E         -- read CD/hardware HIRQ status word
 */

    .section .text.FUN_06042088


    .global track_shadow_validate
    .type track_shadow_validate, @function
track_shadow_validate:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    add #-0x10, r15                     ! allocate 16 bytes of stack frame
    mov.l   .L_pool_ai_state_base, r14  ! r14 = &sym_060A5400 (indirect ptr to AI state)
    mov.l r4, @r15                      ! spill r4 (first arg) to stack[0]
    mov.l @r14, r0                      ! r0 = AI state base pointer
    mov.w   .L_wpool_0604211E, r1       ! r1 = 0x0360 (offset of check_type field)
    mov.l @(r0, r1), r0                 ! r0 = state[+0x360] (check_type)
    cmp/eq #0x1, r0                     ! check_type == 1 (phase 1 active)?
    bf      .L_phase2_check             ! no → skip to phase-2 test
    mov.l @r14, r5                      ! r5 = AI state base pointer
    mov.w   DAT_06042120, r0            ! r0 = 0x0364 (offset of input param field)
    mov.l @r14, r4                      ! r4 = AI state base pointer
    mov.l   .L_pool_shadow_project, r3  ! r3 = track_shadow_project
    mov.l @(r0, r5), r5                 ! r5 = state[+0x364] (input param / r5 arg)
    add #0x4, r0                        ! r0 = 0x0368 (offset of second param field)
    jsr @r3                             ! call track_shadow_project(r4=state_base, r5=param)
    mov.l @(r0, r4), r4                 ! (delay slot) r4 = state[+0x368] (car index arg)
    mov r0, r4                          ! r4 = return value from track_shadow_project
    tst r4, r4                          ! check if projection returned zero (ready)
    bt      .L_projection_ready         ! zero → projection complete, continue
    mov #0x1, r0                        ! return 1 (projection still in progress)
    add #0x10, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay slot) restore r14
.L_projection_ready:
    mov r15, r4                         ! r4 = stack frame base (output buffer for validate)
    mov.l   .L_pool_checkpoint_validate, r3  ! r3 = ai_checkpoint_validate
    jsr @r3                             ! call ai_checkpoint_validate(r4=stack_buf)
    add #0x4, r4                        ! (delay slot) r4 = stack+4 (buffer for result)
    mov.l @r14, r2                      ! r2 = AI state base pointer
    mov r15, r3                         ! r3 = stack frame base
    add #0x4, r3                        ! r3 = stack+4 (where validate wrote result byte)
    mov.b @r3, r1                       ! r1 = result byte from ai_checkpoint_validate
    mov #0x40, r0                       ! r0 = 0x40 (offset of busy_flag field)
    mov.b r1, @(r0, r2)                 ! state[+0x40] = result byte (store busy_flag)
    mov.l @r15, r3                      ! r3 = stack[0] = original r4 (car struct ptr)
    mov.l @r3, r2                       ! r2 = car_struct[+0x0] (counter value)
    add #0x1, r2                        ! r2 = counter + 1
    mov.l r2, @r3                       ! car_struct[+0x0]++ (increment counter)
    mov.l @r14, r3                      ! r3 = AI state base pointer
    mov #0x2, r2                        ! r2 = 2 (phase 2 value)
    mov.w   .L_wpool_0604211E, r0       ! r0 = 0x0360 (offset of check_type field)
    mov.l r2, @(r0, r3)                 ! state[+0x360] = 2 (advance to phase 2)
.L_phase2_check:
    mov.l @r14, r0                      ! r0 = AI state base pointer
    mov.w   .L_wpool_0604211E, r1       ! r1 = 0x0360 (offset of check_type field)
    mov.l @(r0, r1), r0                 ! r0 = state[+0x360] (check_type, may have just changed)
    cmp/eq #0x2, r0                     ! check_type == 2 (phase 2 active)?
    bf      .L_return_check_type        ! no → skip status check, return current value
    mov.w   DAT_06042122, r2            ! r2 = 0x0200 (CSCT status bitmask)
    mov.l   .L_pool_read_status, r3     ! r3 = sym_06035C4E (read HIRQ status)
    jsr @r3                             ! call sym_06035C4E() → r0 = HIRQ status word
    mov.l r2, @r15                      ! (delay slot) spill mask 0x0200 to stack[0]
    mov r0, r4                          ! r4 = HIRQ status word
    mov.l @r15, r3                      ! r3 = 0x0200 (reload bitmask from stack)
    exts.w r4, r5                       ! r5 = sign-extend HIRQ status to 32-bit
    and r3, r5                          ! r5 = status & 0x0200 (isolate CSCT bit)
    tst r5, r5                          ! CSCT bit set?
    bt      .L_csct_not_set             ! zero → CSCT not set, skip to false branch
    bra     .L_csct_set                 ! CSCT set → take true path
    mov #0x1, r5                        ! (delay slot) r5 = 1 (bit was set)
.L_csct_not_set:
    mov #0x0, r5                        ! r5 = 0 (CSCT bit was clear)
.L_csct_set:
    tst r5, r5                          ! r5 zero (CSCT not set)?
    bt      .L_return_check_type        ! zero → do not reset state, return as-is
    mov.l @r14, r3                      ! r3 = AI state base pointer
    mov #0x0, r2                        ! r2 = 0 (reset to idle)
    mov.w   .L_wpool_0604211E, r0       ! r0 = 0x0360 (offset of check_type field)
    mov.l r2, @(r0, r3)                 ! state[+0x360] = 0 (reset check_type to idle)
.L_return_check_type:
    mov.l @r14, r0                      ! r0 = AI state base pointer
    mov.w   .L_wpool_0604211E, r1       ! r1 = 0x0360 (offset of check_type field)
    mov.l @(r0, r1), r0                 ! r0 = state[+0x360] (final check_type value)
    add #0x10, r15                      ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return r0 = check_type (0/1/2)
    mov.l @r15+, r14                    ! (delay slot) restore r14
.L_wpool_0604211E:
    .2byte  0x0360                      ! struct offset: check_type / shadow state phase

    .global DAT_06042120
DAT_06042120:
    .2byte  0x0364                      ! struct offset: input param field (+0x364)

    .global DAT_06042122
DAT_06042122:
    .2byte  0x0200                      ! bitmask: CSCT (CD sector transfer complete) bit
.L_pool_ai_state_base:
    .4byte  sym_060A5400                ! indirect pointer to AI/game state base structure
.L_pool_shadow_project:
    .4byte  track_shadow_project        ! shadow projection function (FUN_06036A1C)
.L_pool_checkpoint_validate:
    .4byte  ai_checkpoint_validate      ! checkpoint validation and commit function
.L_pool_read_status:
    .4byte  sym_06035C4E                ! read CD/hardware HIRQ status word
