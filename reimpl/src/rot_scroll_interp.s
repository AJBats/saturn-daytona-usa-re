/* rot_scroll_interp -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602E462 - 0x0602E4F4
 *
 * VDP2 rotation scroll interpolation using sin/cos lookup tables.
 *
 * Two entry points:
 *
 *   rot_scroll_interp (0x0602E462):
 *     Computes rotation scroll deltas from a negated angle parameter.
 *     Calls cos_lookup and sin_lookup, multiplies results by a scroll
 *     coefficient (from struct offset +12), and accumulates the deltas
 *     into the scroll X (+16) and scroll Y (+24) fields. Stores the
 *     raw deltas at struct offsets +0x18C (X rotation delta) and
 *     +0x190 (Z rotation delta). Saves previous scroll values at
 *     offsets +56 and +60 before updating.
 *
 *   sym_0602E4BC:
 *     Scroll parameter setup â€” reads a car index from the struct,
 *     looks up the car entry in the car array, loads target X/Y
 *     scroll positions from the car struct, loads current X/Y from
 *     the main struct, computes deltas (target - current), and
 *     calls atan2 (in the next TU) to determine the heading angle.
 *     Flows into rot_scroll_vscale.
 *
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0602E462


    .global rot_scroll_interp
    .type rot_scroll_interp, @function
rot_scroll_interp:
    sts.l pr, @-r15                        ! save PR (return address)
    neg r4, r4                             ! negate angle parameter
    mov r4, r7                             ! r7 = negated angle (save for sin call)
    mov.l @(12, r0), r3                    ! r3 = struct[+12] (scroll coefficient)
    mov r3, r9                             ! r9 = scroll coefficient (save for cos multiply)
    mov.l @(16, r0), r5                    ! r5 = struct[+16] (current scroll X)
    mov.l @(24, r0), r6                    ! r6 = struct[+24] (current scroll Y)
    mov.l r5, @(56, r0)                    ! struct[+56] = previous scroll X
    mov.l r6, @(60, r0)                    ! struct[+60] = previous scroll Y
    .byte   0xD0, 0x0D    /* mov.l .L_pool_cos_fn, r0 */  ! r0 = &cos_lookup
    jsr @r0                                ! call cos_lookup(angle in r4)
    nop                                    ! delay slot
    mov r0, r8                             ! r8 = cos(angle)
    mov r7, r4                             ! r4 = negated angle (restore for sin call)
    .byte   0xD0, 0x0C    /* mov.l .L_pool_sin_fn, r0 */  ! r0 = &sin_lookup
    jsr @r0                                ! call sin_lookup(angle in r4)
    nop                                    ! delay slot
    dmuls.l r0, r3                         ! MACL:MACH = sin(angle) * scroll_coeff
    mov r14, r0                            ! r0 = struct base (restored from r14)
    .byte   0xDA, 0x0A    /* mov.l .L_pool_x_delta_off, r10 */  ! r10 = 0x18C (X delta offset)
    sts mach, r11                          ! r11 = MACH (high 32 bits of sin product)
    sts macl, r3                           ! r3 = MACL (low 32 bits of sin product)
    xtrct r11, r3                          ! r3 = middle 32 bits (16.16 fixed-point result)
    mov.l r3, @(r0, r10)                   ! struct[+0x18C] = X rotation delta
    add r3, r5                             ! r5 = scroll X + delta
    mov.l r5, @(16, r0)                    ! struct[+16] = updated scroll X
    dmuls.l r8, r9                         ! MACL:MACH = cos(angle) * scroll_coeff
    .byte   0xDA, 0x07    /* mov.l .L_pool_z_delta_off, r10 */  ! r10 = 0x190 (Z delta offset)
    sts mach, r8                           ! r8 = MACH (high 32 bits of cos product)
    sts macl, r9                           ! r9 = MACL (low 32 bits of cos product)
    xtrct r8, r9                           ! r9 = middle 32 bits (16.16 fixed-point result)
    mov.l r9, @(r0, r10)                   ! struct[+0x190] = Z rotation delta
    add r9, r6                             ! r6 = scroll Y + delta
    mov.l r6, @(24, r0)                    ! struct[+24] = updated scroll Y
    lds.l @r15+, pr                        ! restore PR
    rts                                    ! return
    nop                                    ! delay slot
.L_pool_cos_fn:
    .4byte  cos_lookup                     /* pool: &cos_lookup function */
.L_pool_sin_fn:
    .4byte  sin_lookup                     /* pool: &sin_lookup function */
.L_pool_x_delta_off:
    .4byte  0x0000018C                     /* struct offset +0x18C: X rotation delta */
.L_pool_z_delta_off:
    .4byte  0x00000190                     /* struct offset +0x190: Z rotation delta */

    .global sym_0602E4BC
sym_0602E4BC:
    .byte   0x91, 0x2D    /* mov.w .L_wpool_0602E51A, r1 */  ! r1 = car index offset in struct
    mov.l @(r0, r1), r9                    ! r9 = struct[+car_index_off] (car index)
    shll2 r9                               ! r9 *= 4 (scale to word index)
    .byte   0xD1, 0x19    /* mov.l .L_pool_0602E528, r1 */   ! r1 = &car_array_table_ptr
    mov.l @r1, r3                          ! r3 = car array table index
    .byte   0xD4, 0x19    /* mov.l .L_pool_0602E52C, r4 */   ! r4 = &car_array_base
    shll2 r3                               ! r3 *= 4 (scale to pointer offset)
    add r3, r4                             ! r4 = &car_array_base[table_index]
    mov.l @r4, r4                          ! r4 = car_array_entry pointer
    shll2 r9                               ! r9 *= 4 again (total *16 for car struct size)
    add r9, r4                             ! r4 = &car_struct[car_index]
    mov r4, r10                            ! r10 = car struct pointer (save)
    .byte   0x91, 0x22    /* mov.w .L_wpool_0602E51C, r1 */  ! r1 = target X offset in car struct
    add r10, r1                            ! r1 = &car_struct[target_x_off]
    mov.l @r1, r5                          ! r5 = car target X position
    .byte   0x91, 0x20    /* mov.w .L_wpool_0602E51E, r1 */  ! r1 = target Y offset in car struct
    add r10, r1                            ! r1 = &car_struct[target_y_off]
    mov.l @r1, r6                          ! r6 = car target Y position
    .byte   0x91, 0x1E    /* mov.w .L_wpool_0602E520, r1 */  ! r1 = current X offset in main struct
    mov.l @(r0, r1), r7                    ! r7 = struct[+current_x_off] (current X)
    .byte   0x91, 0x1D    /* mov.w .L_wpool_0602E522, r1 */  ! r1 = current Y offset in main struct
    mov.l @(r0, r1), r8                    ! r8 = struct[+current_y_off] (current Y)
    mov.l r0, @-r15                        ! push struct pointer (save for later)
    mov r5, r4                             ! r4 = target X
    sub r7, r4                             ! r4 = target X - current X (delta X)
    mov r6, r5                             ! r5 = target Y
    sub r8, r5                             ! r5 = target Y - current Y (delta Y)
    .byte   0xD0, 0x0F    /* mov.l .L_pool_0602E530, r0 */   ! r0 = &atan2 (in next TU pool)
