/* render_stage_1 -- VDP2 rendering pipeline stage 1 initialization
 * Translation unit: 0x0601C978 - 0x0601CAEE
 *
 * First stage of the multi-stage VDP2 render pipeline. Called during
 * pre-race configuration (from state 0 init) to set up the display
 * subsystem for a new race/scene.
 *
 * Performs:
 *   1. Disables display output, clears display channels
 *   2. Calls external display update and audio display init
 *   3. Resets frame countdown, stage counter, DMA pending flag
 *   4. Copies palette data from WRAM to VDP2 CRAM banks 1 & 2
 *      (16 word pairs per bank, read from palette_intensity ptr)
 *   5. DMA transfers palette source to CRAM bank 0
 *   6. Copies tile pattern data to VDP2 VRAM (two tile sets via
 *      vram_tile_copy with r7=9 shift parameter)
 *   7. Configures two scroll config structs (scroll_setup function)
 *   8. Initializes display channel nibble config for 5 channels
 *      (channels 0x100, 0x4, 0x8, 0x10, 0x20)
 *   9. Tail: calls tilemap DMA update, sets game state bit 30,
 *      calls display update, clears state tracker
 *
 * Globals:
 *   sym_06086028 — palette intensity (word), base ptr for CRAM copy
 *   sym_0608602C — render state variable (long, cleared to 0)
 *   sym_06086030 — render cycle flag (byte, cleared to 0)
 *   sym_0608601C — frame countdown (long, set to 0x012C = 300)
 *   sym_06086020 — render stage step counter (long, cleared to 0)
 *   sym_06086024 — DMA pending flag (long, cleared to 0)
 *   sym_06059F44 — state tracker (long, cleared to 0)
 *   sym_0605B6D8 — game state flags (bit 30 set at end)
 *
 * Tail section (lines after bra): uses .byte pairs because PC-relative
 * mov.l instructions reach into render_stage_2's constant pool.
 *
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 */

    .section .text.FUN_0601C978


    .global render_stage_1
    .type render_stage_1, @function
render_stage_1:
    mov.l r14, @-r15                            ! save r14
    mov.l r13, @-r15                            ! save r13
    sts.l pr, @-r15                             ! save return address
    mov #0x0, r13                               ! r13 = 0 (constant zero for clearing globals)
    add #-0x4, r15                              ! allocate 4 bytes on stack (scroll config ptr slot)
    mov.l   .L_p_palette_intensity, r14         ! r14 = &palette_intensity (base ptr for CRAM copy)
    mov.l   .L_p_render_state_var, r3           ! r3 = &render_state_var
    mov.l r13, @r3                              ! render_state_var = 0
    mov.l   .L_p_render_cycle_flag, r3          ! r3 = &render_cycle_flag
    mov.b r13, @r3                              ! render_cycle_flag = 0 (byte)
    mov.w   DAT_0601ca3a, r1                    ! r1 = 0x77BD (initial palette word)
    mov.l   .L_fn_display_disable, r3           ! r3 = display_disable (clear bit 15)
    jsr @r3                                     ! call display_disable()
    mov.w r1, @r14                              ! (delay) *palette_intensity = 0x77BD
    mov.l   .L_fn_channels_clear, r3            ! r3 = display_channels_clear
    jsr @r3                                     ! call display_channels_clear()
    nop                                         ! (delay)
    mov.l   .L_fn_display_update, r3            ! r3 = display_update (sym_06026CE0)
    jsr @r3                                     ! call display_update()
    nop                                         ! (delay)
    mov.l   .L_p_state_tracker, r3              ! r3 = &state_tracker
    mov.l r13, @r3                              ! state_tracker = 0
    mov.l   .L_fn_audio_display_init, r3        ! r3 = audio_display_init
    jsr @r3                                     ! call audio_display_init()
    nop                                         ! (delay)
    mov.w   DAT_0601ca3c, r2                    ! r2 = 0x012C (300 frames)
    mov.l   .L_p_frame_countdown, r3            ! r3 = &frame_countdown
    mov.l r2, @r3                               ! frame_countdown = 300
    mov.l   .L_p_stage_counter, r3              ! r3 = &stage_counter
    mov.l r13, @r3                              ! stage_counter = 0
    mov.l   .L_p_dma_pending, r3                ! r3 = &dma_pending_flag
    mov.l r13, @r3                              ! dma_pending_flag = 0
    mov.l   .L_vdp2_cram_0x200, r5             ! r5 = 0x25F00200 (CRAM bank 1 base)
    mov #0x20, r4                               ! r4 = 0x20 (32 bytes = 16 words to copy)
.L_cram_copy_bank1:                             ! -- copy 16 word pairs from palette to CRAM bank 1 --
    mov.w @r14, r3                              ! r3 = read word from palette_intensity ptr
    add #-0x2, r4                               ! r4 -= 2 (count down by word)
    mov.w r3, @r5                               ! write word to CRAM[r5]
    add #0x2, r5                                ! r5 += 2 (advance CRAM write ptr)
    mov.w @r14, r3                              ! r3 = read second word from palette_intensity
    mov r5, r2                                  ! r2 = next CRAM address (for delay slot write)
    add #0x2, r5                                ! r5 += 2 (advance past second word)
    tst r4, r4                                  ! counter == 0?
    bf/s    .L_cram_copy_bank1                  ! loop if counter != 0
    mov.w r3, @r2                               ! (delay) write second word to CRAM[r2]
    mov.l   .L_vdp2_cram_0x400, r5             ! r5 = 0x25F00400 (CRAM bank 2 base)
    mov #0x20, r4                               ! r4 = 0x20 (32 bytes = 16 words to copy)
.L_cram_copy_bank2:                             ! -- copy 16 word pairs from palette to CRAM bank 2 --
    mov.w @r14, r2                              ! r2 = read word from palette_intensity ptr
    add #-0x2, r4                               ! r4 -= 2 (count down by word)
    mov.w r2, @r5                               ! write word to CRAM[r5]
    add #0x2, r5                                ! r5 += 2 (advance CRAM write ptr)
    mov.w @r14, r2                              ! r2 = read second word from palette_intensity
    mov r5, r3                                  ! r3 = next CRAM address (for delay slot write)
    add #0x2, r5                                ! r5 += 2 (advance past second word)
    tst r4, r4                                  ! counter == 0?
    bf/s    .L_cram_copy_bank2                  ! loop if counter != 0
    mov.w r2, @r3                               ! (delay) write second word to CRAM[r3]
    mov.l   .L_palette_src_cram0, r5             ! r5 = palette source data (sym_0604880C)
    mov.l   .L_vdp2_cram_0x000, r4             ! r4 = 0x25F00000 (CRAM bank 0 dest)
    mov.l   .L_fn_dma_transfer, r3             ! r3 = dma_transfer
    jsr @r3                                     ! call dma_transfer(src=palette, dst=CRAM0, size=0x40)
    mov #0x40, r6                               ! (delay) r6 = 0x40 (64 bytes to DMA)
    mov #0x9, r7                                ! r7 = 9 (bit shift / format parameter)
    mov.l   .L_tile_src_a, r5                   ! r5 = 0x00014000 (tile pattern source A)
    mov.l   .L_vdp2_vram_0x70E40, r4           ! r4 = 0x25E70E40 (VDP2 VRAM tile dest A)
    mov.l   .L_fn_vram_tile_copy, r3           ! r3 = vram_tile_copy
    jsr @r3                                     ! call vram_tile_copy(dst, src, flags=0, shift=9)
    mov #0x0, r6                                ! (delay) r6 = 0 (flags)
    mov #0x9, r7                                ! r7 = 9 (bit shift / format parameter)
    mov.l   .L_tile_src_b, r5                   ! r5 = 0x00016BC0 (tile pattern source B)
    mov.l   .L_vdp2_vram_0x7B168, r4           ! r4 = 0x25E7B168 (VDP2 VRAM tile dest B)
    mov.l   .L_fn_vram_tile_copy, r3           ! r3 = vram_tile_copy
    jsr @r3                                     ! call vram_tile_copy(dst, src, flags=0, shift=9)
    mov #0x0, r6                                ! (delay) r6 = 0 (flags)
    mov.l   .L_p_scroll_config_a, r2             ! r2 = &scroll_config_a struct (sym_06063958)
    mov.l r2, @r15                              ! save scroll_config_a ptr on stack
    mov r2, r7                                  ! r7 = &scroll_config_a (for field read)
    mov r2, r5                                  ! r5 = &scroll_config_a (for field read)
    mov.w   .L_w_scroll_extent, r6              ! r6 = 0x0518 (scroll extent / range)
    mov.l   .L_fn_scroll_setup, r3              ! r3 = scroll_setup (sym_06028400)
    mov.l @(4, r7), r7                          ! r7 = scroll_config_a[1] (height/vscroll param)
    mov.l @r5, r5                               ! r5 = scroll_config_a[0] (width/hscroll param)
    jsr @r3                                     ! call scroll_setup(mode=4, hscroll, extent, height)
    mov #0x4, r4                                ! (delay) r4 = 4 (scroll plane index / mode)
    mov.l   .L_p_scroll_config_b, r2            ! r2 = &scroll_config_b struct (sym_06063960)
    mov.l r2, @r15                              ! save scroll_config_b ptr on stack
    mov r2, r7                                  ! r7 = &scroll_config_b (for field read)
    mov r2, r5                                  ! r5 = &scroll_config_b (for field read)
    mov.w   .L_w_scroll_extent, r6              ! r6 = 0x0518 (scroll extent / range)
    mov.l   .L_fn_scroll_setup, r3              ! r3 = scroll_setup (sym_06028400)
    mov.l @(4, r7), r7                          ! r7 = scroll_config_b[1] (height/vscroll param)
    mov.l @r5, r5                               ! r5 = scroll_config_b[0] (width/hscroll param)
    jsr @r3                                     ! call scroll_setup(mode=0, hscroll, extent, height)
    mov #0x0, r4                                ! (delay) r4 = 0 (scroll plane index / mode)
    mov.l   .L_fn_channel_nibble_cfg, r13       ! r13 = channel_nibble_config (loop fn ptr)
    mov.w   .L_w_channel_init_mask, r4          ! r4 = 0x0100 (channel mask for first call)
    bra     .L_channel_config_loop              ! jump to channel config loop body
    mov #0x0, r5                                ! (delay) r5 = 0 (nibble value for channel 0x100)

    .global DAT_0601ca3a
DAT_0601ca3a:                                   /* inline word pool */
    .2byte  0x77BD                              /* initial palette intensity value */

    .global DAT_0601ca3c
DAT_0601ca3c:                                   /* inline word pool */
    .2byte  0x012C                              /* 300 — frame countdown initial value */
.L_w_scroll_extent:
    .2byte  0x0518                              /* 1304 — scroll extent / pixel range */
.L_w_channel_init_mask:
    .2byte  0x0100                              /* channel 8 mask (first nibble cfg call) */
    .2byte  0xFFFF                              /* alignment padding */
.L_p_palette_intensity:
    .4byte  sym_06086028                        /* &palette_intensity (word) */
.L_p_render_state_var:
    .4byte  sym_0608602C                        /* &render_state_var (long) */
.L_p_render_cycle_flag:
    .4byte  sym_06086030                        /* &render_cycle_flag (byte) */
.L_fn_display_disable:
    .4byte  sym_060149E0                        /* display_disable — clear bit 15 */
.L_fn_channels_clear:
    .4byte  display_channels_clear              /* clear all display channels */
.L_fn_display_update:
    .4byte  sym_06026CE0                        /* display_update — refresh display state */
.L_p_state_tracker:
    .4byte  sym_06059F44                        /* &state_tracker (long) */
.L_fn_audio_display_init:
    .4byte  audio_display_init                  /* audio + display subsystem init */
.L_p_frame_countdown:
    .4byte  sym_0608601C                        /* &frame_countdown (long) */
.L_p_stage_counter:
    .4byte  sym_06086020                        /* &stage_counter (long) */
.L_p_dma_pending:
    .4byte  sym_06086024                        /* &dma_pending_flag (long) */
.L_vdp2_cram_0x200:
    .4byte  0x25F00200                          /* VDP2 color RAM bank 1 (+0x200) */
.L_vdp2_cram_0x400:
    .4byte  0x25F00400                          /* VDP2 color RAM bank 2 (+0x400) */
.L_palette_src_cram0:
    .4byte  sym_0604880C                        /* palette source data for CRAM bank 0 DMA */
.L_vdp2_cram_0x000:
    .4byte  0x25F00000                          /* VDP2 color RAM bank 0 (+0x000) */
.L_fn_dma_transfer:
    .4byte  dma_transfer                        /* SCU DMA transfer function */
.L_tile_src_a:
    .4byte  0x00014000                          /* tile pattern source A (WRAM offset) */
.L_vdp2_vram_0x70E40:
    .4byte  0x25E70E40                          /* VDP2 VRAM tile dest A (+0x70E40) */
.L_fn_vram_tile_copy:
    .4byte  sym_0600511E                        /* vram_tile_copy — pattern data transfer */
.L_tile_src_b:
    .4byte  0x00016BC0                          /* tile pattern source B (WRAM offset) */
.L_vdp2_vram_0x7B168:
    .4byte  0x25E7B168                          /* VDP2 VRAM tile dest B (+0x7B168) */
.L_p_scroll_config_a:
    .4byte  sym_06063958                        /* &scroll_config_a struct (8 bytes) */
.L_fn_scroll_setup:
    .4byte  sym_06028400                        /* scroll_setup — configure scroll plane */
.L_p_scroll_config_b:
    .4byte  sym_06063960                        /* &scroll_config_b struct (8 bytes) */
.L_fn_channel_nibble_cfg:
    .4byte  channel_nibble_config               /* display channel nibble configurator */
.L_channel_config_loop:
    jsr @r13                                    ! call channel_nibble_config(0x0100, 0)
    nop                                         ! (delay) — first call: r4=0x100, r5=0
    mov #0x1, r5                                ! r5 = 1 (nibble value for channel 0x4)
    jsr @r13                                    ! call channel_nibble_config(0x4, 1)
    mov #0x4, r4                                ! (delay) r4 = 0x4 (channel mask)
    mov #0x2, r5                                ! r5 = 2 (nibble value for channel 0x8)
    jsr @r13                                    ! call channel_nibble_config(0x8, 2)
    mov #0x8, r4                                ! (delay) r4 = 0x8 (channel mask)
    mov #0x0, r5                                ! r5 = 0 (nibble value for channel 0x10)
    jsr @r13                                    ! call channel_nibble_config(0x10, 0)
    mov #0x10, r4                               ! (delay) r4 = 0x10 (channel mask)
    mov #0x0, r5                                ! r5 = 0 (nibble value for channel 0x20)
    jsr @r13                                    ! call channel_nibble_config(0x20, 0)
    mov #0x20, r4                               ! (delay) r4 = 0x20 (channel mask)
    /* --- tail: uses cross-TU pool from render_stage_2 --- */
    .byte   0xD6, 0x21    /* mov.l r6, sym_06086028 */  ! r6 = &palette_intensity (tilemap DMA arg)
    .byte   0xD4, 0x22    /* mov.l r4, 0x25F00FFE */    ! r4 = VDP2 CRAM 0xFFE (tilemap DMA dest)
    .byte   0xD3, 0x22    /* mov.l r3, tilemap_dma_update */ ! r3 = tilemap_dma_update fn
    jsr @r3                                     ! call tilemap_dma_update(cram_end, 1, palette)
    mov #0x1, r5                                ! (delay) r5 = 1 (update mode)
    .byte   0xD4, 0x22    /* mov.l r4, sym_0605B6D8 */  ! r4 = &game_state_flags
    .byte   0xD2, 0x22    /* mov.l r2, 0x40000000 */    ! r2 = 0x40000000 (bit 30 mask)
    mov.l @r4, r3                               ! r3 = game_state_flags
    or r2, r3                                   ! r3 |= 0x40000000 (set bit 30)
    mov.l r3, @r4                               ! game_state_flags = r3
    .byte   0xD3, 0x21    /* mov.l r3, sym_06026CE0 */  ! r3 = display_update fn
    jsr @r3                                     ! call display_update()
    nop                                         ! (delay)
    mov #0x0, r2                                ! r2 = 0
    .byte   0xD3, 0x20    /* mov.l r3, sym_06059F44 */  ! r3 = &state_tracker
    mov.l r2, @r3                               ! state_tracker = 0 (clear)
    add #0x4, r15                               ! free stack slot
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return
    mov.l @r15+, r14                            ! (delay) restore r14
