/* course_data_rom_load -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601A80C - 0x0601A940
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 *
 * Handles D-pad input on the course data selection screen to cycle
 * through ROM course data entries. Reads edge-triggered and held
 * button state from the input structure at g_pad_state:
 *   - offset +0: currently-held buttons (16-bit)
 *   - offset +2: edge-triggered (new press) buttons (16-bit)
 *
 * D-pad right (bit 15 = 0x8000): increments the ROM course index.
 * D-pad left  (bit 14 = 0x4000): decrements the ROM course index.
 * Held buttons with auto-repeat: same logic using held word at +0,
 *   but only fires when confirm flag (sym_0605D243) equals 0x14.
 * Action buttons (bits 7:3 = 0xF8): reset the index to 0.
 *
 * The index (stored as a 32-bit int at sym_0605D248) is clamped
 * to the range [0, 0x14] (21 entries). After clamping, if
 * Start/A is pressed (bits 10:9 = 0x0600), calls handler_dispatch
 * with the index+2 to trigger a course load command.
 *
 * Finally, dispatches four geometry render calls (sym_060283E0) to
 * update VDP2 scroll layers:
 *   1-2. Fixed scroll layer name (sym_06049CDC) at VRAM offsets
 *        0x079C and 0x081C with layer param 0x0C.
 *   3-4. Per-course scroll data looked up from the table at
 *        sym_0605D2B4[index*2] and sym_0605D2B4[index*2+1],
 *        at the same VRAM offsets with mask 0xE000.
 *
 * Persistent registers:
 *   r11 = geom_render_dispatch (sym_060283E0)
 *   r12 = 0 constant (used for clearing / resetting)
 *   r13 = &input structure (g_pad_state)
 *   r14 = &course ROM index (sym_0605D248)
 *
 * Called from: course selection screen update
 * Calls: handler_dispatch, sym_060283E0 (geom_render_dispatch)
 */

    .section .text.FUN_0601A80C


    .global course_data_rom_load
    .type course_data_rom_load, @function
course_data_rom_load:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    mov.l r11, @-r15                    ! save r11
    sts.l pr, @-r15                     ! save PR (return address)
    add #-0x4, r15                      ! allocate 4 bytes on stack (local var)
    mov.l   .L_pool_input_struct, r13   ! r13 = &input structure (g_pad_state)
    mov.l   .L_pool_course_index, r14   ! r14 = &course ROM index (sym_0605D248)
    mov.l   .L_pool_dpad_right_mask, r6 ! r6 = 0x8000 (D-pad right bit)
    mov.l   .L_pool_confirm_flag, r4    ! r4 = &course confirm flag (sym_0605D243)
    mov.w @(2, r13), r0                 ! r0 = edge-triggered button word (new presses)
    mov r0, r3                          ! r3 = copy of new presses
    extu.w r3, r3                       ! r3 = zero-extend to 32-bit
    and r6, r3                          ! r3 = new_presses & 0x8000 (D-pad right?)
    tst r3, r3                          ! test: was D-pad right pressed?
    bt/s    .L_check_dpad_left_edge     ! if not, check D-pad left
    mov #0x0, r12                       ! r12 = 0 (constant used for clearing)
    mov.l @r14, r3                      ! r3 = current course index
    add #0x1, r3                        ! r3 = index + 1 (move to next course)
    mov.l r3, @r14                      ! store incremented index
    exts.b r12, r2                      ! r2 = 0 (sign-extended byte)
    bra     .L_clamp_and_dispatch       ! jump to clamping logic
    mov.b r2, @r4                       ! (delay) clear confirm flag
.L_check_dpad_left_edge:
    mov.w   DAT_0601a872, r5            ! r5 = 0x4000 (D-pad left bit mask)
    mov.w @(2, r13), r0                 ! r0 = edge-triggered button word
    mov r0, r2                          ! r2 = copy of button word
    extu.w r2, r2                       ! r2 = zero-extend to 32-bit
    and r5, r2                          ! r2 = new_presses & 0x4000 (D-pad left?)
    tst r2, r2                          ! test: was D-pad left pressed?
    bt      .L_check_held_right         ! if not, check held buttons
    mov.l @r14, r3                      ! r3 = current course index
    add #-0x1, r3                       ! r3 = index - 1 (move to previous course)
    mov.l r3, @r14                      ! store decremented index
    exts.b r12, r2                      ! r2 = 0 (sign-extended byte)
    bra     .L_clamp_and_dispatch       ! jump to clamping logic
    mov.b r2, @r4                       ! (delay) clear confirm flag
.L_check_held_right:
    mov.w @r13, r2                      ! r2 = currently-held button word
    extu.w r2, r2                       ! r2 = zero-extend to 32-bit
    and r6, r2                          ! r2 = held_buttons & 0x8000 (D-pad right held?)
    tst r2, r2                          ! test: is D-pad right being held?
    bt      .L_check_held_left          ! if not, check held left
    mov.b @r4, r0                       ! r0 = confirm flag value
    cmp/eq #0x14, r0                    ! is confirm flag == 0x14 (auto-repeat threshold)?
    bf      .L_clamp_and_dispatch       ! if not at threshold, skip increment
    mov.l @r14, r2                      ! r2 = current course index
    add #0x1, r2                        ! r2 = index + 1
    mov.l r2, @r14                      ! store incremented index
    exts.b r12, r3                      ! r3 = 0 (sign-extended byte)
    mov.b r3, @r4                       ! clear confirm flag (reset auto-repeat)
    bra     .L_clamp_and_dispatch       ! jump to clamping logic
    nop                                 ! (delay slot â€” nop)

    .global DAT_0601a872
DAT_0601a872:
    .2byte  0x4000
.L_pool_input_struct:
    .4byte  g_pad_state
.L_pool_course_index:
    .4byte  sym_0605D248
.L_pool_dpad_right_mask:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_confirm_flag:
    .4byte  sym_0605D243
.L_check_held_left:
    mov.w @r13, r2                      ! r2 = currently-held button word
    extu.w r2, r2                       ! r2 = zero-extend to 32-bit
    and r5, r2                          ! r2 = held_buttons & 0x4000 (D-pad left held?)
    tst r2, r2                          ! test: is D-pad left being held?
    bt      .L_clamp_and_dispatch       ! if not, skip to clamping
    mov.b @r4, r0                       ! r0 = confirm flag value
    cmp/eq #0x14, r0                    ! is confirm flag == 0x14 (auto-repeat threshold)?
    bf      .L_clamp_and_dispatch       ! if not at threshold, skip decrement
    mov.l @r14, r2                      ! r2 = current course index
    add #-0x1, r2                       ! r2 = index - 1
    mov.l r2, @r14                      ! store decremented index
    exts.b r12, r3                      ! r3 = 0 (sign-extended byte)
    mov.b r3, @r4                       ! clear confirm flag (reset auto-repeat)
.L_clamp_and_dispatch:
    mov.w @(2, r13), r0                 ! r0 = edge-triggered button word (new presses)
    extu.w r0, r0                       ! r0 = zero-extend to 32-bit
    tst #0xF8, r0                       ! test: any action button pressed? (bits 7:3)
    bt      .L_skip_action_reset        ! if no action buttons, skip reset
    mov.l r12, @r14                     ! reset course index to 0
.L_skip_action_reset:
    mov.l @r14, r3                      ! r3 = current course index
    mov #0x15, r2                       ! r2 = 0x15 (21 = max index + 1)
    cmp/ge r2, r3                       ! is index >= 21?
    bf      .L_skip_upper_clamp         ! if not, skip upper clamp
    mov.l r12, @r14                     ! clamp: reset index to 0 (wrap around)
.L_skip_upper_clamp:
    mov.l @r14, r2                      ! r2 = current course index
    cmp/pz r2                           ! is index >= 0?
    bt      .L_skip_lower_clamp         ! if non-negative, skip lower clamp
    mov #0x14, r2                       ! r2 = 0x14 (20 = max valid index)
    mov.l r2, @r14                      ! clamp: set index to max (wrap around)
.L_skip_lower_clamp:
    mov.w @(2, r13), r0                 ! r0 = edge-triggered button word
    mov.w   DAT_0601a926, r2            ! r2 = 0x0600 (Start + A button mask)
    mov r0, r3                          ! r3 = copy of button word
    extu.w r3, r3                       ! r3 = zero-extend to 32-bit
    and r2, r3                          ! r3 = new_presses & 0x0600
    tst r3, r3                          ! test: was Start or A pressed?
    bt      .L_render_scroll_layers     ! if not, skip handler dispatch
    mov #0x0, r6                        ! r6 = 0 (handler_dispatch param: no flags)
    mov.l @r14, r5                      ! r5 = current course index
    add #0x2, r5                        ! r5 = index + 2 (command offset)
    mov.l r5, @r15                      ! save r5 to stack local var
    mov.l   .L_pool_handler_dispatch, r3 ! r3 = &handler_dispatch
    jsr @r3                             ! call handler_dispatch(r4=index+2, r5=index+2, r6=0)
    mov r5, r4                          ! (delay) r4 = index + 2 (first param)
.L_render_scroll_layers:
    mov.l   .L_pool_geom_render, r11    ! r11 = &geom_render_dispatch (sym_060283E0)
    mov #0x0, r6                        ! r6 = 0 (no mask for fixed layer)
    mov.w   DAT_0601a928, r5            ! r5 = 0x079C (VRAM offset A for scroll layer)
    mov.l   .L_pool_scroll_layer_name, r7 ! r7 = &scroll layer name (sym_06049CDC)
    jsr @r11                            ! call geom_render_dispatch(r4=0xC, r5=0x079C, r6=0, r7=name)
    mov #0xC, r4                        ! (delay) r4 = 0x0C (layer ID param)
    mov.l   .L_pool_scroll_layer_name, r7 ! r7 = &scroll layer name (sym_06049CDC)
    mov #0x0, r6                        ! r6 = 0 (no mask for fixed layer)
    mov.w   DAT_0601a92a, r5            ! r5 = 0x081C (VRAM offset B for scroll layer)
    jsr @r11                            ! call geom_render_dispatch(r4=0xC, r5=0x081C, r6=0, r7=name)
    mov #0xC, r4                        ! (delay) r4 = 0x0C (layer ID param)
    mov.l @r14, r7                      ! r7 = current course index
    mov.l   .L_pool_course_render_tbl, r3 ! r3 = &course_render_table (sym_0605D2B4)
    mov.l   .L_pool_layer_mask, r6      ! r6 = 0xE000 (priority mask for per-course layer)
    mov.w   DAT_0601a928, r5            ! r5 = 0x079C (VRAM offset A)
    shll r7                             ! r7 = index * 2 (two entries per course)
    shll2 r7                            ! r7 = index * 8 (4 bytes per table entry)
    add r3, r7                          ! r7 = &course_render_table[index*2]
    mov.l @r7, r7                       ! r7 = course_render_table[index*2] (scroll data A)
    jsr @r11                            ! call geom_render_dispatch(r4=0xC, r5=0x079C, r6=0xE000, r7=data_A)
    mov #0xC, r4                        ! (delay) r4 = 0x0C (layer ID param)
    mov.l @r14, r7                      ! r7 = current course index
    mov.l   .L_pool_course_render_tbl, r3 ! r3 = &course_render_table (sym_0605D2B4)
    mov.l   .L_pool_layer_mask, r6      ! r6 = 0xE000 (priority mask for per-course layer)
    mov.w   DAT_0601a92a, r5            ! r5 = 0x081C (VRAM offset B)
    shll r7                             ! r7 = index * 2
    add #0x1, r7                        ! r7 = index * 2 + 1 (second entry)
    shll2 r7                            ! r7 = (index*2+1) * 4 (byte offset)
    add r3, r7                          ! r7 = &course_render_table[index*2+1]
    mov.l @r7, r7                       ! r7 = course_render_table[index*2+1] (scroll data B)
    jsr @r11                            ! call geom_render_dispatch(r4=0xC, r5=0x081C, r6=0xE000, r7=data_B)
    mov #0xC, r4                        ! (delay) r4 = 0x0C (layer ID param)
    add #0x4, r15                       ! deallocate stack local var
    lds.l @r15+, pr                     ! restore PR
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! (delay) restore r14

    .global DAT_0601a926
DAT_0601a926:
    .2byte  0x0600

    .global DAT_0601a928
DAT_0601a928:
    .2byte  0x079C

    .global DAT_0601a92a
DAT_0601a92a:
    .2byte  0x081C
.L_pool_handler_dispatch:
    .4byte  handler_dispatch
.L_pool_geom_render:
    .4byte  sym_060283E0
.L_pool_scroll_layer_name:
    .4byte  sym_06049CDC
.L_pool_course_render_tbl:
    .4byte  sym_0605D2B4
.L_pool_layer_mask:
    .4byte  0x0000E000                  /* bits 15:13 mask */
