/* VERIFIED: sym_0602D814 (in this TU) writes car struct +0x0C during racing
 * Method: watchpoint on sym_06078900+0x0C during LEFT steering
 *   PC=0x0602D826 (sym_0602D814+0xE), PR=render_orchestrator+0xE4
 *   wrote 0x00043364 -> 0x00043483 (car state field, possibly speed or heading)
 *   Called from render_orchestrator pipeline.
 * Date: 2026-02-28
 */
/* vdp1_display_submit -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602D43C - 0x0602D89A
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP1 polygon display submission pipeline.
 *
 * vdp1_display_submit (0x0602D43C):
 *   Computes per-object display parameters for VDP1 polygon rendering.
 *   r14 = base pointer to car/object render state structure.
 *   Steps:
 *     1. Calculate draw count from object distance/visibility state
 *     2. Compute perspective scale via hw divide + cos_lookup
 *     3. Compute lateral offset via atan_piecewise + cos_lookup
 *     4. Apply damped steering correction to lateral velocity
 *     5. Clamp final values and set render flags
 *
 * sym_0602D814 — render_state_decay:
 *   Decays render intensity over time using a lookup table curve
 *   (sym_060477BC). Clamps result and writes back residual.
 *
 * sym_0602D88E — render_regs_save:
 *   Prologue that saves callee-saved registers (r8-r13) for the
 *   display submission pipeline entry.
 */

    .section .text.FUN_0602D43C


    .global vdp1_display_submit
    .type vdp1_display_submit, @function
vdp1_display_submit:
    sts.l pr, @-r15                 ! save return address
    mov r14, r0                     ! r14 = object render state base
    mov.w   DAT_0602d48a, r1
    mov #0x0, r12                   ! r12 = draw count (default 0)
    mov.l @(r0, r1), r10           ! r10 = object Z distance
    mov.w   .L_off_draw_count, r11  ! r11 = offset 0x168 (draw count field)
    mov.w   DAT_0602d48e, r2
    mov.w @(r0, r2), r7            ! r7 = visibility counter
    cmp/pl r7                       ! if vis counter > 0, skip draw calc
    bt      .L_load_draw_count
    mov.w   .L_max_abs_range, r3   ! r3 = 0x2F8 (max abs distance)
    mov.l   .L_max_draw_distance, r5 ! r5 = 0x6800 (far clip distance)
    neg r3, r4                      ! r4 = -0x2F8 (min abs distance)
    mov.l @(8, r0), r7             ! r7 = frame counter
    mov.w   .L_frame_threshold, r8
    cmp/gt r7, r8                   ! skip if frame < 240
    bt      .L_load_draw_count
    mov.w   .L_off_obj_data, r2
    mov.l @(r0, r2), r9            ! r9 = object data pointer
    tst r9, r9                      ! skip if object data is NULL
    bt      .L_load_draw_count
    mov.w   DAT_0602d496, r2
    mov.l @(r0, r2), r9            ! r9 = object forward distance
    cmp/gt r5, r9                   ! skip if beyond far clip
    bt      .L_load_draw_count
    mov r10, r8
    cmp/gt r3, r10                  ! check if Z > +max range
    bt      .L_abs_distance_ready
    cmp/ge r4, r10                  ! check if Z > -max range
    bt      .L_load_draw_count
    neg r8, r8                      ! negate to get abs(distance)
.L_abs_distance_ready:
    sub r3, r8                      ! r8 = abs(distance) - max_range
    mov #0x4, r1                    ! min draw count = 4
    mov #0xA, r2                    ! max draw count = 10
    cmp/gt r1, r8
    bt      .L_check_max_draw       ! if draw > 4, check upper bound
    mov r1, r8                      ! clamp to min 4
    bra     .L_store_draw_count
    nop

    .global DAT_0602d48a
DAT_0602d48a:
    .2byte  0x0154
.L_off_draw_count:
    .2byte  0x0168

    .global DAT_0602d48e
DAT_0602d48e:
    .2byte  0x0166
.L_max_abs_range:
    .2byte  0x02F8
.L_frame_threshold:
    .2byte  0x00F0
.L_off_obj_data:
    .2byte  0x0040

    .global DAT_0602d496
DAT_0602d496:
    .2byte  0x010C
.L_max_draw_distance:
    .4byte  0x00006800                  /* far clip distance threshold */
.L_check_max_draw:
    cmp/gt r8, r2                   ! if max > draw count, keep it
    bt      .L_store_draw_count
    mov r2, r8                      ! clamp to max 10
.L_store_draw_count:
    mov.w r8, @(r0, r11)           ! write draw count to struct
.L_load_draw_count:
    mov.w @(r0, r11), r3           ! r3 = current draw count
    mov r3, r12                     ! r12 = draw count copy
    cmp/pl r3                       ! if draw count <= 0, skip to cos
    bf      .L_compute_cos_scale
    mov.w   DAT_0602d542, r1
    mov.l @(r0, r1), r4            ! r4 = extra decrement flag
    tst r4, r4
    bf      .L_decrement_draw       ! if flag set, decrement by 1 only
    add #-0x2, r3                   ! else decrement by 2 extra
.L_decrement_draw:
    add #-0x1, r3                   ! decrement by 1
    mov.w r3, @(r0, r11)           ! store updated draw count
    mov.l   .L_perspective_base, r4 ! r4 = 0xA0000 (10.0 fixed 16.16)
    mov r4, r2
    mov #0x0, r5                    ! r5 = 0 (default scale if skipped)
    shll16 r3                       ! r3 = draw_count << 16
    sub r3, r2                      ! r2 = perspective_base - draw_count
    mov r2, r3
    cmp/pz r2                       ! skip hw divide if negative
    bf      .L_skip_perspective
    mov.w   DAT_0602d544, r1
    mov.l @(r0, r1), r5            ! r5 = forward distance (16.16)
    dmuls.l r3, r5                  ! 32x32 multiply
    sts mach, r3
    sts macl, r5
    xtrct r3, r5                    ! r5 = (persp * dist) >> 16
    mov.w   .L_hw_div_base_a, r2   ! r2 -> 0xFFFFFF00 (hw divider)
    mov r5, r3
    mov.l r4, @(0, r2)             ! DVSR = perspective_base (divisor)
    shlr16 r3
    exts.w r3, r3
    mov.l r3, @(16, r2)            ! DVDNTH = dividend high
    shll16 r5
    mov.l r5, @(20, r2)            ! DVDNTL = dividend low (triggers div)
    mov.l @(28, r2), r5            ! r5 = quotient from hw divider
.L_skip_perspective:
    mov.w   DAT_0602d544, r1
    bsr     .L_vis_counter_decay    ! call visibility counter decay sub
    mov.l r5, @(r0, r1)            ! (delay slot) store scale result
.L_compute_cos_scale:
    mov.w   DAT_0602d548, r1
    mov.l @(r0, r1), r4            ! r4 = yaw angle for cos lookup
    mov.l   .L_fn_cos_lookup_a, r0
    jsr @r0                         ! r0 = cos(yaw)
    nop
    shll16 r10                      ! r10 = Z_distance << 16
    dmuls.l r0, r10                 ! multiply cos(yaw) * Z_distance
    sts mach, r0
    sts macl, r10
    xtrct r0, r10                   ! extract 16.16 result
    shlr16 r10
    exts.w r10, r10                 ! sign-extend to 32-bit
    neg r10, r10                    ! negate (camera convention)
    mov r14, r0                     ! restore base pointer
    mov.w   DAT_0602d54a, r1
    mov.w   DAT_0602d544, r2
    mov.l @(r0, r1), r3            ! r3 = orientation angle
    mov.l @(r0, r2), r4            ! r4 = forward distance
    dmuls.l r3, r4                  ! angle * distance (fixed-point)
    sts mach, r3
    sts macl, r4
    xtrct r3, r4                    ! r4 = 16.16 product
    mov.w   .L_off_scale_factor, r2
    mov.w @(r0, r2), r3            ! r3 = per-object scale factor
    dmuls.l r3, r4                  ! scale * (angle * distance)
    sts mach, r3
    sts macl, r4
    shll8 r3                        ! merge 8.24 result
    shlr16 r4
    shlr8 r4
    or r3, r4                       ! r4 = final lateral component
    mov.l @(12, r0), r2            ! r2 = squared distance
    mov.l   .L_min_distance_sq, r3 ! r3 = 0x100 (min threshold)
    cmp/ge r3, r2                   ! if sq_dist >= threshold
    bt      .L_compute_sq_distance  ! compute precise angle via atan
    mov #0x0, r3                    ! else use quarter-turn default
    mov.l   .L_fp_quarter, r6      ! r6 = 0.25 (16.16)
    cmp/ge r3, r4                   ! choose sign based on lateral dir
    bt      .L_angle_sign_ready
    neg r6, r6                      ! negate for opposite side
.L_angle_sign_ready:
    bra     .L_drift_correction
    mov.l r3, @-r15                 ! (delay slot) push sq_dist flag = 0

    .global DAT_0602d542
DAT_0602d542:
    .2byte  0x011C

    .global DAT_0602d544
DAT_0602d544:
    .2byte  0x010C
.L_hw_div_base_a:
    .2byte  0xFF00                      /* -> 0xFFFFFF00 (SH-2 hw divider) */

    .global DAT_0602d548
DAT_0602d548:
    .2byte  0x005C

    .global DAT_0602d54a
DAT_0602d54a:
    .2byte  0x0144
.L_off_scale_factor:
    .2byte  0x00CE
    .2byte  0x0000
.L_perspective_base:
    .4byte  0x000A0000                  /* 10.0 in 16.16 fixed-point */
.L_fn_cos_lookup_a:
    .4byte  cos_lookup
.L_min_distance_sq:
    .4byte  0x00000100                  /* 256 — min sq_dist for atan path */
.L_fp_quarter:
    .4byte  0x00004000                  /* 0.25 (16.16 fixed-point) */
.L_compute_sq_distance:
    mov r2, r3                      ! r2 = r3 = distance
    dmuls.l r2, r3                  ! distance^2 (squared distance)
    sts mach, r2
    sts macl, r3
    xtrct r2, r3                    ! r3 = sq_dist (16.16)
    mov.l r3, @-r15                 ! push sq_dist for later check
    mov.w   .L_hw_div_base_b, r2   ! r2 -> 0xFFFFFF00 (hw divider)
    mov r4, r1
    mov.l r3, @(0, r2)             ! DVSR = sq_dist (divisor)
    shlr16 r1
    exts.w r1, r1
    mov.l r1, @(16, r2)            ! DVDNTH = lateral_component high
    shll16 r4
    mov.l r4, @(20, r2)            ! DVDNTL = lateral_component low
    mov.l   .L_fn_atan_piecewise_a, r0
    mov.l @(28, r2), r4            ! r4 = division quotient
    jsr @r0                         ! r0 = atan(lateral / sq_dist)
    nop
    cmp/eq #0x0, r0                 ! if atan returned 0, use fallback
    bf      .L_store_angle_result
    mov.w   DAT_0602d5f2, r4       ! offset 0x7F = fallback angle byte
    add r14, r4
    mov.b @r4, r0                   ! r0 = fallback angle from struct
.L_store_angle_result:
    mov r0, r6                      ! r6 = final viewing angle
.L_drift_correction:
    mov r14, r0                     ! restore base pointer
    mov.w   DAT_0602d5f4, r1
    mov #0x0, r8                    ! r8 = drift active flag (0 = off)
    mov.w @(r0, r1), r2            ! r2 = visibility counter
    cmp/pl r2                       ! skip drift if vis <= 0
    bf      .L_apply_steer_scale
    mov.l @(8, r0), r2             ! r2 = frame counter
    mov #0x46, r4                   ! 70 frames threshold
    cmp/ge r4, r2                   ! skip drift if frame >= 70
    bt      .L_apply_steer_scale
    mov.w   .L_off_obj_data_b, r1
    mov.l @(r0, r1), r2            ! r2 = object X position
    mov.w   .L_off_lateral_vel, r3
    mov.l @(r0, r3), r4            ! r4 = lateral velocity
    xor r2, r4                      ! check sign mismatch
    cmp/pz r4                       ! if same sign, no drift needed
    bt      .L_apply_steer_scale
    mov #0x1, r8                    ! drift is active
    shar r2                         ! r2 = position / 2
    mov #0x9, r5
    muls.w r2, r5                   ! drift angle = (pos/2) * 9
    shll16 r6                       ! r6 = viewing_angle << 16
    sts macl, r4                    ! r4 = drift angle
    mov.l   .L_fn_cos_lookup_b, r0
    jsr @r0                         ! r0 = cos(drift_angle)
    nop
    dmuls.l r0, r6                  ! cos(drift) * viewing_angle
    sts mach, r2
    sts macl, r6
    xtrct r2, r6                    ! extract 16.16 result
    shlr16 r6
    exts.w r6, r6                   ! r6 = corrected viewing angle
    cmp/pz r6                       ! if non-negative, keep it
    bt      .L_apply_steer_scale
    mov #0x0, r6                    ! clamp negative to zero
.L_apply_steer_scale:
    mov.w   .L_off_lateral_vel, r3
    mov r14, r0                     ! restore base pointer
    mov.l @(r0, r3), r5            ! r5 = lateral velocity
    mov #0x3, r4
    muls.w r4, r6                   ! r6 = viewing_angle * 3
    neg r5, r5                      ! r5 = -lateral_vel (target)
    sts macl, r6                    ! r6 = scaled angle
    cmp/pz r5                       ! branch on sign of target
    bf      .L_clamp_neg_lateral
    cmp/gt r5, r6                   ! clamp r6 to abs(target)
    bt      .L_use_lateral_limit
    bra     .L_compute_steer_accum
    nop
.L_hw_div_base_b:
    .2byte  0xFF00                      /* -> 0xFFFFFF00 (SH-2 hw divider) */

    .global DAT_0602d5f2
DAT_0602d5f2:
    .2byte  0x007F

    .global DAT_0602d5f4
DAT_0602d5f4:
    .2byte  0x0166
.L_off_obj_data_b:
    .2byte  0x0040
.L_off_lateral_vel:
    .2byte  0x005C
    .2byte  0x0000
.L_fn_atan_piecewise_a:
    .4byte  atan_piecewise
.L_fn_cos_lookup_b:
    .4byte  cos_lookup
.L_clamp_neg_lateral:
    neg r6, r6
    cmp/gt r6, r5
    bt      .L_use_lateral_limit
    bra     .L_compute_steer_accum
    mov #0x0, r7
.L_use_lateral_limit:
    mov r5, r6
.L_compute_steer_accum:
    neg r6, r11                     ! r11 = -clamped_angle
    mov r14, r0                     ! restore base pointer
    mov.w   .L_off_steer_accum, r1
    mov.l @(r0, r1), r5            ! r5 = steering accumulator
    sub r11, r10                    ! r10 += clamped_angle
    sub r5, r10                     ! r10 -= old accumulator
    add r10, r5                     ! r5 = new accumulator (damped)
    mov.w   .L_steer_clamp_max, r3 ! r3 = 0x300 (max steer)
    neg r3, r4                      ! r4 = -0x300 (min steer)
    cmp/gt r4, r5                   ! clamp to [-0x300, +0x300]
    bt      .L_check_steer_max
    mov r4, r5                      ! clamp to min
    bra     .L_steer_clamped
    nop
.L_off_steer_accum:
    .2byte  0x0178
.L_steer_clamp_max:
    .2byte  0x0300
.L_check_steer_max:
    cmp/gt r5, r3
    bt      .L_steer_clamped
    mov r3, r5
.L_steer_clamped:
    mov.l r5, @(r0, r1)            ! write clamped steer accumulator
    mov.w   DAT_0602d67c, r2
    mov.l @(r0, r2), r3            ! r3 = previous lateral velocity
    mov r3, r6                      ! r6 = copy of prev velocity
    add r3, r5                      ! r5 = steer_accum + prev_vel
    sub r5, r6                      ! r6 = prev_vel - new_vel (error)
    neg r6, r6                      ! negate error
    shar r6                         ! r6 >>= 3 (damping factor = 1/8)
    shar r6
    shar r6
    sub r6, r5                      ! apply damping correction
    mov.l r5, @(r0, r2)            ! store damped lateral velocity
    mov.w   .L_off_orient_angle, r1
    mov.w   .L_off_forward_vel, r2
    mov.l @(r0, r1), r3            ! r3 = orientation angle
    mov.l @(r0, r2), r4            ! r4 = forward velocity
    dmuls.l r3, r4                  ! angle * forward_vel
    sts mach, r3
    sts macl, r4
    xtrct r3, r4                    ! r4 = 16.16 product
    mov.w   DAT_0602d682, r2
    mov.w @(r0, r2), r3            ! r3 = additional scale factor
    dmuls.l r3, r4                  ! apply second scale
    sts mach, r3
    sts macl, r4
    shll8 r3                        ! merge 8.24 result
    shlr16 r4
    shlr8 r4
    or r3, r4                       ! r4 = orientation-weighted velocity
    mov.l @r15+, r3                 ! pop sq_dist flag
    tst r3, r3                      ! if sq_dist was non-zero, compute atan
    bf      .L_compute_orient_atan
    mov.l   .L_fp_quarter_b, r6 ! else use 0.25 default angle
    bra     .L_speed_range_clamp
    nop

    .global DAT_0602d67c
DAT_0602d67c:
    .2byte  0x005C
.L_off_orient_angle:
    .2byte  0x0140
.L_off_forward_vel:
    .2byte  0x0108

    .global DAT_0602d682
DAT_0602d682:
    .2byte  0x00CC
.L_fp_quarter_b:
    .4byte  0x00004000                  /* 0.25 (16.16 fixed-point) */
.L_compute_orient_atan:
    mov.w   .L_hw_div_base_c, r2   ! r2 -> 0xFFFFFF00 (hw divider)
    mov r4, r1
    mov.l r3, @(0, r2)             ! DVSR = sq_dist (divisor)
    shlr16 r1
    exts.w r1, r1
    mov.l r1, @(16, r2)            ! DVDNTH = orient_vel high
    shll16 r4
    mov.l r4, @(20, r2)            ! DVDNTL = orient_vel low
    mov.l @(28, r2), r4            ! r4 = quotient
    mov.l   .L_fn_atan_piecewise_b, r0
    jsr @r0                         ! r0 = atan(orient_vel / sq_dist)
    nop
    cmp/eq #0x0, r0                 ! if atan returned 0, use fallback
    bf      .L_orient_angle_ready
    mov.w   .L_off_fallback_angle_b, r4 ! offset 0x7E = alt fallback byte
    add r14, r4
    mov.b @r4, r0                   ! r0 = fallback angle
.L_orient_angle_ready:
    mov r0, r6                      ! r6 = orientation viewing angle
.L_speed_range_clamp:
    mov r14, r0                     ! restore base pointer
    mov #0x32, r3                   ! r3 = 50 (min speed for display)
    mov.w   DAT_0602d6c2, r4       ! r4 = 0xFA = 250 (max speed)
    mov.l @(8, r0), r7             ! r7 = current speed value
    cmp/gt r3, r7                   ! if speed > 50, check max
    bt      .L_check_speed_max
    mov r3, r7                      ! clamp to min 50
    bra     .L_speed_clamped
    nop
.L_hw_div_base_c:
    .2byte  0xFF00                      /* -> 0xFFFFFF00 (SH-2 hw divider) */
.L_off_fallback_angle_b:
    .2byte  0x007E

    .global DAT_0602d6c2
DAT_0602d6c2:
    .2byte  0x00FA
.L_fn_atan_piecewise_b:
    .4byte  atan_piecewise
.L_check_speed_max:
    cmp/gt r7, r4
    bt      .L_speed_clamped
    mov r4, r7
.L_speed_clamped:
    sub r3, r4                      ! r4 = max_speed - 50 (divisor)
    sub r3, r7                      ! r7 = speed - 50 (dividend)
    mov.l   .L_fn_hw_divide, r12   ! r12 -> hw_divide_protected
    shll8 r7                        ! r7 <<= 8 (fixed-point dividend)
    mov r4, r0                      ! r0 = divisor
    jsr @r12                        ! r0 = (speed-50)/(max-50) ratio
    mov r7, r1                      ! (delay slot) r1 = dividend
    mov r14, r0                     ! restore base pointer
    mov #0x2, r3
    mov #0x3, r4
    muls.w r4, r1                   ! r1 = quotient * 3
    shll8 r3                        ! r3 = 0x200 (512 base offset)
    sts macl, r7
    add r3, r7                      ! r7 = 512 + quotient*3 (draw param)
    mov.w   .L_off_obj_data_c, r1
    mov.w   DAT_0602d732, r2
    mov.l @(r0, r1), r3            ! r3 = object target angle
    mov.l @(r0, r2), r4            ! r4 = current lateral velocity
    mov r4, r13                     ! r13 = save lateral vel
    mov r3, r5                      ! r5 = target - current (delta)
    sub r4, r5
    mov.l r7, @-r15                 ! push draw param
    muls.w r6, r7                   ! r6*r7 = angle * draw_param
    sts macl, r6
    neg r4, r4
    mov r5, r7                      ! r7 = delta for sign check
    shlr8 r6                        ! r6 >>= 8 (scale down)
    xor r3, r7                      ! check if target & delta same sign
    cmp/pz r7
    bt      .L_clamp_angular_vel    ! same sign: no wrap needed
    mov.l   .L_half_circle_angle, r4 ! r4 = 0xFE0 (half circle)
    cmp/pz r3                       ! adjust wrap direction by target sign
    bt      .L_wrap_angle_offset
    neg r4, r4
.L_wrap_angle_offset:
    sub r4, r3                      ! wrap angle around half circle
    neg r3, r3
    dmuls.l r3, r6                  ! wrapped_delta * scaled_angle
    mov.l   .L_fn_hw_divide, r12
    mov r4, r0                      ! divisor = half_circle
    jsr @r12                        ! r0 = wrapped ratio
    sts macl, r1                    ! (delay slot) r1 = product
    mov r0, r6                      ! r6 = wrapped angular velocity
    mov r14, r0                     ! restore base pointer
.L_clamp_angular_vel:
    cmp/pz r5                       ! branch on sign of delta
    bf      .L_clamp_neg_angular
    cmp/gt r5, r6                   ! clamp r6 to abs(delta)
    bt      .L_use_angular_limit
    bra     .L_final_angular_scale
    nop
.L_off_obj_data_c:
    .2byte  0x0040

    .global DAT_0602d732
DAT_0602d732:
    .2byte  0x005C
.L_fn_hw_divide:
    .4byte  sym_0602ECCC
.L_half_circle_angle:
    .4byte  0x00000FE0                  /* ~180 degrees in angle units */
.L_clamp_neg_angular:
    neg r6, r6
    cmp/gt r6, r5
    bt      .L_use_angular_limit
    bra     .L_final_angular_scale
    nop
.L_use_angular_limit:
    mov r5, r6
.L_final_angular_scale:
    shll8 r6                        ! r6 <<= 8 (fixed-point dividend)
    mov.l   .L_fn_hw_divide_b, r12
    mov.l @r15+, r0                 ! pop draw param as divisor
    jsr @r12                        ! r0 = angular_vel / draw_param
    mov r6, r1                      ! (delay slot) r1 = dividend
    mov r0, r6                      ! r6 = scaled angular velocity
    mov r14, r0                     ! restore base pointer
    sub r5, r6                      ! r6 -= delta (smooth correction)
    mov.w   DAT_0602d790, r1
    mov.l @(r0, r1), r3            ! r3 = previous angular value
    sub r6, r3                      ! r3 = prev - new (error)
    neg r3, r3
    shar r3                         ! r3 >>= 3 (1/8 damping)
    shar r3
    shar r3
    sub r3, r6                      ! apply damping correction
    mov.l r6, @(r0, r1)            ! store damped angular value
    mov.l @(8, r0), r3             ! r3 = frame counter
    mov.w   .L_min_frame_for_drift, r4 ! r4 = 65 (min frames for drift check)
    cmp/ge r3, r4                   ! skip drift flags if frame < 65
    mov.w   .L_off_lateral_vel_b, r7
    bt      .L_final_vel_clamp
    mov.l @(r0, r7), r6            ! r6 = lateral velocity
    mov.l   .L_neg_lateral_threshold, r5 ! r5 = -0x3280 (large neg threshold)
    cmp/ge r6, r5                   ! if vel >= threshold (near object)
    bt      .L_set_near_flag        ! set near render flag
    neg r5, r5                      ! r5 = +0x3280
    cmp/gt r6, r5                   ! if vel < +threshold, skip
    bt      .L_final_vel_clamp
    mov.l @(0, r0), r2             ! r2 = render flags word
    mov.l   .L_flag_cache_through, r3 ! 0x20000000 = cache-through bit
    or r3, r2
    mov.l   .L_flag_priority_a, r3  ! 0x40000000 = far render flag
    or r3, r2                       ! set far + cache-through flags
    bra     .L_final_vel_clamp
    mov.l r2, @(0, r0)             ! (delay slot) store flags

    .global DAT_0602d790
DAT_0602d790:
    .2byte  0x0058
.L_min_frame_for_drift:
    .2byte  0x0041
.L_off_lateral_vel_b:
    .2byte  0x005C
    .2byte  0x0000
.L_fn_hw_divide_b:
    .4byte  sym_0602ECCC
.L_neg_lateral_threshold:
    .4byte  0xFFFFCD80                  /* -0x3280 lateral distance threshold */
.L_flag_cache_through:
    .4byte  0x20000000                  /* cache-through render flag */
.L_flag_priority_a:
    .4byte  0x40000000                  /* 0.25 (2.30) or 16384.0 (16.16) */
.L_set_near_flag:
    mov.l @(0, r0), r2             ! r2 = render flags word
    mov.l   .L_flag_render_near, r3 ! 0x10000000 = near render flag
    or r3, r2
    mov.l   .L_flag_priority_b, r3 ! 0x40000000 = priority flag
    or r3, r2                       ! set near + priority flags
    bra     .L_final_vel_clamp
    mov.l r2, @(0, r0)             ! (delay slot) store flags
    .2byte  0x0000
.L_flag_render_near:
    .4byte  0x10000000                  /* near-object render flag */
.L_flag_priority_b:
    .4byte  0x40000000                  /* 0.25 (2.30) or 16384.0 (16.16) */
.L_final_vel_clamp:
    mov.l @(r0, r7), r6            ! r6 = lateral velocity
    mov.l   .L_vel_clamp_limit, r3 ! r3 = -0x3400 (velocity clamp)
    cmp/ge r6, r3                   ! if vel >= -clamp, check exceeded
    bt      .L_vel_exceeded_clamp
    neg r3, r3                      ! r3 = +0x3400
    cmp/ge r6, r3                   ! if vel >= +clamp, ok to return
    bt      .L_return
.L_vel_exceeded_clamp:
    mov r3, r6                      ! clamp velocity to limit
    mov #0x1, r4
    mov.w   .L_off_clamp_flag, r1
    mov.w r4, @(r0, r1)            ! set clamp-occurred flag
.L_return:
    lds.l @r15+, pr                 ! restore return address
    rts
    mov.l r6, @(r0, r7)            ! (delay slot) store clamped velocity
.L_off_clamp_flag:
    .2byte  0x00D4
    .2byte  0x0000
.L_vel_clamp_limit:
    .4byte  0xFFFFCC00                  /* -0x3400 velocity clamp limit */
.L_vis_counter_decay:                   ! subroutine: manage visibility counter
    mov.l r3, @-r15                 ! save r3
    mov.l @(8, r0), r3             ! r3 = frame counter
    mov.w   .L_off_vis_counter, r1
    cmp/pl r3                       ! skip if frame <= 0
    bf      .L_vis_decay_done
    mov.l r4, @-r15
    mov.l r5, @-r15
    mov #0x3, r4                    ! threshold = 3
    mov.w @(r0, r1), r3            ! r3 = current vis counter
    cmp/gt r4, r3                   ! if counter > 3, don't reset
    bt      .L_vis_write_counter
    mov.l   .L_vis_reset_value, r5 ! r5 = 10 (reset value)
    tst r3, r3                      ! if counter == 0, use full reset
    bt      .L_vis_nonzero_adjust
    add #-0x3, r5                   ! else reset to 7 (10 - 3)
.L_vis_nonzero_adjust:
    mov.w r5, @(r0, r1)            ! write new vis counter
.L_vis_write_counter:
    mov.l @r15+, r5                 ! restore r5
    mov.l @r15+, r4                 ! restore r4
.L_vis_decay_done:
    rts
    mov.l @r15+, r3                 ! (delay slot) restore r3
.L_off_vis_counter:
    .2byte  0x0166
    .2byte  0x0000
.L_vis_reset_value:
    .4byte  0x0000000A                  /* 10 = visibility counter reset */

    .global sym_0602D814
sym_0602D814:                               ! render_state_decay entry
    mov r14, r0                     ! r14 = object render state base
    mov.l @(12, r0), r4            ! r4 = current intensity (16.16)
    mov.w   DAT_0602d862, r2       ! offset 0xFC = decay rate field
    mov.l @(r0, r2), r3            ! r3 = decay rate (negative)
    add r3, r4                      ! r4 = intensity + decay_rate
    mov.l r4, @(12, r0)            ! store updated intensity
    cmp/pz r4                       ! if intensity >= 0, continue
    bt      sym_0602D82A
    mov #0x0, r3                    ! else clamp to zero
    mov.l r3, @(12, r0)            ! intensity = 0
    mov.l r3, @(r0, r2)            ! decay_rate = 0

    .global sym_0602D82A
sym_0602D82A:                               ! compute display intensity from curve
    mov.w   DAT_0602d864, r2       ! offset 0xDC = curve index field
    mov.l @(12, r0), r3            ! r3 = current intensity
    mov.w @(r0, r2), r4            ! r4 = curve table index
    mov.l   .L_decay_curve_table, r5 ! r5 -> sym_060477BC (curve LUT)
    shll2 r4                        ! r4 *= 4 (32-bit entries)
    add r5, r4                      ! r4 -> table[index]
    mov.l @r4, r4                   ! r4 = curve value at index
    mov.l   .L_decay_scale_factor, r5 ! r5 = 0x0221AC91 (global scale)
    dmuls.l r3, r4                  ! intensity * curve_value
    nop
    nop
    sts mach, r3
    sts macl, r4
    xtrct r3, r4                    ! r4 = scaled intensity (16.16)
    dmuls.l r4, r5                  ! apply global scale factor
    mov.w   DAT_0602d866, r1       ! offset 0xE0 = output field
    mov #0x0, r3
    sts mach, r4
    sts macl, r5
    xtrct r4, r5                    ! r5 = final scaled result (16.16)
    shlr16 r5                       ! r5 = integer part
    mov r5, r6                      ! r6 = copy for residual calc
    mov.l   .L_max_intensity, r4   ! r4 = 0x2134 (max intensity)
    cmp/gt r3, r5                   ! if result > 0, check max
    bt      .L_check_max_intensity
    mov r3, r5                      ! clamp to 0
    bra     .L_intensity_clamped
    nop

    .global DAT_0602d862
DAT_0602d862:
    .2byte  0x00FC

    .global DAT_0602d864
DAT_0602d864:
    .2byte  0x00DC

    .global DAT_0602d866
DAT_0602d866:
    .2byte  0x00E0
.L_decay_curve_table:
    .4byte  sym_060477BC
.L_decay_scale_factor:
    .4byte  0x0221AC91                  /* global intensity scale constant */
.L_max_intensity:
    .4byte  0x00002134                  /* max display intensity value */
.L_check_max_intensity:
    cmp/gt r5, r4                   ! if max > result, keep result
    bt      .L_intensity_clamped
    mov r4, r5                      ! clamp to max intensity
.L_intensity_clamped:
    mov.l r5, @(r0, r1)            ! store clamped intensity
    sub r5, r6                      ! r6 = unclamped - clamped (residual)
    cmp/pz r6
    bt      .L_store_residual       ! if residual >= 0, store it
    mov #0x0, r6                    ! else clamp residual to 0
.L_store_residual:
    mov.w   DAT_0602d88c, r1       ! offset 0xE8 = residual field
    mov.l r6, @(r0, r1)            ! store residual for next frame
    rts
    nop

    .global DAT_0602d88c
DAT_0602d88c:
    .2byte  0x00E8

    .global sym_0602D88E
sym_0602D88E:                               ! render_regs_save: pipeline prologue
    mov.l r8, @-r15                 ! save callee-saved registers
    mov.l r9, @-r15
    mov.l r10, @-r15
    mov.l r11, @-r15
    mov.l r12, @-r15
    mov.l r13, @-r15
