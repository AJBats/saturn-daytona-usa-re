/* mat_euler_rotate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E6E0 - 0x0601E764
 * Auto-generated by tools/generate_l3_tu.py
 *
 * HUD element dispatch helper (simple variant) — brackets a vtable call
 * with SMPC RESDISA (0x1A) / RESENAB (0x19) for inter-CPU synchronization.
 *
 * This is the simpler sibling of mat_transpose (0x0601E770). It omits the
 * strlen/name-clamping preamble and calls vtable slot 6 (offset +24) instead
 * of slot 5 (offset +20).
 *
 * Flow:
 *   1. Polls SMPC SF, issues RESDISA (0x1A) to disable reset button.
 *   2. Waits for RESDISA completion.
 *   3. Reads the function dispatch table (sym_06000354), indexes into
 *      the HUD element array (sym_06087094, 0x20 bytes per element),
 *      and calls vtable slot 6 (offset +24) with the element's
 *      display ID from field +0x1C.
 *   4. Polls SMPC SF, issues RESENAB (0x19) to re-enable reset button.
 *   5. Waits for RESENAB completion and returns the dispatch result.
 *
 * Arguments:
 *   r4  = element index (saved to stack)
 *   r13 = (overwritten) loaded with SMPC SF address
 *   r14 = SMPC SF bit mask (typically 1, set by caller)
 *
 * Returns:
 *   r0 = result from vtable dispatch call
 *
 * Key data:
 *   sym_06000354 = function dispatch table pointer
 *   sym_06087094 = HUD element array (0x20 bytes per element)
 */

    .section .text.FUN_0601E6E0


    .global mat_euler_rotate
    .type mat_euler_rotate, @function
mat_euler_rotate:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r13, @-r15                    ! save r13 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes of stack frame
    mov.l   .L_smpc_sf, r13            ! r13 = 0x20100063 (SMPC SF register, cache-through)
    mov #0x1, r14                       ! r14 = 1 (SF busy flag / bit mask)
    mov.l r4, @r15                      ! stack[0] = element index (argument)
/* --- SMPC sync: wait for SF ready, issue RESDISA (0x1A) command --- */
.L_poll_sf_pre_resdisa:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend to 32 bits
    and r14, r2                         ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                      ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_pre_resdisa      ! spin while SMPC is busy
    extu.b r14, r2                      ! r2 = 1 (SF busy flag value)
    mov.b r2, @r13                      ! SF = 1 (set busy before issuing new command)
    mov #0x1A, r3                       ! 0x1A = SMPC RESDISA command (Reset Disable)
    mov.l   .L_smpc_comreg_ct, r2       ! r2 = 0x2010001F (SMPC COMREG, cache-through)
    mov.b r3, @r2                       ! write RESDISA command to COMREG
/* --- Wait for RESDISA completion --- */
.L_poll_resdisa_done:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend
    and r14, r2                         ! isolate bit 0
    tst r2, r2                          ! SF.bit0 == 0? (command completed)
    bf      .L_poll_resdisa_done        ! spin while busy
/* --- Read dispatch table and call vtable slot 6 for this HUD element --- */
    mov.l   .L_dispatch_table_ptr, r3   ! r3 = &dispatch_table_ptr (sym_06000354)
    mov.l @r15, r4                      ! r4 = element index (from stack)
    mov.l @r3, r3                       ! r3 = *dispatch_table_ptr (actual dispatch table)
    shll2 r4                            ! r4 = index * 4
    mov.l @(24, r3), r2                 ! r2 = dispatch_table[6] (vtable slot 6, offset +24)
    shll2 r4                            ! r4 = index * 16
    mov.l   .L_hud_element_array, r3    ! r3 = HUD element array base (sym_06087094)
    shll r4                             ! r4 = index * 32 (element stride = 0x20)
    add r3, r4                          ! r4 = &hud_element[index]
    mov.w @(28, r4), r0                 ! r0 = element[index].field_1C (display ID, word at +0x1C)
    mov r0, r4                          ! r4 = display_id
    jsr @r2                             ! call vtable_slot6(display_id)
    extu.w r4, r4                       ! (delay) zero-extend display_id to 32 bits
    mov r0, r4                          ! r4 = dispatch result (saved for return)
/* --- SMPC sync: wait for SF ready, issue RESENAB (0x19) command --- */
.L_poll_sf_pre_resenab:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend
    and r14, r2                         ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                      ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_pre_resenab      ! spin while busy
    extu.b r14, r2                      ! r2 = 1 (SF busy flag value)
    mov.b r2, @r13                      ! SF = 1 (set busy before issuing new command)
    mov #0x19, r3                       ! 0x19 = SMPC RESENAB command (Reset Enable)
    mov.l   .L_smpc_comreg_ct, r2       ! r2 = 0x2010001F (SMPC COMREG, cache-through)
    mov.b r3, @r2                       ! write RESENAB command to COMREG
/* --- Wait for RESENAB completion, then return --- */
.L_poll_resenab_done:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend
    and r14, r2                         ! isolate bit 0
    tst r2, r2                          ! SF.bit0 == 0? (command completed)
    bf      .L_poll_resenab_done        ! spin while busy
    mov r4, r0                          ! r0 = dispatch result (return value)
    add #0x4, r15                       ! deallocate 4 bytes of stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13 (callee-saved)
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14 (callee-saved)
    .2byte  0xFFFF
/* --- Constant pool --- */
.L_smpc_sf:
    .4byte  0x20100063                  /* SMPC SF — status flag */
.L_smpc_comreg_ct:
    .4byte  0x2010001F                  /* SMPC COMREG (cache-through) */
.L_dispatch_table_ptr:
    .4byte  sym_06000354                /* function dispatch table pointer */
.L_hud_element_array:
    .4byte  sym_06087094                /* HUD element array (0x20 bytes per element) */
