/* hud_state_machine.s -- HUD element state scanner & priority selector
 * Translation unit: 0x0601E4D4 - 0x0601E636
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Function catalog:
 *   hud_state_machine — Iterates over all active HUD elements, queries each
 *                       element's display state via SMPC-synchronized dispatch,
 *                       and returns the index of the highest-priority element
 *                       that needs attention.
 *
 * HUD element array (sym_06087094):
 *   Each element is 0x20 (32) bytes. Key fields:
 *     +0x1C (word) — element display ID (passed to dispatch function)
 *     +0x1E (byte) — "needs update" flag (non-zero = element requires refresh)
 *
 * Return values:
 *   0..2 — index of first element whose state "changed" (from dispatch result)
 *   3..5 — index of first element whose "needs update" flag is set (offset +3)
 *   8    — no element needs attention (idle state)
 *
 * SMPC synchronization:
 *   The function brackets each dispatch call with SMPC command sequences
 *   (RESDISA 0x1A / RESENAB 0x19) using SF flag polling. This provides
 *   inter-processor synchronization for shared HUD data access.
 */

    .section .text.FUN_0601E4D4


    .global hud_state_machine
    .type hud_state_machine, @function
hud_state_machine:
    mov.l r14, @-r15               ! save r14
    mov.l r13, @-r15               ! save r13
    mov.l r12, @-r15               ! save r12
    mov.l r11, @-r15               ! save r11
    mov.l r10, @-r15               ! save r10
    mov.l r9, @-r15                ! save r9
    mov.l r8, @-r15                ! save r8
    sts.l pr, @-r15                ! save return address
    add #-0xC, r15                 ! allocate 12 bytes: [r15]=update_buf_ptr, [r15+4..6]=update_flags[3], [r15+8..10]=changed_flags[3]

/* === Register assignments ===
 * r8  = 0 (zero constant)
 * r9  = &changed_flags[0]  (r15 + 8, 3 bytes on stack)
 * r10 = SMPC COMREG address (0x2010001F, cache-through)
 * r13 = SMPC SF address (COMREG + 0x44 = 0x20100063)
 * r14 = 1 (bit mask for SF polling)
 * r12 = loop index (0..element_count-1)
 * r11 = pointer to current HUD element (computed per iteration)
 */
    mov #0x0, r8                   ! r8 = 0 (zero constant, used throughout)
    mov r15, r9                    ! r9 -> stack base
    add #0x8, r9                   ! r9 = &changed_flags[0] (3-byte array at sp+8)
    mov.l   .L_smpc_comreg_ct, r10 ! r10 = 0x2010001F (SMPC COMREG, cache-through)
    mov r10, r13                   ! r13 = COMREG base
    add #0x44, r13                 ! r13 = 0x20100063 (SMPC SF register)
    mov #0x1, r14                  ! r14 = 1 (SF bit mask)
    mov r15, r3                    ! r3 -> stack base
    add #0x4, r3                   ! r3 = &update_flags[0] (3-byte array at sp+4)
    mov.l r3, @r15                 ! [sp+0] = &update_flags[0] (save pointer for later)

/* === Initialize both 3-byte flag arrays to zero ===
 * changed_flags[0..2] = 0   (at sp+8..10, pointed by r9)
 * update_flags[0..2]  = 0   (at sp+4..6, pointed by r3 via [sp+0])
 */
    mov r3, r5                     ! r5 = &update_flags[0]
    mov r9, r4                     ! r4 = &changed_flags[0]
    mov.b r8, @r5                  ! update_flags[0] = 0
    mov.b r8, @r4                  ! changed_flags[0] = 0
    add #0x1, r5                   ! r5 -> update_flags[1]
    add #0x1, r4                   ! r4 -> changed_flags[1]
    extu.b r8, r2                  ! r2 = 0 (zero-extended)
    mov.b r2, @r5                  ! update_flags[1] = 0
    mov.b r2, @r4                  ! changed_flags[1] = 0
    add #0x1, r5                   ! r5 -> update_flags[2]
    add #0x1, r4                   ! r4 -> changed_flags[2]
    mov.b r8, @r5                  ! update_flags[2] = 0
    mov.b r8, @r4                  ! changed_flags[2] = 0
    bra     .L_loop_check          ! jump to loop condition check
    mov r8, r12                    ! r12 = 0 (loop index, delay slot)

/* === Out-of-TU constant pool (not reached by execution) ===
 * These entries are referenced by .byte-encoded mov.l instructions
 * from adjacent TUs. They must remain in this exact order.
 */
    .4byte  sym_06087084           ! HUD element count (word)
    .4byte  sym_06000354           ! function dispatch table pointer
    .4byte  sym_06087094           ! HUD element array base (0x20 bytes each)
    .4byte  sym_060877D8           ! current player/car index (byte)
    .4byte  sym_0604A5C0           ! course size table (4 bytes per entry)
.L_smpc_comreg_ct:
    .4byte  0x2010001F             /* SMPC COMREG (cache-through) */

/* === Main loop body: process one HUD element per iteration ===
 * r12 = current element index (0..count-1)
 * Computes element pointer, queries its state through SMPC-synchronized
 * dispatch, then sets changed/update flags as appropriate.
 */
.L_loop_body:
    mov r12, r11                   ! r11 = element index
    shll2 r11                      ! r11 = index * 4
    shll2 r11                      ! r11 = index * 16
    shll r11                       ! r11 = index * 32 (element stride = 0x20)
    mov.l   .L_pool_element_array, r3 ! r3 = &hud_element_array base
    add r3, r11                    ! r11 = &hud_element[index] (pointer to current element)

/* --- SMPC sync: wait for SF ready, issue RESDISA (0x1A) command --- */
.L_poll_sf_set_a:
    mov.b @r13, r3                 ! read SMPC SF register
    extu.b r3, r3                  ! zero-extend
    and r14, r3                    ! isolate bit 0 (busy flag)
    cmp/eq r14, r3                 ! SF.bit0 == 1? (previous cmd still active)
    bt      .L_poll_sf_set_a       ! spin while busy
    mov.b r14, @r13                ! SF = 1 (acknowledge/set busy before new command)
    mov #0x1A, r2                  ! 0x1A = SMPC RESDISA command
    mov.b r2, @r10                 ! write command to COMREG
.L_poll_sf_clear_a:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0
    tst r2, r2                     ! SF.bit0 == 0? (command completed)
    bf      .L_poll_sf_clear_a     ! spin while busy

/* --- Call dispatch function to query element display state ---
 * Loads element's display ID from field +0x1C, then calls the
 * dispatch table function at offset +4 with (element_id, 0).
 */
    mov.l   .L_pool_dispatch_ptr, r3 ! r3 = &dispatch_table_ptr (sym_06000354)
    mov #0x0, r5                   ! r5 = 0 (second arg: query mode)
    mov.w @(28, r11), r0           ! r0 = element[index].field_1C (display ID, word)
    mov.l @r3, r3                  ! r3 = *dispatch_table_ptr (actual table address)
    mov r0, r4                     ! r4 = display_id (first arg)
    mov.l @(4, r3), r2             ! r2 = dispatch_table[1] (function pointer at offset +4)
    jsr @r2                        ! call dispatch_fn(display_id, 0)
    extu.w r4, r4                  ! zero-extend display_id to 32 bits (delay slot)

/* --- Call hud_render_stage to render the element ---
 * r4 = element display ID, r5 = pointer into course-specific buffer,
 * r6 = geometry output buffer ptr.
 * The BSR target is FUN_0601E764 (hud_render_stage).
 */
    mov.l   .L_pool_geom_output_ptr, r6 ! r6 = &geom_output_buf_ptr (sym_0605E098)
    mov.l   .L_pool_player_index, r5 ! r5 = &player_index (sym_060877D8)
    mov.l   .L_pool_course_name_table, r2 ! r2 = course_name_table base (sym_0604A57C)
    mov.w @(28, r11), r0           ! r0 = element[index].field_1C (display ID again)
    mov.l @r6, r6                  ! r6 = *geom_output_buf_ptr (actual buffer address)
    mov.b @r5, r5                  ! r5 = current player/car index byte
    extu.b r5, r5                  ! zero-extend player index
    mov r5, r3                     ! r3 = player_index (copy for stride calc)
    shll2 r5                       ! r5 = player_index * 4
    shll2 r3                       ! r3 = player_index * 4
    shll r3                        ! r3 = player_index * 8
    add r3, r5                     ! r5 = player_index * 12 (course name stride)
    add r2, r5                     ! r5 = &course_name[player_index] (12-byte string)
    .byte   0xB0, 0xF0    /* bsr 0x0601E764 (hud_render_stage) */
    mov r0, r4                     ! r4 = display_id (delay slot, arg for hud_render_stage)
    mov r0, r4                     ! r4 = return value from hud_render_stage (render result)

/* --- SMPC sync: wait for SF ready, issue RESENAB (0x19) command --- */
.L_poll_sf_set_b:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0
    cmp/eq r14, r2                 ! SF.bit0 == 1?
    bt      .L_poll_sf_set_b       ! spin while busy
    extu.b r14, r2                 ! r2 = 1
    mov.b r2, @r13                 ! SF = 1 (set busy before new command)
    mov #0x19, r3                  ! 0x19 = SMPC RESENAB command
    mov.b r3, @r10                 ! write command to COMREG
.L_poll_sf_clear_b:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0
    tst r2, r2                     ! SF.bit0 == 0? (command completed)
    bf      .L_poll_sf_clear_b     ! spin while busy

/* --- Check render result: if non-zero, element state changed --- */
    tst r4, r4                     ! render_result == 0?
    bf      .L_skip_changed_flag   ! non-zero: skip (element already handled)
    mov r12, r3                    ! r3 = element index
    add r9, r3                     ! r3 = &changed_flags[index]
    extu.b r14, r2                 ! r2 = 1
    mov.b r2, @r3                  ! changed_flags[index] = 1 (mark as changed)

/* --- Check element's "needs update" field at offset +0x1E --- */
.L_skip_changed_flag:
    mov #0x1E, r0                  ! offset 0x1E within element struct
    mov.b @(r0, r11), r0           ! r0 = element[index].needs_update_flag (byte at +0x1E)
    extu.b r0, r0                  ! zero-extend
    tst r0, r0                     ! needs_update == 0?
    bt      .L_next_element        ! yes: skip to next element
    mov r15, r3                    ! r3 -> stack base
    add #0x4, r3                   ! r3 = &update_flags[0]
    add r12, r3                    ! r3 = &update_flags[index]
    extu.b r14, r2                 ! r2 = 1
    mov.b r2, @r3                  ! update_flags[index] = 1 (mark for update)

.L_next_element:
    add #0x1, r12                  ! r12++ (advance to next element)

/* === Loop condition: compare index against element count === */
.L_loop_check:
    mov.l   .L_pool_element_count, r3 ! r3 = &element_count (sym_06087084)
    mov.w @r3, r3                  ! r3 = element_count (word value)
    extu.w r3, r3                  ! zero-extend to 32 bits
    cmp/ge r3, r12                 ! index >= count?
    bf      .L_loop_body           ! no: process next element

/* =========================================================================
 * Phase 2: Priority scan — find highest-priority element needing attention.
 * First scan changed_flags[0..2] — return index 0..2 if any set.
 * Then scan update_flags[0..2]  — return index 3..5 if any set.
 * If nothing found, return 8 (idle / no element needs attention).
 * ========================================================================= */
    mov r8, r4                     ! r4 = 0 (scan index for changed_flags)

/* --- Scan changed_flags array (priority 0..2) --- */
.L_scan_changed:
    mov r4, r3                     ! r3 = scan index
    add r9, r3                     ! r3 = &changed_flags[index]
    mov.b @r3, r0                  ! r0 = changed_flags[index]
    extu.b r0, r0                  ! zero-extend
    tst r0, r0                     ! flag == 0?
    bt      .L_changed_not_set     ! yes: try next
    bra     .L_return              ! no: this element changed — return its index
    extu.b r4, r0                  ! r0 = index (0..2, delay slot) — return value

.L_changed_not_set:
    add #0x1, r4                   ! r4++ (next changed flag)
    mov #0x3, r3                   ! r3 = 3 (max changed entries)
    cmp/ge r3, r4                  ! scanned all 3?
    bf      .L_scan_changed        ! no: continue scanning

/* --- Scan update_flags array (priority 3..5) --- */
    mov r15, r6                    ! r6 -> stack base
    mov.l @r15, r4                 ! r4 = &update_flags[0] (saved pointer from init)
    add #0x7, r6                   ! r6 = &update_flags[2]+1 (end sentinel: sp+7)
    cmp/hs r6, r4                  ! already past end? (shouldn't happen, but guard)
    bt/s    .L_no_update_found     ! yes: skip scan
    mov #0x3, r5                   ! r5 = 3 (base offset for update results, delay slot)

.L_scan_update:
    mov.b @r4, r0                  ! r0 = update_flags[index]
    extu.b r0, r0                  ! zero-extend
    tst r0, r0                     ! flag == 0?
    bt      .L_update_not_set      ! yes: try next
    bra     .L_return              ! no: this element needs update — return offset
    extu.b r5, r0                  ! r0 = r5 (3..5, delay slot) — return value

/* === Inline constant pool (must not be reordered) ===
 * These pool entries are referenced by mov.l instructions above via
 * PC-relative addressing. Their positions are fixed.
 */
.L_pool_element_array:
    .4byte  sym_06087094           ! HUD element array base (0x20 bytes per element)
.L_pool_dispatch_ptr:
    .4byte  sym_06000354           ! function dispatch table pointer (deref'd to get vtable)
.L_pool_geom_output_ptr:
    .4byte  sym_0605E098           ! geometry output buffer pointer (deref'd)
.L_pool_player_index:
    .4byte  sym_060877D8           ! current player/car index (byte)
.L_pool_course_name_table:
    .4byte  sym_0604A57C           ! course name string table (12 bytes per entry)
.L_pool_element_count:
    .4byte  sym_06087084           ! HUD element count (word at this address)

.L_update_not_set:
    add #0x1, r4                   ! r4++ (next update_flags entry)
    cmp/hs r6, r4                  ! past end of update array?
    bf/s    .L_scan_update         ! no: continue scanning
    add #0x1, r5                   ! r5++ (increment return offset, delay slot)

.L_no_update_found:
    mov #0x8, r0                   ! r0 = 8 (no element needs attention — idle)

/* === Function epilogue: restore registers and return === */
.L_return:
    add #0xC, r15                  ! free 12 bytes of stack
    lds.l @r15+, pr                ! restore return address
    mov.l @r15+, r8                ! restore r8
    mov.l @r15+, r9                ! restore r9
    mov.l @r15+, r10               ! restore r10
    mov.l @r15+, r11               ! restore r11
    mov.l @r15+, r12               ! restore r12
    mov.l @r15+, r13               ! restore r13
    rts                            ! return (r0 = priority index or 8)
    mov.l @r15+, r14               ! restore r14 (delay slot)
