/* ai_waypoint_pathfind -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06014D2C - 0x06014F34
 * Auto-generated by tools/generate_l3_tu.py
 *
 * AI waypoint pathfinding state machine -- evaluates AI car state against
 * waypoint ranges and dispatches waypoint handler calls for slots 8-15.
 * Followed by slot flag assignment based on object proximity.
 *
 * Persistent registers:
 *   r8  = &waypoint_state_word (16-bit state value)
 *   r9  = 8 (loop limit / slot count)
 *   r11 = slot table base (per-slot 8-byte entries)
 *   r12 = 16 (loop limit for waypoint handler calls)
 *   r13 = 1 (constant)
 *   r14 = &waypoint_phase (16-bit phase counter)
 *
 * State machine:
 *   1. If waypoint_disable flag set -> skip to post-pathfind
 *   2. If traffic light bit 11 (0x0800) clear -> skip to post-pathfind
 *   3. If race_complete bit 0 clear (path A):
 *      a. Check phase in (11..22): set flag, call handler 8x, advance phase
 *      b. Else check phase in [4..22): set state, advance phase by +18
 *   4. If race_complete bit 0 set (path B):
 *      a. Check phase in (11..23): set flag, call handler 8x, advance phase
 *      b. Else check phase in [4..23): set state, advance phase by +19
 *
 * Post-pathfind:
 *   - Optional obj_data_compact call (if compaction flag set)
 *   - BSR to external post-pathfind handler + vdp2_util_loop
 *   - Loop over 8 slots: check object[+44] proximity value against 0/0.5/1.0
 *     -> assign slot flags (0x44/0x48 for active, 0x4C/0x50 for inactive)
 *
 * Note: .word 0x0029/0x0129 are MOVT R0/R1 instructions (store T bit).
 * The L3 generator didn't decode these -- they compute boolean results
 * from the preceding CMP instructions.
 */

    .section .text.FUN_06014D2C


    .global ai_waypoint_pathfind
    .type ai_waypoint_pathfind, @function
ai_waypoint_pathfind:
    mov.l r14, @-r15                      ! save r14
    mov.l r13, @-r15                      ! save r13
    mov.l r12, @-r15                      ! save r12
    mov #0x10, r12                    /* r12 = 16 (handler call count) */
    mov.l r11, @-r15                      ! save r11
    mov.l r10, @-r15                      ! save r10
    mov.l r9, @-r15                       ! save r9
    mov #0x8, r9                      /* r9 = 8 (slot count) */
    mov.l r8, @-r15                       ! save r8
    sts.l pr, @-r15                       ! save return address
    mov.l   .L_pool_waypoint_state_word, r8   ! r8 = &waypoint_state_word
    mov.l   .L_pool_slot_table, r11       ! r11 = slot table base
    mov.l   .L_pool_waypoint_phase, r14   ! r14 = &waypoint_phase
    mov.l   .L_pool_waypoint_disable, r4  ! r4 = &waypoint_disable flag
    mov.b @r4, r3                         ! r3 = waypoint_disable flag value
    tst r3, r3                            ! test if disabled
    bt/s    .L_check_traffic_light        /* not disabled -> check traffic light */
    mov #0x1, r13                     /* r13 = 1 */
    bra     .L_post_pathfind              /* disabled -> skip to post-pathfind */
    nop
.L_check_traffic_light:
    mov.l   .L_pool_traffic_light_state, r3   ! r3 = &traffic light state register
    mov.w @r3, r2                         ! r2 = traffic light state word
    mov.w   DAT_06014de4, r3         /* 0x0800 = light state bit 11 */
    extu.w r2, r2                         ! zero-extend to 32 bits
    and r3, r2                            ! isolate bit 11
    tst r2, r2                            ! test if light bit set
    bf      .L_race_flag_dispatch         /* light active -> proceed */
    bra     .L_post_pathfind              /* light inactive -> skip */
    nop
.L_race_flag_dispatch:                        /* --- race complete flag dispatch --- */
    mov #0x4, r7                          ! r7 = 4 (wide-range lower threshold)
    mov.l   .L_pool_race_complete_flag, r3    ! r3 = &race_complete_flag
    mov.l @r3, r3                         ! r3 = race_complete_flag value
    and r13, r3                       /* check bit 0 */
    tst r3, r3                            ! test race complete bit 0
    bf/s    .L_path_b_race_complete       /* bit 0 set -> path B */
    mov #0xB, r6                      /* r6 = 11 (lower threshold) */
    mov.w @r14, r5                    /* --- path A: race incomplete --- */
    extu.w r5, r5                         ! zero-extend phase
    cmp/gt r6, r5                     /* phase > 11? */
    .word 0x0029 /* movt r0 -- T = (phase > 11) */
    mov #0x16, r3                     /* 22 = upper threshold */
    cmp/ge r3, r5                     /* phase >= 22? */
    .word 0x0129 /* movt r1 -- T = (phase >= 22) */
    add #-0x1, r1                         ! r1 = (phase >= 22) - 1
    neg r1, r1                        /* r1 = !r1 (invert: phase < 22) */
    and r1, r0                        /* r0 = (phase > 11) AND (phase < 22) */
    tst r0, r0                            ! test combined range result
    bt      .L_path_a_wide_range          /* not in range -> check wider range */
    exts.b r13, r3                        ! r3 = 1 (sign-extended byte)
    mov.b r3, @r4                     /* set waypoint disable flag */
    extu.b r9, r10                    /* r10 = 8 (start slot) */
.L_path_a_handler_loop:                       /* call handler for slots 8-15 */
    mov.l   .L_pool_fn_waypoint_handler_a, r3 ! load handler function address
    jsr @r3                            /* waypoint_handler(slot_index) */
    extu.b r10, r4                        ! r4 = slot index arg (delay slot)
    add #0x1, r10                         ! advance to next slot
    extu.b r10, r2                        ! r2 = current slot (zero-extended)
    cmp/ge r12, r2                    /* slot < 16? */
    bf      .L_path_a_handler_loop        ! loop if more slots remain
    exts.w r13, r2                        ! r2 = 1 (sign-extended word)
    mov.w r2, @r8                     /* state_word = 1 */
    mov #0x14, r2                     /* 20 = phase threshold */
    mov.w @r14, r3                        ! r3 = current phase
    extu.w r3, r3                         ! zero-extend phase
    cmp/gt r2, r3                     /* phase > 20? */
    bf/s    .L_path_a_write_phase         ! phase <= 20 -> use default
    mov #0x20, r4                     /* default next phase = 0x20 */
    mov #0x22, r4                     /* phase > 20 -> next = 0x22 */
.L_path_a_write_phase:
    extu.b r4, r4                         ! zero-extend phase value
    bra     .L_post_pathfind              ! jump to post-pathfind
    mov.w r4, @r14                    /* update phase */
.L_path_a_wide_range:                         /* --- check wider range [4..22) --- */
    mov.w @r14, r5                        ! r5 = current phase
    extu.w r5, r5                         ! zero-extend
    cmp/ge r7, r5                     /* phase >= 4? */
    .word 0x0029 /* movt r0 */
    mov #0x16, r3                         ! r3 = 22 (upper threshold)
    cmp/ge r3, r5                     /* phase >= 22? */
    .word 0x0129 /* movt r1 */
    add #-0x1, r1                         ! r1 = (phase >= 22) - 1
    neg r1, r1                            ! r1 = !(phase >= 22) = (phase < 22)
    and r1, r0                        /* (phase >= 4) AND (phase < 22) */
    tst r0, r0                            ! test combined result
    bt      .L_path_a_skip               /* not in range -> skip */
    mov.b r13, @r4                    /* set disable flag */
    exts.w r13, r2                        ! r2 = 1 (sign-extended)
    mov.w r2, @r8                     /* state_word = 1 */
    mov.w @r14, r3                        ! r3 = current phase
    extu.w r3, r3                         ! zero-extend
    add #0x12, r3                     /* phase += 18 */
    extu.w r3, r3                         ! zero-extend result
    mov.w r3, @r14                        ! write updated phase
.L_path_a_skip:
    bra     .L_post_pathfind              ! jump to post-pathfind
    nop

    .global DAT_06014de4
DAT_06014de4:
    .2byte  0x0800                        /* traffic light state bit 11 mask */
    .2byte  0xFFFF
.L_pool_waypoint_state_word:
    .4byte  sym_06085F94               /* waypoint state word (16-bit) */
.L_pool_slot_table:
    .4byte  sym_06063F64               /* per-slot data table base */
.L_pool_waypoint_phase:
    .4byte  sym_06085F90               /* waypoint phase counter (16-bit) */
.L_pool_waypoint_disable:
    .4byte  sym_06085F89               /* waypoint disable flag (byte) */
.L_pool_traffic_light_state:
    .4byte  sym_06063D9A               /* traffic light state register */
.L_pool_race_complete_flag:
    .4byte  sym_0607EBF4               /* race complete flag (bit 0 checked) */
.L_pool_fn_waypoint_handler_a:
    .4byte  sym_060172E4               /* waypoint handler function */
.L_path_b_race_complete:                      /* --- path B: race complete --- */
    mov.w @r14, r5                        ! r5 = current phase
    extu.w r5, r5                         ! zero-extend
    cmp/gt r6, r5                     /* phase > 11? */
    .word 0x0029 /* movt r0 */
    mov #0x17, r3                     /* 23 = upper threshold (vs 22 in path A) */
    cmp/ge r3, r5                         ! phase >= 23?
    .word 0x0129 /* movt r1 */
    add #-0x1, r1                         ! r1 = (phase >= 23) - 1
    neg r1, r1                            ! r1 = !(phase >= 23) = (phase < 23)
    and r1, r0                        /* (phase > 11) AND (phase < 23) */
    tst r0, r0                            ! test combined range result
    bt      .L_path_b_wide_range          /* not in range -> check wider */
    exts.b r13, r3                        ! r3 = 1 (sign-extended byte)
    mov.b r3, @r4                     /* set disable flag */
    extu.b r9, r10                        ! r10 = 8 (start slot)
.L_path_b_handler_loop:                       /* call handler for slots 8-15 */
    mov.l   .L_pool_fn_waypoint_handler_b, r3 ! load handler function address
    jsr @r3                               ! waypoint_handler(slot_index)
    extu.b r10, r4                        ! r4 = slot index arg (delay slot)
    add #0x1, r10                         ! advance to next slot
    extu.b r10, r2                        ! r2 = current slot (zero-extended)
    cmp/ge r12, r2                        ! slot >= 16?
    bf      .L_path_b_handler_loop        ! loop if more slots remain
    exts.w r13, r2                        ! r2 = 1 (sign-extended word)
    mov.w r2, @r8                     /* state_word = 1 */
    mov #0x14, r2                         ! r2 = 20 (phase threshold)
    mov.w @r14, r3                        ! r3 = current phase
    extu.w r3, r3                         ! zero-extend phase
    cmp/gt r2, r3                         ! phase > 20?
    bf/s    .L_path_b_write_phase         ! phase <= 20 -> use default
    mov #0x23, r4                     /* default = 0x23 */
    mov #0x26, r4                     /* phase > 20 -> 0x26 */
.L_path_b_write_phase:
    extu.b r4, r4                         ! zero-extend phase value
    bra     .L_post_pathfind              ! jump to post-pathfind
    mov.w r4, @r14                        ! write updated phase
.L_path_b_wide_range:                         /* --- wider range check [4..23) --- */
    mov.w @r14, r5                        ! r5 = current phase
    extu.w r5, r5                         ! zero-extend
    cmp/ge r7, r5                     /* phase >= 4? */
    .word 0x0029 /* movt r0 */
    mov #0x17, r3                         ! r3 = 23 (upper threshold)
    cmp/ge r3, r5                         ! phase >= 23?
    .word 0x0129 /* movt r1 */
    add #-0x1, r1                         ! r1 = (phase >= 23) - 1
    neg r1, r1                            ! r1 = !(phase >= 23) = (phase < 23)
    and r1, r0                            ! r0 = (phase >= 4) AND (phase < 23)
    tst r0, r0                            ! test combined result
    bt      .L_post_pathfind              /* not in range -> skip */
    mov.b r13, @r4                        ! set disable flag
    exts.w r13, r2                        ! r2 = 1 (sign-extended)
    mov.w r2, @r8                     /* state_word = 1 */
    mov.w @r14, r3                        ! r3 = current phase
    extu.w r3, r3                         ! zero-extend
    add #0x13, r3                     /* phase += 19 (vs 18 in path A) */
    extu.w r3, r3                         ! zero-extend result
    mov.w r3, @r14                        ! write updated phase
.L_post_pathfind:                             /* === Post-pathfind processing === */
    mov.l   .L_pool_compact_flag, r0      ! r0 = &compact_flag
    mov.b @r0, r0                         ! r0 = compact_flag value
    tst r0, r0                            ! test if compaction needed
    bt      .L_skip_compact               /* no compaction needed */
    mov.l   .L_pool_fn_obj_compact, r3    ! load obj_data_compact address
    jsr @r3                            /* obj_data_compact() */
    nop
.L_skip_compact:
    .byte   0xB0, 0x59    /* bsr 0x06014F34 (external) -- post-pathfind handler */
    nop
    mov.l   .L_pool_fn_vdp2_util, r3     ! load vdp2_util_loop address
    jsr @r3                            /* vdp2_util_loop() */
    nop
    mov.l   .L_pool_active_slot_idx, r5  /* --- slot flag assignment loop --- */
    mov #0x0, r4                      /* r4 = slot iterator */
    mov.l @r5, r5                     /* r5 = active slot index */
    mov r5, r10                           ! r10 = active slot index
    add #0x6, r10                     /* r10 = slot + 6 */
    shll2 r10                             ! r10 *= 4
    shll r10                          /* r10 = (slot+6) * 8 */
    add r11, r10                      /* r10 -> slot_table[slot+6] */
.L_slot_loop:                                 /* --- per-slot iteration --- */
    extu.b r4, r6                         ! r6 = idx (zero-extended)
    mov.l   .L_pool_slot_data_base, r2   ! r2 = slot data array base
    mov r6, r3                            ! r3 = idx (for stride calc)
    shll2 r6                          /* idx * 4 */
    shll2 r3                              ! idx * 4
    shll2 r3                              ! idx * 16
    shll2 r3                          /* idx * 64 */
    add r3, r6                        /* idx * 68 (entry stride) */
    exts.w r6, r6                         ! sign-extend offset
    add r2, r6                        /* r6 -> slot_data[idx] */
    mov.l @(44, r6), r6              /* slot_data[idx][+44] = proximity value */
    tst r6, r6                        /* value == 0? */
    .word 0x0029 /* movt r0 -- T = (value == 0) */
    xor #0x1, r0                      /* invert: r0 = (value != 0) */
    mov.l   .L_pool_fp_half, r3      /* 0.5 in 16.16 */
    cmp/eq r3, r6                     /* value == 0.5? */
    .word 0x0129 /* movt r1 */
    add #-0x1, r1                         ! r1 = (value == 0.5) - 1
    mov.l   .L_pool_fp_one, r3       /* 1.0 in 16.16 */
    neg r1, r1                        /* r1 = !(value == 0.5) */
    and r1, r0                        /* r0 = (value != 0) AND (value != 0.5) */
    cmp/eq r3, r6                     /* value == 1.0? */
    .word 0x0129 /* movt r1 */
    add #-0x1, r1                         ! r1 = (value == 1.0) - 1
    neg r1, r1                        /* r1 = !(value == 1.0) */
    and r1, r0                        /* r0 = nonzero AND not 0.5 AND not 1.0 */
    tst r0, r0                            ! test if special value
    bt      .L_slot_inactive_flags        /* special value -> use alternate flags */
    extu.b r4, r3                     /* --- non-special: active flags --- */
    add r5, r3                        /* slot + idx */
    shll2 r3                              ! (slot + idx) * 4
    shll r3                           /* * 8 */
    add r11, r3                       /* -> slot_table entry */
    mov #0x44, r2                         ! r2 = 0x44 (active flag A)
    mov r2, r0                            ! r0 = active flag A
    mov.w r0, @(6, r3)               /* entry[+6] = 0x44 (active flag A) */
    bra     .L_slot_write_flag_b          ! jump to write flag B
    mov #0x48, r0                     /* active flag B = 0x48 */
.L_slot_inactive_flags:                       /* --- special value: inactive flags --- */
    extu.b r4, r2                         ! r2 = idx (zero-extended)
    add r5, r2                            ! r2 = slot + idx
    shll2 r2                              ! (slot + idx) * 4
    shll r2                               ! (slot + idx) * 8
    add r11, r2                           ! r2 -> slot_table entry
    mov #0x4C, r0                         ! r0 = 0x4C (inactive flag A)
    mov.w r0, @(6, r2)               /* entry[+6] = 0x4C (inactive flag A) */
    mov #0x50, r3                         ! r3 = 0x50 (inactive flag B)
    mov r3, r0                        /* inactive flag B = 0x50 */
.L_slot_write_flag_b:
    add #0x1, r4                          ! advance slot iterator
    extu.b r4, r3                         ! r3 = idx (zero-extended)
    cmp/ge r9, r3                     /* idx < 8? */
    bf/s    .L_slot_loop              /* -> next slot */
    mov.w r0, @(6, r10)              /* write flag B to reference slot */
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r8                       ! restore r8
    mov.l @r15+, r9                       ! restore r9
    mov.l @r15+, r10                      ! restore r10
    mov.l @r15+, r11                      ! restore r11
    mov.l @r15+, r12                      ! restore r12
    mov.l @r15+, r13                      ! restore r13
    rts                                   ! return
    mov.l @r15+, r14                      ! restore r14 (delay slot)
    .2byte  0xFFFF
.L_pool_fn_waypoint_handler_b:
    .4byte  sym_060172E4               /* waypoint handler (dup for reach) */
.L_pool_compact_flag:
    .4byte  sym_06085F8A               /* object compaction needed flag (byte) */
.L_pool_fn_obj_compact:
    .4byte  obj_data_compact           /* object data compaction function */
.L_pool_fn_vdp2_util:
    .4byte  vdp2_util_loop             /* VDP2 utility loop */
.L_pool_active_slot_idx:
    .4byte  sym_06085F98               /* active slot index (ptr, dereferenced) */
.L_pool_slot_data_base:
    .4byte  sym_06084FC8               /* slot data array base */
.L_pool_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
