/* disp_util_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060330A4 - 0x06033100
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Display element position delta calculator.
 * Reads current and previous X/Y positions from two indexed tables,
 * computes deltas with 1.5x scaling (val + val>>1), clamps against
 * thresholds, and prepares smoothed offset for display scrolling.
 */

    .section .text.FUN_060330A4


    .global disp_util_main
    .type disp_util_main, @function
disp_util_main:
    sts.l pr, @-r15                     ! save return address
    .byte   0xB0, 0x61    /* bsr 0x0603316C (external) */
    nop                                 ! delay slot: call display index helper
    lds.l @r15+, pr                     ! restore return address
    .byte   0xD8, 0x26    /* mov.l .L_pool_06033148, r8 */
    .byte   0xD9, 0x27    /* mov.l .L_pool_0603314C, r9 */
    mov.l @(r0, r8), r13                ! r13 = prev X position from table A
    mov.l @(r0, r9), r14                ! r14 = prev Y position from table B
    .byte   0xDA, 0x26    /* mov.l .L_pool_06033150, r10 */
    add r10, r0                         ! r0 += offset to next frame slot
    .byte   0xD7, 0x26    /* mov.l .L_pool_06033154, r7 */
    mov.l @r7, r7                       ! r7 = deref pointer to frame counter ptr
    mov.l @r7, r7                       ! r7 = deref frame counter value
    add #-0x1, r7                       ! r7 = frame_count - 1
    mov.l @(r0, r8), r11                ! r11 = current X position from table A
    mov.l @(r0, r9), r12                ! r12 = current Y position from table B
    neg r11, r11                        ! r11 = -current_x
    neg r12, r12                        ! r12 = -current_y
    add r13, r11                        ! r11 = prev_x - current_x (delta X)
    add r14, r12                        ! r12 = prev_y - current_y (delta Y)
    mov r11, r4                         ! r4 = delta_x
    shar r4                             ! r4 = delta_x >> 1 (arithmetic shift right)
    add r4, r11                         ! r11 = delta_x + delta_x/2 = delta_x * 1.5
    mov r12, r4                         ! r4 = delta_y (saved for later use)
    mov r11, r1                         ! r1 = scaled delta_x
    .byte   0xD2, 0x20    /* mov.l .L_pool_06033158, r2 */
    cmp/pz r1                           ! is scaled delta_x >= 0?
    bt      .L_abs_dx_positive          ! if positive, skip negate
    neg r1, r1                          ! r1 = abs(scaled delta_x)
.L_abs_dx_positive:
    cmp/gt r2, r1                       ! abs(delta_x) > x_threshold?
    .byte   0x89, 0x29    /* bt 0x06033136 (external) */
    mov r12, r1                         ! r1 = delta_y
    .byte   0xD2, 0x1D    /* mov.l .L_pool_0603315C, r2 */
    cmp/pz r1                           ! is delta_y >= 0?
    bt      .L_abs_dy_positive          ! if positive, skip negate
    neg r1, r1                          ! r1 = abs(delta_y)
.L_abs_dy_positive:
    cmp/gt r2, r1                       ! abs(delta_y) > y_threshold?
    .byte   0x89, 0x22    /* bt 0x06033136 (external) */
    mov.l r0, @-r15                     ! save r0 (table index) on stack
    mov.l r6, @-r15                     ! save r6 on stack
    sts.l pr, @-r15                     ! save return address
    .byte   0xB0, 0x39    /* bsr 0x0603316C (external) */
    nop                                 ! delay slot: call display index helper again
    lds.l @r15+, pr                     ! restore return address
    neg r6, r0                          ! r0 = -r6 (negate display offset result)
    mov.l @r15+, r6                     ! restore r6 from stack
