/* game_state_dispatch — main game state machine dispatcher
 * Translation unit: 0x0600F424 - 0x0600F650
 *
 * Top-level per-frame state dispatch. Reads game_state byte from
 * sym_0607887F and calls the corresponding handler via jump table
 * at sym_0605AC2C. Surrounding logic handles:
 *
 *   - State 9: special pre-race setup (VDP2 color RAM DMA + display init)
 *   - States 0-4: same as state 9 but with shorter param set
 *   - States >= 0xA: controller input polling — reads button words
 *     from sym_06063D98 and masks them against 4 different bit fields
 *     (sym_06078656/58/5A/5C) to determine selected mode (0-3), stored
 *     in sym_06078648
 *   - States 9-11: HUD tile data DMA for split-screen or single modes
 *   - Post-dispatch: bsr external helper, then decrements frame budget
 *     counter at sym_06089EDC by 0x30, tail-calls frame_end_commit
 *
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 */

    .section .text.FUN_0600F424


    .global game_state_dispatch
    .type game_state_dispatch, @function
game_state_dispatch:
    mov.l r14, @-r15                     ! save r14
    mov #0x4, r3                         ! r3 = 0x4 (threshold for state <= 4)
    mov.l r13, @-r15                     ! save r13
    mov.l r12, @-r15                     ! save r12
    sts.l pr, @-r15                      ! save PR
    add #-0x4, r15                       ! allocate 4 bytes on stack
    mov.l   .L_ptr_game_state, r14       ! r14 → &game_state byte
    mov.b @r14, r4                       ! r4 = game_state (signed)
    extu.b r4, r4                        ! r4 = game_state (unsigned 0-255)
    cmp/gt r3, r4                        ! state > 4?
    bf      .L_state_le_4               ! if state <= 4, go handle palette
    mov r4, r0                           ! r0 = state (for cmp/eq imm)
    cmp/eq #0x9, r0                      ! state == 9?
    bf      .L_check_input_poll          ! state 5-8: skip palette, go to input
.L_state_le_4:                               ! --- states 0-4 and 9: palette setup ---
    mov.b @r14, r0                       ! r0 = game_state
    extu.b r0, r0                        ! zero-extend
    cmp/eq #0x9, r0                      ! state == 9?
    bf      .L_state_not_9               ! no: use shorter param set
    mov.l   .L_ptr_attract_countdown, r1 ! r1 → &attract_countdown
    mov.l   .L_fn_model_data_lookup, r2  ! r2 → model_data_lookup()
    mov.l @r1, r1                        ! r1 = attract_countdown value
    jsr @r2                              ! call model_data_lookup(r1, 0x3C)
    mov #0x3C, r0                        ! (delay) r0 = 0x3C (palette count)
    mov r0, r7                           ! r7 = 0x3C
    mov #0x18, r6                        ! r6 = 0x18 (stride)
    mov.w   .L_const_palette_size, r5    ! r5 = 0x0148 (palette byte count)
    mov.l   .L_fn_display_layer_init, r3 ! r3 → display_layer_init()
    jsr @r3                              ! call display_layer_init(0xC, 0x148, 0x18, 0x3C)
    mov #0xC, r4                         ! (delay) r4 = 0xC (layer count)
    bra     .L_check_input_poll          ! done with state 9 palette path
    nop                                  ! (delay)
.L_const_palette_size:
    .2byte  0x0148                       ! palette byte count for state 9
    .4byte  0x25F00720                   ! VDP2 color RAM +0x720 (course ext A)
    .4byte  sym_060487CC                 ! WRAM palette source data A
    .4byte  0x25F00680                   ! VDP2 color RAM +0x680
    .4byte  0x25F00140                   ! VDP2 color RAM +0x140 (bank 6)
    .4byte  sym_060483EC                 ! WRAM palette source data B
    .4byte  0x25F000C0                   ! VDP2 color RAM +0x0C0
    .4byte  0x25F006C0                   ! VDP2 color RAM +0x6C0 (course bank)
    .4byte  sym_0605AAA0                 ! VDP2 scroll position state
.L_ptr_game_state:
    .4byte  sym_0607887F                 ! → game_state byte (8-bit)
    .4byte  sym_0605B6D8                 ! → render mode flags (32-bit)
    .4byte  0x40000000                   ! bit 30 mask ("race ready" flag)
    .4byte  sym_06026CE0                 ! → camera state finalization fn
    .4byte  sym_06059F44                 ! → animation state (32-bit)
.L_ptr_attract_countdown:
    .4byte  sym_0607EBCC                 ! → attract mode countdown (32-bit)
.L_fn_model_data_lookup:
    .4byte  sym_06034FE0                 ! → model/data lookup function
.L_fn_display_layer_init:
    .4byte  sym_06028430                 ! → display layer init function
.L_state_not_9:                              ! --- states 0-4 (not 9): shorter palette ---
    mov.l   .L_ptr_attract_countdown_b, r1 ! r1 → &attract_countdown
    mov.l   .L_fn_model_data_lookup_b, r2  ! r2 → model_data_lookup()
    mov.l @r1, r1                        ! r1 = attract_countdown value
    jsr @r2                              ! call model_data_lookup(r1, 0x3C)
    mov #0x3C, r0                        ! (delay) r0 = 0x3C
    mov r0, r7                           ! r7 = 0x3C
    mov #0x18, r6                        ! r6 = 0x18 (stride)
    mov.w   .L_const_palette_size_b, r5  ! r5 = 0x0148 (palette byte count)
    mov.l   .L_fn_display_layer_init_b, r3 ! r3 → display_layer_init()
    jsr @r3                              ! call display_layer_init(0x8, 0x148, 0x18, 0x3C)
    mov #0x8, r4                         ! (delay) r4 = 0x8 (fewer layers)
.L_check_input_poll:                         ! --- input poll for mode select (states >= 0xA) ---
    mov #0xA, r3                         ! r3 = 0xA (threshold)
    mov.b @r14, r2                       ! r2 = game_state
    extu.b r2, r2                        ! zero-extend
    cmp/ge r3, r2                        ! state >= 0xA?
    bf      .L_check_hud_tile_dma        ! no: skip input polling
    mov.l   .L_ptr_timer_half_word, r3   ! r3 → &timer_half_word
    mov.l   .L_fp_half, r2              ! r2 = 0x8000 (expected timer value)
    mov.w @r3, r3                        ! r3 = timer_half_word (16-bit)
    extu.w r3, r3                        ! zero-extend
    cmp/eq r2, r3                        ! timer == 0x8000?
    bf      .L_check_hud_tile_dma        ! no: not ready for input
    mov.l   .L_ptr_input_lock_flag, r0   ! r0 → &input_lock_flag
    mov.b @r0, r0                        ! r0 = input_lock_flag
    tst r0, r0                           ! locked?
    bf      .L_check_hud_tile_dma        ! yes: skip input
    mov.l   .L_ptr_button_state, r4      ! r4 → &button_state_word
    mov.l   .L_ptr_mode_select_result, r5 ! r5 → &mode_select_result
    mov.l   .L_ptr_btn_mask_a, r2        ! r2 → &btn_mask_a
    mov.w @r4, r4                        ! r4 = button_state (16-bit)
    mov.w @r2, r2                        ! r2 = btn_mask_a (16-bit)
    exts.w r4, r3                        ! r3 = buttons (sign-extended)
    extu.w r2, r2                        ! r2 = mask_a (zero-extended)
    and r2, r3                           ! r3 = buttons & mask_a
    tst r3, r3                           ! any mask_a bits pressed?
    bt      .L_check_btn_mask_b          ! no: try next mask
    mov #0x0, r3                         ! mode = 0
    mov.b r3, @r5                        ! *mode_select_result = 0
    bra     .L_check_hud_tile_dma        ! done
    nop                                  ! (delay)
.L_check_btn_mask_b:                         ! --- test button mask B ---
    exts.w r4, r2                        ! r2 = buttons (sign-extended)
    mov.l   .L_ptr_btn_mask_b, r3        ! r3 → &btn_mask_b
    mov.w @r3, r3                        ! r3 = btn_mask_b (16-bit)
    extu.w r3, r3                        ! zero-extend
    and r3, r2                           ! r2 = buttons & mask_b
    tst r2, r2                           ! any mask_b bits pressed?
    bt      .L_check_btn_mask_c          ! no: try next mask
    mov #0x1, r3                         ! mode = 1
    mov.b r3, @r5                        ! *mode_select_result = 1
    bra     .L_check_hud_tile_dma        ! done
    nop                                  ! (delay)
.L_check_btn_mask_c:                         ! --- test button mask C ---
    exts.w r4, r2                        ! r2 = buttons (sign-extended)
    mov.l   .L_ptr_btn_mask_c, r3        ! r3 → &btn_mask_c
    mov.w @r3, r3                        ! r3 = btn_mask_c (16-bit)
    extu.w r3, r3                        ! zero-extend
    and r3, r2                           ! r2 = buttons & mask_c
    tst r2, r2                           ! any mask_c bits pressed?
    bt      .L_check_btn_mask_d          ! no: try last mask
    mov #0x2, r3                         ! mode = 2
    mov.b r3, @r5                        ! *mode_select_result = 2
    bra     .L_check_hud_tile_dma        ! done
    nop                                  ! (delay)
.L_const_palette_size_b:
    .2byte  0x0148                       ! palette byte count for states 0-4
    .2byte  0xFFFF                       ! padding / alignment
.L_ptr_attract_countdown_b:
    .4byte  sym_0607EBCC                 ! → attract mode countdown (32-bit)
.L_fn_model_data_lookup_b:
    .4byte  sym_06034FE0                 ! → model/data lookup function
.L_fn_display_layer_init_b:
    .4byte  sym_06028430                 ! → display layer init function
.L_ptr_timer_half_word:
    .4byte  sym_0607865E                 ! → timer half-word (16-bit, 0x8000 = ready)
.L_fp_half:
    .4byte  0x00008000                   ! 0.5 (16.16 fixed-point) / timer ready value
.L_ptr_input_lock_flag:
    .4byte  sym_0605AB18                 ! → input lock flag (byte, nonzero = locked)
.L_ptr_button_state:
    .4byte  sym_06063D98                 ! → controller button state word (16-bit)
.L_ptr_mode_select_result:
    .4byte  sym_06078648                 ! → mode select result (byte, 0-3)
.L_ptr_btn_mask_a:
    .4byte  sym_06078656                 ! → button mask A (16-bit, mode 0)
.L_ptr_btn_mask_b:
    .4byte  sym_06078658                 ! → button mask B (16-bit, mode 1)
.L_ptr_btn_mask_c:
    .4byte  sym_0607865A                 ! → button mask C (16-bit, mode 2)
.L_check_btn_mask_d:                         ! --- test button mask D ---
    exts.w r4, r4                        ! r4 = buttons (sign-extended)
    mov.l   .L_ptr_btn_mask_d, r2        ! r2 → &btn_mask_d
    mov.w @r2, r2                        ! r2 = btn_mask_d (16-bit)
    extu.w r2, r2                        ! zero-extend
    and r2, r4                           ! r4 = buttons & mask_d
    tst r4, r4                           ! any mask_d bits pressed?
    bt      .L_check_hud_tile_dma        ! no: no mode selected
    mov #0x3, r3                         ! mode = 3
    mov.b r3, @r5                        ! *mode_select_result = 3
.L_check_hud_tile_dma:                       ! --- HUD tile DMA (states 9-11) ---
    mov #0xC, r2                         ! r2 = 0xC (upper bound)
    mov.b @r14, r4                       ! r4 = game_state
    extu.b r4, r4                        ! zero-extend
    cmp/ge r2, r4                        ! state >= 0xC?
    bt      .L_dispatch_state_handler    ! yes: skip tile DMA
    mov #0x8, r2                         ! r2 = 0x8 (lower bound)
    cmp/gt r2, r4                        ! state > 0x8? (i.e. state 9-11)
    bf      .L_dispatch_state_handler    ! no: skip tile DMA
    mov.w   DAT_0600f612, r13           ! r13 = 0x08A4 (tile source offset A)
    mov.l   .L_ptr_attract_timer, r0     ! r0 → &attract_timer
    mov.l @r0, r0                        ! r0 = attract_timer value
    tst r0, r0                           ! attract_timer == 0?
    bt      .L_tile_dma_split            ! yes: use split-screen tile path
    mov.l   .L_ptr_display_mode, r0      ! r0 → &display_mode
    mov.l @r0, r0                        ! r0 = display_mode
    cmp/eq #0x1, r0                      ! display_mode == 1?
    bf      .L_tile_dma_mode_b           ! no: use mode B tile data
    mov.l   .L_ptr_tile_data_src_a, r2   ! r2 → tile_data_src_a struct
    mov r13, r6                          ! r6 = 0x08A4 (tile offset A)
    mov.l r2, @r15                       ! save struct ptr on stack
    mov r2, r7                           ! r7 = struct base (for @(4,r7))
    mov r2, r5                           ! r5 = struct base (for @r5)
    mov.w   DAT_0600f614, r3            ! r3 = 0x5000 (VRAM offset)
    mov.l @(4, r7), r7                   ! r7 = struct[1] (dest addr)
    mov.l @r5, r5                        ! r5 = struct[0] (src addr)
    add r3, r7                           ! r7 += 0x5000 (final dest)
    mov.l   .L_fn_display_list_load, r3  ! r3 → display_list_load()
    jsr @r3                              ! call display_list_load(0xC, r5, r6, r7)
    mov #0xC, r4                         ! (delay) r4 = 0xC (count)
    bra     .L_dispatch_state_handler    ! done with tile DMA
    nop                                  ! (delay)
.L_tile_dma_mode_b:                          ! --- tile DMA mode B (display_mode != 1) ---
    mov.l   .L_ptr_tile_data_src_b, r2   ! r2 → tile_data_src_b struct
    mov r13, r6                          ! r6 = 0x08A4 (tile offset A)
    mov.l r2, @r15                       ! save struct ptr on stack
    mov r2, r7                           ! r7 = struct base
    mov r2, r5                           ! r5 = struct base
    mov.w   DAT_0600f614, r3            ! r3 = 0x5000 (VRAM offset)
    mov.l @(4, r7), r7                   ! r7 = struct[1] (dest addr)
    mov.l @r5, r5                        ! r5 = struct[0] (src addr)
    add r3, r7                           ! r7 += 0x5000 (final dest)
    mov.l   .L_fn_display_list_load, r3  ! r3 → display_list_load()
    jsr @r3                              ! call display_list_load(0xC, r5, r6, r7)
    mov #0xC, r4                         ! (delay) r4 = 0xC (count)
    bra     .L_dispatch_state_handler    ! done with tile DMA
    nop                                  ! (delay)
.L_tile_dma_split:                           ! --- split-screen tile DMA (attract_timer == 0) ---
    mov.l   .L_ptr_split_tile_data, r12  ! r12 → split-screen tile data base
    mov r13, r5                          ! r5 = 0x08A4 (tile offset A)
    mov.l   .L_fn_geom_dispatch_final, r3 ! r3 → geom_dispatch_final()
    mov.w   .L_const_tile_offset, r6     ! r6 = 0x0090 (tile offset)
    mov r12, r7                          ! r7 = tile data base
    jsr @r3                              ! call geom_dispatch_final(0xC, 0x08A4, 0x90, base)
    mov #0xC, r4                         ! (delay) r4 = 0xC
    mov r12, r7                          ! r7 = tile data base (2nd call)
    mov.w   .L_const_tile_offset, r6     ! r6 = 0x0090
    mov.w   DAT_0600f618, r5            ! r5 = 0x09A4 (tile offset B)
    mov.l   .L_fn_geom_dispatch_final, r3 ! r3 → geom_dispatch_final()
    jsr @r3                              ! call geom_dispatch_final(0xC, 0x09A4, 0x90, base)
    mov #0xC, r4                         ! (delay) r4 = 0xC
    mov r12, r7                          ! r7 = tile data base (3rd call)
    mov #0x0, r6                         ! r6 = 0x0 (no offset)
    mov.w   DAT_0600f61a, r5            ! r5 = 0x0AA4 (tile offset C)
    mov.l   .L_fn_geom_render_dispatch, r3 ! r3 → geom_render_dispatch()
    jsr @r3                              ! call geom_render_dispatch(0xC, 0x0AA4, 0, base)
    mov #0xC, r4                         ! (delay) r4 = 0xC
.L_dispatch_state_handler:                   ! --- dispatch state handler via jump table ---
    mov.l   .L_fn_pre_transform_setup, r3 ! r3 → pre_transform_setup()
    jsr @r3                              ! call pre_transform_setup()
    nop                                  ! (delay)
    mov.b @r14, r2                       ! r2 = game_state
    mov.l   .L_ptr_state_handler_table, r3 ! r3 → state_handler_table[]
    extu.b r2, r2                        ! r2 = state index (0-255)
    shll2 r2                             ! r2 *= 4 (word offset)
    add r3, r2                           ! r2 = &table[state]
    mov.l @r2, r2                        ! r2 = table[state] (handler ptr)
    jsr @r2                              ! call state handler
    nop                                  ! (delay)
    .byte   0xB4, 0xEA                   /* bsr 0x0600FFD0 (external post-state helper) */
    nop                                  ! (delay)
    mov.l   .L_ptr_frame_budget, r4      ! r4 → &frame_budget
    mov.l @r4, r2                        ! r2 = frame_budget
    add #-0x30, r2                       ! r2 -= 0x30 (deduct this function's cost)
    mov.l r2, @r4                        ! *frame_budget = r2
    add #0x4, r15                        ! free stack slot
    lds.l @r15+, pr                      ! restore PR
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    mov.l   .L_fn_frame_end_commit, r3   ! r3 → frame_end_commit()
    jmp @r3                              ! tail-call frame_end_commit()
    mov.l @r15+, r14                     ! (delay) restore r14

    .global DAT_0600f612
DAT_0600f612:
    .2byte  0x08A4                       ! tile source offset A (HUD tiles)

    .global DAT_0600f614
DAT_0600f614:
    .2byte  0x5000                       ! VRAM destination offset for tile DMA
.L_const_tile_offset:
    .2byte  0x0090                       ! tile offset for split-screen paths

    .global DAT_0600f618
DAT_0600f618:
    .2byte  0x09A4                       ! tile source offset B (split path 2)

    .global DAT_0600f61a
DAT_0600f61a:
    .2byte  0x0AA4                       ! tile source offset C (split path 3)
.L_ptr_btn_mask_d:
    .4byte  sym_0607865C                 ! → button mask D (16-bit, mode 3)
.L_ptr_attract_timer:
    .4byte  sym_0607EAE0                 ! → attract timer (32-bit, 0 = split mode)
.L_ptr_display_mode:
    .4byte  sym_06078644                 ! → display mode (32-bit, 1 = mode A)
.L_ptr_tile_data_src_a:
    .4byte  sym_06063848                 ! → tile data struct A (src/dest pair)
.L_fn_display_list_load:
    .4byte  sym_06028400                 ! → display list load function
.L_ptr_tile_data_src_b:
    .4byte  sym_06063850                 ! → tile data struct B (src/dest pair)
.L_ptr_split_tile_data:
    .4byte  sym_0605ACE4                 ! → split-screen tile data base
.L_fn_geom_dispatch_final:
    .4byte  sym_060284AE                 ! → geometry dispatch final function
.L_fn_geom_render_dispatch:
    .4byte  sym_060283E0                 ! → geometry render dispatch function
.L_fn_pre_transform_setup:
    .4byte  sym_06026DBC                 ! → pre-transform setup function
.L_ptr_state_handler_table:
    .4byte  sym_0605AC2C                 ! → state handler jump table (word[])
.L_ptr_frame_budget:
    .4byte  sym_06089EDC                 ! → frame budget counter (32-bit)
.L_fn_frame_end_commit:
    .4byte  frame_end_commit             ! → frame end commit (tail call target)
