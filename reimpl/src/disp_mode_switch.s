/* disp_mode_switch -- Display scroll position interpolator
 * Translation unit: 0x06033020 - 0x06033086
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Smoothly interpolates the display horizontal scroll offset toward a
 * target value using exponential easing (halving the delta each frame).
 *
 * If scroll-enable (bit 0 of display flags byte) is set, the target
 * scroll offset is 0x3333; otherwise the target is 0.  The current
 * scroll position (sym_06082A28) moves halfway toward the target each
 * frame, then the resulting position is added to the caller's display
 * coordinate.
 *
 * Arguments:
 *   r4 — pointer to a 32-bit display coordinate; scroll offset is
 *         added to the value at @r4.
 *
 * Returns:
 *   Updates @r4 in-place with the applied scroll offset.
 *   Updates the persistent scroll position (sym_06082A28).
 */

    .section .text.FUN_06033020


    .global disp_mode_switch
    .type disp_mode_switch, @function
disp_mode_switch:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    mov.l r11, @-r15                    ! save r11
    mov.l r10, @-r15                    ! save r10
    mov.l r9, @-r15                     ! save r9
    mov.l r8, @-r15                     ! save r8
    mov.l   .L_pool_disp_flags, r0      ! r0 = &display_flags_byte (sym_06082A25)
    mov.b @r0, r1                       ! r1 = display flags byte
    mov.l   .L_pool_scroll_enable_mask, r0 ! r0 = 0x01 (scroll-enable bit mask)
    tst r0, r1                          ! test bit 0 of display flags
    bt      .L_scroll_disabled          ! if bit 0 clear -> scroll disabled, target = 0
    mov.l   .L_pool_scroll_target, r5   ! r5 = 0x3333 (scroll target when enabled)
    bra     .L_interpolate              ! jump to interpolation
    nop                                 ! delay slot
    .2byte  0x0000                      ! alignment padding
.L_pool_disp_flags:
    .4byte  sym_06082A25                ! pool: display flags byte address
.L_pool_scroll_enable_mask:
    .4byte  0x00000001                  ! pool: bit 0 mask — scroll enable flag
.L_pool_scroll_target:
    .4byte  0x00003333                  ! pool: scroll target offset when enabled
.L_scroll_disabled:
    xor r5, r5                          ! r5 = 0 (scroll target when disabled)
.L_interpolate:
    mov.l   .L_pool_scroll_pos, r0      ! r0 = &scroll_position (sym_06082A28)
    mov.l @r0, r1                       ! r1 = current scroll position
    sub r1, r5                          ! r5 = target - current (delta)
    shar r5                             ! r5 = delta >> 1 (halve for exponential ease)
    add r5, r1                          ! r1 = current + delta/2 (new position)
    mov.l r1, @r0                       ! store updated scroll position
    mov.l @r4, r2                       ! r2 = caller's display coordinate
    add r1, r2                          ! r2 += scroll position (apply offset)
    mov.l r2, @r4                       ! store updated display coordinate
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    mov.l @r15+, r14                    ! restore r14
    rts                                 ! return to caller
    nop                                 ! delay slot
    .2byte  0x0000                      ! alignment padding
.L_pool_scroll_pos:
    .4byte  sym_06082A28                ! pool: scroll position (32-bit, persistent)
    .4byte  0x000B0009                  ! (tail data — beyond TU boundary)
    .4byte  0xD0076002
    .4byte  0x60024015
    .2byte  0x8907
