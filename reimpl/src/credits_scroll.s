/* credits_scroll -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603F244 - 0x0603F2E0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Credits scroll main loop — drives the credits text scroll sequence.
 *
 * Entry: credits_scroll (called from credits_scroll_entry, which saves
 *        r10-r14 and passes the scroll parameter in r10)
 *
 * Arguments (inherited from credits_scroll_entry):
 *   r10 = scroll parameter (passed through to checkpoint_state_check as r4)
 *
 * Returns: r0 = ground_height + 2 on success, -1 on any error/abort
 *
 * Flow:
 *   1. Load function pointers into callee-saved registers:
 *        r11 = dma_int_handler (via large_prologue_save fallthrough)
 *        r12 = checkpoint_state_check
 *        r13 = &game_state_base (sym_060A4D14)
 *   2. Read game_state[0xC8] and call checkpoint_state_check for initial
 *      validation. If state is invalid (-5), return -1.
 *   3. Initialize the event callback parameter to 0.5 (16.16 fixed-point)
 *      via sym_06041884 (init_callback_param).
 *   4. Main loop: repeatedly call dma_int_handler to process DMA events
 *      and frame updates. After each iteration, re-check checkpoint state.
 *      - If dma_int_handler returns -12 (abort), return -1.
 *      - Loop continues while checkpoint_state_check returns nonzero.
 *   5. When checkpoint state reaches 0 (scroll complete):
 *      a. Call state_field_read — if nonzero, return -1.
 *      b. Call track_shadow_ground to query ground height into stack locals.
 *      c. Return locals[0] + 2 (adjusted ground height).
 */

    .section .text.FUN_0603F244


    .global credits_scroll
    .type credits_scroll, @function
credits_scroll:
    sts.l pr, @-r15                     ! save return address
    add #-0xC, r15                      ! allocate 12 bytes of stack locals
    mov.l   .L_dma_handler, r11         ! r11 = dma_int_handler (via large_prologue_save)
    mov.l   .L_checkpoint_check, r12    ! r12 = checkpoint_state_check
    mov.l   .L_game_state_ptr, r13      ! r13 = &game_state_base pointer
    mov.w   .L_state_field_offset, r0   ! r0 = 0xC8 (offset into game state struct)
    mov.l @r13, r5                      ! r5 = game_state_base
    jsr @r12                            ! checkpoint_state_check(???, state[0xC8])
    mov.l @(r0, r5), r5                 ! (delay) r5 = game_state[0xC8]
    cmp/eq #-0x5, r0                    ! check for invalid state return (-5)
    bf/s    .L_initial_state_ok         ! branch if state is valid
    mov r0, r14                         ! (delay) r14 = checkpoint result
    bra     .L_return                   ! invalid state — abort
    mov #-0x1, r0                       ! (delay) return -1
.L_initial_state_ok:
    mov.l   .L_fp_half, r4             ! r4 = 0x8000 (0.5 in 16.16 fixed-point)
    mov.l   .L_init_callback_param, r3  ! r3 = init_callback_param (sym_06041884)
    jsr @r3                             ! init_callback_param(0.5) — set event timing
    nop                                 ! (delay)
    bra     .L_check_scroll_done        ! enter loop — check if scroll already done
    nop                                 ! (delay)
.L_process_frame:
    jsr @r11                            ! dma_int_handler — process DMA/events for one frame
    nop                                 ! (delay)
    cmp/eq #-0xC, r0                    ! check for DMA abort (-12)
    bf      .L_frame_ok                 ! branch if no abort
    bra     .L_return                   ! DMA abort — bail out
    mov #-0x1, r0                       ! (delay) return -1
.L_frame_ok:
    mov.l @r13, r5                      ! r5 = game_state_base (reload)
    mov.w   .L_state_field_offset, r0   ! r0 = 0xC8
    mov.l @(r0, r5), r5                 ! r5 = game_state[0xC8]
    jsr @r12                            ! checkpoint_state_check(scroll_param, state[0xC8])
    mov r10, r4                         ! (delay) r4 = scroll_param (from entry)
    mov r0, r14                         ! r14 = checkpoint result
.L_check_scroll_done:
    tst r14, r14                        ! is checkpoint result zero (scroll complete)?
    bf      .L_process_frame            ! nonzero — keep processing frames
    mov.l   .L_state_field_read, r3     ! r3 = state_field_read
    jsr @r3                             ! state_field_read() — finalize state
    nop                                 ! (delay)
    tst r0, r0                          ! check return value
    bt      .L_state_ok                 ! zero — success, continue
    bra     .L_return                   ! nonzero — error
    mov #-0x1, r0                       ! (delay) return -1
.L_state_ok:
    mov r15, r6                         ! r6 = &locals[0] (output param 3)
    mov r15, r5                         ! r5 = &locals[0] (output param 2)
    mov r15, r4                         ! r4 = &locals[0] (will become +4)
    mov.l   .L_track_shadow_ground, r3  ! r3 = track_shadow_ground
    add #0x8, r6                        ! r6 = &locals[8] (third output slot)
    jsr @r3                             ! track_shadow_ground(&locals[4], &locals[0], &locals[8])
    add #0x4, r4                        ! (delay) r4 = &locals[4] (first output slot)
    mov r0, r4                          ! r4 = return status from track_shadow_ground
    tst r4, r4                          ! check for error
    bt      .L_shadow_ok                ! zero — success
    bra     .L_return                   ! nonzero — error
    mov #-0x1, r0                       ! (delay) return -1
.L_shadow_ok:
    mov.l @r15, r0                      ! r0 = locals[0] (ground height result)
    add #0x2, r0                        ! adjust ground height by +2
.L_return:
    add #0xC, r15                       ! free stack locals
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r10                    ! restore r10 (saved by credits_scroll_entry)
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14
.L_state_field_offset:
    .2byte  0x00C8
.L_dma_handler:
    .4byte  large_prologue_save
.L_checkpoint_check:
    .4byte  checkpoint_state_check
.L_game_state_ptr:
    .4byte  sym_060A4D14
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_init_callback_param:
    .4byte  sym_06041884
.L_state_field_read:
    .4byte  state_field_read
.L_track_shadow_ground:
    .4byte  track_shadow_ground
