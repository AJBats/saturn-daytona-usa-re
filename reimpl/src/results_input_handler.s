/* results_input_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060167DC - 0x06016940
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Two functions for managing results-screen scroll state and animation setup.
 *
 * results_input_handler (FUN_060167DC):
 *   Advances the scroll position for a results element and handles
 *   direction reversal (bounce) when the scroll limit is reached.
 *   Also calls the external track vertex builder (FUN_06016DD8) to
 *   update the element's render state, then writes display flags on
 *   the element if the scroll wrapped.
 *
 *   Parameters (from caller conventions inferred from context):
 *     r3  = scroll class / index offset (multiplied up to address a sub-array)
 *     r4  = element index
 *     r12 = a value stored into the element on wrap (e.g. 0 / palette index)
 *     r14 = element index (duplicated, used for Y-field sub-accesses)
 *
 *   Element structure layout (0x44-byte stride at sym_06084FC8):
 *     +0x02 (byte): animation phase counter
 *     +0x2C (long): current scroll position  [offset 44]
 *     +0x30 (long): scroll bounce value       [offset 48]
 *     +0x38 (long): target Y / scroll max     [offset 60]   -- used as upper limit
 *     +0x41 (byte): completion counter
 *
 * loc_060168DA (FUN_060168DA):
 *   Sets the target Y value (offset +0x38) for a results element and
 *   increments its animation phase counter (+0x02).  Chooses one of two
 *   target constants (0xC000 or 0x4000) depending on whether the element
 *   index is >= 7.  Returns the new phase value in r0.
 *
 *   Parameters:
 *     r4  = element index
 */

    .section .text.FUN_060167DC


    .global results_input_handler
    .type results_input_handler, @function
results_input_handler:
    sts.l pr, @-r15                 ! save return address (PR)
    shll2 r3                        ! r3 = scroll_class * 4
    mov.l   .L_pool_elem_array_base, r13    ! r13 = sym_06084FC8 (element array base)
    mov.w   .L_wpool_0601686C, r2           ! r2  = 0x0F00  (scroll increment per frame)
    shll2 r3                        ! r3 = scroll_class * 16
    add r3, r4                      ! r4 = elem_idx + scroll_class*16  (sub-array offset)
    exts.w r4, r4                   ! sign-extend r4 to 32 bits
    add r13, r4                     ! r4 = &sub_array[class_offset]
    mov.l @(44, r4), r3             ! r3 = elem->scroll_pos  (+0x2C)
    add r2, r3                      ! r3 = scroll_pos + 0x0F00  (advance by one step)
    mov.l r3, @(44, r4)             ! elem->scroll_pos = updated value
    mov r3, r2                      ! r2 = new scroll_pos (for compare)
    mov.l @(60, r4), r3             ! r3 = elem->scroll_max  (+0x3C)
    cmp/ge r3, r2                   ! new_scroll_pos >= scroll_max?
    bf/s    _no_scroll_wrap         ! no: skip wrap; delay slot sets up r11
    extu.b r12, r11                 ! (delay slot) r11 = zero-extended r12 (wrap flag init)
    extu.b r14, r4                  ! r4  = elem_index (byte, zero-extended)
    mov r4, r3                      ! r3  = elem_index copy
    shll2 r4                        ! r4  = idx * 4
    shll2 r3                        ! \
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r4                      ! r4  = idx * 0x44  (0x44-byte stride)
    exts.w r4, r4                   ! sign-extend offset
    add r13, r4                     ! r4  = &elem[idx]
    mov.l @(60, r4), r2             ! r2  = elem->scroll_max (+0x3C)
    mov.l r2, @(44, r4)             ! elem->scroll_pos = scroll_max  (clamp/wrap to max)
    mov #0x1, r11                   ! r11 = 1  (wrap occurred flag)
_no_scroll_wrap:
    extu.b r14, r3                  ! r3  = elem_index (zero-extended)
    mov r3, r2                      ! r2  = elem_index copy
    shll2 r3                        ! r3  = idx * 4
    shll2 r2                        ! \
    shll2 r2                        !  | r2 = idx * 64
    shll2 r2                        ! /
    add r2, r3                      ! r3  = idx * 0x44
    exts.w r3, r3                   ! sign-extend offset
    add r13, r3                     ! r3  = &elem[idx]
    mov.l @(48, r3), r0             ! r0  = elem->bounce_val (+0x30)
    tst r0, r0                      ! is bounce_val zero?
    bt      _skip_bounce            ! yes: no bounce active, skip to vtx builder call
    extu.b r14, r3                  ! r3  = elem_index
    mov #0x7, r2                    ! r2  = 7  (threshold: indices 0-6 vs 7+)
    mov.w   .L_wpool_0601686E, r4           ! r4  = 0x1800  (bounce velocity step)
    cmp/ge r2, r3                   ! elem_index >= 7?
    bt      _bounce_subtract        ! yes: subtract step (different direction)
    extu.b r14, r5                  ! r5  = elem_index
    mov r5, r3                      ! r3  = elem_index copy
    shll2 r5                        ! r5  = idx * 4
    shll2 r3                        ! \
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r5                      ! r5  = idx * 0x44
    exts.w r5, r5                   ! sign-extend
    add r13, r5                     ! r5  = &elem[idx]
    mov.l @(48, r5), r2             ! r2  = elem->bounce_val (+0x30)
    add r4, r2                      ! r2  = bounce_val + 0x1800  (advance bounce upward)
    mov.l r2, @(48, r5)             ! elem->bounce_val = updated
    mov r2, r3                      ! r3  = new bounce_val (for sign check)
    cmp/pz r3                       ! new bounce_val >= 0?
    bf      _skip_bounce            ! no (still negative): do not reset, jump to vtx builder
    extu.b r14, r3                  ! r3  = elem_index
    mov r3, r2                      ! r2  = elem_index copy
    shll2 r3                        ! r3  = idx * 4
    shll2 r2                        ! \
    shll2 r2                        !  | r2 = idx * 64
    shll2 r2                        ! /
    add r2, r3                      ! r3  = idx * 0x44
    exts.w r3, r3                   ! sign-extend
    add r13, r3                     ! r3  = &elem[idx]
    mov.l r12, @(48, r3)            ! elem->bounce_val = r12  (reset bounce to base value)
    bra     _skip_bounce            ! jump to vtx builder
    nop                             ! (delay slot)
.L_wpool_0601686C:                          ! 0x0F00 = scroll step added to scroll_pos each frame
    .2byte  0x0F00
.L_wpool_0601686E:                          ! 0x1800 = bounce velocity delta per frame
    .2byte  0x1800
.L_pool_elem_array_base:
    .4byte  sym_06084FC8
_bounce_subtract:
    extu.b r14, r5                  ! r5  = elem_index
    mov r5, r3                      ! r3  = elem_index copy
    shll2 r5                        ! r5  = idx * 4
    shll2 r3                        ! \
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r5                      ! r5  = idx * 0x44
    exts.w r5, r5                   ! sign-extend
    add r13, r5                     ! r5  = &elem[idx]
    mov.l @(48, r5), r2             ! r2  = elem->bounce_val (+0x30)
    sub r4, r2                      ! r2  = bounce_val - 0x1800  (advance bounce downward)
    mov r2, r3                      ! r3  = new bounce_val (for sign check)
    mov.l r2, @(48, r5)             ! elem->bounce_val = updated
    cmp/pl r3                       ! new bounce_val > 0?
    bt      _skip_bounce            ! yes: still positive, no reset needed
    extu.b r14, r3                  ! r3  = elem_index
    mov r3, r2                      ! r2  = elem_index copy
    shll2 r3                        ! r3  = idx * 4
    shll2 r2                        ! \
    shll2 r2                        !  | r2 = idx * 64
    shll2 r2                        ! /
    add r2, r3                      ! r3  = idx * 0x44
    exts.w r3, r3                   ! sign-extend
    add r13, r3                     ! r3  = &elem[idx]
    mov.l r12, @(48, r3)            ! elem->bounce_val = r12  (reset bounce to base value)
_skip_bounce:
    .byte   0xB2, 0x97    /* bsr 0x06016DD8 (external) */  ! call track_vtx_builder (update element vertices)
    extu.b r14, r4                  ! (delay slot) r4 = elem_index (param for vtx builder)
    extu.b r11, r11                 ! r11 = wrap_occurred flag (zero-extended)
    tst r11, r11                    ! did scroll wrap this frame?
    bt      _epilogue               ! no: skip display flag write
    extu.b r14, r4                  ! r4  = elem_index
    mov r4, r3                      ! r3  = elem_index copy
    shll2 r4                        ! r4  = idx * 4
    shll2 r3                        ! \
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r4                      ! r4  = idx * 0x44
    exts.w r4, r4                   ! sign-extend
    add r13, r4                     ! r4  = &elem[idx]
    mov #0x4, r2                    ! r2  = 4  (display flag value)
    mov #0x41, r0                   ! r0  = 0x41  (byte offset to completion counter)
    mov.b r2, @(r0, r4)             ! elem->completion_counter = 4  (mark wrapped)
    mov #0x3, r3                    ! r3  = 3
    mov r3, r0                      ! r0  = 3
    mov.b r0, @(2, r4)              ! elem->phase = 3  (reset animation phase)
_epilogue:
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r11                ! restore r11
    mov.l @r15+, r12                ! restore r12
    mov.l @r15+, r13                ! restore r13
    rts                             ! return
    mov.l @r15+, r14                ! (delay slot) restore r14

    /* -----------------------------------------------------------------------
     * loc_060168DA / FUN_060168DA
     *
     * Sets the target Y value (+0x38) for the element at index r4 and
     * increments the animation phase byte (+0x02).  Two target constants
     * are used:
     *   - 0x4000  for element indices 0-6  (lower-index entries)
     *   - 0xC000  for element indices >= 7 (higher-index entries)
     *
     * Entry:  r4 = element index
     * Return: r0 = new phase value (old_phase + 1)
     * ----------------------------------------------------------------------- */
    .global loc_060168DA
loc_060168DA:
    extu.b r4, r3                   ! r3  = elem_index (zero-extended byte)
    mov #0x7, r2                    ! r2  = 7  (threshold between the two groups)
    mov.l   .L_pool_elem_array_base2, r5    ! r5  = sym_06084FC8 (element array base)
    cmp/ge r2, r3                   ! elem_index >= 7?
    bt      _high_index_target      ! yes: use 0xC000 target for higher indices
    extu.b r4, r2                   ! r2  = elem_index
    extu.b r4, r1                   ! r1  = elem_index (for separate shift chain)
    mov r2, r3                      ! r3  = elem_index copy
    shll8 r1                        ! r1  = idx * 256  (first step of 0x44 multiply via shift)
    shll2 r2                        ! r2  = idx * 4
    shll2 r3                        ! \
    shll2 r1                        !  | continue shifts
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r2                      ! r2  = idx * 4 + idx * 64 = idx * 0x44... partial
    exts.w r2, r2                   ! sign-extend r2
    shll r1                         ! r1  = idx * 512  (another shift step)
    mov.w   .L_wpool_06016938, r3           ! r3  = 0xC000  (target Y for high indices)
    add r3, r1                      ! r1  = target with offset
    bra     _write_target_y         ! go write target
    add r5, r2                      ! (delay slot) r2 = &elem[idx] base
_high_index_target:
    extu.b r4, r2                   ! r2  = elem_index
    mov r2, r3                      ! r3  = elem_index copy
    shll2 r2                        ! r2  = idx * 4
    shll2 r3                        ! \
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r2                      ! r2  = idx * 0x44
    exts.w r2, r2                   ! sign-extend
    add r5, r2                      ! r2  = &elem[idx]
    mov.w   .L_wpool_0601693A, r1           ! r1  = 0x4000  (target Y for low indices)
_write_target_y:
    mov.l r1, @(56, r2)             ! elem->target_y (+0x38) = chosen target constant
    extu.b r4, r4                   ! r4  = elem_index (re-zero-extend for final access)
    mov r4, r3                      ! r3  = elem_index copy
    shll2 r4                        ! r4  = idx * 4
    shll2 r3                        ! \
    shll2 r3                        !  | r3 = idx * 64
    shll2 r3                        ! /
    add r3, r4                      ! r4  = idx * 0x44
    exts.w r4, r4                   ! sign-extend
    add r5, r4                      ! r4  = &elem[idx]
    mov.b @(2, r4), r0              ! r0  = elem->phase (+0x02)
    mov r0, r2                      ! r2  = old_phase
    add #0x1, r2                    ! r2  = old_phase + 1
    mov r2, r0                      ! r0  = new_phase (return value)
    rts                             ! return (r0 = new phase)
    mov.b r0, @(2, r4)              ! (delay slot) elem->phase = new_phase
.L_wpool_06016938:                          ! 0xC000 = target Y value for high-index elements (idx >= 7)
    .2byte  0xC000
.L_wpool_0601693A:                          ! 0x4000 = target Y value for low-index elements (idx < 7)
    .2byte  0x4000
.L_pool_elem_array_base2:
    .4byte  sym_06084FC8
