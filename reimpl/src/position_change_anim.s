/* position_change_anim -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015954 - 0x06015AA4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Position-change animation driver — iterates over 8 HUD element slots
 * (68-byte structs at sym_06084FC8) and animates each slot's progress
 * value (offset +0x2C) toward either 0.0 or 1.0 in 16.16 fixed-point.
 *
 * For each slot:
 *   1. Set element type (offset +2) to 2, clear counter (offset +0x30)
 *   2. If progress is in (0, 0.5): subtract step (0x2000), clamp to 0
 *   3. If progress is > 0.5: add step (0x2000), clamp to 1.0
 *   4. If progress == 0: increment "all done" counter
 *   5. Call track_vtx_builder to recompute rotated minimap vertices
 *
 * After the loop, if all 8 slots reached 0 (done_count == 8), tail-call
 * sym_060172E4 (slot clear/reset) to finalize. Otherwise return normally.
 *
 * Input:  r4 = display element index (byte, passed through to tail call)
 * Output: slot animation progress values updated; vertices recomputed
 *
 * Persistent registers:
 *   r8  = 8 (slot count / loop limit)
 *   r9  = 0x00008000 (0.5 in 16.16 fixed-point)
 *   r10 = 0x2000 (animation step per frame, 16.16 fixed-point)
 *   r11 = 0x00010000 (1.0 in 16.16 fixed-point)
 *   r12 = 0 (constant zero)
 *   r13 = sym_06084FC8 (slot data array base)
 *   r14 = loop counter (slot index, 0..7)
 *
 * Stack frame (8 bytes):
 *   sp+0 = done_count (byte) — number of slots that reached progress 0
 *   sp+4 = saved r4 (byte) — original display element index for tail call
 */

    .section .text.FUN_06015954


    .global position_change_anim
    .type position_change_anim, @function
position_change_anim:
    mov.l r14, @-r15                       ! save r14 (callee-saved)
    mov.l r13, @-r15                       ! save r13
    mov.l r12, @-r15                       ! save r12
    mov.l r11, @-r15                       ! save r11
    mov.l r10, @-r15                       ! save r10
    mov.l r9, @-r15                        ! save r9
    mov.l r8, @-r15                        ! save r8
    sts.l pr, @-r15                        ! save return address
    add #-0x8, r15                         ! allocate 8-byte stack frame
    mov #0x8, r8                           ! r8 = 8 (slot count / loop limit)
    mov.l   .L_fp_half, r9                 ! r9 = 0x8000 (0.5 in 16.16 FP)
    mov.w   .L_w_anim_step, r10         ! r10 = 0x2000 (animation step per frame)
    mov.l   .L_fp_one, r11                 ! r11 = 0x10000 (1.0 in 16.16 FP)
    mov #0x0, r12                          ! r12 = 0 (constant zero)
    mov.l   .L_slot_data_base, r13         ! r13 = sym_06084FC8 (slot array base)
    mov r4, r0                             ! r0 = display element index (arg)
    mov.b r0, @(4, r15)                    ! sp[4] = save element index for tail call
    extu.b r12, r3                         ! r3 = 0 (zero-extended)
    mov.b r3, @r15                         ! sp[0] = done_count = 0
    extu.b r12, r14                        ! r14 = 0 (loop counter / slot index)
.L_slot_loop:
    extu.b r14, r4                         ! r4 = slot index (zero-extended)
    mov #0x2, r2                           ! r2 = 2 (element type: position change)
    mov r4, r3                             ! r3 = slot index (for stride calc)
    mov r2, r0                             ! r0 = element type value
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68 (slot struct stride)
    exts.w r4, r4                          ! sign-extend offset to longword
    add r13, r4                            ! r4 = &slot_data[idx] (struct base ptr)
    mov.l r12, @(48, r4)                   ! slot[+0x30] = 0 (clear frame counter)
    mov.b r0, @(2, r4)                     ! slot[+2] = 2 (set element type)
    mov.l @(44, r4), r5                    ! r5 = slot[+0x2C] (animation progress, 16.16 FP)
    cmp/ge r9, r5                          ! T = (progress >= 0.5)?
    .word 0x0029 /* MOVT R0 */             ! r0 = T (1 if progress >= 0.5, else 0)
    xor #0x1, r0                           ! r0 = !r0 (1 if progress < 0.5)
    cmp/gt r12, r5                         ! T = (progress > 0)?
    .word 0x0129 /* MOVT R1 */             ! r1 = T (1 if progress > 0, else 0)
    and r1, r0                             ! r0 = (progress < 0.5) AND (progress > 0)
    tst r0, r0                             ! test combined condition
    bt      .L_not_decaying                ! if false → progress is NOT in (0, 0.5), skip decay
    /* --- progress is in (0, 0.5): decay toward zero --- */
    extu.b r14, r4                         ! r4 = slot index
    mov r4, r3                             ! r3 = slot index (stride calc)
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(44, r4), r2                    ! r2 = current progress
    sub r10, r2                            ! r2 -= step (0x2000)
    mov.l r2, @(44, r4)                    ! store decremented progress
    mov r2, r3                             ! r3 = new progress
    cmp/pz r3                              ! T = (progress >= 0)?
    bt      .L_call_vtx_builder            ! if still positive → done, go build vertices
    /* progress went negative — clamp to zero */
    extu.b r14, r3                         ! r3 = slot index
    mov r3, r2                             ! r2 = slot index (stride calc)
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68
    exts.w r3, r3                          ! sign-extend offset
    add r13, r3                            ! r3 = &slot_data[idx]
    mov.l r12, @(44, r3)                   ! slot[+0x2C] = 0 (clamp to zero)
    bra     .L_call_vtx_builder            ! go build vertices
    nop                                    ! (branch delay slot)
.L_not_decaying:
    /* --- check if progress > 0.5: grow toward 1.0 --- */
    extu.b r14, r2                         ! r2 = slot index
    mov r2, r3                             ! r3 = slot index (stride calc)
    shll2 r2                               ! r2 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r2                             ! r2 = idx * 68
    exts.w r2, r2                          ! sign-extend offset
    add r13, r2                            ! r2 = &slot_data[idx]
    mov.l @(44, r2), r2                    ! r2 = current progress
    cmp/gt r9, r2                          ! T = (progress > 0.5)?
    bf      .L_slot_at_zero                ! if not → progress is at zero, count as done
    /* --- progress is > 0.5: grow toward 1.0 --- */
    extu.b r14, r4                         ! r4 = slot index
    mov r4, r3                             ! r3 = slot index (stride calc)
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(44, r4), r2                    ! r2 = current progress
    add r10, r2                            ! r2 += step (0x2000)
    mov r2, r3                             ! r3 = new progress
    mov.l r2, @(44, r4)                    ! store incremented progress
    cmp/gt r11, r3                         ! T = (progress > 1.0)?
    bf      .L_call_vtx_builder            ! if not → done, go build vertices
    /* progress exceeded 1.0 — clamp to 1.0 */
    extu.b r14, r3                         ! r3 = slot index
    mov r3, r2                             ! r2 = slot index (stride calc)
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68
    exts.w r3, r3                          ! sign-extend offset
    add r13, r3                            ! r3 = &slot_data[idx]
    mov.l r11, @(44, r3)                   ! slot[+0x2C] = 0x10000 (clamp to 1.0)
    bra     .L_call_vtx_builder            ! go build vertices
    nop                                    ! (branch delay slot)
.L_w_anim_step:
    .2byte  0x2000                     /* [HIGH] animation step per frame (16.16 FP) */
    .2byte  0xFFFF
.L_fp_half:
    .4byte  0x00008000                 /* [HIGH] 0.5 (16.16 fixed-point) */
.L_fp_one:
    .4byte  0x00010000                 /* [HIGH] 1.0 (16.16 fixed-point) */
.L_slot_data_base:
    .4byte  sym_06084FC8               /* [HIGH] HUD element slot data array base */
.L_slot_at_zero:
    /* --- progress == 0: slot animation complete, increment done counter --- */
    extu.b r14, r2                         ! r2 = slot index
    mov r2, r3                             ! r3 = slot index (stride calc)
    shll2 r2                               ! r2 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r2                             ! r2 = idx * 68
    exts.w r2, r2                          ! sign-extend offset
    add r13, r2                            ! r2 = &slot_data[idx]
    mov.l r12, @(44, r2)                   ! slot[+0x2C] = 0 (ensure zero)
    mov.b @r15, r2                         ! r2 = done_count (from stack)
    add #0x1, r2                           ! done_count++
    mov.b r2, @r15                         ! store updated done_count
.L_call_vtx_builder:
    mov.l   .L_track_vtx_builder, r3       ! r3 = &track_vtx_builder
    jsr @r3                                ! call track_vtx_builder(slot_index)
    extu.b r14, r4                         ! r4 = slot index (delay slot: arg for call)
    add #0x1, r14                          ! r14++ (advance to next slot)
    extu.b r14, r2                         ! r2 = new slot index (zero-extended)
    cmp/ge r8, r2                          ! T = (slot index >= 8)?
    bf      .L_slot_loop                   ! if not done → process next slot
    /* --- all 8 slots processed — check if all animations complete --- */
    mov.b @r15, r0                         ! r0 = done_count
    extu.b r0, r0                          ! zero-extend done_count
    cmp/eq #0x8, r0                        ! all 8 slots at zero?
    bf      .L_return_normal               ! if not → return normally (animation ongoing)
    /* --- all slots done: tail-call slot reset function --- */
    mov.b @(4, r15), r0                    ! r0 = saved element index (from stack)
    mov r0, r4                             ! r4 = element index (arg for tail call)
    extu.b r4, r4                          ! zero-extend argument
    add #0x8, r15                          ! deallocate stack frame
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r8                        ! restore r8
    mov.l @r15+, r9                        ! restore r9
    mov.l @r15+, r10                       ! restore r10
    mov.l @r15+, r11                       ! restore r11
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    mov.l   .L_slot_reset_fn, r3           ! r3 = &sym_060172E4 (slot clear/reset)
    jmp @r3                                ! tail-call slot reset (does not return here)
    mov.l @r15+, r14                       ! restore r14 (delay slot)
.L_return_normal:
    add #0x8, r15                          ! deallocate stack frame
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r8                        ! restore r8
    mov.l @r15+, r9                        ! restore r9
    mov.l @r15+, r10                       ! restore r10
    mov.l @r15+, r11                       ! restore r11
    mov.l @r15+, r12                       ! restore r12
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return to caller
    mov.l @r15+, r14                       ! restore r14 (delay slot)
.L_track_vtx_builder:
    .4byte  track_vtx_builder          /* [HIGH] rotated minimap vertex builder */
.L_slot_reset_fn:
    .4byte  sym_060172E4               /* [MEDIUM] VDP2 register clear / slot reset */
