/* menu_element_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603F3F6 - 0x0603F4B0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * menu_element_render(r4=ring_desc, r5=dest_buf, r6=byte_count):
 *   Copies 'byte_count' bytes from a ring buffer into 'dest_buf'.
 *   The ring buffer is described by a descriptor struct at r4:
 *     @(0, r4)  = source data pointer (NULL means no data — zero-fill dest)
 *     @(4, r4)  = ring buffer base address
 *     @(8, r4)  = current read cursor (offset into ring buffer)
 *
 *   Ring buffer size is fixed at 0x800 (2048) bytes.
 *
 *   If the source pointer is NULL, tail-calls memset to zero-fill dest.
 *   If the cursor is invalid (-1) or past the buffer end (>= 0x800),
 *   calls cmd_multi_validate to refill the ring buffer and resets cursor.
 *   Handles wrap-around: if the read would cross the buffer boundary,
 *   copies the tail portion, refills, then copies the head portion.
 *
 *   External references (via pool / raw .byte pairs):
 *     sym_06036D78          = memset(dst, byte_val, count)
 *     sym_06036D94          = memcmp (unused in practice here — pool artifact)
 *     sym_060A4D14          = game state base pointer
 *     cmd_multi_validate    = refill ring buffer (at .L_fn_cmd_multi_validate)
 *     sym_060360FC          = memmove(dst, src, count) (at .L_fn_memmove)
 */

    .section .text.FUN_0603F3F6


    .global menu_element_render
    .type menu_element_render, @function
menu_element_render:
    mov.l r14, @-r15                    ! save r14 (will hold ring_desc)
    mov.l r13, @-r15                    ! save r13 (will hold byte_count / remaining)
    mov r4, r14                         ! r14 = ring_desc pointer
    mov.l r12, @-r15                    ! save r12 (will hold copy_len)
    mov.l r11, @-r15                    ! save r11 (will hold buf_size = 0x800)
    mov.l r10, @-r15                    ! save r10 (will hold dest_buf)
    mov r5, r10                         ! r10 = dest_buf
    mov.l r9, @-r15                     ! save r9 (will hold cursor)
    sts.l pr, @-r15                     ! save return address
    mov.w   .L_ring_buf_size, r11      ! r11 = 0x0800 (ring buffer size = 2048)
    mov.l @r14, r0                      ! r0 = ring_desc->source_data_ptr
    tst r0, r0                          ! source_data_ptr == NULL?
    bf/s    .L_source_valid             ! no — source exists, proceed with copy
    mov r6, r13                         ! r13 = byte_count (delay slot)
! --- Source is NULL: zero-fill destination and return ---
    mov r13, r6                         ! r6 = byte_count (arg3 for memset)
    mov #0x0, r5                        ! r5 = 0 (fill byte — zero)
    mov r10, r4                         ! r4 = dest_buf (arg1 for memset)
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    .byte   0xD3, 0x04    /* mov.l .L_pool_memset, r3 */  ! r3 = &memset (sym_06036D78)
    jmp @r3                             ! tail-call memset(dest_buf, 0, byte_count)
    mov.l @r15+, r14                    ! restore r14 (delay slot)
! --- Constant pool (inline, between code paths) ---
    .2byte  0x043C                      ! alignment pad
.L_ring_buf_size:
    .2byte  0x0800                      /* [HIGH] ring buffer size constant (2048 bytes) */
    .2byte  0xFFFF                      ! padding / unused
    .4byte  sym_06036D94                ! pool: memcmp (not called here directly)
    .4byte  sym_060A4D14                ! pool: game state base pointer
.L_pool_memset:
    .4byte  sym_06036D78                ! pool: memset(dst, byte_val, count)
! --- Source pointer is valid: check cursor and copy ---
.L_source_valid:
    mov.l @(8, r14), r4                 ! r4 = cursor (current read offset)
    mov r4, r0                          ! r0 = cursor (for comparison)
    cmp/eq #-0x1, r0                    ! cursor == -1 (invalid/uninitialized)?
    bt      .L_refill_buffer            ! yes — refill ring buffer
    .byte   0x93, 0x3D    /* mov.w .L_ring_buf_size_ext, r3 */  ! r3 = 0x0800 (buf_size, from external pool)
    cmp/ge r3, r4                       ! cursor >= buf_size?
    bf      .L_cursor_valid             ! no — cursor is valid, skip refill
! --- Cursor invalid or past end: refill ring buffer ---
.L_refill_buffer:
    mov r11, r7                         ! r7 = buf_size (arg4 for cmd_multi_validate)
    mov.l @(4, r14), r6                 ! r6 = ring_buf_base (arg3)
    mov #0x1, r5                        ! r5 = 1 (mode flag — refill)
    .byte   0xD3, 0x1C    /* mov.l .L_fn_cmd_multi_validate, r3 */  ! r3 = &cmd_multi_validate
    jsr @r3                             ! call cmd_multi_validate(src_ptr, 1, ring_buf, buf_size)
    mov.l @r14, r4                      ! r4 = source_data_ptr (arg1, delay slot)
    mov #0x0, r2                        ! r2 = 0
    mov.l r2, @(8, r14)                 ! ring_desc->cursor = 0 (reset after refill)
! --- Calculate how many bytes to copy before wrap ---
.L_cursor_valid:
    mov.l @(8, r14), r9                 ! r9 = cursor (current read offset)
    neg r9, r12                         ! r12 = -cursor
    add r11, r12                        ! r12 = buf_size - cursor (bytes until end)
    cmp/hs r12, r13                     ! byte_count >= bytes_until_end? (unsigned)
    bt      .L_no_wrap                  ! yes — need full remaining (will wrap or exact)
    bra     .L_clamp_to_request         ! no — byte_count < remaining, just copy byte_count
    mov r13, r12                        ! r12 = byte_count (delay slot — copy_len = byte_count)
.L_no_wrap:
    mov r11, r12                        ! r12 = buf_size
    sub r9, r12                         ! r12 = buf_size - cursor (copy exactly to end)
! --- First copy: from cursor to end of buffer (or full request) ---
.L_clamp_to_request:
    mov r12, r6                         ! r6 = copy_len (arg3 for memmove)
    mov.l @(4, r14), r5                 ! r5 = ring_buf_base (source)
    .byte   0xD3, 0x15    /* mov.l .L_fn_memmove, r3 */  ! r3 = &memmove (sym_060360FC)
    add r9, r5                          ! r5 = ring_buf_base + cursor (source offset)
    jsr @r3                             ! call memmove(dest_buf, ring_buf+cursor, copy_len)
    mov r10, r4                         ! r4 = dest_buf (arg1, delay slot)
! --- Update cursor, check if wrap-around is needed ---
    mov.l @(8, r14), r2                 ! r2 = cursor (before update)
    add r12, r2                         ! r2 = cursor + copy_len (new cursor)
    cmp/hs r13, r12                     ! copy_len >= byte_count? (unsigned)
    bt/s    .L_done                     ! yes — all bytes copied, no wrap needed
    mov.l r2, @(8, r14)                 ! ring_desc->cursor = updated cursor (delay slot)
! --- Wrap-around: refill buffer and copy remaining bytes ---
    sub r12, r13                        ! r13 = byte_count - copy_len (remaining bytes)
    mov r11, r7                         ! r7 = buf_size (arg4)
    mov #0x1, r5                        ! r5 = 1 (mode flag — refill)
    .byte   0xD3, 0x0E    /* mov.l .L_fn_cmd_multi_validate, r3 */  ! r3 = &cmd_multi_validate
    mov.l @(4, r14), r6                 ! r6 = ring_buf_base (arg3)
    jsr @r3                             ! call cmd_multi_validate(src_ptr, 1, ring_buf, buf_size)
    mov.l @r14, r4                      ! r4 = source_data_ptr (arg1, delay slot)
    mov r13, r6                         ! r6 = remaining byte_count (arg3 for memmove)
    mov r12, r4                         ! r4 = copy_len (offset into dest_buf)
    .byte   0xD3, 0x0C    /* mov.l .L_fn_memmove, r3 */  ! r3 = &memmove (sym_060360FC)
    mov.l @(4, r14), r5                 ! r5 = ring_buf_base (source — starts at offset 0)
    jsr @r3                             ! call memmove(dest_buf+copy_len, ring_buf, remaining)
    add r10, r4                         ! r4 = dest_buf + copy_len (arg1, delay slot)
    mov.l r13, @(8, r14)                ! ring_desc->cursor = remaining (new cursor position)
! --- Epilogue: restore registers and return ---
.L_done:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .2byte  0xE601                      ! trailing data (mov #0x1, r6 encoding — not executed)
