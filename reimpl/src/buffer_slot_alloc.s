/* buffer_slot_alloc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041034 - 0x060410CA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Allocates a new entry in the 16-byte slot array within the game state
 * structure. Validates that the target slot is active and that the array
 * has not reached its 24-entry capacity. On success, populates the new
 * entry's fields from the function arguments and triggers road validation.
 *
 * Parameters:
 *   r4  = slot index (byte, sign-extended)
 *   r5  = second param byte (stored at entry+0x01)
 *   r6  = pointer to 6-byte data block (copied to entry+0x02 via memcpy_byte)
 *   r7  = long value stored at entry+0x08
 *   @(16, r15) = stack arg: long value stored at entry+0x0C
 *
 * Returns:
 *   r0 = 0 on success
 *   r0 = -7 if slot is not active (status byte != 1)
 *   r0 = -8 if slot array is full (count >= 24)
 *
 * Game state struct (base = *sym_060A5400):
 *   +0x18 = per-slot status byte array (1 = active)
 *   +0x54 = current entry count
 *   +0x58 = dirty flag (set to 1 on first allocation)
 *   +0x5C = base of 16-byte entry array (up to 24 entries)
 *
 * Entry layout (16 bytes each, at state+0x5C + index*16):
 *   +0x00 = byte: slot index / type (from r4)
 *   +0x01 = byte: second param (from r5)
 *   +0x02 = 6 bytes: data block (copied from r6)
 *   +0x08 = long: param (from r7)
 *   +0x0C = long: param (from stack)
 *
 * Calls:
 *   memcpy_byte (sym_06035228) — r0=count, r1=dst, r2=src
 *   track_road_validate (BSR) — post-allocation validation
 */

    .section .text.FUN_06041034


    .global buffer_slot_alloc
    .type buffer_slot_alloc, @function
buffer_slot_alloc:
    mov.l r14, @-r15                             ! save r14 (callee-saved)
    mov #0x54, r0                                ! r0 = 0x54 (offset to entry count)
    mov.l r13, @-r15                             ! save r13 (callee-saved)
    sts.l pr, @-r15                              ! save return address
    add #-0x4, r15                               ! allocate 4 bytes of stack space
    mov.l   .L_pool_state_base_ptr, r14          ! r14 = &sym_060A5400 (state base indirect ptr)
    mov.l @r14, r1                               ! r1 = *sym_060A5400 (state base address)
    mov.l @(r0, r1), r1                          ! r1 = state[+0x54] (current entry count)
    mov.l @r14, r0                               ! r0 = state base address
    add #0x18, r0                                ! r0 = &state[+0x18] (slot status array)
    mov.b @(r0, r4), r0                          ! r0 = state[+0x18 + r4] (status byte for slot r4)
    cmp/eq #0x1, r0                              ! is slot active (status == 1)?
    bt      .L_slot_active                       ! yes -> proceed with allocation
    bra     .L_epilogue                          ! no -> return error
    mov #-0x7, r0                                ! r0 = -7 (slot not active error)
.L_slot_active:
    mov #0x18, r2                                ! r2 = 24 (max entry capacity)
    cmp/ge r2, r1                                ! is count >= 24?
    bf      .L_capacity_ok                       ! no -> capacity available
    bra     .L_epilogue                          ! yes -> return error
    mov #-0x8, r0                                ! r0 = -8 (array full error)
.L_pool_state_base_ptr:
    .4byte  sym_060A5400
.L_capacity_ok:
    mov.l @r14, r2                               ! r2 = state base address
    mov #0x58, r0                                ! r0 = 0x58 (offset to dirty flag)
    mov.l @(r0, r2), r0                          ! r0 = state[+0x58] (dirty flag)
    tst r0, r0                                   ! is dirty flag zero (not yet set)?
    bf      .L_dirty_already_set                 ! nonzero -> skip setting
    mov.l @r14, r3                               ! r3 = state base address
    mov #0x1, r2                                 ! r2 = 1
    mov #0x58, r0                                ! r0 = 0x58 (dirty flag offset)
    mov.l r2, @(r0, r3)                          ! state[+0x58] = 1 (mark dirty)
.L_dirty_already_set:
    mov r1, r13                                  ! r13 = entry count (will be entry index)
    exts.b r4, r4                                ! sign-extend r4 (slot index) to 32 bits
    exts.b r5, r5                                ! sign-extend r5 (second param) to 32 bits
    mov.l @r14, r2                               ! r2 = state base address
    shll2 r13                                    ! r13 = count * 4
    mov r5, r0                                   ! r0 = second param (for later store)
    add #0x5C, r2                                ! r2 = &state[+0x5C] (entry array base)
    shll2 r13                                    ! r13 = count * 16 (entry offset)
    add r13, r2                                  ! r2 = &entry[count] (new entry address)
    mov.b r4, @r2                                ! entry[+0x00] = r4 (slot index byte)
    mov.l @r14, r2                               ! r2 = state base address
    add #0x5C, r2                                ! r2 = &state[+0x5C] (entry array base)
    add r13, r2                                  ! r2 = &entry[count]
    mov.b r0, @(1, r2)                           ! entry[+0x01] = r5 (second param byte)
    mov r6, r2                                   ! r2 = src pointer (6-byte data block)
    .byte   0xD3, 0x1A    /* mov.l .L_pool_060410FC, r3 */  ! r3 = memcpy_byte (sym_06035228)
    mov.l @r14, r1                               ! r1 = state base address
    add #0x5C, r1                                ! r1 = &state[+0x5C] (entry array base)
    add r13, r1                                  ! r1 = &entry[count]
    add #0x2, r1                                 ! r1 = &entry[+0x02] (dst for data copy)
    jsr @r3                                      ! call memcpy_byte(r0=6, r1=dst, r2=src)
    mov #0x6, r0                                 ! r0 = 6 (byte count to copy)
    mov #0x54, r0                                ! r0 = 0x54 (offset to entry count)
    mov.l @r14, r3                               ! r3 = state base address
    add #0x5C, r3                                ! r3 = &state[+0x5C] (entry array base)
    add r13, r3                                  ! r3 = &entry[count]
    mov.l r7, @(8, r3)                           ! entry[+0x08] = r7 (long param)
    mov.l @r14, r3                               ! r3 = state base address
    mov.l @(16, r15), r2                         ! r2 = stack arg (5th parameter)
    add #0x5C, r3                                ! r3 = &state[+0x5C] (entry array base)
    add r3, r13                                  ! r13 = &entry[count] (absolute)
    mov.l r2, @(12, r13)                         ! entry[+0x0C] = stack arg (long param)
    mov.l @r14, r3                               ! r3 = state base address
    mov.l @(r0, r3), r2                          ! r2 = state[+0x54] (current entry count)
    add #0x1, r2                                 ! r2 = count + 1
    mov.l r2, @(r0, r3)                          ! state[+0x54] = count + 1 (increment)
    .byte   0xB4, 0x00    /* bsr 0x060418BE (external) */  ! call track_road_validate
    mov r15, r4                                  ! r4 = stack pointer (iteration counter ptr)
    mov #0x0, r0                                 ! r0 = 0 (success)
.L_epilogue:
    add #0x4, r15                                ! free stack space
    lds.l @r15+, pr                              ! restore return address
    mov.l @r15+, r13                             ! restore r13
    rts                                          ! return
    mov.l @r15+, r14                             ! restore r14 (delay slot)
