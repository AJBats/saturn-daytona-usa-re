/* results_screen_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015FC2 - 0x06016228
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Results screen element animation interpolator.
 *
 * Called from results_init_stub (FUN_06015FB0), which saves r11-r14
 * and sets up the initial index computation before falling through here.
 *
 * Each results screen display element (position, time, bonus, etc.) is
 * stored as a 0x44-byte entry in the array at sym_06084FC8. This function
 * animates one element toward its target values:
 *
 *   1. Y-axis interpolation: accumulate delta (+0x18) into current_y (+0x30),
 *      clamping to target_y (+0x38) when overshot.
 *   2. X-axis interpolation: accumulate velocity (+0x10) into current_x (+0x04),
 *      then call int_abs to measure distance to origin (+0x34). If close
 *      enough (< 15.0 in 16.16 FP), apply speed damping to decelerate.
 *   3. Call track_vtx_builder to compute rotated vertex coordinates for
 *      the element's minimap car icon.
 *   4. If the element reached its target, increment the completion counter
 *      (byte +0x41). After 4 completions, mark animation state (byte +0x02)
 *      as finished (state 2). Otherwise, decrement the phase counter.
 *
 * Entry (from results_init_stub fallthrough):
 *   r3  = element_index * 4  (partially computed)
 *   r4  = element_index * 4  (partially computed)
 *   r14 = element_index (original r4 param, saved by stub)
 *   r13, r12, r11 = free (saved by stub)
 *
 * Structure layout (0x44-byte stride at sym_06084FC8):
 *   +0x02 (byte): animation phase counter
 *   +0x04 (long): current X position (16.16 fixed-point)
 *   +0x10 (long): X velocity (16.16 FP)
 *   +0x18 (long): Y delta / acceleration (16.16 FP)
 *   +0x1C (long): double-speed flag (nonzero = double interpolation rate)
 *   +0x30 (long): current Y value (16.16 FP)
 *   +0x34 (long): X origin / reference position (16.16 FP)
 *   +0x38 (long): target Y value (16.16 FP)
 *   +0x41 (byte): completion counter (incremented each time target reached)
 */

    .section .text.FUN_06015FC2


    .global results_screen_render
    .type results_screen_render, @function
results_screen_render:
    sts.l pr, @-r15                         ! save return address
    shll2 r3                                ! r3 = idx * 16 (was idx*4 from stub)
    .byte   0xDD, 0x3D    /* mov.l .L_pool_elem_array_base, r13 */ ! r13 = element array base (sym_06084FC8)
    shll2 r3                                ! r3 = idx * 64
    add r3, r4                              ! r4 = idx*4 + idx*64 = idx * 68 (0x44 stride)
    exts.w r4, r4                           ! sign-extend offset to 32-bit
    add r13, r4                             ! r4 = &elem[idx] (pointer to this element)
    mov.l @(48, r4), r2                     ! r2 = elem.current_y (+0x30)
    mov.l @(56, r4), r3                     ! r3 = elem.target_y (+0x38)
    cmp/eq r3, r2                           ! current_y == target_y?
    bt/s    .L_y_interp_done                ! yes: skip Y interpolation
    mov #0x0, r12                           ! r12 = 0 (animation_changed flag = false)
    extu.b r14, r4                          ! r4 = element index
    mov r4, r3                              ! r3 = element index (copy)
    shll2 r4                                ! r4 = idx * 4
    shll2 r3                                ! \
    shll2 r3                                !  | r3 = idx * 64
    shll2 r3                                ! /
    add r3, r4                              ! r4 = idx * 0x44
    exts.w r4, r4                           ! sign-extend
    add r13, r4                             ! r4 = &elem[idx]
    mov.l @(24, r4), r2                     ! r2 = elem.y_delta (+0x18)
    mov.l @(48, r4), r3                     ! r3 = elem.current_y (+0x30)
    add r2, r3                              ! r3 = current_y + y_delta (advance Y)
    mov.l r3, @(48, r4)                     ! elem.current_y = updated value
    mov.l @(24, r4), r2                     ! r2 = elem.y_delta (reload)
    cmp/pz r2                               ! is y_delta >= 0? (moving in positive direction)
    .word 0x0029 /* MOVT R0 */             ! r0 = T bit (1 if positive, 0 if negative)
    xor #0x1, r0                            ! r0 = !positive (1 if moving negative)
    mov.l @(56, r4), r2                     ! r2 = elem.target_y (+0x38)
    cmp/gt r2, r3                           ! current_y > target_y?
    .word 0x0129 /* MOVT R1 */             ! r1 = T bit (1 if overshot upward)
    add #-0x1, r1                           ! r1 = overshoot - 1 (0 if overshot, -1 if not)
    neg r1, r1                              ! r1 = 1 if overshot, 0 if not
    and r1, r0                              ! r0 = overshot AND moving_negative (clamp needed)
    tst r0, r0                              ! test if clamping needed
    bt      .L_check_y_clamp_positive       ! no clamp needed for negative direction
    extu.b r14, r4                          ! r4 = element index
    mov r4, r3                              ! r3 = index copy
    shll2 r4                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r4                              ! r4 = idx * 0x44
    exts.w r4, r4                           ! sign-extend
    add r13, r4                             ! r4 = &elem[idx]
    mov.l @(56, r4), r2                     ! r2 = elem.target_y
    mov.l r2, @(48, r4)                     ! elem.current_y = target_y (clamp to target)
.L_check_y_clamp_positive:
    extu.b r14, r4                          ! r4 = element index
    mov r4, r3                              ! r3 = index copy
    shll2 r4                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r4                              ! r4 = idx * 0x44
    exts.w r4, r4                           ! sign-extend
    add r13, r4                             ! r4 = &elem[idx]
    mov.l @(24, r4), r2                     ! r2 = elem.y_delta
    cmp/pz r2                               ! is y_delta >= 0?
    .word 0x0029 /* MOVT R0 */             ! r0 = T bit (1 if positive)
    mov.l @(48, r4), r3                     ! r3 = elem.current_y (updated)
    mov.l @(56, r4), r2                     ! r2 = elem.target_y
    cmp/ge r2, r3                           ! current_y >= target_y?
    .word 0x0129 /* MOVT R1 */             ! r1 = T bit (1 if at or past target)
    and r1, r0                              ! r0 = positive AND past_target (clamp needed)
    tst r0, r0                              ! test if clamping needed
    bt      .L_y_interp_done                ! no: Y interpolation complete for this frame
    extu.b r14, r4                          ! r4 = element index
    mov r4, r3                              ! r3 = index copy
    shll2 r4                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r4                              ! r4 = idx * 0x44
    exts.w r4, r4                           ! sign-extend
    add r13, r4                             ! r4 = &elem[idx]
    mov.l @(56, r4), r2                     ! r2 = elem.target_y
    mov.l r2, @(48, r4)                     ! elem.current_y = target_y (clamp)
.L_y_interp_done:
    extu.b r14, r11                         ! r11 = element index
    mov r11, r3                             ! r3 = index copy
    shll2 r11                               ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r11                             ! r11 = idx * 0x44
    exts.w r11, r11                         ! sign-extend
    add r13, r11                            ! r11 = &elem[idx] (kept in r11 for reuse)
    mov.l @(16, r11), r2                    ! r2 = elem.x_velocity (+0x10)
    mov.l @(4, r11), r3                     ! r3 = elem.current_x (+0x04)
    add r2, r3                              ! r3 = current_x + x_velocity
    mov r3, r4                              ! r4 = new_x (save for abs call)
    mov.l r3, @(4, r11)                     ! elem.current_x = new_x
    mov.l @(52, r11), r2                    ! r2 = elem.x_origin (+0x34)
    .byte   0xD3, 0x10    /* mov.l .L_pool_int_abs, r3 */ ! r3 = int_abs function address
    jsr @r3                                 ! call int_abs(r4 = new_x - x_origin)
    sub r2, r4                              ! r4 = new_x - x_origin (delay slot)
    .byte   0xD2, 0x10    /* mov.l .L_pool_distance_threshold, r2 */ ! r2 = 0x000F0000 (15.0 in 16.16 FP)
    cmp/gt r2, r0                           ! |distance| > 15.0?
    bt      .L_x_interp_done               ! yes: too far away, skip speed damping
    extu.b r14, r2                          ! r2 = element index
    mov r2, r3                              ! r3 = index copy
    shll2 r2                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r2                              ! r2 = idx * 0x44
    exts.w r2, r2                           ! sign-extend
    add r13, r2                             ! r2 = &elem[idx]
    mov.l @(16, r2), r2                     ! r2 = elem.x_velocity
    cmp/pz r2                               ! is x_velocity >= 0?
    bt      .L_x_vel_positive               ! yes: use positive damping
    extu.b r14, r2                          ! r2 = element index
    mov r2, r3                              ! r3 = index copy
    shll2 r2                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r2                              ! r2 = idx * 0x44
    exts.w r2, r2                           ! sign-extend
    add r13, r2                             ! r2 = &elem[idx]
    .byte   0xD1, 0x05    /* mov.l .L_pool_neg_velocity, r1 */ ! r1 = 0xFFFC0000 (-4.0 in 16.16 FP)
    mov.w   .L_wpool_neg_speed_adj, r4     ! r4 = 0xFFFFF800 (-0.03125 in 16.16 FP, sign-extended)
    bra     .L_apply_speed_damping          ! go apply damping
    mov.l r1, @(16, r2)                    ! elem.x_velocity = -4.0 (reset to base negative speed)
.L_wpool_neg_speed_adj:
    .2byte  0xF800                          ! -2048 (sign-extended = -0.03125 in 16.16 FP)
.L_pool_elem_array_base:
    .4byte  sym_06084FC8                    ! results element array base
.L_pool_int_abs:
    .4byte  sym_06035438                    ! int_abs: r0 = |r4|
.L_pool_distance_threshold:
    .4byte  0x000F0000                  /* nibble 4 mask */ ! 15.0 in 16.16 FP — distance threshold for damping
.L_pool_neg_velocity:
    .4byte  0xFFFC0000                      ! -4.0 in 16.16 FP — base negative X velocity
.L_x_vel_positive:
    extu.b r14, r2                          ! r2 = element index
    mov r2, r3                              ! r3 = index copy
    shll2 r2                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r2                              ! r2 = idx * 0x44
    exts.w r2, r2                           ! sign-extend
    add r13, r2                             ! r2 = &elem[idx]
    .byte   0xD1, 0x47    /* mov.l .L_pool_pos_velocity, r1 */ ! r1 = 0x00040000 (+4.0 in 16.16 FP)
    mov.l r1, @(16, r2)                    ! elem.x_velocity = +4.0 (reset to base positive speed)
    mov.w   .L_wpool_pos_speed_adj, r4     ! r4 = 0x0800 (+2048 = +0.03125 in 16.16 FP)
.L_apply_speed_damping:
    extu.b r14, r3                          ! r3 = element index
    mov r3, r2                              ! r2 = index copy
    shll2 r3                                ! \
    shll2 r2                                !  |
    shll2 r2                                !  | compute idx * 0x44
    shll2 r2                                ! /
    add r2, r3                              ! r3 = idx * 0x44
    exts.w r3, r3                           ! sign-extend
    add r13, r3                             ! r3 = &elem[idx]
    mov.l @(28, r3), r0                     ! r0 = elem.double_speed_flag (+0x1C)
    tst r0, r0                              ! is double_speed_flag zero?
    bt      .L_apply_single_damp            ! yes: apply single rate damping
    extu.b r14, r5                          ! r5 = element index
    mov r5, r3                              ! r3 = index copy
    shll2 r5                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r5                              ! r5 = idx * 0x44
    exts.w r5, r5                           ! sign-extend
    add r13, r5                             ! r5 = &elem[idx]
    mov.l @(16, r5), r2                     ! r2 = elem.x_velocity
    shll r2                                 ! r2 *= 2 (double the velocity)
    mov.l r2, @(16, r5)                     ! elem.x_velocity = doubled
    shll r4                                 ! r4 *= 2 (double the damping adjustment too)
.L_apply_single_damp:
    extu.b r14, r3                          ! r3 = element index
    mov r3, r2                              ! r2 = index copy
    shll2 r3                                ! \
    shll2 r2                                !  |
    shll2 r2                                !  | compute idx * 0x44
    shll2 r2                                ! /
    add r2, r3                              ! r3 = idx * 0x44
    exts.w r3, r3                           ! sign-extend
    add r13, r3                             ! r3 = &elem[idx]
    mov.l @(16, r3), r1                     ! r1 = elem.x_velocity
    sub r4, r1                              ! r1 = x_velocity - damping_adjustment (slow down)
    mov.l r1, @(16, r3)                     ! elem.x_velocity = damped value
.L_x_interp_done:
    extu.b r14, r5                          ! r5 = element index
    mov r5, r3                              ! r3 = index copy
    shll2 r5                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r5                              ! r5 = idx * 0x44
    exts.w r5, r5                           ! sign-extend
    add r13, r5                             ! r5 = &elem[idx]
    mov.l @(16, r5), r2                     ! r2 = elem.x_velocity
    cmp/pz r2                               ! is x_velocity >= 0?
    .word 0x0029 /* MOVT R0 */             ! r0 = T bit (1 if positive velocity)
    xor #0x1, r0                            ! r0 = !positive (1 if negative velocity)
    mov.l @(4, r5), r3                      ! r3 = elem.current_x (+0x04)
    mov.l @(52, r5), r2                     ! r2 = elem.x_origin (+0x34)
    cmp/gt r2, r3                           ! current_x > x_origin?
    .word 0x0129 /* MOVT R1 */             ! r1 = T bit (1 if past origin in positive dir)
    add #-0x1, r1                           ! r1 = past_origin - 1
    neg r1, r1                              ! r1 = 1 if NOT past origin, 0 if past
    and r1, r0                              ! r0 = negative_vel AND not_past_origin
    tst r0, r0                              ! test if X passed through origin (negative direction)
    bt/s    .L_check_x_clamp_positive       ! no: check positive direction
    mov #0x1, r4                            ! r4 = 1 (animation_changed = true, in delay slot)
    extu.b r14, r5                          ! r5 = element index
    mov r5, r3                              ! r3 = index copy
    shll2 r5                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r5                              ! r5 = idx * 0x44
    exts.w r5, r5                           ! sign-extend
    add r13, r5                             ! r5 = &elem[idx]
    mov.l @(52, r5), r2                     ! r2 = elem.x_origin
    mov.l r2, @(4, r5)                      ! elem.current_x = x_origin (snap to origin)
    bra     .L_render_element               ! go render the element
    extu.b r4, r12                          ! r12 = 1 (animation_changed = true, delay slot)
.L_check_x_clamp_positive:
    extu.b r14, r5                          ! r5 = element index
    mov r5, r3                              ! r3 = index copy
    shll2 r5                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r5                              ! r5 = idx * 0x44
    exts.w r5, r5                           ! sign-extend
    add r13, r5                             ! r5 = &elem[idx]
    mov.l @(16, r5), r2                     ! r2 = elem.x_velocity
    cmp/pz r2                               ! is x_velocity >= 0?
    .word 0x0029 /* MOVT R0 */             ! r0 = T bit (1 if positive)
    mov.l @(4, r5), r3                      ! r3 = elem.current_x
    mov.l @(52, r5), r2                     ! r2 = elem.x_origin
    cmp/ge r2, r3                           ! current_x >= x_origin?
    .word 0x0129 /* MOVT R1 */             ! r1 = T bit (1 if at or past origin)
    and r1, r0                              ! r0 = positive_vel AND past_origin
    tst r0, r0                              ! test if X reached origin (positive direction)
    bt      .L_render_element               ! no: continue rendering without snapping
    extu.b r14, r5                          ! r5 = element index
    mov r5, r3                              ! r3 = index copy
    shll2 r5                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r5                              ! r5 = idx * 0x44
    exts.w r5, r5                           ! sign-extend
    add r13, r5                             ! r5 = &elem[idx]
    mov.l @(52, r5), r2                     ! r2 = elem.x_origin
    mov.l r2, @(4, r5)                      ! elem.current_x = x_origin (snap to origin)
    extu.b r4, r12                          ! r12 = 1 (animation_changed = true)
.L_render_element:
    .byte   0xB6, 0x10    /* bsr 0x06016DD8 (external) */ ! call track_vtx_builder (compute vertex positions)
    extu.b r14, r4                          ! r4 = element index (delay slot, param for vtx builder)
    extu.b r12, r12                         ! zero-extend animation_changed flag
    tst r12, r12                            ! did animation reach target this frame?
    bt      .L_epilogue                     ! no: skip completion logic
    extu.b r14, r4                          ! r4 = element index
    mov #0x41, r0                           ! r0 = 0x41 (offset to completion counter byte)
    mov r4, r3                              ! r3 = index copy
    shll2 r4                                ! \
    shll2 r3                                !  |
    shll2 r3                                !  | compute idx * 0x44
    shll2 r3                                ! /
    add r3, r4                              ! r4 = idx * 0x44
    exts.w r4, r4                           ! sign-extend
    add r13, r4                             ! r4 = &elem[idx]
    mov.b @(r0, r4), r2                     ! r2 = elem.completion_counter (+0x41)
    add #0x1, r2                            ! r2++ (increment completion counter)
    mov.b r2, @(r0, r4)                     ! elem.completion_counter = r2
    mov #0x3, r2                            ! r2 = 3 (completion threshold)
    mov.b @(r0, r4), r3                     ! r3 = elem.completion_counter (reload)
    extu.b r3, r3                           ! zero-extend byte
    cmp/gt r2, r3                           ! completion_counter > 3?
    bf      .L_decrement_phase              ! no: just decrement phase
    extu.b r14, r14                         ! r14 = element index (reuse r14 for final access)
    mov r14, r2                             ! r2 = index copy
    shll2 r14                               ! \
    shll2 r2                                !  |
    shll2 r2                                !  | compute idx * 0x44
    shll2 r2                                ! /
    add r2, r14                             ! r14 = idx * 0x44
    exts.w r14, r14                         ! sign-extend
    add r13, r14                            ! r14 = &elem[idx]
    bra     .L_write_phase                  ! go write new phase value
    mov #0x2, r0                            ! r0 = 2 (animation complete state, delay slot)
.L_wpool_pos_speed_adj:
    .2byte  0x0800                          ! +2048 (+0.03125 in 16.16 FP) — positive speed adjustment
    .2byte  0xFFFF                          ! padding (alignment)
.L_pool_pos_velocity:
    .4byte  0x00040000                  /* 4.0 (16.16 fixed-point) */ ! +4.0 base positive X velocity
.L_decrement_phase:
    extu.b r14, r14                         ! r14 = element index
    mov r14, r2                             ! r2 = index copy
    shll2 r14                               ! \
    shll2 r2                                !  |
    shll2 r2                                !  | compute idx * 0x44
    shll2 r2                                ! /
    add r2, r14                             ! r14 = idx * 0x44
    exts.w r14, r14                         ! sign-extend
    add r13, r14                            ! r14 = &elem[idx]
    mov.b @(2, r14), r0                     ! r0 = elem.phase_counter (+0x02)
    mov r0, r3                              ! r3 = phase_counter
    add #-0x1, r3                           ! r3 = phase_counter - 1
    mov r3, r0                              ! r0 = decremented phase
.L_write_phase:
    mov.b r0, @(2, r14)                     ! elem.phase_counter = new value
.L_epilogue:
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return
    mov.l @r15+, r14                        ! restore r14 (delay slot)
