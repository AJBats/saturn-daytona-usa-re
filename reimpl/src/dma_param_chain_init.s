/* dma_param_chain_init -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603FD40 - 0x0603FE44
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP2 scroll screen DMA parameter chain initializer.
 *
 * dma_param_chain_init(r4=scroll_idx, r5=base_addr, r6=y_dir, r7=x_offset,
 *                      sp[0x64]=stride, sp[0x68]=block_size):
 *   Configures a VDP2 scroll screen's register block via palette_engine_core,
 *   then sets up DMA source addresses for scroll data transfer.
 *
 *   Steps:
 *     1. Disables the scroll screen (clears enable bit via sym_06042BBE)
 *     2. Builds a 10-longword parameter descriptor block on the stack:
 *        - Scroll direction fields (y_dir, x_dir) mapped to 0/1/2
 *          (0=zero, 1=positive, 2=negative)
 *        - Block size, stride, and flag fields
 *     3. Calls palette_engine_core to write VDP2 scroll registers
 *     4. Re-enables the scroll screen (sets enable bit via sym_06042BAC)
 *     5. Polls palette_render_main until render completes (busy-wait)
 *     6. Computes DMA source offsets from position * stride
 *     7. Calls external DMA setup (BSR to 0x0603FFE6)
 *     8. Calls sym_0603C05C to clear/initialize the target memory region
 *
 * loc_0603FE40:
 *   Trivial stub — returns 1 (always-true status).
 */

    .section .text.FUN_0603FD40


    .global dma_param_chain_init
    .type dma_param_chain_init, @function
dma_param_chain_init:
    mov.l r14, @-r15            ! save r14
    mov #0x64, r0               ! r0 = 0x64 (offset to stride arg on caller stack)
    mov.l r13, @-r15            ! save r13
    mov r4, r14                 ! r14 = scroll_idx (scroll screen index)
    mov.l r12, @-r15            ! save r12
    mov #0x0, r13               ! r13 = 0 (constant zero)
    mov.l r11, @-r15            ! save r11
    mov #0x1, r12               ! r12 = 1 (constant one)
    mov.l r10, @-r15            ! save r10
    mov r6, r11                 ! r11 = y_dir (y direction parameter)
    mov.l r9, @-r15             ! save r9
    mov.l r8, @-r15             ! save r8
    sts.l pr, @-r15             ! save return address
    sts.l macl, @-r15           ! save macl
    add #-0x40, r15             ! allocate 64-byte local frame
    mov.l   .L_pool_palette_render_main, r9 ! r9 = &palette_render_main (for poll loop)
    mov.l r5, @r15              ! sp[0] = base_addr
    mov.l r7, @(4, r15)         ! sp[4] = x_offset
    mov.l @(r0, r15), r10       ! r10 = caller sp[0x64] = stride
    mov.l   .L_pool_disable_scroll, r3 ! r3 = &sym_06042BBE (disable scroll enable bit)
    mov #0x68, r0               ! r0 = 0x68 (offset to block_size arg)
    mov.l @(r0, r15), r8        ! r8 = caller sp[0x68] = block_size
    jsr @r3                     ! call sym_06042BBE(scroll_idx) — disable scroll
    mov r14, r4                 ! r4 = scroll_idx (delay slot)
    mov.l r13, @(52, r15)       ! sp[52] = 0 (param block: clear field)
    mov #0x7, r3                ! r3 = 0x07 (flags bitmask)
    mov r15, r4                 ! r4 = sp (pointer to param block base)
    mov.l r12, @(56, r15)       ! sp[56] = 1 (param block: enable field)
    mov.l r3, @(60, r15)        ! sp[60] = 0x07 (param block: flags — bits 0,1,2 set)
    mov.l   .L_pool_color_palette_setup, r3 ! r3 = &sym_06042A8C (color palette setup)
    jsr @r3                     ! call sym_06042A8C(param_block + 0x34)
    add #0x34, r4               ! r4 = sp + 0x34 (delay slot: point past param fields)
    mov.l @(4, r15), r2         ! r2 = x_offset
    mov.l r2, @(12, r15)        ! sp[12] = x_offset (param block: color bank field)
    mov.l @r15, r3              ! r3 = base_addr
    mov.l r3, @(16, r15)        ! sp[16] = base_addr (param block: palette number field)
    mov r8, r3                  ! r3 = block_size
    shlr2 r3                    ! r3 = block_size >> 2 (longword count)
    mov.l r3, @(8, r15)         ! sp[8] = longword_count (param block: slot 2 value)
    cmp/pl r11                  ! test if y_dir > 0
    bf/s    .L_y_not_positive   ! branch if y_dir <= 0
    mov.l r3, @(20, r15)        ! sp[20] = longword_count (param block: color offset)
    bra     .L_y_dir_done       ! y_dir > 0: use value 1
    mov.l r12, @(24, r15)       ! sp[24] = 1 (positive direction) (delay slot)
.L_y_not_positive:
    cmp/pz r11                  ! test if y_dir >= 0
    bt      .L_y_dir_zero       ! branch if y_dir == 0 (since >0 already failed)
    mov #0x2, r3                ! r3 = 2 (negative direction)
    mov.l r3, @(24, r15)        ! sp[24] = 2 (param block: special priority = negative)
    bra     .L_y_dir_done       ! done setting y direction
    nop                         ! delay slot
.L_y_dir_zero:
    mov.l r13, @(24, r15)       ! sp[24] = 0 (param block: special priority = zero)
.L_y_dir_done:
    cmp/pl r10                  ! test if stride > 0
    bf      .L_x_not_positive   ! branch if stride <= 0
    bra     .L_x_dir_done       ! stride > 0: use value 1
    mov.l r12, @(28, r15)       ! sp[28] = 1 (positive direction) (delay slot)
.L_x_not_positive:
    cmp/pz r10                  ! test if stride >= 0
    bt      .L_x_dir_zero       ! branch if stride == 0
    mov #0x2, r3                ! r3 = 2 (negative direction)
    mov.l r3, @(28, r15)        ! sp[28] = 2 (param block: function bits = negative)
    bra     .L_x_dir_done       ! done setting x direction
    nop                         ! delay slot
    .2byte  0xFFFF              /* alignment padding */
.L_pool_palette_render_main:
    .4byte  palette_render_main
.L_pool_disable_scroll:
    .4byte  sym_06042BBE
.L_pool_color_palette_setup:
    .4byte  sym_06042A8C
.L_x_dir_zero:
    mov.l r13, @(28, r15)       ! sp[28] = 0 (param block: function bits = zero)
.L_x_dir_done:
    mov r14, r5                 ! r5 = scroll_idx (second arg for palette_engine_core)
    mov r15, r4                 ! r4 = sp (param block pointer)
    mov.w   .L_wpool_block_size, r3 ! r3 = 0x0800 (2048 bytes — DMA block size)
    mov.l r3, @(32, r15)        ! sp[32] = 0x0800 (param block: byte write value)
    shlr2 r3                    ! r3 = 0x0200 (512 longwords)
    mov.l r3, @(36, r15)        ! sp[36] = 0x0200 (param block: flags for engine_core)
    mov.l r13, @(40, r15)       ! sp[40] = 0 (param block: clear field)
    mov.w   .L_wpool_scroll_flags, r3 ! r3 = 0x017F (flags: bits 0-6 + bit 8 set)
    mov.l r3, @(48, r15)        ! sp[48] = 0x017F (param block: full flag set)
    mov.l   .L_pool_palette_engine_core, r3 ! r3 = &palette_engine_core
    jsr @r3                     ! call palette_engine_core(param_block, scroll_idx)
    add #0xC, r4                ! r4 = sp + 0x0C (delay slot: offset into param block)
    mov.l   .L_pool_enable_scroll, r3 ! r3 = &sym_06042BAC (enable scroll enable bit)
    jsr @r3                     ! call sym_06042BAC(scroll_idx) — re-enable scroll
    mov r14, r4                 ! r4 = scroll_idx (delay slot)
.L_poll_render:
    jsr @r9                     ! call palette_render_main(scroll_idx) — poll status
    mov r14, r4                 ! r4 = scroll_idx (delay slot)
    tst r0, r0                  ! test if result == 0
    bt      .L_poll_render      ! loop until palette_render_main returns nonzero
    mov #0x3, r4                ! r4 = 3 (DMA alignment mask)
    mov.l @(8, r15), r14        ! r14 = longword_count (block_size >> 2)
    mov.l @(4, r15), r3         ! r3 = x_offset
    mov.l @r15, r2              ! r2 = base_addr
    mul.l r14, r10              ! macl = longword_count * stride
    sts macl, r6                ! r6 = longword_count * stride
    shll2 r6                    ! r6 = (longword_count * stride) << 2 (byte offset)
    mul.l r14, r11              ! macl = longword_count * y_dir
    add r3, r6                  ! r6 += x_offset (x source address)
    sts macl, r5                ! r5 = longword_count * y_dir
    shll2 r5                    ! r5 = (longword_count * y_dir) << 2 (byte offset)
    add r2, r5                  ! r5 += base_addr (y source address)
    .byte   0xB0, 0xED    /* bsr 0x0603FFE6 (external) */
    and r8, r4                  ! r4 = block_size & 3 (alignment bits) (delay slot)
    mov r8, r5                  ! r5 = block_size (DMA transfer length)
    mov.l   .L_pool_mem_clear, r3 ! r3 = &sym_0603C05C (memory region clear)
    jsr @r3                     ! call sym_0603C05C(base_addr, block_size)
    mov.l @r15, r4              ! r4 = base_addr (delay slot)
    add #0x40, r15              ! deallocate 64-byte local frame
    lds.l @r15+, macl           ! restore macl
    lds.l @r15+, pr             ! restore return address
    mov.l @r15+, r8             ! restore r8
    mov.l @r15+, r9             ! restore r9
    mov.l @r15+, r10            ! restore r10
    mov.l @r15+, r11            ! restore r11
    mov.l @r15+, r12            ! restore r12
    mov.l @r15+, r13            ! restore r13
    rts                         ! return
    mov.l @r15+, r14            ! restore r14 (delay slot)
    .2byte  0x000B              /* trailing data (rts encoding) */
    .2byte  0xE000              /* trailing data (mov #0, r0 encoding) */
.L_wpool_block_size:
    .2byte  0x0800
.L_wpool_scroll_flags:
    .2byte  0x017F
    .2byte  0xFFFF              /* alignment padding */
.L_pool_palette_engine_core:
    .4byte  palette_engine_core
.L_pool_enable_scroll:
    .4byte  sym_06042BAC
.L_pool_mem_clear:
    .4byte  sym_0603C05C

    .global loc_0603FE40
loc_0603FE40:
    rts                         ! return
    mov #0x1, r0                ! r0 = 1 (always-true status) (delay slot)
