/* VERIFIED: runs every physics frame during racing, 3x more often during steering
 * Method: call-trace differential — 5 frames idle vs 5 frames with LEFT/RIGHT in race
 *   LEFT:  117 calls (baseline 39, +78) — 3x increase
 *   RIGHT: 117 calls (baseline 39, +78) — identical response
 *   All 6 sub-functions (gear_shift_handler, engine_force, friction_stub,
 *   accel_response, player_collision, track_segment_advance) show the same +78 delta,
 *   confirming they are called as a batch from this function's physics pipeline.
 * Date: 2026-02-28
 */
/* player_physics_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600E71A - 0x0600E7C8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Player car per-frame physics pipeline — orchestrates the 6 physics
 * sub-steps for the player's car each frame:
 *
 *   1. gear_shift_handler    — process manual gear changes
 *   2. engine_force           — compute engine torque/output
 *   3. friction_stub          — apply surface friction
 *   4. accel_response         — compute acceleration from input/gear/speed
 *   5. player_collision       — detect and respond to collisions
 *   6. track_segment_advance  — advance track segment tracking
 *
 * After the pipeline, a surface-change timer at car[+0x208] is checked:
 * when it reaches zero, the next surface entry is looked up from a
 * 24-byte slot array (indexed by car[+0x1E4]), and the surface type
 * is written to car[+0x1F8].
 *
 * Final step: velocity integration
 *   car[+0x1F4] = car[+0x1EC] + car[+0x228] * speed_coefficient
 */

    .section .text.FUN_0600E71A


    .global player_physics_main
    .type player_physics_main, @function
player_physics_main:
    mov.l r14, @-r15
    sts.l pr, @-r15
    sts.l macl, @-r15
    .byte   0xDE, 0x21    /* mov.l .L_car_struct_ptr, r14 */
    .byte   0xD3, 0x22    /* mov.l .L_fn_gear_shift, r3 */
    jsr @r3                            /* step 1: gear shift handler */
    mov.l @r14, r14                    /* r14 = car struct pointer */
    .byte   0xD3, 0x21    /* mov.l .L_fn_engine_force, r3 */
    jsr @r3                            /* step 2: engine force computation */
    nop
    .byte   0xD3, 0x21    /* mov.l .L_fn_friction, r3 */
    jsr @r3                            /* step 3: surface friction */
    nop
    .byte   0xD3, 0x20    /* mov.l .L_fn_accel_response, r3 */
    jsr @r3                            /* step 4: acceleration response */
    nop
    .byte   0xD3, 0x20    /* mov.l .L_fn_player_collision, r3 */
    jsr @r3                            /* step 5: player collision */
    nop
    mov.w   DAT_0600e79c, r0          /* r0 = +0x208 (surface change timer) */
    mov.l @(r0, r14), r2              /* r2 = car.surface_timer */
    cmp/pl r2
    bf      .L_0600E778               /* timer <= 0 → skip surface update */
    mov.w   DAT_0600e79c, r0
    mov.l @(r0, r14), r2              /* decrement surface timer */
    add #-0x1, r2
    mov.l r2, @(r0, r14)
    tst r2, r2
    bf      .L_0600E778               /* timer > 0 still → skip */
    mov.w   DAT_0600e79e, r0          /* timer reached 0 → surface lookup */
    mov.l @(r0, r14), r4              /* r4 = car[+0x1E4] (surface slot index) */
    mov r4, r3
    shll2 r4                           /* idx * 4 */
    shll r4                            /* idx * 8 */
    shll2 r3                           /* idx * 4 */
    shll2 r3                           /* idx * 16 */
    add r3, r4                         /* r4 = idx * 24 (slot stride) */
    add #-0x4, r0                      /* r0 = +0x1E0 (slot base pointer) */
    mov.l @(r0, r14), r3              /* r3 = car[+0x1E0] (slot array base) */
    add r3, r4                         /* r4 = &slot[idx] */
    mov.w @(20, r4), r0               /* slot[+20] = surface type (16-bit) */
    mov r0, r3
    mov.w   .L_off_surface_type, r0   /* +0x1F8 = car.surface_type */
    mov.l r3, @(r0, r14)              /* store new surface type */
    mov.w   .L_surface_reset_val, r3  /* 0x0400 = reset constant */
    add #0xC, r0                       /* r0 = +0x204 */
    mov.l r3, @(r0, r14)              /* car[+0x204] = 0x400 */
.L_0600E778:
    .byte   0xD3, 0x11    /* mov.l .L_fn_track_advance, r3 */
    jsr @r3                            /* step 6: track segment advance */
    nop
    mov.w   .L_off_speed, r0          /* velocity integration */
    .byte   0xD3, 0x10    /* mov.l .L_speed_coeff, r3 */
    mov.l @(r0, r14), r2              /* r2 = car[+0x228] (forward speed) */
    mov.l @r3, r3                      /* r3 = speed coefficient */
    add #-0x3C, r0                     /* r0 = +0x1EC */
    mul.l r3, r2                       /* speed * coefficient */
    mov.l @(r0, r14), r3              /* r3 = car[+0x1EC] (position base) */
    sts macl, r2                       /* r2 = product (low 32 bits) */
    add #0x8, r0                       /* r0 = +0x1F4 */
    add r3, r2                         /* r2 = position + speed*coeff */
    mov.l r2, @(r0, r14)              /* car[+0x1F4] = integrated position */
    lds.l @r15+, macl
    lds.l @r15+, pr
    rts
    mov.l @r15+, r14

    .global DAT_0600e79c
DAT_0600e79c:
    .2byte  0x0208                        /* car struct offset: surface change timer */

    .global DAT_0600e79e
DAT_0600e79e:
    .2byte  0x01E4                        /* car struct offset: surface slot index */
.L_off_surface_type:
    .2byte  0x01F8                        /* car struct offset: surface type */
.L_surface_reset_val:
    .2byte  0x0400                        /* surface timer reset constant */
.L_off_speed:
    .2byte  0x0228                        /* car struct offset: forward speed */
    .2byte  0xFFFF
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* pointer to current car struct */
.L_fn_gear_shift:
    .4byte  gear_shift_handler         /* step 1: manual gear shift */
.L_fn_engine_force:
    .4byte  sym_06008640               /* step 2: engine torque/force */
.L_fn_friction:
    .4byte  friction_stub              /* step 3: surface friction */
.L_fn_accel_response:
    .4byte  accel_response             /* step 4: acceleration curve */
.L_fn_player_collision:
    .4byte  player_collision           /* step 5: collision detection */
.L_fn_track_advance:
    .4byte  track_segment_advance      /* step 6: track segment tracking */
.L_speed_coeff:
    .4byte  sym_0607EA9C               /* speed integration coefficient */
