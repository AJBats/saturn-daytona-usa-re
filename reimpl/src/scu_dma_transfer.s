/* scu_dma_transfer -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603FE80 - 0x0603FF3A
 * Auto-generated by tools/generate_l3_tu.py
 */

/* ==========================================================================
 * scu_dma_transfer — SCU DMA Level 0 Transfer with Interrupt Protection
 * ==========================================================================
 *
 * Initiates an SCU DMA level 0 transfer with full interrupt protection.
 * Disables interrupts before programming, polls for DMA completion via
 * the SCU IST register, then restores the previous interrupt state.
 *
 * Arguments:
 *   r4  = previous interrupt mask (passed to restore call at end)
 *   r5  = DMA write (destination) address — 0 means skip transfer
 *   r6  = indirect mode flag (nonzero → set indirect bit in D0AD)
 *   r7  = DMA read (source) address
 *   @(28, r15) = address update mode flag (nonzero → set 0x100 in D0AD)
 *   @(32, r15) = transfer byte count
 *
 * SCU DMA Level 0 registers at 0x25FE0000:
 *   +0x00 D0R  — read (source) address
 *   +0x04 D0W  — write (destination) address
 *   +0x08 D0C  — transfer byte count
 *   +0x0C D0AD — address add value (src/dst increment control)
 *   +0x10 D0EN — DMA enable (0x0101 = enable + start)
 *   +0x14 D0MD — DMA mode (7 = direct, immediate start)
 *
 * SCU IST bit 11 (0x0800) = DMA level 0 end interrupt.
 * The function polls this bit to detect transfer completion.
 *
 * Also contains two small return stubs (dma_callback_return_0,
 * dma_callback_return_1) used as DMA completion callback entries.
 * ========================================================================== */

    .section .text.FUN_0603FE80


    .global scu_dma_transfer
    .type scu_dma_transfer, @function
scu_dma_transfer:
    mov.l r14, @-r15                    ! save r14 (will hold SCU IST addr)
    mov.l r13, @-r15                    ! save r13 (will hold DMA-end bit mask)
    sts.l pr, @-r15                     ! save return address
    add #-0x10, r15                     ! allocate 16 bytes of local stack
    mov.w   .L_dma_end_bit_mask, r13    ! r13 = 0x0800 (DMA L0 end interrupt bit)
    mov.l   .L_scu_ist, r14            ! r14 = 0x25FE00A4 (SCU IST register)
    mov.l r5, @r15                      ! local[0] = write (dest) address
    mov.l r6, @(8, r15)                ! local[2] = indirect mode flag
    mov.l r7, @(4, r15)                ! local[1] = read (source) address
    mov.l   .L_bios_int_state_ptr, r3  ! r3 = &sym_06000348 (interrupt state var)
    mov.l @r3, r3                       ! r3 = current interrupt state value
    mov.l r3, @(12, r15)               ! local[3] = saved interrupt state (for restore)
    mov.l @r15, r0                      ! r0 = dest address
    tst r0, r0                          ! dest address == 0?
    bf      .L_dest_valid               ! no — proceed with DMA setup
    bra     .L_epilogue_no_dma          ! yes — skip transfer entirely
    nop                                 ! (delay slot)
.L_dest_valid:
    mov.l   .L_abus_cs1_timing, r3     ! r3 = 0x10041004 (A-bus CS1 timing value)
    mov.l   .L_scu_asr1, r2            ! r2 = 0x25FE00B4 (SCU ASR1 register)
    mov.l r3, @r2                       ! SCU ASR1 = 0x10041004 (configure A-bus timing)
    mov.l   .L_bios_int_ctrl_ptr, r3   ! r3 = &sym_06000340 (interrupt control fn ptr)
    mov.l @r3, r3                       ! r3 = interrupt control function address
    jsr @r3                             ! call interrupt control to disable interrupts
    mov #-0x1, r4                       ! r4 = 0xFFFFFFFF (mask all — delay slot)
    mov.w   .L_ist_dma_clear, r2       ! r2 = 0xF7FF (clear DMA L0 end bit)
    mov.l r2, @r14                      ! SCU IST = 0xF7FF (acknowledge DMA L0 end)
    mov.l @(4, r15), r3                ! r3 = read (source) address
    mov.l   .L_scu_d0r, r2             ! r2 = 0x25FE0000 (SCU D0R — read addr reg)
    mov.l r3, @r2                       ! D0R = source address
    add #0x4, r2                        ! r2 = 0x25FE0004 (SCU D0W — write addr reg)
    mov.l @r15, r3                      ! r3 = write (dest) address
    mov.l r3, @r2                       ! D0W = dest address
    mov.l @(32, r15), r3               ! r3 = byte count (6th arg, 2nd stack param)
    add #0x4, r2                        ! r2 = 0x25FE0008 (SCU D0C — byte count reg)
    mov.l r3, @r2                       ! D0C = transfer byte count
    mov.l @(28, r15), r0               ! r0 = addr update mode flag (5th arg)
    tst r0, r0                          ! addr update flag == 0?
    bf      .L_addr_update_set          ! no — use 0x100 (source addr increment)
    bra     .L_addr_update_done         ! yes — use 0 (fixed source address)
    mov #0x0, r4                        ! r4 = 0 (no source addr update — delay slot)
.L_addr_update_set:
    mov.w   .L_src_addr_add, r4         ! r4 = 0x0100 (source address add value)
.L_addr_update_done:
    mov.l @(8, r15), r0                ! r0 = indirect mode flag
    tst r0, r0                          ! indirect flag == 0?
    bf      .L_indirect_set             ! no — use indirect DMA mode
    bra     .L_indirect_done            ! yes — direct DMA mode
    mov #0x0, r5                        ! r5 = 0 (direct mode — delay slot)
.L_dma_end_bit_mask:
    .2byte  0x0800                      /* SCU IST bit 11: DMA L0 end interrupt */
.L_ist_dma_clear:
    .2byte  0xF7FF                      /* IST write mask: clear DMA L0 end bit */
.L_src_addr_add:
    .2byte  0x0100                      /* D0AD source address add value */
    .2byte  0xFFFF                      /* padding */
.L_scu_ist:
    .4byte  0x25FE00A4                  /* SCU IST — interrupt status */
.L_bios_int_state_ptr:
    .4byte  sym_06000348
.L_abus_cs1_timing:
    .4byte  0x10041004
.L_scu_asr1:
    .4byte  0x25FE00B4                  /* SCU ASR1 — A-bus timing CS1 */
.L_bios_int_ctrl_ptr:
    .4byte  sym_06000340
.L_scu_d0r:
    .4byte  0x25FE0000                  /* SCU D0R — DMA level 0 read addr */
.L_indirect_set:
    mov #0x2, r5                        ! r5 = 2 (indirect DMA mode)
.L_indirect_done:
    or r5, r4                           ! r4 = addr_update | indirect_mode
    .byte   0xD3, 0x12    /* mov.l @(0x25FE000C), r3 — D0AD register addr (cross-TU pool) */
    mov.l r4, @r3                       ! D0AD = address add mode
    mov #0x7, r2                        ! r2 = 7 (DMA mode: direct, immediate start)
    add #0x8, r3                        ! r3 = 0x25FE0014 (D0MD — mode register)
    mov.l r2, @r3                       ! D0MD = 7 (start DMA transfer)
    .byte   0x92, 0x1E    /* mov.w @(0x0101), r2 — DMA enable value (cross-TU pool) */
    add #-0x4, r3                       ! r3 = 0x25FE0010 (D0EN — enable register)
    mov.l r2, @r3                       ! D0EN = 0x0101 (enable + go)
.L_poll_dma_end:
    mov.l @r14, r2                      ! r2 = SCU IST current value
    and r13, r2                         ! isolate DMA L0 end bit (0x0800)
    tst r2, r2                          ! DMA complete?
    bt      .L_poll_dma_end             ! no — keep polling
    .byte   0xD3, 0x0D    /* mov.l @(sym_06000340), r3 — int ctrl fn ptr (cross-TU pool) */
    mov.l @r3, r3                       ! r3 = interrupt control function address
    mov.l @(12, r15), r4               ! r4 = saved interrupt state (restore arg)
    add #0x10, r15                      ! deallocate local stack frame
    lds.l @r15+, pr                     ! restore PR (unused — tail call follows)
    mov.l @r15+, r13                    ! restore r13
    jmp @r3                             ! tail-call: restore interrupts to saved state
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_epilogue_no_dma:
    add #0x10, r15                      ! deallocate local stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return — no DMA was performed
    mov.l @r15+, r14                    ! restore r14 (delay slot)

    .global loc_0603FF32
loc_0603FF32:
    rts                                 ! return immediately
    mov #0x0, r0                        ! return 0 (DMA callback: success/idle)

    .global loc_0603FF36
loc_0603FF36:
    rts                                 ! return immediately
    mov #0x1, r0                        ! return 1 (DMA callback: busy/active)
