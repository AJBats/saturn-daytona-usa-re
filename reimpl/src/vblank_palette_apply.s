/* vblank_palette_apply -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603FC60 - 0x0603FCE4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Applies a batch of palette entries during VBlank.
 *
 * Computes a batch size from the descriptor's remaining/pending counts,
 * optionally divides by the phase counter for sub-batching, and clamps
 * against a limit obtained from the element_b callback. If no element_a
 * has been allocated yet, dispatches through slot 3 to allocate one.
 *
 * Args:
 *   r4 = desc      — palette descriptor struct pointer
 *   r5 = head      — display list head
 *   r6 = elem_b    — element_b handle (passed to callback)
 *
 * Descriptor struct offsets used:
 *   +4   element_a         — palette element pointer (NULL if not yet allocated)
 *   +16  remaining_count   — max entries this call can process
 *   +20  total_count       — total palette entries
 *   +24  applied_count_b   — entries already applied (subtracted from total)
 *   +28  applied_offset    — current offset into element_a data
 *   +48  phase_counter     — number of sub-phases for gradual application
 *
 * Calls:
 *   sym_06034FFC (signed_div_32)   — r0 = r1 / r0 (signed 32-bit divide)
 *   sym_0603F8EE (cmd_dispatch_slot2) — dispatches callback from desc slot 2
 *   sym_0603F900 (cmd_dispatch_slot3) — dispatches callback from desc slot 3
 *     (cross-TU pool reference at 0x0603FD34 in hud_palette_select)
 */

    .section .text.FUN_0603FC60


    .global vblank_palette_apply
    .type vblank_palette_apply, @function
vblank_palette_apply:
    mov.l r14, @-r15                    ! save r14
    mov r4, r14                         ! r14 = desc (palette descriptor)
    mov.l r13, @-r15                    ! save r13
    sts.l pr, @-r15                     ! save return address
    add #-0x8, r15                      ! allocate 8 bytes on stack
    mov.l r5, @r15                      ! stack[0] = head (display list head)
    mov.l r6, @(4, r15)                 ! stack[4] = elem_b (element_b handle)
    mov.l @(16, r14), r4                ! r4 = desc->remaining_count
    mov.l @(20, r14), r5                ! r5 = desc->total_count
    mov.l @(24, r14), r3                ! r3 = desc->applied_count_b
    sub r3, r5                          ! r5 = total_count - applied_count_b = pending_count
    cmp/ge r5, r4                       ! remaining_count >= pending_count?
    bt      .L_use_pending              ! yes — use smaller pending_count
    bra     .L_batch_ready              ! no — use remaining_count
    mov r4, r13                         ! r13 = remaining_count (delay slot)
.L_use_pending:
    mov r5, r13                         ! r13 = pending_count (smaller of the two)
.L_batch_ready:
    mov.l @(48, r14), r2                ! r2 = desc->phase_counter
    mov #0x1, r3                        ! r3 = 1
    cmp/gt r3, r2                       ! phase_counter > 1?
    bf      .L_batch_done               ! no — single phase, skip sub-batching
    mov.l @(4, r14), r0                 ! r0 = desc->element_a
    tst r0, r0                          ! element_a == NULL?
    bt      .L_query_elem_b             ! yes — skip divide, just query limit
    mov.l @(4, r14), r1                 ! r1 = desc->element_a
    mov.l @(28, r14), r3                ! r3 = desc->applied_offset
    mov.l   .L_pool_signed_div_32, r2   ! r2 = &signed_div_32
    mov.l @(8, r1), r1                  ! r1 = element_a->data_size (field +8)
    sub r3, r1                          ! r1 = data_size - applied_offset = remaining_data
    jsr @r2                             ! r0 = remaining_data / phase_counter
    mov.l @(48, r14), r0                ! r0 = phase_counter (delay slot — divisor)
    mov r0, r13                         ! r13 = per-phase batch from element_a
.L_query_elem_b:
    mov.l   .L_pool_dispatch_slot2, r3  ! r3 = &cmd_dispatch_slot2
    jsr @r3                             ! r0 = slot2_callback(elem_b) — query available count
    mov.l @(4, r15), r4                 ! r4 = elem_b from stack (delay slot)
    mov r0, r1                          ! r1 = available count from callback
    mov.l   .L_pool_signed_div_32, r2   ! r2 = &signed_div_32
    jsr @r2                             ! r0 = available_count / phase_counter
    mov.l @(48, r14), r0                ! r0 = phase_counter (delay slot — divisor)
    mov r0, r4                          ! r4 = per-phase limit from elem_b
    cmp/ge r4, r13                      ! batch_size >= per_phase_limit?
    bt      .L_clamp_batch              ! yes — clamp down to limit
    bra     .L_batch_done               ! no — keep current batch_size
    nop

    .global DAT_0603fcb6
DAT_0603fcb6:
    .word 0xFF7F /* UNKNOWN */
.L_pool_signed_div_32:
    .4byte  sym_06034FFC
.L_pool_dispatch_slot2:
    .4byte  sym_0603F8EE
.L_clamp_batch:
    mov r4, r13                         ! r13 = clamped batch_size (per-phase limit)
.L_batch_done:
    mov.l @(4, r14), r0                 ! r0 = desc->element_a
    tst r0, r0                          ! element_a == NULL?
    bf      .L_epilogue                 ! non-NULL — already allocated, done
    mov r13, r5                         ! r5 = batch_size (requested allocation count)
    .byte   0xD3, 0x1A    /* mov.l .L_pool_0603FD34, r3 */  ! r3 = &cmd_dispatch_slot3 (cross-TU pool)
    jsr @r3                             ! r0 = slot3_callback(head, batch_size) — allocate element
    mov.l @r15, r4                      ! r4 = head from stack (delay slot)
    mov.l r0, @(4, r14)                 ! desc->element_a = allocated element
    tst r0, r0                          ! allocation succeeded?
    bt      .L_epilogue                 ! NULL — allocation failed, skip init
    mov #0x0, r3                        ! r3 = 0
    mov.l r3, @(28, r14)                ! desc->applied_offset = 0 (reset for new element)
.L_epilogue:
    add #0x8, r15                       ! free stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
