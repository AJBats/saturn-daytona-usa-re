/* track_segment_advance -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600CEBA - 0x0600CF58
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Track Segment Advancement & Heading Interpolation
 * ==================================================
 * Called per-car from player_physics_main (step 7) and ai_physics_main.
 * Checks if the car has advanced past the current track segment boundary
 * and updates segment counters and heading data accordingly.
 *
 * Logic:
 *   1. Read current segment index from car[+0x184]
 *   2. Look up segment heading from track segment table (sym_0607EB84)
 *      using index * 4 as byte offset; read heading word at [index*4]
 *   3. Save old heading (car[+0x01EC]) into backup (car[+0x01F0]),
 *      then store new heading from segment table into car[+0x01EC]
 *   4. Call memcpy_byte twice:
 *      a. Copy 2 bytes from car[+0x160] to car[+0x162] (save old heading component)
 *      b. Copy 2 bytes from segment[index]+2 to car[+0x160] (load new heading component)
 *   5. Compute delta = old_heading_backup - new_heading (car[+0x01F0] - car[+0x01EC])
 *   6. If delta > 0 AND delta > (section_count - 16):
 *      -> Car passed segment boundary
 *      -> Increment crossing counter (car[+0x228]), copy to car[+0x21C]
 *      -> Compute distance_remaining = total_track_length - car[+0x22C]
 *      -> Store remaining to car[+0x220], total to car[+0x22C]
 *
 * Car struct offsets used:
 *   +0x0160 = heading component (current, 2 bytes)
 *   +0x0162 = heading component (previous, 2 bytes)
 *   +0x0184 = current track segment index
 *   +0x01EC = target heading (from segment table)
 *   +0x01F0 = previous heading backup
 *   +0x0220 = distance remaining
 *   +0x021C = crossing counter copy
 *   +0x0228 = crossing counter (primary)
 *   +0x022C = distance traveled / total track length
 *
 * External references:
 *   sym_0607E940 = pointer to current car struct
 *   sym_0607EB84 = pointer to track segment table (4 bytes per entry)
 *   sym_06035228 = memcpy_byte(r0=count, r1=dst, r2=src)
 *   sym_0607EA9C = track section count
 *   sym_0607EBD0 = total track length
 */

    .section .text.FUN_0600CEBA


    .global track_segment_advance
    .type track_segment_advance, @function
track_segment_advance:
    sts.l pr, @-r15                             ! save return address
    .byte   0xD4, 0x22    /* mov.l .L_p_car_struct_ptr, r4 */  ! r4 = &car_struct_ptr (sym_0607E940)
    mov.w   DAT_0600cf3a, r0                    ! r0 = 0x0184 (segment index offset)
    .byte   0xD3, 0x20    /* mov.l .L_p_segment_table, r3 */   ! r3 = &segment_table_ptr (sym_0607EB84)
    mov.l @r4, r4                               ! r4 = car struct base
    mov.l @r3, r3                               ! r3 = segment table base
    mov.l @(r0, r4), r5                         ! r5 = car[0x184] = current segment index
    add #0x68, r0                               ! r0 = 0x01EC (target heading offset)
    shll2 r5                                    ! r5 = index * 4 (byte offset into segment table)
    mov.l @(r0, r4), r2                         ! r2 = car[0x01EC] = current target heading
    add r3, r5                                  ! r5 = &segment_table[index]
    add #0x4, r0                                ! r0 = 0x01F0 (heading backup offset)
    mov.l r2, @(r0, r4)                         ! car[0x01F0] = save current heading as backup
    mov.w @r5, r3                               ! r3 = segment_table[index] heading word
    add #-0x4, r0                               ! r0 = 0x01EC (target heading offset)
    extu.w r3, r3                               ! zero-extend heading to 32-bit
    mov.l r3, @(r0, r4)                         ! car[0x01EC] = new target heading from segment table
    mov.w   .L_wpool_0600CF3C, r1               ! r1 = 0x0162 (previous heading component offset)
    mov.w   .L_wpool_0600CF3E, r2               ! r2 = 0x0160 (current heading component offset)
    .byte   0xD3, 0x1A    /* mov.l .L_p_memcpy_byte, r3 */     ! r3 = memcpy_byte (sym_06035228)
    add r4, r1                                  ! r1 = &car[0x162] (dst: save old heading component)
    add r4, r2                                  ! r2 = &car[0x160] (src: current heading component)
    jsr @r3                                     ! call memcpy_byte: copy car[0x160] -> car[0x162]
    mov #0x2, r0                                ! (delay) r0 = 2 bytes to copy
    mov r5, r2                                  ! r2 = &segment_table[index]
    .byte   0xD3, 0x17    /* mov.l .L_p_memcpy_byte, r3 */     ! r3 = memcpy_byte (sym_06035228)
    mov.w   .L_wpool_0600CF3E, r1               ! r1 = 0x0160 (current heading component offset)
    add #0x2, r2                                ! r2 = &segment_table[index]+2 (second heading word)
    add r4, r1                                  ! r1 = &car[0x160] (dst: update heading component)
    jsr @r3                                     ! call memcpy_byte: copy segment[idx]+2 -> car[0x160]
    mov #0x2, r0                                ! (delay) r0 = 2 bytes to copy
    mov.w   DAT_0600cf40, r0                    ! r0 = 0x01F0 (heading backup offset)
    mov.l @(r0, r4), r6                         ! r6 = car[0x01F0] = old heading backup
    add #-0x4, r0                               ! r0 = 0x01EC (target heading offset)
    mov.l @(r0, r4), r3                         ! r3 = car[0x01EC] = new target heading
    sub r3, r6                                  ! r6 = old_backup - new_target = heading delta
    exts.w r6, r6                               ! sign-extend delta to 32-bit
    exts.w r6, r5                               ! r5 = delta (working copy)
    cmp/pl r5                                   ! is delta > 0? (forward progress)
    bf      .L_no_segment_cross                 ! if not, skip segment crossing logic
    .byte   0xD2, 0x11    /* mov.l .L_p_section_count, r2 */   ! r2 = &section_count (sym_0607EA9C)
    mov.l @r2, r2                               ! r2 = section_count
    add #-0x10, r2                              ! r2 = section_count - 16 (crossing threshold)
    cmp/gt r2, r5                               ! delta > threshold?
    bf      .L_no_segment_cross                 ! if not, not enough progress to cross segment
    mov.w   .L_wpool_0600CF42, r0               ! r0 = 0x0228 (crossing counter offset)
    mov.l @(r0, r4), r2                         ! r2 = car[0x228] = crossing counter
    add #0x1, r2                                ! increment crossing counter
    mov.l r2, @(r0, r4)                         ! car[0x228] = counter + 1
    add #-0xC, r0                               ! r0 = 0x021C (secondary counter offset)
    mov.l r2, @(r0, r4)                         ! car[0x21C] = counter + 1 (copy to secondary)
    .byte   0xD5, 0x0C    /* mov.l .L_p_total_track_len, r5 */ ! r5 = &total_track_length (sym_0607EBD0)
    mov.l @r5, r3                               ! r3 = total_track_length
    add #0x10, r0                               ! r0 = 0x022C (distance traveled offset)
    mov.l @(r0, r4), r2                         ! r2 = car[0x22C] = distance traveled
    sub r2, r3                                  ! r3 = total - traveled = distance remaining
    add #-0xC, r0                               ! r0 = 0x0220 (distance remaining offset)
    mov.l r3, @(r0, r4)                         ! car[0x220] = distance remaining
    mov.l @r5, r3                               ! r3 = total_track_length (reload)
    add #0xC, r0                                ! r0 = 0x022C (distance traveled offset)
    mov.l r3, @(r0, r4)                         ! car[0x22C] = total_track_length (reset baseline)
.L_no_segment_cross:
    lds.l @r15+, pr                             ! restore return address
    rts                                         ! return
    nop                                         ! (delay slot)

    .global DAT_0600cf3a
DAT_0600cf3a:                                   ! car struct offset: segment index
    .2byte  0x0184
.L_wpool_0600CF3C:                              ! car struct offset: previous heading component
    .2byte  0x0162
.L_wpool_0600CF3E:                              ! car struct offset: current heading component
    .2byte  0x0160

    .global DAT_0600cf40
DAT_0600cf40:                                   ! car struct offset: heading backup
    .2byte  0x01F0
.L_wpool_0600CF42:                              ! car struct offset: crossing counter
    .2byte  0x0228
.L_p_segment_table:                             ! -> track segment table pointer (sym_0607EB84)
    .4byte  sym_0607EB84
.L_p_car_struct_ptr:                            ! -> current car struct pointer (sym_0607E940)
    .4byte  sym_0607E940
.L_p_memcpy_byte:                               ! -> memcpy_byte function (sym_06035228)
    .4byte  sym_06035228
.L_p_section_count:                             ! -> track section count (sym_0607EA9C)
    .4byte  sym_0607EA9C
.L_p_total_track_len:                           ! -> total track length (sym_0607EBD0)
    .4byte  sym_0607EBD0
