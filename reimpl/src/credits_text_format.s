/* credits_text_format -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603F2EC - 0x0603F342
 * Auto-generated by tools/generate_l3_tu.py
 *
 * credits_text_format(r13=entry_count, r14=output_buf):
 *   Formats credit text entries into an output buffer. Initializes a ring
 *   buffer descriptor via ring_desc_init (0x0603F3DA), then loops through
 *   entries: reads each via vblank_dma_chain (0x0603F582), checks for valid
 *   data (non-zero first byte), and copies valid entries to the output buffer
 *   via the entry copy routine (0x0603F84C). Advances the output buffer by
 *   0xC per entry. On exit, marks the last entry with bit 7 set at offset 11
 *   (end-of-page flag) and returns the processed entry count in r0.
 */

    .section .text.FUN_0603F2EC


    .global credits_text_format
    .type credits_text_format, @function
credits_text_format:
    sts.l pr, @-r15                             ! save return address
    add #-0x38, r15                             ! allocate 0x38 (56) bytes of stack frame
    mov.l r4, @r15                              ! save credits_data pointer on stack [sp+0]
    mov r15, r4                                 ! r4 = stack frame base (for descriptor)
    .byte   0xB0, 0x71    /* bsr 0x0603F3DA (external) */ ! call ring_desc_init — init ring buffer descriptor
    add #0x24, r4                               ! r4 = &stack_descriptor (delay slot)
    mov #0x0, r4                                ! r4 = 0 (used for comparison and init)
    cmp/gt r4, r13                              ! entry_count > 0?
    bf/s    .L_loop_done                        ! no entries to process — skip to exit
    mov r4, r12                                 ! r12 = 0 (processed count, delay slot)
.L_loop_body:
    mov r15, r5                                 ! r5 = stack frame base
    mov r15, r4                                 ! r4 = stack frame base
    add #0x4, r5                                ! r5 = &local_buf[0x4] (entry read buffer)
    .byte   0xB1, 0x3C    /* bsr 0x0603F582 (external) */ ! call vblank_dma_chain — read next entry record
    add #0x24, r4                               ! r4 = &stack_descriptor (delay slot)
    mov r15, r2                                 ! r2 = stack frame base
    add #0x4, r2                                ! r2 = &local_buf[0x4] (entry read buffer)
    mov.b @r2, r3                               ! r3 = first byte of entry record
    extu.b r3, r3                               ! zero-extend to 32 bits
    tst r3, r3                                  ! is entry byte zero (end of data)?
    bf      .L_entry_valid                      ! non-zero — entry has data, process it
    bra     .L_loop_done                        ! zero — no more entries, exit loop
    nop                                         ! delay slot (nop)
.L_entry_valid:
    mov r15, r5                                 ! r5 = stack frame base
    add #0x4, r5                                ! r5 = &local_buf[0x4] (entry read buffer)
    .byte   0xB2, 0x95    /* bsr 0x0603F84C (external) */ ! call entry copy routine — copy entry to output
    mov r14, r4                                 ! r4 = output buffer pointer (delay slot)
    add #0xC, r14                               ! advance output buffer by 0xC (12 bytes per entry)
    add #-0x1, r13                              ! r13-- (decrement remaining entry count)
    cmp/pl r13                                  ! r13 > 0 (more entries to process)?
    bt/s    .L_loop_body                        ! yes — process next entry
    add #0x1, r12                               ! r12++ (increment processed count, delay slot)
.L_loop_done:
    add #-0xC, r14                              ! step back to last written entry
    mov.b @(11, r14), r0                        ! r0 = entry flags byte at offset 11
    or #0x80, r0                                ! set bit 7 (end-of-page marker)
    mov.b r0, @(11, r14)                        ! write back flags with end-of-page bit set
    mov r12, r0                                 ! r0 = processed entry count (return value)
    add #0x38, r15                              ! deallocate stack frame
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return (r0 = number of entries processed)
    mov.l @r15+, r14                            ! restore r14 (delay slot)
