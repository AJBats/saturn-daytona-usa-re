/* attract_init_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603EF64 - 0x0603F0FC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Attract-mode interpolation/transition setup helpers.
 *
 * This TU manages two interpolation "slots" in a shared state block
 * (sym_06063624).  Each slot stores a start position, direction flag,
 * step size (in 2048-unit increments), and step count.  Active flags
 * at offsets +32 (slot A) and +36 (slot B) gate initialisation so a
 * slot cannot be re-initialised while it is still in use.
 *
 * Functions:
 *   attract_init_setup          -- compute step count for an animation range
 *   interp_linear_remainder     -- r0 = (field_8 * field_12) - field_16
 *   interp_slot_a_init          -- set up slot A in the state block
 *   interp_slot_b_init          -- set up slot B in the state block
 *   interp_slot_apply           -- apply a slot's step to the target and clear
 *
 * Step-size unit = 2048 (0x800).  shift-right-11 converts raw range to
 * step count; shift-left-11 converts step count back to raw range.
 */

    .section .text.FUN_0603EF64


    .global attract_init_setup
    .type attract_init_setup, @function
/* attract_init_setup
 *   r4 = state struct pointer
 *          +16 = max / end value
 *          +20 = current / start value
 *   r5 = requested step count (0xFFFF = sentinel → use max positive)
 *   r6 = output pointer for raw step size (NULL = don't store)
 *   Returns r0 = clamped step count
 */
attract_init_setup:
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes on stack (local var)
    mov.l @(16, r4), r7                 ! r7 = state->max (field +16)
    mov.l @(20, r4), r3                 ! r3 = state->current (field +20)
    mov.l   .L_sentinel_mask, r2        ! r2 = 0x0000FFFF (sentinel value)
    sub r3, r7                          ! r7 = range = max - current
    cmp/eq r2, r5                       ! requested_steps == 0xFFFF sentinel?
    bf      .L_sentinel_skip            ! no → keep r5 as-is
    mov.l   .L_max_positive, r5         ! yes → r5 = 0x7FFFFFFF (largest count)
.L_sentinel_skip:
    mov.w   DAT_0603ef8a, r2            ! r2 = 0x07FF (rounding bias = 2048-1)
    add r7, r2                          ! r2 = range + 0x7FF (round up)
    shlr8 r2                            ! r2 >>= 8
    shlr2 r2                            ! r2 >>= 2
    shlr r2                             ! r2 >>= 1  (total >>= 11, i.e. / 2048)
    cmp/hs r2, r5                       ! requested_steps >= max_steps?
    bt/s    .L_clamp_to_max             ! yes → clamp step count to max
    mov.l r2, @r15                      ! [delay] store max_steps on stack
    bra     .L_after_clamp              ! no clamping needed
    nop

    .global DAT_0603ef8a
DAT_0603ef8a:
    .2byte  0x07FF
.L_sentinel_mask:
    .4byte  0x0000FFFF                  /* low 16-bit mask (sentinel compare) */
.L_max_positive:
    .4byte  0x7FFFFFFF                  /* max positive 16.16 fixed-point */
.L_clamp_to_max:
    mov.l @r15, r5                      ! r5 = max_steps (clamped)
.L_after_clamp:
    tst r6, r6                          ! output pointer == NULL?
    bt      .L_epilogue                 ! yes → skip raw-step output
    mov r5, r3                          ! r3 = step_count
    shll8 r3                            ! r3 <<= 8
    shll2 r3                            ! r3 <<= 2
    shll r3                             ! r3 <<= 1  (total <<= 11 = * 2048)
    mov.l r3, @r6                       ! *output = raw_step_size
    mov.l @(20, r4), r2                 ! r2 = state->current
    mov.l @(16, r4), r1                 ! r1 = state->max
    add r3, r2                          ! r2 = current + raw_step_size
    cmp/gt r1, r2                       ! current + raw > max?
    bf      .L_epilogue                 ! no → no overflow, done
    mov.w   DAT_0603eff4, r0            ! r0 = 0x0800 (step unit = 2048)
    mov.l   .L_fn_signed_mod, r2        ! r2 = &signed_mod_32
    jsr @r2                             ! call signed_mod_32: r0 = r1 % r0
    mov r7, r1                          ! [delay] r1 = range (dividend)
    mov r0, r4                          ! r4 = remainder = range % 2048
    mov.l @r6, r0                       ! r0 = raw_step_size from output
    tst r0, r0                          ! raw_step_size == 0?
    bt      .L_epilogue                 ! yes → nothing to adjust
    tst r4, r4                          ! remainder == 0?
    bt      .L_epilogue                 ! yes → no fractional correction needed
    mov.w   DAT_0603eff4, r3            ! r3 = 0x0800 (step unit)
    sub r4, r3                          ! r3 = 2048 - remainder (overshoot)
    mov.l @r6, r2                       ! r2 = raw_step_size
    sub r3, r2                          ! r2 = raw_step_size - overshoot
    mov.l r2, @r6                       ! *output = corrected raw_step_size
.L_epilogue:
    add #0x4, r15                       ! free stack local
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov r5, r0                          ! [delay] r0 = step_count (return value)

    .global sym_0603EFD4
/* interp_linear_remainder
 *   r4 = state struct pointer
 *          +8  = multiplier A
 *          +12 = multiplier B
 *          +16 = subtrahend
 *   Returns r0 = (A * B) - subtrahend
 */
sym_0603EFD4:
    sts.l macl, @-r15                   ! save MACL (caller-save)
    mov.l @(8, r4), r0                  ! r0 = state->field_8  (multiplier A)
    mov.l @(12, r4), r3                 ! r3 = state->field_12 (multiplier B)
    mov.l @(16, r4), r2                 ! r2 = state->field_16 (subtrahend)
    mul.l r3, r0                        ! MACL = A * B
    sts macl, r0                        ! r0 = A * B
    sub r2, r0                          ! r0 = (A * B) - subtrahend
    rts                                 ! return r0
    lds.l @r15+, macl                   ! [delay] restore MACL

    .global sym_0603EFE6
/* interp_slot_a_init
 *   r4 = state struct pointer
 *          +4  = base position
 *          +16 = max value
 *          +20 = current offset
 *   r5 = step count
 *   Returns r0 = pointer to slot A, or 0 if already active
 */
sym_0603EFE6:
    mov.l   .L_state_block_a, r3        ! r3 = &state_block (sym_06063624)
    mov.l @(32, r3), r0                 ! r0 = slot_a_active flag
    tst r0, r0                          ! slot A already active?
    bt/s    .L_slot_a_setup             ! no → proceed with setup
    mov #0x1, r7                        ! [delay] r7 = 1 (direction / active flag)
    rts                                 ! slot A busy → return 0
    mov #0x0, r0                        ! [delay] r0 = 0 (failure)

    .global DAT_0603eff4
DAT_0603eff4:
    .2byte  0x0800
    .2byte  0xFFFF
.L_fn_signed_mod:
    .4byte  sym_06036BE4
.L_state_block_a:
    .4byte  sym_06063624
.L_slot_a_setup:
    mov.l   .L_state_block_a2, r6       ! r6 = &state_block (slot A base)
    mov.l @(4, r4), r3                  ! r3 = state->base_position
    mov.l @(20, r4), r2                 ! r2 = state->current_offset
    add r2, r3                          ! r3 = base + offset (start position)
    mov.l r3, @r6                       ! slot_a[+0] = start_position
    mov r5, r3                          ! r3 = step_count
    mov.l r7, @(4, r6)                  ! slot_a[+4] = direction (1)
    shll8 r3                            ! r3 <<= 8
    shll2 r3                            ! r3 <<= 2
    shll r3                             ! r3 <<= 1  (total <<= 11 = * 2048)
    mov.l r3, @(8, r6)                  ! slot_a[+8] = raw_step_size
    mov.l @(16, r4), r2                 ! r2 = state->max
    mov.l @(20, r4), r3                 ! r3 = state->current_offset
    mov.l @(8, r6), r1                  ! r1 = raw_step_size
    sub r3, r2                          ! r2 = max - current = remaining range
    cmp/gt r2, r1                       ! raw_step_size > remaining?
    bf      .L_slot_a_no_clamp          ! no → fits within range
    mov.l @(16, r4), r2                 ! r2 = state->max
    mov.l @(20, r4), r3                 ! r3 = state->current_offset
    sub r3, r2                          ! r2 = remaining range
    mov.l r2, @(8, r6)                  ! slot_a[+8] = clamped step size
.L_slot_a_no_clamp:
    mov.l r5, @(12, r6)                 ! slot_a[+12] = step_count
    mov.l   .L_state_block_a2, r2       ! r2 = &state_block
    mov.l r7, @(32, r2)                 ! state_block[+32] = 1 (slot A active)
    mov r6, r0                          ! r0 = pointer to slot A
    rts                                 ! return slot A pointer
    nop

    .global sym_0603F036
/* interp_slot_b_init
 *   r4 = state struct pointer
 *          +4  = base position
 *          +16 = max value
 *   r5 = raw value to store
 *   Returns r0 = pointer to slot B, or 0 if already active
 */
sym_0603F036:
    mov.l   .L_state_block_a2, r3       ! r3 = &state_block
    mov.l @(36, r3), r0                 ! r0 = slot_b_active flag
    tst r0, r0                          ! slot B already active?
    bt      .L_slot_b_setup             ! no → proceed with setup
    rts                                 ! slot B busy → return 0
    mov #0x0, r0                        ! [delay] r0 = 0 (failure)
.L_slot_b_setup:
    mov.l   .L_state_block_a2, r6       ! r6 = &state_block
    mov.l @(4, r4), r3                  ! r3 = state->base_position
    mov.l @(16, r4), r2                 ! r2 = state->max
    add #0x10, r6                       ! r6 = &state_block + 0x10 (slot B base)
    add r2, r3                          ! r3 = base + max (end position)
    mov #0x1, r4                        ! r4 = 1 (direction / active flag)
    mov.l r3, @r6                       ! slot_b[+0] = end_position
    mov.l r4, @(4, r6)                  ! slot_b[+4] = direction (1)
    mov.l r5, @(8, r6)                  ! slot_b[+8] = raw_value
    mov.w   .L_round_bias_b, r3         ! r3 = 0x07FF (rounding bias)
    add r3, r5                          ! r5 = raw_value + 0x7FF (round up)
    shlr8 r5                            ! r5 >>= 8
    shlr2 r5                            ! r5 >>= 2
    shlr r5                             ! r5 >>= 1  (total >>= 11 = / 2048)
    mov.l r5, @(12, r6)                 ! slot_b[+12] = step_count
    mov.l   .L_state_block_a2, r2       ! r2 = &state_block
    mov.l r4, @(36, r2)                 ! state_block[+36] = 1 (slot B active)
    mov r6, r0                          ! r0 = pointer to slot B
    rts                                 ! return slot B pointer
    nop
.L_round_bias_b:
    .2byte  0x07FF
.L_state_block_a2:
    .4byte  sym_06063624

    .global sym_0603F070
/* interp_slot_apply
 *   r4 = state struct pointer
 *          +16 = max value   (target for slot B)
 *          +20 = current     (target for slot A)
 *   r5 = slot pointer (must match slot A or B address)
 *   r6 = delta to apply (-1 = use slot's stored step size)
 *   Applies the delta to the appropriate field and clears the active flag.
 */
sym_0603F070:
    mov.l   .L_state_block_apply, r3    ! r3 = &state_block (slot A base)
    cmp/eq r3, r5                       ! r5 == slot A address?
    bf/s    .L_check_slot_b             ! no → check slot B
    mov #0x0, r7                        ! [delay] r7 = 0 (will clear active flag)
    mov r6, r0                          ! r0 = delta argument
    cmp/eq #-0x1, r0                    ! delta == -1 (use stored step)?
    bf      .L_apply_slot_a             ! no → use delta as-is
    mov.l @(8, r5), r6                  ! yes → r6 = slot_a[+8] (stored step size)
.L_apply_slot_a:
    mov.l @(20, r4), r2                 ! r2 = state->current
    add r6, r2                          ! r2 = current + delta
    mov.l r2, @(20, r4)                 ! state->current = updated value
    mov.l   .L_state_block_apply, r3    ! r3 = &state_block
    mov.l r7, @(32, r3)                 ! state_block[+32] = 0 (slot A inactive)
    bra     .L_apply_done               ! done
    nop
.L_check_slot_b:
    mov.l   .L_state_block_apply, r3    ! r3 = &state_block
    add #0x10, r3                       ! r3 = &state_block + 0x10 (slot B base)
    cmp/eq r3, r5                       ! r5 == slot B address?
    bf      .L_apply_done               ! no match → do nothing
    mov r6, r0                          ! r0 = delta argument
    cmp/eq #-0x1, r0                    ! delta == -1 (use stored step)?
    bf      .L_apply_slot_b             ! no → use delta as-is
    mov.l @(8, r5), r6                  ! yes → r6 = slot_b[+8] (stored step size)
.L_apply_slot_b:
    mov.l @(16, r4), r2                 ! r2 = state->max
    add r6, r2                          ! r2 = max + delta
    mov.l r2, @(16, r4)                 ! state->max = updated value
    mov.l   .L_state_block_apply, r3    ! r3 = &state_block
    mov.l r7, @(36, r3)                 ! state_block[+36] = 0 (slot B inactive)
.L_apply_done:
    rts                                 ! return
    nop
    .4byte  0x66425664
    .4byte  0x35678B00
    .4byte  0x65634511
    .4byte  0x8900E500
    .4byte  0x63534318
    .4byte  0x43084300
    .4byte  0x14356233
    .4byte  0x53443237
    .4byte  0x8B015345
    .4byte  0x1434000B
    .4byte  0x6053FFFF
.L_state_block_apply:
    .4byte  sym_06063624
    .4byte  0x5045930B
    .4byte  0x303C4019
    .4byte  0x4009000B
    .4byte  0x40015341
    .4byte  0x25325242
    .4byte  0x26225343
    .4byte  0x000B2732
    .4byte  0x07FF0000
