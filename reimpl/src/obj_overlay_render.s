/* obj_overlay_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06021178 - 0x06021450
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Object overlay sprite renderer for the racing HUD.
 * Checks the player car's position (X/Y) and track segment against
 * fixed-point thresholds to decide whether an overlay sprite should
 * be shown, hidden, or kept in its current state.  Uses a 2-bit
 * flag word at sym_0608959C:
 *   bit 0 = overlay currently active
 *   bit 1 = render requested this frame
 *
 * When rendering is requested, copies overlay sprite data to VDP1
 * via DMA.  Two parallel paths exist:
 *   - Flag-set path: overlay was already active (uses sym_060039F2)
 *   - Flag-clear path: overlay just became active (uses dma_config_dispatch)
 * Each path further branches on terrain rendering mode (sym_06083255)
 * to select the correct sprite table and palette lookup.
 *
 * Register plan:
 *   r9  = 0x1 (bit mask constant)
 *   r10 = DMA size for small sprite copy (0xC0)
 *   r11 = display/scroll table base ptr (sym_06063F5C)
 *   r12 = tile index ptr (sym_06059FFC)
 *   r13 = dma_transfer function ptr
 *   r14 = overlay state flags word ptr (sym_0608959C)
 */

    .section .text.FUN_06021178


    .global obj_overlay_render
    .type obj_overlay_render, @function
obj_overlay_render:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    sts.l pr, @-r15
    mov #0x1, r9                       ! r9 = bit mask constant
    mov.l   .L_overlay_state_flags, r14 ! r14 = overlay flags word ptr
    mov.l   .L_car_struct_ptr, r6      ! r6 = &car_struct_ptr
    mov.w   .L_car_struct_seg_offset, r0 ! r0 = 0x1EC (segment field offset)
    mov.l @r6, r4                      ! r4 = car_struct base
    mov.l @r6, r5                      ! r5 = car_struct base (for Y load)
    mov.l @r6, r3                      ! r3 = car_struct base (for seg load)
    mov.l @(16, r4), r4                ! r4 = car pos X (16.16 fixed-point)
    mov.l @(r0, r3), r6                ! r6 = track segment index
    mov.l   .L_pos_x_upper_thresh, r3
    cmp/gt r3, r4                      ! pos_x > 0x0076.0000 ?
    bf/s    .L_check_secondary_range
    mov.l @(24, r5), r5                ! r5 = car pos Y (16.16 fixed-point)
    mov.l   .L_pos_x_lower_thresh, r3
    cmp/ge r3, r4                      ! pos_x >= 0x014B.0000 ?
    bt      .L_check_secondary_range
    mov.l   .L_pos_y_upper_thresh, r3
    cmp/ge r3, r5                      ! pos_y >= 0x00D0.0000 ?
    bt      .L_check_secondary_range
    mov.l   .L_pos_y_lower_thresh, r3
    cmp/gt r3, r5                      ! pos_y > 0xFF3B.0000 ?
    bf      .L_check_secondary_range
    mov #0x57, r3                      ! segment range: 0x57-0x79
    cmp/gt r3, r6                      ! segment > 0x57 ?
    bf      .L_check_render_needed
    mov #0x7A, r3
    cmp/ge r3, r6                      ! segment >= 0x7A ?
    bt      .L_check_render_needed
    mov.w @r14, r3                     ! --- in primary zone + segment range ---
    extu.w r3, r3
    and r9, r3                         ! test bit 0 (overlay active?)
    tst r3, r3
    bf      .L_skip_to_end_checks      ! already active, skip flag set
    mov.w @r14, r0
    or #0x1, r0                        ! set bit 0 (overlay active)
    mov.w r0, @r14
    mov.w @r14, r0
    or #0x2, r0                        ! set bit 1 (render requested)
    mov.w r0, @r14
.L_skip_to_end_checks:
    bra     .L_check_render_needed
    nop
.L_car_struct_seg_offset:
    .2byte  0x01EC                     ! car struct offset to segment field
    .2byte  0xFFFF                     ! padding
.L_overlay_state_flags:
    .4byte  sym_0608959C               ! overlay state word (bit 0=active, bit 1=render)
.L_car_struct_ptr:
    .4byte  sym_0607E940               ! current car struct pointer
.L_pos_x_upper_thresh:
    .4byte  0x00760000                 ! 118.0 fixed-point
.L_pos_x_lower_thresh:
    .4byte  0x014B0000                 ! 331.0 fixed-point
.L_pos_y_upper_thresh:
    .4byte  0x00D00000                 ! 208.0 fixed-point
.L_pos_y_lower_thresh:
    .4byte  0xFF3B0000                 ! -197.0 fixed-point (signed)
.L_check_secondary_range:                  ! --- outside primary zone ---
    mov.l   .L_sec_range_x_thresh, r2
    cmp/ge r2, r4                      ! pos_x >= 0xFE9A.0000 ?
    bt      .L_range_tier2_check_x
    mov.l   .L_sec_range_y_thresh, r2
    cmp/ge r2, r5                      ! pos_y >= 0xFDCD.0000 ?
    bf      .L_outside_inner_zone
.L_range_tier2_check_x:
    mov.l   .L_tier2_range_x_thresh, r2
    cmp/ge r2, r4                      ! pos_x >= 0xFE95.0000 ?
    bt      .L_range_tier3_check
    mov.l   .L_tier2_range_y_thresh, r2
    cmp/ge r2, r5                      ! pos_y >= 0xFDD3.0000 ?
    bf      .L_outside_inner_zone
.L_range_tier3_check:
    mov.l   .L_tier3_range_x_thresh, r2
    cmp/ge r2, r4                      ! pos_x >= 0xFE8F.0000 ?
    bt      .L_inside_inner_zone
    mov.l   .L_tier3_range_y_thresh, r2
    cmp/ge r2, r5                      ! pos_y >= 0xFDD8.0000 ?
    bt      .L_inside_inner_zone
.L_outside_inner_zone:                     ! --- not in innermost zone: activate overlay ---
    mov.w @r14, r2
    extu.w r2, r2
    and r9, r2                         ! test bit 0
    tst r2, r2
    bf      .L_check_render_needed     ! already active, skip
    mov.w @r14, r0
    or #0x1, r0                        ! set bit 0 (active)
    mov.w r0, @r14
    mov.w @r14, r0
    or #0x2, r0                        ! set bit 1 (render)
    bra     .L_check_render_needed
    mov.w r0, @r14
.L_inside_inner_zone:                      ! --- in innermost zone: deactivate overlay ---
    mov.w @r14, r2
    extu.w r2, r2
    and r9, r2                         ! test bit 0
    tst r2, r2
    bt      .L_check_render_needed     ! not active, skip
    mov #-0x2, r3                      ! mask = 0xFFFFFFFE
    mov.w @r14, r2
    and r3, r2                         ! clear bit 0 (deactivate)
    mov.w r2, @r14
    mov.w @r14, r0
    or #0x2, r0                        ! set bit 1 (render one more frame)
    mov.w r0, @r14
.L_check_render_needed:                    ! --- check if DMA render is needed ---
    mov.w @r14, r0
    extu.w r0, r0
    shlr r0                            ! shift bit 1 into bit 0
    tst #0x1, r0                       ! test bit 1 (render requested?)
    bf      .L_begin_sprite_dma        ! yes — go copy sprite data
    bra     .L_return                  ! no — skip rendering
    nop
.L_begin_sprite_dma:                       ! --- begin overlay sprite DMA ---
    mov.w   .L_dma_size_sprite_c0, r10 ! r10 = 0xC0 (small sprite DMA size)
    mov.l   .L_display_table_base, r11 ! r11 = &display_table_base
    mov.l   .L_tile_index_ptr, r12     ! r12 = &tile_index
    mov.l   .L_fn_dma_transfer, r13    ! r13 = dma_transfer fn ptr
    mov.w @r14, r3
    extu.w r3, r3
    and r9, r3                         ! test bit 0 (was overlay already active?)
    tst r3, r3
    bt      .L_flagclear_path          ! not active — use dma_config_dispatch
    mov.l   .L_fn_dma_config_alt, r3   ! active — use alt DMA config
    jsr @r3
    nop
    mov.w   .L_dma_size_200, r6        ! r6 = 0x200 (DMA size)
    mov.l   .L_sprite_src_a, r5       ! r5 = sprite source A
    mov.l @r12, r4                     ! r4 = tile_index
    mov.l @r11, r3                     ! r3 = display_table_base
    shll2 r4                           ! r4 = tile_index * 8
    shll r4
    jsr @r13                           ! dma_transfer(dst, src, size)
    add r3, r4                         ! r4 = display_base + tile_index*8
    mov.w   DAT_060212d8, r6          ! r6 = 0x17C0 (DMA size)
    mov.l   .L_sprite_src_b, r5       ! r5 = sprite source B
    mov.l @r12, r4
    mov.l @r11, r3
    mov.w   .L_sprite_offset_3c0, r2  ! r2 = 0x3C0
    shll2 r4
    shll r4
    add r3, r4
    jsr @r13                           ! dma_transfer(dst+0x3C0, src_b, 0x17C0)
    add r2, r4
    mov.l   .L_terrain_mode_flag, r3
    mov.b @r3, r3                      ! read terrain rendering mode flag
    tst r3, r3
    bf      .L_flagset_terrain_mode    ! nonzero = terrain mode active
    mov r10, r6                        ! r6 = 0xC0 (small sprite DMA)
    mov.l   .L_car_player_index, r5   ! r5 = &car_player_index
    mov.l   .L_sprite_table_base_a, r3 ! r3 = sprite_table_base_a
    mov.l @r12, r4
    mov.l @r11, r2
    mov.l @r5, r5                      ! r5 = car_player_index
    shll2 r4
    shll2 r5                           ! r5 = index * 4
    shll r4
    add r3, r5                         ! r5 = &sprite_table[index]
    add r2, r4
    mov.l @r5, r5                      ! r5 = sprite_table[index]
    jsr @r13                           ! dma_transfer(dst+0x40, sprite, 0xC0)
    add #0x40, r4
    mov r10, r6                        ! r6 = 0xC0
    mov.l   .L_hud_variant_index, r5  ! r5 = &hud_variant_index (byte)
    mov.l   .L_sprite_table_base_a, r3
    mov.l @r12, r4
    mov.b @r5, r5                      ! r5 = hud_variant (byte)
    shll2 r4
    extu.b r5, r5                      ! zero-extend byte
    shll2 r5                           ! r5 = variant * 4
    add r3, r5
    mov.l @r5, r5                      ! r5 = sprite_table[variant]
    shll r4
    mov.l @r11, r2
    mov.w   .L_sprite_offset_100, r1  ! r1 = 0x100
    bra     .L_flagset_final_dma
    add r2, r4
.L_dma_size_sprite_c0:
    .2byte  0x00C0                     ! 192 bytes — small sprite DMA size
.L_dma_size_200:
    .2byte  0x0200                     ! 512 bytes — first sprite block DMA size

    .global DAT_060212d8
DAT_060212d8:
    .2byte  0x17C0                     ! 6080 bytes — second sprite block DMA size
.L_sprite_offset_3c0:
    .2byte  0x03C0                     ! 960 — offset within sprite dest buffer
.L_sprite_offset_100:
    .2byte  0x0100                     ! 256 — offset for variant sprite copy
    .2byte  0xFFFF                     ! padding
.L_sec_range_x_thresh:
    .4byte  0xFE9A0000                 ! -358.0 fixed-point (secondary zone X)
.L_sec_range_y_thresh:
    .4byte  0xFDCD0000                 ! -563.0 fixed-point (secondary zone Y)
.L_tier2_range_x_thresh:
    .4byte  0xFE950000                 ! -363.0 fixed-point (tier 2 zone X)
.L_tier2_range_y_thresh:
    .4byte  0xFDD30000                 ! -557.0 fixed-point (tier 2 zone Y)
.L_tier3_range_x_thresh:
    .4byte  0xFE8F0000                 ! -369.0 fixed-point (tier 3 / inner zone X)
.L_tier3_range_y_thresh:
    .4byte  0xFDD80000                 ! -552.0 fixed-point (tier 3 / inner zone Y)
.L_display_table_base:
    .4byte  sym_06063F5C               ! display/scroll base table ptr
.L_tile_index_ptr:
    .4byte  sym_06059FFC               ! tile index value (ptr, *8 for offset)
.L_fn_dma_transfer:
    .4byte  dma_transfer               ! DMA transfer function
.L_fn_dma_config_alt:
    .4byte  sym_060039F2               ! dma_config_dispatch secondary entry
.L_sprite_src_a:
    .4byte  sym_0604D608               ! overlay sprite source A (flag-set path)
.L_sprite_src_b:
    .4byte  sym_0604EFC8               ! overlay sprite source B (flag-set path)
.L_terrain_mode_flag:
    .4byte  sym_06083255               ! terrain rendering mode flag (byte)
.L_car_player_index:
    .4byte  sym_06078868               ! car/player index for sprite lookup
.L_sprite_table_base_a:
    .4byte  sym_0605D084               ! sprite table base (flag-set path)
.L_hud_variant_index:
    .4byte  sym_0607ED91               ! HUD variant index (byte)
.L_flagset_terrain_mode:                   ! --- flag-set + terrain mode: alternate sprite lookup ---
    mov #0x20, r6                      ! r6 = 0x20 (DMA size 32 bytes)
    mov.l   .L_display_mode_flags, r5 ! r5 = &display_mode_flags
    mov.l   .L_sprite_table_alt, r3   ! r3 = sprite_table_alt base
    mov.l   .L_race_end_state, r4     ! r4 = &race_end_state
    mov.l   .L_sprite_bank_offset, r2 ! r2 = sprite bank byte offset
    mov.l   .L_sprite_bank_base, r1   ! r1 = &sprite_bank_base (halfword)
    mov.l @r12, r0                     ! r0 = tile_index
    mov.l @r5, r5                      ! r5 = display_mode_flags value
    mov.l @r4, r4                      ! r4 = &race_end_state data
    mov.w @r1, r1                      ! r1 = sprite_bank_base (halfword)
    shll2 r0                           ! r0 = tile_index * 4
    shll2 r5                           ! r5 = flags * 4
    add r2, r4                         ! r4 += bank offset
    extu.w r1, r1                      ! zero-extend halfword
    add r3, r5                         ! r5 = &alt_table[flags]
    mov.b @r4, r4                      ! r4 = bank byte
    mov.l @r5, r5                      ! r5 = alt_table[flags]
    extu.b r4, r4                      ! zero-extend byte
    add r1, r4                         ! r4 += bank_base
    shll2 r4                           ! r4 = (bank_base + bank) * 32
    shll2 r4
    shll r4
    shll r0                            ! r0 = tile_index * 8
    add r0, r4                         ! r4 += tile_index * 8
    mov.l @r11, r1                     ! r1 = display_table_base
.L_flagset_final_dma:
    jsr @r13                           ! dma_transfer(dst, src, size)
    add r1, r4                         ! r4 = final dest address
    bra     .L_clear_overlay_bits
    nop
.L_flagclear_path:                         ! --- overlay just activated: full DMA config ---
    mov.l   .L_fn_dma_config_dispatch, r3
    jsr @r3                            ! dma_config_dispatch()
    nop
    mov.w   .L_dma_size_200_2, r6     ! r6 = 0x200
    mov.l   .L_sprite_src_a_2, r5    ! r5 = sprite source A (flag-clear path)
    mov.l @r12, r4
    mov.l @r11, r3
    shll2 r4
    shll r4
    jsr @r13                           ! dma_transfer(dst, src_a, 0x200)
    add r3, r4
    mov.w   DAT_06021416, r6          ! r6 = 0x17C0
    mov.l   .L_sprite_src_b_2, r5    ! r5 = sprite source B (flag-clear path)
    mov.l @r12, r4
    mov.l @r11, r3
    mov.w   .L_sprite_offset_3c0_2, r2 ! r2 = 0x3C0
    shll2 r4
    shll r4
    add r3, r4
    jsr @r13                           ! dma_transfer(dst+0x3C0, src_b, 0x17C0)
    add r2, r4
    mov.l   .L_terrain_mode_flag_2, r3
    mov.b @r3, r3                      ! read terrain mode flag
    tst r3, r3
    bf      .L_flagclear_terrain_mode  ! nonzero = terrain mode
    mov r10, r6                        ! r6 = 0xC0
    mov.l   .L_car_player_index_2, r5
    mov.l   .L_sprite_table_base_b, r3
    mov.l @r12, r4
    mov.l @r11, r2
    mov.l @r5, r5                      ! r5 = car_player_index
    shll2 r4
    shll2 r5                           ! r5 = index * 4
    shll r4
    add r3, r5                         ! r5 = &sprite_table_b[index]
    add r2, r4
    mov.l @r5, r5                      ! r5 = sprite_table_b[index]
    jsr @r13                           ! dma_transfer(dst+0x40, sprite, 0xC0)
    add #0x40, r4
    mov r10, r6                        ! r6 = 0xC0
    mov.l   .L_hud_variant_index_2, r5
    mov.l   .L_sprite_table_base_b, r3
    mov.l @r12, r4
    mov.b @r5, r5                      ! r5 = hud_variant (byte)
    shll2 r4
    extu.b r5, r5
    shll2 r5                           ! r5 = variant * 4
    add r3, r5
    mov.l @r5, r5                      ! r5 = sprite_table_b[variant]
    shll r4
    mov.l @r11, r2
    mov.w   .L_sprite_offset_100_2, r1 ! r1 = 0x100
    bra     .L_flagclear_final_dma
    add r2, r4
.L_flagclear_terrain_mode:                 ! --- flag-clear + terrain mode: alternate sprite lookup ---
    mov #0x20, r6                      ! r6 = 0x20 (DMA size)
    mov.l   .L_display_mode_flags, r5
    mov.l   .L_sprite_table_alt_2, r3
    mov.l   .L_race_end_state, r4
    mov.l   .L_sprite_bank_offset, r2
    mov.l   .L_sprite_bank_base, r1
    mov.l @r12, r0                     ! r0 = tile_index
    mov.l @r5, r5                      ! r5 = display_mode_flags
    mov.l @r4, r4                      ! r4 = &race_end_state data
    mov.w @r1, r1                      ! r1 = sprite_bank_base
    shll2 r0
    shll2 r5
    add r2, r4
    extu.w r1, r1
    add r3, r5                         ! r5 = &alt_table_2[flags]
    mov.b @r4, r4                      ! r4 = bank byte
    mov.l @r5, r5                      ! r5 = alt_table_2[flags]
    extu.b r4, r4
    add r1, r4                         ! r4 = bank_base + bank
    shll2 r4                           ! r4 *= 32
    shll2 r4
    shll r4
    shll r0                            ! r0 = tile_index * 8
    add r0, r4
    mov.l @r11, r1                     ! r1 = display_table_base
.L_flagclear_final_dma:
    jsr @r13                           ! dma_transfer(dst, src, size)
    add r1, r4
.L_clear_overlay_bits:                     ! --- clear render-request bits after DMA ---
    mov #-0x3, r3                      ! mask = 0xFFFFFFFC (clear bits 0 and 1)
    mov.w @r14, r2
    and r3, r2                         ! flags &= ~0x3
    mov.w r2, @r14
.L_return:
    lds.l @r15+, pr
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_dma_size_200_2:
    .2byte  0x0200                     ! 512 bytes — sprite block DMA size

    .global DAT_06021416
DAT_06021416:
    .2byte  0x17C0                     ! 6080 bytes — second sprite block DMA size
.L_sprite_offset_3c0_2:
    .2byte  0x03C0                     ! 960 — dest buffer offset
.L_sprite_offset_100_2:
    .2byte  0x0100                     ! 256 — variant sprite offset
.L_display_mode_flags:
    .4byte  sym_0607EAB8               ! display mode flags (bit 0 = extended)
.L_sprite_table_alt:
    .4byte  sym_0605D0B4               ! alternate sprite table (terrain, flag-set)
.L_race_end_state:
    .4byte  sym_0607EAD8               ! race end state (0/1/2)
.L_sprite_bank_offset:
    .4byte  sym_060448B5               ! sprite bank byte offset
.L_sprite_bank_base:
    .4byte  sym_0607886C               ! sprite bank base (halfword)
.L_fn_dma_config_dispatch:
    .4byte  dma_config_dispatch        ! full DMA config function
.L_sprite_src_a_2:
    .4byte  sym_0604D408               ! overlay sprite source A (flag-clear path)
.L_sprite_src_b_2:
    .4byte  sym_0604D808               ! overlay sprite source B (flag-clear path)
.L_terrain_mode_flag_2:
    .4byte  sym_06083255               ! terrain rendering mode flag (byte)
.L_car_player_index_2:
    .4byte  sym_06078868               ! car/player index for sprite lookup
.L_sprite_table_base_b:
    .4byte  sym_0605D05C               ! sprite table base (flag-clear path)
.L_hud_variant_index_2:
    .4byte  sym_0607ED91               ! HUD variant index (byte)
.L_sprite_table_alt_2:
    .4byte  sym_0605D0AC               ! alternate sprite table (terrain, flag-clear)
