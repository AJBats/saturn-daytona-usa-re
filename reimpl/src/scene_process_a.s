/* scene_process_a -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06025224 - 0x06025478
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Scene geometry processor for car display slots (variant A, 10 slots).
 * Near-twin of scene_process_b (which handles 8 slots with different offsets).
 *
 * Selects scene data based on game state (4, 5, or default), dispatches
 * geometry setup via geom_dispatch, then performs layer setup for three
 * rendering layers (0x6000, 0x7000 offsets) with different DMA sizes.
 *
 * After layer setup, iterates 10 car slots:
 *   - Calls car_physics_final for each slot
 *   - Checks render type against threshold (0x00B4 = type 9, else type 8)
 *   - Skips detailed render if game state is 4/5 and type matches threshold
 *   - For eligible slots: looks up slot offset table, reads direction pair
 *     tables A and B, dispatches layer_setup with computed geometry data
 *
 * Persistent registers:
 *   r8  = render_param (0x00A9)
 *   r11 = render_type_threshold (0x00A9 + 0x0B = 0x00B4)
 *   r12 = obj_table_base (sym_06063750)
 *   r13 = slot_idx (loop counter, 0..9)
 *   r14 = fn_layer_setup (sym_06028400)
 *
 * Stack layout (24 bytes):
 *   sp[0]  = temp ptr (slot offset / direction table entry)
 *   sp[4]  = arg (saved r4 / slot_idx * 2)
 *   sp[8]  = &obj_table_base[render_entry]
 *   sp[12] = &dir_table_entry
 *   sp[16] = base_count (type 8 or 9)
 *   sp[20] = &slot_offset[4] (second pass ptr)
 */

    .section .text.FUN_06025224


    .global scene_process_a
    .type scene_process_a, @function
scene_process_a:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x18, r15                     ! allocate 24 bytes of stack locals
    mov.w   DAT_0602528a, r8            ! r8 = 0x00A9 (render param)
    mov.l   .L_obj_table_base, r12      ! r12 = obj table base (persistent)
    mov.l   .L_fn_layer_setup, r14      ! r14 = fn_layer_setup (persistent)
    mov r8, r11                         ! r11 = render param (will become threshold)
    mov.l r4, @(4, r15)                 ! sp[4] = arg (car index from caller)
    mov.l   .L_game_state_ptr, r4       ! r4 -> game state byte
    mov.w   .L_scene_data_size, r13     ! r13 = 0x0C08 (scene data size)
    mov.w   .L_obj_table_offset, r10    ! r10 = 0x0590 (obj table entry offset)
    mov.b @r4, r0                       ! r0 = game_state
    extu.b r0, r0
    cmp/eq #0x4, r0                     ! game_state == 4? (race mode)
    bf/s    .L_not_state4
    add #0xB, r11                       ! r11 = 0x00B4 (render type threshold) [delay slot]
    mov.l   .L_scene_data_state4, r7    ! === State 4 path: race scene data ===
    mov r13, r5                         ! r5 = scene data size
    mov.l   .L_fn_geom_dispatch, r3
    mov.w   .L_dma_size_small, r6       ! r6 = 0x0090 (DMA transfer size)
    jsr @r3                             ! geom_dispatch(8, size, dma_sz, scene_data)
    mov #0x8, r4                        ! r4 = DMA mode 8 [delay slot]
    mov r12, r7                         ! r7 = obj_table_base
    add r10, r7                         ! r7 = &obj_table_base[0x0590]
    mov.l r7, @r15                      ! sp[0] = &obj_entry
    mov.l @(4, r7), r7                  ! r7 = obj_entry.frame_data_ptr (+4)
    mov.w   DAT_06025292, r6            ! r6 = 0x0C3E (layer size)
    mov.l @r15, r5
    mov.l @r5, r5                       ! r5 = obj_entry.render_fn_ptr (+0)
    jsr @r14                            ! layer_setup(8, r5, r6, r7)
    mov #0x8, r4                        ! [delay slot]
    bra     .L_slot_dispatch
    nop
.L_not_state4:                              ! === Check state 5 ===
    mov.b @r4, r0                       ! r0 = game_state (re-read)
    extu.b r0, r0
    cmp/eq #0x5, r0                     ! game_state == 5? (post-race/replay)
    bf      .L_state_default            ! neither 4 nor 5 -> default path
    mov.l   .L_scene_data_state5, r7    ! === State 5 path ===
    mov r13, r5                         ! r5 = scene data size
    mov.l   .L_fn_geom_dispatch, r3
    mov.w   .L_dma_size_small, r6
    jsr @r3                             ! geom_dispatch(8, size, dma_sz, scene_data_5)
    mov #0x8, r4                        ! [delay slot]
    bra     .L_layer_setup_common
    nop

    .global DAT_0602528a
DAT_0602528a:
    .2byte  0x00A9                      /* render param (physics mode) */
.L_scene_data_size:
    .2byte  0x0C08                      /* scene data block size */
.L_obj_table_offset:
    .2byte  0x0590                      /* offset into obj table for main entry */
.L_dma_size_small:
    .2byte  0x0090                      /* DMA transfer size (small) */

    .global DAT_06025292
DAT_06025292:
    .2byte  0x0C3E                      /* layer size for state 4 extra pass */
.L_obj_table_base:
    .4byte  sym_06063750                /* car/obj table base (8-byte stride) */
.L_fn_layer_setup:
    .4byte  sym_06028400                /* layer setup / geometry dispatch */
.L_game_state_ptr:
    .4byte  sym_06061198                /* game state byte */
.L_scene_data_state4:
    .4byte  sym_060590B8                /* scene data for state 4 (race) */
.L_fn_geom_dispatch:
    .4byte  sym_060284AE                /* geometry dispatch function */
.L_scene_data_state5:
    .4byte  sym_060590E0                /* scene data for state 5 (post-race) */
.L_state_default:                           ! === Default state path ===
    mov.l   .L_scene_data_default, r7   ! r7 = default scene data
    mov r13, r5                         ! r5 = scene data size
    mov.l   .L_fn_geom_dispatch_2, r3
    mov.w   .L_dma_size_small_2, r6
    jsr @r3                             ! geom_dispatch(8, size, dma_sz, default_data)
    mov #0x8, r4                        ! [delay slot]
.L_layer_setup_common:                      ! === Layer setup for states 5 and default ===
    mov r12, r13                        ! r13 = obj_table_base
    mov.w   DAT_0602537a, r6            ! r6 = 0x0C34 (layer A size)
    add r10, r13                        ! r13 = &obj_table_base[0x0590]
    mov.l @(4, r13), r7                 ! r7 = obj_entry.frame_data_ptr
    mov.l @r13, r5                      ! r5 = obj_entry.render_fn_ptr
    jsr @r14                            ! layer_setup(8, render_fn, layer_A_sz, frame_data)
    mov #0x8, r4                        ! [delay slot]
    mov.l @(4, r13), r7                 ! r7 = frame_data_ptr (same entry)
    mov.w   DAT_0602537c, r6            ! r6 = 0x0C4E (layer B size)
    mov.l @r13, r5                      ! r5 = render_fn_ptr
    jsr @r14                            ! layer_setup(8, render_fn, layer_B_sz, frame_data)
    mov #0x8, r4                        ! [delay slot]
.L_slot_dispatch:                           ! === Scene slot table dispatch ===
    mov.l @(4, r15), r7                 ! r7 = car index (from caller)
    mov.l   .L_scene_slot_table, r3
    mov.w   .L_dma_size_small_2, r6     ! r6 = 0x0090
    mov.w   DAT_0602537e, r5            ! r5 = 0x02A4 (slot table entry size)
    mov.l   .L_fn_geom_dispatch_2, r2
    shll2 r7
    shll r7                             ! r7 = car_index * 8
    add r3, r7                          ! r7 -> scene_slot_table[car_index]
    jsr @r2                             ! geom_dispatch(8, 0x02A4, 0x0090, slot_entry)
    mov #0x8, r4                        ! [delay slot]
    mov.w   DAT_06025380, r7            ! r7 = 0x0428 (obj table offset for layer 1)
    mov #0x10, r6                       ! r6 = 16 (DMA size: small fixed)
    add r12, r7                         ! r7 = &obj_table_base[0x0428]
    mov.l r7, @r15                      ! sp[0] = &obj_entry_1
    mov.l @(4, r7), r7                  ! r7 = obj_entry_1.frame_data_ptr
    mov.w   DAT_06025382, r3            ! r3 = 0x6000 (frame data offset)
    mov.l @r15, r5
    add r3, r7                          ! r7 = frame_data_ptr + 0x6000
    mov.l @r5, r5                       ! r5 = obj_entry_1.render_fn_ptr
    jsr @r14                            ! layer_setup(8, render_fn, 16, frame+0x6000)
    mov #0x8, r4                        ! [delay slot]
    mov.w   DAT_06025384, r7            ! r7 = 0x0430 (obj table offset for layer 2)
    add r12, r7                         ! r7 = &obj_table_base[0x0430]
    mov.l r7, @r15                      ! sp[0] = &obj_entry_2
    mov.l @(4, r7), r7                  ! r7 = obj_entry_2.frame_data_ptr
    mov.w   DAT_06025386, r3            ! r3 = 0x7000 (frame data offset)
    mov.w   .L_dma_size_mid, r6         ! r6 = 0x02A0 (DMA size: medium)
    mov.l @r15, r5
    add r3, r7                          ! r7 = frame_data_ptr + 0x7000
    mov.l @r5, r5                       ! r5 = obj_entry_2.render_fn_ptr
    jsr @r14                            ! layer_setup(8, render_fn, 0x02A0, frame+0x7000)
    mov #0x8, r4                        ! [delay slot]
    mov.w   DAT_0602538a, r7            ! r7 = 0x0438 (obj table offset for layer 3)
    add r12, r7                         ! r7 = &obj_table_base[0x0438]
    mov.l r7, @r15                      ! sp[0] = &obj_entry_3
    mov.l @(4, r7), r7                  ! r7 = obj_entry_3.frame_data_ptr
    mov.w   DAT_06025386, r3            ! r3 = 0x7000
    mov.w   .L_dma_size_large, r6       ! r6 = 0x02B4 (DMA size: large)
    mov.l @r15, r5
    add r3, r7                          ! r7 = frame_data_ptr + 0x7000
    mov.l @r5, r5                       ! r5 = obj_entry_3.render_fn_ptr
    jsr @r14                            ! layer_setup(8, render_fn, 0x02B4, frame+0x7000)
    mov #0x8, r4                        ! [delay slot]
    mov #0x0, r13                       ! r13 = slot_idx = 0 (loop counter)
    mov.l @(4, r15), r10                ! r10 = car_index (from caller)
    shll2 r10                           ! r10 = car_index * 4
    mov.l   .L_render_record_table, r3
    add r3, r10                         ! r10 -> render_record_table[car_index]
.L_car_loop_start:                          ! === Per-slot physics + render loop (0..9) ===
    extu.w r8, r5                       ! r5 = render_param (0x00A9)
    mov.l   .L_fn_car_physics, r3
    jsr @r3                             ! car_physics_final(slot_idx, render_param)
    extu.w r13, r4                      ! r4 = slot_idx [delay slot]
    mov r13, r2
    mov.l @r10, r3                      ! r3 = render_record_table[car_index] base
    shll2 r2
    shll r2                             ! r2 = slot_idx * 8
    add r3, r2                          ! r2 -> slot_data[slot_idx]
    mov.w @(6, r2), r0                  ! r0 = slot_data[slot_idx].render_type (+6)
    mov r0, r2
    extu.w r2, r2
    cmp/eq r11, r2                      ! render_type == threshold (0x00B4)?
    bf      .L_render_dispatch          ! no -> always do detailed render
    mov.l   .L_game_state_ptr_2, r0     ! yes -> check if state allows skip
    mov.b @r0, r0
    extu.b r0, r0
    cmp/eq #0x4, r0                     ! game_state == 4?
    bt      .L_render_dispatch          ! state 4 -> still render despite threshold
    mov.l   .L_game_state_ptr_2, r0
    mov.b @r0, r0
    extu.b r0, r0
    cmp/eq #0x5, r0                     ! game_state == 5?
    bf      .L_next_slot                ! not 4 or 5 -> skip detailed render
.L_render_dispatch:                         ! === Detailed render record dispatch ===
    mov r13, r9                         ! r9 = slot_idx
    mov.l @r10, r3                      ! r3 = render record base
    shll2 r9
    shll r9                             ! r9 = slot_idx * 8 (slot offset)
    add r9, r3                          ! r3 -> slot_data[slot_idx]
    mov.w @(6, r3), r0                  ! r0 = render_type
    mov r0, r2
    extu.w r2, r2
    cmp/eq r11, r2                      ! render_type == 0x00B4?
    bt      .L_use_type_9               ! yes -> base_count = 9
    bra     .L_render_record_proc
    mov #0x8, r2                        ! no -> base_count = 8 [delay slot]
.L_dma_size_small_2:
    .2byte  0x0090                      /* DMA transfer size (small, 2nd pool copy) */

    .global DAT_0602537a
DAT_0602537a:
    .2byte  0x0C34                      /* layer A size (states 5/default) */

    .global DAT_0602537c
DAT_0602537c:
    .2byte  0x0C4E                      /* layer B size (states 5/default) */

    .global DAT_0602537e
DAT_0602537e:
    .2byte  0x02A4                      /* slot table entry size */

    .global DAT_06025380
DAT_06025380:
    .2byte  0x0428                      /* obj table offset: layer 1 */

    .global DAT_06025382
DAT_06025382:
    .2byte  0x6000                      /* frame data offset: layer 1 */

    .global DAT_06025384
DAT_06025384:
    .2byte  0x0430                      /* obj table offset: layer 2 */

    .global DAT_06025386
DAT_06025386:
    .2byte  0x7000                      /* frame data offset: layers 2 & 3 */
.L_dma_size_mid:
    .2byte  0x02A0                      /* DMA transfer size (medium) */

    .global DAT_0602538a
DAT_0602538a:
    .2byte  0x0438                      /* obj table offset: layer 3 */
.L_dma_size_large:
    .2byte  0x02B4                      /* DMA transfer size (large) */
    .2byte  0xFFFF                      /* alignment padding */
.L_scene_data_default:
    .4byte  sym_06059104                /* scene data for default state */
.L_fn_geom_dispatch_2:
    .4byte  sym_060284AE                /* geometry dispatch (2nd pool copy) */
.L_scene_slot_table:
    .4byte  sym_06058F94                /* scene slot table base */
.L_render_record_table:
    .4byte  sym_06061170                /* render record table (4-byte per car) */
.L_fn_car_physics:
    .4byte  car_physics_final           /* per-car physics final update */
.L_game_state_ptr_2:
    .4byte  sym_06061198                /* game state byte (2nd pool copy) */
.L_use_type_9:                              ! render type 0xB4 -> base_count = 9
    mov #0x9, r2
.L_render_record_proc:                      ! === Pass A: direction table A layer setup ===
    extu.w r2, r2                       ! r2 = base_count (8 or 9)
    mov r13, r6                         ! r6 = slot_idx
    mov r2, r0
    shll r6                             ! r6 = slot_idx * 2
    mov.w r0, @(16, r15)               ! sp[16] = base_count
    mov.l   .L_slot_offset_table, r7
    add r9, r7                          ! r7 -> slot_offset_table[slot_idx * 8]
    mov.l r7, @r15                      ! sp[0] = &slot_offset_entry
    mov.l @r7, r7                       ! r7 = slot_offset value
    shll2 r7
    shll r7                             ! r7 = slot_offset * 8
    add r12, r7                         ! r7 -> obj_table_base[slot_offset]
    mov.l r7, @(8, r15)                ! sp[8] = &obj_entry
    mov.l @(4, r7), r7                  ! r7 = obj_entry.frame_data_ptr
    mov.l   .L_fp_half, r3             ! r3 = 0x8000 (0.5 fixed-point)
    mov.l r6, @(4, r15)                ! sp[4] = slot_idx * 2
    add r3, r7                          ! r7 = frame_data_ptr + 0.5 (rounding)
    mov.l   .L_dir_table_a, r3
    add r3, r6                          ! r6 -> dir_table_a[slot_idx * 2]
    mov.l r6, @(12, r15)               ! sp[12] = &dir_table_a_entry
    mov.b @(1, r6), r0                  ! r0 = dir_high (byte[1])
    mov.l @(12, r15), r2
    mov r0, r6
    mov.b @r2, r2                       ! r2 = dir_low (byte[0])
    extu.b r6, r6
    extu.b r2, r2
    shll2 r6
    shll2 r6
    shll2 r6                            ! dir_high << 6
    add r2, r6                          ! r6 = (dir_high << 6) + dir_low
    shll r6                             ! r6 = direction_index * 2
    mov.l @(8, r15), r5                ! r5 -> obj_entry
    mov.l @r15, r4                      ! r4 -> slot_offset_entry
    mov.l @r5, r5                       ! r5 = obj_entry.render_fn_ptr
    add #0x4, r4                        ! r4 -> slot_offset_entry + 4
    mov.l r4, @(20, r15)               ! sp[20] = &slot_offset[+4]
    mov.l @r4, r4                       ! r4 = slot_offset[+4] value
    jsr @r14                            ! layer_setup(r4*4, render_fn, dir_idx*2, frame_data)
    shll2 r4                            ! r4 *= 4 [delay slot]
    mov.w @(16, r15), r0               ! === Pass B: direction table B layer setup ===
    mov.l @r10, r3                      ! r3 = render record base
    mov r0, r7                          ! r7 = base_count
    add r9, r3                          ! r3 -> slot_data[slot_idx]
    extu.w r7, r7
    mov.w @(6, r3), r0                  ! r0 = render_type
    shll8 r7                            ! r7 = base_count << 8
    mov r0, r2
    shll2 r7                            ! r7 = base_count << 10
    extu.w r2, r3
    shll2 r7                            ! r7 = base_count << 12
    shll2 r3
    shll r3                             ! r3 = render_type * 8
    mov r12, r2
    add r3, r2                          ! r2 -> obj_table_base[render_type * 8]
    mov.l r2, @(8, r15)                ! sp[8] = &obj_entry_B
    mov.l @(4, r2), r3                  ! r3 = obj_entry_B.frame_data_ptr
    add r3, r7                          ! r7 = (base_count << 12) + frame_data_ptr
    mov.l @(4, r15), r6                ! r6 = slot_idx * 2
    mov.l   .L_dir_table_b, r3
    add r3, r6                          ! r6 -> dir_table_b[slot_idx * 2]
    mov.l r6, @r15                      ! sp[0] = &dir_table_b_entry
    mov.b @(1, r6), r0                  ! r0 = dir_high_B (byte[1])
    mov r0, r6
    extu.b r6, r6
    shll2 r6
    shll2 r6
    shll2 r6                            ! dir_high_B << 6
    mov.l @r15, r2
    mov.b @r2, r2                       ! r2 = dir_low_B (byte[0])
    extu.b r2, r2
    add r2, r6                          ! r6 = (dir_high_B << 6) + dir_low_B
    shll r6                             ! r6 = direction_index_B * 2
    mov.l @(8, r15), r5                ! r5 -> obj_entry_B
    mov.l @(20, r15), r4               ! r4 -> slot_offset[+4]
    mov.l @r5, r5                       ! r5 = obj_entry_B.render_fn_ptr
    mov.l @r4, r4                       ! r4 = slot_offset[+4] value
    jsr @r14                            ! layer_setup(r4*4, render_fn_B, dir_idx_B*2, data_B)
    shll2 r4                            ! r4 *= 4 [delay slot]
.L_next_slot:                               ! === Loop increment ===
    add #0x1, r13                       ! slot_idx++
    mov #0xA, r3                        ! r3 = 10 (slot limit)
    cmp/ge r3, r13                      ! slot_idx >= 10?
    bt      .L_epilogue                 ! yes -> done
    bra     .L_car_loop_start           ! no -> next slot
    nop
.L_epilogue:                                ! === Restore registers and return ===
    add #0x18, r15                      ! deallocate 24 bytes of stack
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
    .2byte  0xFFFF                      /* alignment padding */
.L_slot_offset_table:
    .4byte  sym_06058FBC                /* per-slot offset entries (8-byte stride) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point rounding) */
.L_dir_table_a:
    .4byte  sym_0605904C                /* direction pair table A (2-byte stride) */
.L_dir_table_b:
    .4byte  sym_06059060                /* direction pair table B (2-byte stride) */
