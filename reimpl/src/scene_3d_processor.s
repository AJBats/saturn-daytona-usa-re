/* scene_3d_processor -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06027CA4 - 0x06027EDE
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ==========================================================================
 * 3D Scene Processor — Polygon Culling & Depth Ordering
 * ==========================================================================
 *
 * Called 4 times per car per frame (once for each view: front, rear-view
 * mirror, side view, shadow/overlay). Determines which 3D polygons are
 * visible and submits them for VDP1 rendering.
 *
 * FUNCTION: scene_3d_processor (FUN_06027CA4)
 *   Args:
 *     r4 = scene buffer pointer (one of 4 view buffers)
 *          scene_buf[0x00] = camera Z position
 *          scene_buf[0x08] = camera depth range
 *          scene_buf[0x0C] = (output) model reference / material mask
 *          scene_buf[0x0E] = (output) hw_divide result
 *          scene_buf[0x10] = (output) sort key source
 *     r5 = view index (0-3), saved to stack
 *
 *   Call chain:
 *     per-car loop (FUN_0600E0C0)
 *       -> FUN_060061C8 (pre-render transform setup)
 *       -> scene_3d_processor(0x06063EB0, 0)  view 0 (front camera)
 *       -> scene_3d_processor(0x06063E9C, 1)  view 1 (rear-view mirror)
 *       -> scene_3d_processor(0x06063ED8, 2)  view 2 (side view)
 *       -> scene_3d_processor(0x06063EC4, 3)  view 3 (shadow/overlay)
 *       -> FUN_0603053C(1) (render finalize)
 *
 *   Algorithm:
 *     Phase 1: Compute visible segment index from camera Z position
 *       segment = (cam_Z + 0x04000000) >> 21
 *       Adjusts by depth range: (0x03FFFFFF - cam_depth) >> 21, scaled
 *
 *     Phase 2: Mode check — camera_mode at sym_0607EAD8
 *       Mode 2 (LOD-aware): search visibility list at sym_06061270 for
 *       matching segment. If found and car distance <= 70, use override
 *       parameters from sym_06061240, write to render queue sym_06063F50.
 *       Otherwise: use standard scene node table at sym_060C2000.
 *
 *     Phase 3: Frustum culling — 4-plane half-space test
 *       For each polygon in the segment, tests against 4 frustum planes
 *       (A/B/C/D) using 64-bit multiply (dmuls.l) of plane normal against
 *       camera Z. Each plane has a flag bit in the polygon flags word:
 *         bit 0x0100 = plane A (near/far check)
 *         bit 0x0200 = plane B (left/right check)
 *         bit 0x0400 = plane C (top/bottom check)
 *         bit 0x0800 = plane D (depth check)
 *       Flag set: test result > 0 means cull (positive half-space)
 *       Flag clear: test result < 0 means cull (negative half-space)
 *       Failed polygons: advance model_id by 2, decrement poly count.
 *
 *     Phase 4: Visible model submission
 *       Read mesh data from polygon pool, mask with 0xFF.
 *       Call hw_divide (sym_0602ECCC) for depth sort key computation.
 *       Store results to scene buffer and car structure.
 *
 *     Phase 5: Depth key output
 *       Look up output offset from sym_0606128A by view index.
 *       Store depth sort key at car_ptr[offset].
 *
 *   Key data structures:
 *     sym_060C2000 — Scene node table (4 bytes per segment)
 *                    [model_id : u16][poly_count : u16]
 *     sym_060BF000 — Texture/material index table (word per polygon)
 *     sym_060A6000 — Polygon data pool (0x34 = 52 bytes per entry)
 *                    +0x00: flags word (cull mode bits)
 *                    +0x10: plane A normal + offset (8 bytes)
 *                    +0x18: plane B normal + offset (8 bytes)
 *                    +0x20: plane C normal + offset (8 bytes)
 *                    +0x28: plane D normal + offset (8 bytes)
 *                    +0x30: color/material byte
 *     sym_06061270 — Visibility list (mode 2, zero-terminated words)
 *     sym_06061240 — Model parameter overrides (LOD-based)
 *     sym_06063F50 — Render queue control word
 *     sym_0607EAD8 — Camera mode (2 = LOD-aware special mode)
 *     sym_0607E940 — Current car pointer
 *     sym_0606128A — Output offset table (per-view word offsets)
 *
 *   Register allocation (in frustum cull loop):
 *     r4  = scene buffer base (input parameter, preserved)
 *     r5  = polygon data entry pointer (computed from material)
 *     r6  = polygon flags word (32-bit, plane cull bits)
 *     r7  = plane normal (loaded from polygon data)
 *     r8  = saved sort key source for final store
 *     r9  = plane offset (loaded from polygon data)
 *     r10 = camera depth value for offset addition
 *     r11 = plane bitmask (loaded per-plane from pool)
 *     r12 = polygon count (decremented as models are culled)
 *     r13 = model ID (incremented by 2 on cull, indexes tables)
 *     r14 = plane flag bitmask (0x01000000, shifted left per plane)
 */

    .section .text.FUN_06027CA4


    .global scene_3d_processor
    .type scene_3d_processor, @function
scene_3d_processor:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    mov.l r11, @-r15                    ! save r11
    mov.l r10, @-r15                    ! save r10
    mov.l r9, @-r15                     ! save r9
    mov.l r8, @-r15                     ! save r8
    sts.l pr, @-r15                     ! save return address
    mov.l r5, @-r15                     ! save view index (0-3) to stack
    ! --- Phase 1: compute visible segment index from camera position ---
    mov.l @r4, r1                       ! r1 = scene_buf[0] (camera Z position)
    mov.l   _pool_z_bias, r2            ! r2 = 0x04000000 (Z position bias)
    add r2, r1                          ! r1 = cam_Z + 0x04000000 (shift to unsigned range)
    shlr16 r1                           ! r1 >>= 16
    shlr2 r1                            ! r1 >>= 2
    shlr2 r1                            ! r1 >>= 2  (total: >>20)
    shlr r1                             ! r1 >>= 1  (total: >>21 = segment index)
    mov.l @(8, r4), r2                  ! r2 = scene_buf[8] (camera depth range)
    mov.l   _pool_z_range_mask, r3      ! r3 = 0x03FFFFFF (max Z range)
    sub r2, r3                          ! r3 = 0x03FFFFFF - depth (remaining range)
    shlr16 r3                           ! r3 >>= 16
    shlr2 r3                            ! r3 >>= 2
    shlr2 r3                            ! r3 >>= 2  (total: >>20)
    shlr r3                             ! r3 >>= 1  (total: >>21)
    shll2 r3                            ! r3 <<= 2
    shll2 r3                            ! r3 <<= 2  (total: <<4)
    shll2 r3                            ! r3 <<= 2  (total: <<6, scale to segment stride)
    add r3, r1                          ! r1 = segment index + range offset
    ! --- Phase 2: check camera mode for LOD-aware override path ---
    mov.l   _pool_camera_mode_ptr, r2   ! r2 -> sym_0607EAD8 (camera mode variable)
    mov.l @r2, r0                       ! r0 = *camera_mode
    cmp/eq #0x2, r0                     ! mode == 2? (LOD-aware special mode)
    bf      .L_use_scene_table          ! no -> use standard scene node table
    ! --- Mode 2: search visibility list for matching segment ---
    mov.l r1, @-r15                     ! push segment index (restored later)
    mov r1, r10                         ! r10 = segment index (search target)
    mov.l   _pool_visibility_list, r1   ! r1 -> sym_06061270 (visibility list, zero-terminated)
    xor r12, r12                        ! r12 = 0 (byte offset into override table)
.L_vis_search_loop:
    mov.w @r1+, r0                      ! r0 = next entry in visibility list
    tst r0, r0                          ! entry == 0? (end of list)
    bt      .L_vis_no_override          ! yes -> no override found
    cmp/eq r0, r10                      ! entry matches our segment?
    bt      .L_vis_match_found          ! yes -> use LOD override
    bra     .L_vis_search_loop          ! keep searching
    add #0x2, r12                       ! (delay) advance override table offset
_pool_z_bias:
    .4byte  0x04000000                  ! Z position bias for unsigned segment calc
_pool_z_range_mask:
    .4byte  0x03FFFFFF                  ! max Z range mask
_pool_camera_mode_ptr:
    .4byte  sym_0607EAD8               ! -> camera mode variable (2 = LOD-aware)
_pool_visibility_list:
    .4byte  sym_06061270               ! -> visibility list (zero-terminated words)
.L_vis_match_found:
    ! --- Found matching segment in visibility list; check car distance ---
    mov.l   _pool_car_ptr, r1          ! r1 -> sym_0607E940 (current car pointer)
    mov.l @r1, r1                       ! r1 = *car_ptr (car struct base)
    mov.w   DAT_06027d26, r0           ! r0 = 0x01EC (offset to car distance field)
    mov.l @(r0, r1), r1                ! r1 = car[0x01EC] (distance from camera)
    mov #0x46, r0                       ! r0 = 70 (max LOD override distance)
    cmp/gt r0, r1                       ! distance > 70?
    bt      .L_vis_no_override         ! yes -> too far, skip override
    ! --- Apply LOD override: read model params from override table ---
    shll r12                            ! r12 *= 2 (word offset -> byte offset for dword table)
    mov.l   _pool_model_overrides, r0  ! r0 -> sym_06061240 (model parameter overrides)
    add r12, r0                         ! r0 -> override entry for this segment
    mov.l   _pool_render_queue_ctrl, r1 ! r1 -> sym_06063F50 (render queue control word)
    mov.w @r0+, r2                      ! r2 = override model_id (first word)
    mov.w @r0, r12                      ! r12 = override poly_count (second word)
    bra     .L_vis_override_applied    ! apply the override values
    mov.w r2, @r1                       ! (delay) write model_id to render queue control

    .global DAT_06027d26
DAT_06027d26:
    .2byte  0x01EC                      ! offset to car distance field in car struct
_pool_car_ptr:
    .4byte  sym_0607E940               ! -> current car pointer
_pool_model_overrides:
    .4byte  sym_06061240               ! -> model parameter override table (LOD-based)
_pool_render_queue_ctrl:
    .4byte  sym_06063F50               ! -> render queue control word
.L_vis_no_override:
    xor r12, r12                        ! r12 = 0 (no override: zero poly count)
.L_vis_override_applied:
    mov.l @r15+, r1                     ! pop segment index (pushed before search)
    tst r12, r12                        ! poly_count == 0? (no override applied)
    bt      .L_use_scene_table         ! yes -> fall through to standard path
    bra     .L_check_poly_count        ! no -> have override, use it
    mov r2, r13                         ! (delay) r13 = override model_id
.L_use_scene_table:
    ! --- Standard path: look up scene node table for this segment ---
    mov r1, r2                          ! r2 = segment index
    shll2 r2                            ! r2 *= 4 (4 bytes per scene node entry)
    mov.l   _pool_scene_node_table, r0 ! r0 -> sym_060C2000 (scene node table)
    add r0, r2                          ! r2 -> node_table[segment]
    mov.w @r2, r13                      ! r13 = node[0] = first model_id (u16)
    extu.w r13, r13                     ! zero-extend model_id to 32 bits
    mov.w @(2, r2), r0                  ! r0 = node[2] = polygon count (u16)
    mov r0, r12                         ! r12 = poly_count (loop counter)
.L_check_poly_count:
    cmp/pl r12                          ! poly_count > 0?
    bt      .L_begin_frustum_cull      ! yes -> start frustum culling
    ! --- No polygons: store zeros and skip to depth output ---
    mov #0x0, r0                        ! r0 = 0
    mov r0, r3                          ! r3 = 0 (sort key = none)
    bra     .L_store_result            ! skip to result storage
    mov #0x0, r6                        ! (delay) r6 = 0 (flags = none)
_pool_scene_node_table:
    .4byte  sym_060C2000               ! -> scene node table (4 bytes per segment)
.L_begin_frustum_cull:
    ! --- Phase 3: frustum culling — test polygon against 4 planes ---
    ! Look up material/texture for this model_id
    mov.l   _pool_texture_index_table, r0 ! r0 -> sym_060BF000 (texture index table)
    mov.w @(r0, r13), r5               ! r5 = texture_table[model_id] (material index)
    mov #0x34, r6                       ! r6 = 52 (bytes per polygon entry)
    mov.l   _pool_polygon_data_pool, r0 ! r0 -> sym_060A6000 (polygon data pool base)
    muls.w r6, r5                       ! MACL = material_index * 52
    sts macl, r5                        ! r5 = byte offset into polygon pool
    add r5, r0                          ! r0 -> polygon entry for this material
    mov.l @r0, r6                       ! r6 = polygon flags word (+0x00)
    add #0x10, r0                       ! r0 -> plane A data (+0x10)
    ! --- Plane A: first frustum half-space test ---
    mov #0x1, r14                       ! r14 = 1 (will become plane A flag 0x01000000)
    mov.l @r0+, r7                      ! r7 = plane A normal (multiply factor)
    shll16 r14                          ! r14 = 0x00010000
    mov.l @r4, r2                       ! r2 = scene_buf[0] (camera Z)
    shll8 r14                           ! r14 = 0x01000000 (plane A flag bitmask)
    dmuls.l r7, r2                      ! MACH:MACL = normal * cam_Z (64-bit product)
    mov.l @r0+, r9                      ! r9 = plane A offset
    mov.l @(8, r4), r10                 ! r10 = scene_buf[8] (camera depth)
    sts mach, r2                        ! r2 = high 32 bits of product
    sts macl, r3                        ! r3 = low 32 bits of product
    xtrct r2, r3                        ! r3 = middle 32 bits (fixed-point result)
    tst r14, r6                         ! flag 0x01000000 set in polygon flags?
    add r9, r3                          ! r3 += plane offset
    bf      .L_plane_a_test            ! flag set -> check positive half-space
    add r10, r3                         ! flag clear -> add camera depth to result
.L_plane_a_test:
    mov.w   _wpool_plane_a_mask, r11   ! r11 = 0x0100 (plane A cull flag)
    tst r11, r6                         ! plane A cull flag set in polygon flags?
    bt      .L_plane_a_neg_check       ! no -> check negative half-space instead
    cmp/pl r3                           ! result > 0? (positive half-space)
    bf      .L_plane_b_setup           ! no -> passed this plane, continue
    ! --- Culled by plane A (positive): skip polygon ---
    add #0x2, r13                       ! advance model_id to next polygon
    bra     .L_check_poly_count        ! re-check with decremented count
    add #-0x1, r12                      ! (delay) poly_count--
_wpool_plane_a_mask:
    .2byte  0x0100                      ! plane A cull direction flag
    .2byte  0x0000                      ! padding
_pool_texture_index_table:
    .4byte  sym_060BF000               ! -> texture/material index table
_pool_polygon_data_pool:
    .4byte  sym_060A6000               ! -> polygon data pool (52 bytes per entry)
.L_plane_a_neg_check:
    cmp/pz r3                           ! result >= 0? (non-negative)
    bt      .L_plane_b_setup           ! yes -> passed this plane
    ! --- Culled by plane A (negative): skip polygon ---
    add #0x2, r13                       ! advance model_id to next polygon
    bra     .L_check_poly_count        ! re-check with decremented count
    add #-0x1, r12                      ! (delay) poly_count--
.L_plane_b_setup:
    ! --- Plane B: second frustum half-space test ---
    mov r4, r1                          ! r1 = scene buffer base (reload for @r1)
    mov.l @r0+, r7                      ! r7 = plane B normal (multiply factor)
    mov.l @r1, r2                       ! r2 = scene_buf[0] (camera Z)
    shll r14                            ! r14 <<= 1 -> 0x02000000 (plane B flag)
    dmuls.l r7, r2                      ! MACH:MACL = normal * cam_Z
    mov.l @r0+, r9                      ! r9 = plane B offset
    mov.l @(8, r4), r10                 ! r10 = scene_buf[8] (camera depth)
    sts mach, r2                        ! r2 = high 32 bits
    sts macl, r3                        ! r3 = low 32 bits
    xtrct r2, r3                        ! r3 = fixed-point result
    tst r14, r6                         ! flag 0x02000000 set?
    add r9, r3                          ! r3 += plane offset
    bf      .L_plane_b_test            ! flag set -> positive check
    add r10, r3                         ! flag clear -> add camera depth
.L_plane_b_test:
    mov.w   _wpool_plane_b_mask, r11   ! r11 = 0x0200 (plane B cull flag)
    tst r11, r6                         ! plane B cull flag set?
    bt      .L_plane_b_neg_check       ! no -> check negative half-space
    cmp/pl r3                           ! result > 0?
    bf      .L_plane_c_setup           ! no -> passed plane B
    ! --- Culled by plane B (positive): skip polygon ---
    add #0x2, r13                       ! advance model_id
    bra     .L_check_poly_count        ! re-check
    add #-0x1, r12                      ! (delay) poly_count--
_wpool_plane_b_mask:
    .2byte  0x0200                      ! plane B cull direction flag
.L_plane_b_neg_check:
    cmp/pz r3                           ! result >= 0?
    bt      .L_plane_c_setup           ! yes -> passed plane B
    ! --- Culled by plane B (negative): skip polygon ---
    add #0x2, r13                       ! advance model_id
    bra     .L_check_poly_count        ! re-check
    add #-0x1, r12                      ! (delay) poly_count--
.L_plane_c_setup:
    ! --- Plane C: third frustum half-space test ---
    mov.l @r0+, r7                      ! r7 = plane C normal (multiply factor)
    mov.l @r4, r2                       ! r2 = scene_buf[0] (camera Z)
    shll r14                            ! r14 <<= 1 -> 0x04000000 (plane C flag)
    dmuls.l r7, r2                      ! MACH:MACL = normal * cam_Z
    mov.l @r0+, r9                      ! r9 = plane C offset
    mov.l @(8, r4), r10                 ! r10 = scene_buf[8] (camera depth)
    sts mach, r2                        ! r2 = high 32 bits
    sts macl, r3                        ! r3 = low 32 bits
    xtrct r2, r3                        ! r3 = fixed-point result
    tst r14, r6                         ! flag 0x04000000 set?
    add r9, r3                          ! r3 += plane offset
    bf      .L_plane_c_test            ! flag set -> positive check
    add r10, r3                         ! flag clear -> add camera depth
.L_plane_c_test:
    mov.w   _wpool_plane_c_mask, r10   ! r10 = 0x0400 (plane C cull flag)
    tst r10, r6                         ! plane C cull flag set?
    bt      .L_plane_c_neg_check       ! no -> check negative half-space
    cmp/pl r3                           ! result > 0?
    bf      .L_plane_d_setup           ! no -> passed plane C
    ! --- Culled by plane C (positive): skip polygon ---
    add #0x2, r13                       ! advance model_id
    bra     .L_check_poly_count        ! re-check
    add #-0x1, r12                      ! (delay) poly_count--
_wpool_plane_c_mask:
    .2byte  0x0400                      ! plane C cull direction flag
.L_plane_c_neg_check:
    cmp/pz r3                           ! result >= 0?
    bt      .L_plane_d_setup           ! yes -> passed plane C
    ! --- Culled by plane C (negative): skip polygon ---
    add #0x2, r13                       ! advance model_id
    bra     .L_check_poly_count        ! re-check
    add #-0x1, r12                      ! (delay) poly_count--
.L_plane_d_setup:
    ! --- Plane D: fourth frustum half-space test ---
    mov.l @r0+, r7                      ! r7 = plane D normal (multiply factor)
    mov.l @r4, r2                       ! r2 = scene_buf[0] (camera Z)
    shll r14                            ! r14 <<= 1 -> 0x08000000 (plane D flag)
    dmuls.l r7, r2                      ! MACH:MACL = normal * cam_Z
    mov.l @r0+, r9                      ! r9 = plane D offset
    mov.l @(8, r4), r10                 ! r10 = scene_buf[8] (camera depth)
    sts mach, r2                        ! r2 = high 32 bits
    sts macl, r3                        ! r3 = low 32 bits
    xtrct r2, r3                        ! r3 = fixed-point result
    tst r14, r6                         ! flag 0x08000000 set?
    add r9, r3                          ! r3 += plane offset
    bf      .L_plane_d_test            ! flag set -> positive check
    add r10, r3                         ! flag clear -> add camera depth
.L_plane_d_test:
    mov.l   _pool_plane_d_mask, r10    ! r10 = 0x00000800 (plane D cull flag)
    tst r10, r6                         ! plane D cull flag set?
    bt      .L_plane_d_neg_check       ! no -> check negative half-space
    cmp/pl r3                           ! result > 0?
    bf      .L_all_planes_passed       ! no -> passed all 4 planes!
    ! --- Culled by plane D (positive): skip polygon ---
    add #0x2, r13                       ! advance model_id
    bra     .L_check_poly_count        ! re-check
    add #-0x1, r12                      ! (delay) poly_count--
    .2byte  0x0000                      ! alignment padding
_pool_plane_d_mask:
    .4byte  0x00000800                  ! plane D cull direction flag (bit 11)
.L_plane_d_neg_check:
    cmp/pz r3                           ! result >= 0?
    bt      .L_all_planes_passed       ! yes -> passed all 4 planes!
    ! --- Culled by plane D (negative): skip polygon ---
    add #0x2, r13                       ! advance model_id
    bra     .L_check_poly_count        ! re-check
    add #-0x1, r12                      ! (delay) poly_count--
.L_all_planes_passed:
    ! --- Phase 4: polygon passed all frustum planes — submit for rendering ---
    mov.l   _pool_poly_data_base, r1   ! r1 -> sym_060A6000 (polygon data pool base)
    add r5, r1                          ! r1 -> this polygon's data entry (r5 = byte offset)
    mov.l @r1, r3                       ! r3 = polygon entry[0x00] (raw flags/material data)
    mov.w   DAT_06027e98, r6           ! r6 = 0x00FF (material ID mask)
    and r6, r3                          ! r3 = material byte (low 8 bits only)
    mov r3, r0                          ! r0 = masked material byte
.L_store_result:
    ! --- Store model reference to scene buffer ---
    mov.w r0, @(12, r4)                 ! scene_buf[0x0C] = material/model reference
    mov #0x0, r0                        ! r0 = 0
    cmp/eq r0, r6                       ! flags == 0? (no polygon found / empty scene)
    bt      .L_empty_scene             ! yes -> skip depth computation
    ! --- Compute depth sort key via hardware division ---
    add #0x30, r1                       ! r1 -> polygon_entry[0x30] (sort key source)
    mov.w @r1, r0                       ! r0 = sort key source (word at +0x30)
    mov.l r0, @(16, r4)                 ! scene_buf[0x10] = sort key source
    mov r0, r8                          ! r8 = sort key source (saved for later store)
    mov r5, r1                          ! r1 = polygon data offset (dividend for hw_divide)
    mov #0x34, r0                       ! r0 = 52 (divisor = entry size)
    mov.l   _pool_hw_divide, r12       ! r12 -> sym_0602ECCC (hardware divide function)
    jsr @r12                            ! call hw_divide(r0=52, r1=offset) -> r0=index
    mov.l r3, @-r15                     ! (delay) push material byte (save across call)
    mov.l @r15+, r3                     ! pop material byte
    mov.w r0, @(14, r4)                 ! scene_buf[0x0E] = divide result (polygon index)
    ! --- Store sort key to car structure ---
    mov.l   _pool_car_ptr_b, r6        ! r6 -> sym_0607E940 (current car pointer)
    mov.l @r6, r0                       ! r0 = *car_ptr (car struct base)
    mov.l @r15+, r5                     ! pop view index (pushed in prologue)
    cmp/pl r5                           ! view_index > 0?
    bt      .L_store_depth_key         ! yes -> use standard path
    ! --- View 0 special: also store sort key at fixed offset ---
    mov.w   DAT_06027e9a, r1           ! r1 = 0x025C (offset in car struct for view 0)
    bra     .L_store_depth_key         ! continue to common store path
    mov.l r8, @(r0, r1)                ! (delay) car_ptr[0x025C] = sort key source

    .global DAT_06027e98
DAT_06027e98:
    .2byte  0x00FF                      ! material ID mask (low byte)

    .global DAT_06027e9a
DAT_06027e9a:
    .2byte  0x025C                      ! car struct offset for view 0 sort key
_pool_poly_data_base:
    .4byte  sym_060A6000               ! -> polygon data pool base
_pool_hw_divide:
    .4byte  sym_0602ECCC               ! -> hw_divide (protected hardware integer divide)
_pool_car_ptr_b:
    .4byte  sym_0607E940               ! -> current car pointer
.L_empty_scene:
    ! --- No visible polygon: just load car pointer and pop view index ---
    mov.l   _pool_car_ptr_c, r6        ! r6 -> sym_0607E940 (current car pointer)
    mov.l @r6, r0                       ! r0 = *car_ptr (car struct base)
    mov.l @r15+, r5                     ! pop view index
.L_store_depth_key:
    ! --- Phase 5: store depth sort key at per-view offset in car struct ---
    shll r5                             ! r5 = view_index * 2 (word offset)
    mov.l   _pool_output_offset_table, r2 ! r2 -> sym_0606128A (per-view output offsets)
    add r5, r2                          ! r2 -> offset_table[view_index]
    mov.w @r2, r2                       ! r2 = output offset (word)
    extu.w r2, r2                       ! zero-extend to 32 bits
    mov.l r3, @(r0, r2)                ! car_ptr[offset] = depth sort key
    ! --- Epilogue: restore registers and return ---
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14
_pool_car_ptr_c:
    .4byte  sym_0607E940               ! -> current car pointer
_pool_output_offset_table:
    .4byte  sym_0606128A               ! -> per-view output offset table
    .4byte  0x00093600                  ! (trailing data)
    .4byte  0x89FCAFD5                  ! (trailing data)
    .2byte  0x0009                      ! (trailing data)
