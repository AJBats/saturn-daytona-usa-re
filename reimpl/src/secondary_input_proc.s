/* secondary_input_proc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06035A08 - 0x06035C08
 * Auto-generated by tools/generate_l3_tu.py
 *
 * IEEE 754 double-precision floating-point library (continued from slave_main_loop.s).
 *
 * secondary_input_proc (fp_mul_64 body)
 *   Continuation of sym_060359E4 (fp_mul_64) which began in slave_main_loop.s.
 *   The prologue in slave_main_loop pushed r0-r7, r2-r3, r8-r13 and loaded
 *   operands A (r4:r5) and B (r6:r7) from the stack. This TU picks up at the
 *   r14/macl/mach saves, extracts exponents and mantissas, handles special cases
 *   (NaN/Inf/zero/denormal) by branching back into the fp_add epilog, performs
 *   64-bit mantissa multiplication via dmulu.l, normalizes, rounds, packs the
 *   IEEE 754 result, and stores it through the output pointer on the stack.
 *
 *   External branches (bt/bra encoded as .byte pairs) jump to shared special-case
 *   handlers in the fp_add_64 / fp_sub_64 code within slave_main_loop.s:
 *     0x06035940 — exp_a_max handler (NaN/Inf for operand A)
 *     0x06035968 — exp_b_zero handler (zero/denorm for operand B)
 *     0x06035980 — shift_up_3 / align mantissas (A exp zero, B nonzero)
 *     0x060359A4 — norm_b_start handler
 *     0x060359C8 — exact_zero result (underflow)
 *     0x060359D2 — fadd_epilog (shared pack-and-return)
 *
 * sym_06035B34 (fp_cmp_64)
 *   Double-precision equality comparison. Takes two doubles on the stack,
 *   returns r0=0 if equal, r0=1 if not equal. Handles NaN/Inf/zero special
 *   cases: NaN != anything, Inf == Inf, +0 == -0.
 *
 * sym_06035BC8 (int_to_fp_stack)
 *   Convert unsigned 32-bit integer to IEEE 754 double. Input in r0, result
 *   stored through pointer on stack. Similar to sym_060358EC but uses a
 *   different stack frame layout (pointer at offset 8 instead of 12).
 */

    .section .text.FUN_06035A08


    .global secondary_input_proc
    .type secondary_input_proc, @function
secondary_input_proc:
    mov.l r14, @-r15                ! save r14 (continuing fp_mul_64 prologue from slave_main_loop)
    sts.l macl, @-r15              ! save macl (needed for dmulu.l)
    sts.l mach, @-r15              ! save mach (needed for dmulu.l)
    mov.l   .L_pool_exp_mask, r3   ! r3 = 0x7FF (IEEE 754 double exponent mask, 11 bits)
    mov.l   .L_pool_mant_mask, r0  ! r0 = 0xFFFFF (IEEE 754 double mantissa mask, 20 bits)
    mov r4, r10                    ! r10 = A_hi XOR B_hi (for sign of result)
    xor r6, r10                    ! r10 = sign_A ^ sign_B (result sign in bit 31)
    mov r4, r8                     ! extract exponent from operand A
    shlr16 r8                      ! shift A_hi right 20 bits to isolate exponent
    shlr2 r8                       !   (shlr16 + shlr2 + shlr2 = shift right 20)
    shlr2 r8                       !   r8 = A_hi >> 20
    and r3, r8                     ! r8 = exp_A (masked to 11 bits)
    mov r6, r9                     ! extract exponent from operand B
    shlr16 r9                      ! shift B_hi right 20 bits to isolate exponent
    shlr2 r9                       !   (shlr16 + shlr2 + shlr2 = shift right 20)
    shlr2 r9                       !   r9 = B_hi >> 20
    and r3, r9                     ! r9 = exp_B (masked to 11 bits)
    and r0, r4                     ! r4 = mant_A_hi (high 20 bits of mantissa)
    and r0, r6                     ! r6 = mant_B_hi (high 20 bits of mantissa)
    cmp/eq r3, r8                  ! exp_A == 0x7FF? (NaN or Infinity)
    .byte   0x89, 0x86    /* bt 0x06035940 (external) — exp_a_max: handle NaN/Inf for A */
    cmp/eq r3, r9                  ! exp_B == 0x7FF? (NaN or Infinity)
    .byte   0x89, 0x98    /* bt 0x06035968 (external) — exp_b_zero: handle NaN/Inf for B */
    tst r8, r8                     ! exp_A == 0? (zero or denormal)
    .byte   0x89, 0xA2    /* bt 0x06035980 (external) — shift_up_3: handle zero/denorm A */
    tst r9, r9                     ! exp_B == 0? (zero or denormal)
    .byte   0x89, 0xB2    /* bt 0x060359A4 (external) — norm_b_start: handle zero/denorm B */
    mov.l   .L_pool_exp_bias, r2   ! r2 = 0x3FF (IEEE 754 double bias = 1023)
    add r9, r8                     ! r8 = exp_A + exp_B (biased sum)
    sub r2, r8                     ! r8 = exp_A + exp_B - bias (unbias one copy)
    cmp/ge r3, r8                  ! result exp >= 0x7FF? (overflow to Inf)
    .byte   0x89, 0xC4    /* bt 0x060359D2 (external) — fadd_epilog: overflow → Inf */
    mov #-0x35, r3                 ! r3 = -53 (minimum biased exponent for denormal)
    cmp/gt r8, r3                  ! -53 > result_exp? (underflow to zero)
    .byte   0x89, 0xBC    /* bt 0x060359C8 (external) — exact_zero: underflow → 0 */
    mov.l   .L_pool_implicit_one, r0 ! r0 = 0x00100000 (implicit 1 bit at position 20)
    or r0, r4                      ! r4 = 1.mant_A_hi (set implicit leading 1)
    or r0, r6                      ! r6 = 1.mant_B_hi (set implicit leading 1)
    dmulu.l r5, r7                 ! multiply low words: mant_A_lo * mant_B_lo
    sts mach, r2                   ! r2 = (A_lo * B_lo) >> 32 (high part)
    sts macl, r3                   ! r3 = (A_lo * B_lo) & 0xFFFFFFFF (low part)
    dmulu.l r4, r6                 ! multiply high words: mant_A_hi * mant_B_hi
    sts mach, r9                   ! r9 = (A_hi * B_hi) >> 32 (overflow into next word)
    sts macl, r1                   ! r1 = (A_hi * B_hi) & 0xFFFFFFFF
    dmulu.l r4, r7                 ! cross-multiply: mant_A_hi * mant_B_lo
    sts mach, r4                   ! r4 = (A_hi * B_lo) >> 32
    sts macl, r7                   ! r7 = (A_hi * B_lo) & 0xFFFFFFFF
    dmulu.l r5, r6                 ! cross-multiply: mant_A_lo * mant_B_hi
    sts mach, r6                   ! r6 = (A_lo * B_hi) >> 32
    sts macl, r0                   ! r0 = (A_lo * B_hi) & 0xFFFFFFFF
    clrt                           ! clear T for multi-word addition
    addc r2, r7                    ! r7 += (A_lo*B_lo)_hi, propagate carry
    addc r4, r6                    ! r6 += (A_hi*B_lo)_hi + carry
    mov #0x0, r2                   ! r2 = 0 (for carry propagation)
    addc r7, r0                    ! r0 += r7 (accumulate cross products low)
    addc r6, r1                    ! r1 += r6 (accumulate cross products high)
    addc r2, r9                    ! r9 += carry (propagate final carry)
    tst r3, r3                     ! was (A_lo*B_lo)_lo nonzero? (sticky bit)
    bt      .L_sticky_clear        ! skip if low product was exactly zero
    or #0x1, r0                    ! set sticky bit (lowest bit) for rounding
.L_sticky_clear:
    xtrct r0, r3                   ! r3 = r0[15:0]:r3[31:16] (pack 96-bit product)
    xtrct r1, r0                   ! r0 = r1[15:0]:r0[31:16] (shift product right 16)
    xtrct r9, r1                   ! r1 = r9[15:0]:r1[31:16] (top of 128-bit product)
    shlr r1                        ! shift 96-bit mantissa right 1 bit (align to 2x implicit bit)
    rotcr r0                       !   propagate through r0
    rotcr r3                       !   propagate through r3
    mov.l   .L_pool_carry_boundary, r5 ! r5 = 0x01000000 (carry boundary = implicit 1 shifted left 3)
    tst r1, r5                     ! is result >= 2.0 (needs renormalization)?
    bt      .L_no_extra_shift      ! no extra shift needed
    shlr r1                        ! shift right 1 more to normalize (mantissa was >= 2.0)
    rotcr r0                       !   propagate through r0
    rotcr r3                       !   propagate through r3
    add #0x1, r8                   ! increment exponent to compensate for right shift
    mov.l   .L_pool_exp_mask, r4   ! r4 = 0x7FF (check for overflow)
    cmp/eq r4, r8                  ! result exp == 0x7FF? (overflow to Inf)
    bf      .L_no_extra_shift      ! no overflow, continue
    .byte   0xAF, 0x97    /* bra 0x060359D2 (external) — fadd_epilog: overflow → Inf */
    nop                            ! branch delay slot
.L_no_extra_shift:
    tst r3, r3                     ! check low bits for rounding (guard/round/sticky)
    bt      .L_round_skip          ! low bits are zero, no rounding needed
    or #0x1, r0                    ! set sticky bit in result for rounding info
.L_round_skip:
    cmp/pl r8                      ! result exponent > 0? (normal number)
    bt      .L_pack_mantissa       ! yes, go to packing
    neg r8, r8                     ! r8 = -exp (shift amount for denormalization)
    add #0x1, r8                   ! adjust: need to shift right by (1 - exp)
.L_denorm_shift:
    shlr r1                        ! shift mantissa right to create denormal
    rotcr r0                       !   propagate through r0
    .word 0x0329 /* UNKNOWN */     ! (encoded instruction within denorm loop)
    dt r8                          ! decrement shift counter, set T when zero
    bf/s    .L_denorm_shift        ! loop until fully denormalized
    or r3, r0                      ! merge sticky bits from shifted-out data
.L_pack_mantissa:
    tst #0x4, r0                   ! test guard bit (bit 2 of r0)
    bt      .L_no_round            ! guard bit clear → no rounding needed
    tst #0xB, r0                   ! test round+sticky bits (bits 0,1,3)
    bt      .L_no_round            ! all zero → exactly halfway, round to even (no round)
    mov #0x8, r4                   ! r4 = 8 (round increment: add 1 to bit 3)
    addc r4, r0                    ! r0 += 8 (round up mantissa)
    addc r2, r1                    ! propagate carry into high word
    cmp/gt r1, r5                  ! did rounding cause mantissa overflow? (r1 > 0x01000000)
    bt      .L_no_round            ! no overflow, continue
    shlr r1                        ! overflow: shift right 1 to renormalize
    rotcr r0                       !   propagate through r0
    add #0x1, r8                   ! increment exponent for normalization
.L_no_round:
    shlr r1                        ! remove 3 guard bits (shift right 3)
    rotcr r0                       !   propagate through r0
    shlr r1                        !   second guard bit shift
    rotcr r0                       !   propagate
    shlr r1                        !   third guard bit shift
    rotcr r0                       !   propagate — mantissa now in final position
    mov.l   .L_pool_mant_mask, r2  ! r2 = 0xFFFFF (20-bit mantissa mask)
    and r2, r1                     ! r1 = final mantissa high 20 bits (strip implicit 1)
    shll16 r8                      ! pack exponent into bits [30:20] of result_hi
    shll2 r8                       !   (shll16 + shll2 + shll2 = shift left 20)
    shll2 r8                       !   r8 = biased_exp << 20
    or r8, r1                      ! r1 = exponent | mantissa_hi
    shll r1                        ! shift left 1 to make room for sign bit
    shll r10                       ! T = sign of result (bit 31 of XOR'd signs)
    rotcr r1                       ! insert sign bit as MSB of result_hi
    lds.l @r15+, mach              ! restore mach
    lds.l @r15+, macl              ! restore macl
    mov.l @r15+, r14               ! restore r14
    mov.l @r15+, r13               ! restore r13
    mov.l @r15+, r12               ! restore r12
    mov.l @r15+, r11               ! restore r11
    mov.l @r15+, r10               ! restore r10
    mov.l @r15+, r9                ! restore r9
    mov.l @r15+, r8                ! restore r8
    mov.l @r15+, r3                ! restore r3
    mov.l @r15+, r2                ! restore r2
    mov.l @(24, r15), r6           ! r6 = output pointer (passed on stack)
    mov.l r1, @r6                  ! store result_hi (sign|exp|mant_hi) to output
    mov.l r0, @(4, r6)             ! store result_lo (mant_lo) to output+4
    mov.l @r15+, r7                ! restore r7
    mov.l @r15+, r6                ! restore r6
    mov.l @r15+, r5                ! restore r5
    mov.l @r15+, r4                ! restore r4
    mov.l @r15+, r1                ! restore r1
    mov.l @r15+, r0                ! restore r0
    rts                            ! return to caller
    add #0x14, r15                 ! deallocate remaining stack frame (5 words)
.L_pool_exp_mask:
    .4byte  0x000007FF             ! IEEE 754 double exponent mask (11 bits)
.L_pool_mant_mask:
    .4byte  0x000FFFFF             ! IEEE 754 double mantissa mask (high 20 bits)
.L_pool_implicit_one:
    .4byte  0x00100000             ! implicit 1 bit at position 20 (1.0 in mantissa field)
.L_pool_carry_boundary:
    .4byte  0x01000000             ! carry boundary (implicit 1 << 3, with guard bits)
.L_pool_exp_bias:
    .4byte  0x000003FF             ! IEEE 754 double exponent bias (1023)

    .global sym_06035B34
sym_06035B34:
    mov.l r4, @-r15                ! save r4 (fp_cmp_64: double equality comparison)
    mov.l r5, @-r15                ! save r5
    mov.l r6, @-r15                ! save r6
    mov.l r7, @-r15                ! save r7
    mov.l @(24, r15), r4           ! r4 = A_hi (operand A high word from stack)
    mov.l @(28, r15), r5           ! r5 = A_lo (operand A low word from stack)
    mov.l @(16, r15), r6           ! r6 = B_hi (operand B high word from stack)
    mov.l @(20, r15), r7           ! r7 = B_lo (operand B low word from stack)
    mov.l r8, @-r15                ! save r8
    mov.l r9, @-r15                ! save r9
    mov.l r10, @-r15               ! save r10
    mov.l r11, @-r15               ! save r11
    mov.l   .L_cmp_exp_field, r0   ! r0 = 0x7FF00000 (exponent+sign field mask)
    mov r4, r10                    ! r10 = A_hi (preserve full original)
    mov r6, r11                    ! r11 = B_hi (preserve full original)
    mov r4, r8                     ! extract exp+sign field from A
    and r0, r8                     ! r8 = A_hi & 0x7FF00000 (A exponent field)
    mov r6, r9                     ! extract exp+sign field from B
    and r0, r9                     ! r9 = B_hi & 0x7FF00000 (B exponent field)
    mov.l   .L_cmp_mant_field, r0  ! r0 = 0xFFFFF (mantissa mask)
    and r0, r4                     ! r4 = A mantissa (high 20 bits)
    and r0, r6                     ! r6 = B mantissa (high 20 bits)
    mov.l   .L_cmp_exp_field, r0   ! r0 = 0x7FF00000 (for NaN/Inf check)
    cmp/eq r0, r8                  ! A exponent == 0x7FF? (NaN or Inf)
    bt      .L_cmp_a_special       ! yes → check if NaN (mantissa nonzero)
.L_cmp_check_b:
    cmp/eq r0, r9                  ! B exponent == 0x7FF? (NaN or Inf)
    bt      .L_cmp_b_special       ! yes → check if NaN
.L_cmp_check_a_zero:
    tst r8, r8                     ! A exponent == 0? (zero or denormal)
    bt      .L_cmp_both_zero       ! yes → check if both zero
.L_cmp_compare:
    cmp/eq r10, r11                ! A_hi == B_hi? (compare high words)
    bf      .L_cmp_not_equal       ! high words differ → not equal
    cmp/eq r5, r7                  ! A_lo == B_lo? (compare low words)
    bf      .L_cmp_not_equal       ! low words differ → not equal
    bra     .L_cmp_done            ! both words match → equal
    mov #0x0, r0                   ! r0 = 0 (equal)
.L_cmp_not_equal:
    mov #0x1, r0                   ! r0 = 1 (not equal)
.L_cmp_done:
    mov.l @r15+, r11               ! restore r11
    mov.l @r15+, r10               ! restore r10
    mov.l @r15+, r9                ! restore r9
    mov.l @r15+, r8                ! restore r8
    mov.l @r15+, r7                ! restore r7
    mov.l @r15+, r6                ! restore r6
    mov.l @r15+, r5                ! restore r5
    mov.l @r15+, r4                ! restore r4
    rts                            ! return: r0 = 0 (equal) or 1 (not equal)
    add #0x10, r15                 ! deallocate stack frame (4 words for stack args)
.L_cmp_a_special:
    tst r4, r4                     ! A mantissa_hi != 0? (NaN check)
    bf      .L_cmp_not_equal       ! A is NaN → not equal to anything
    tst r5, r5                     ! A mantissa_lo != 0? (NaN check low word)
    bf      .L_cmp_not_equal       ! A is NaN → not equal
    bra     .L_cmp_check_b         ! A is Inf (mantissa=0) → continue checking B
    nop                            ! delay slot
.L_cmp_b_special:
    tst r6, r6                     ! B mantissa_hi != 0? (NaN check)
    bf      .L_cmp_not_equal       ! B is NaN → not equal to anything
    tst r7, r7                     ! B mantissa_lo != 0? (NaN check low word)
    bf      .L_cmp_not_equal       ! B is NaN → not equal
    bra     .L_cmp_check_a_zero    ! B is Inf → continue checking A
    nop                            ! delay slot
.L_cmp_both_zero:
    tst r9, r9                     ! B exponent == 0 too?
    bf      .L_cmp_not_equal       ! B has nonzero exp → not equal (A is zero/denorm)
    tst r4, r4                     ! A mantissa_hi == 0?
    bf      .L_cmp_compare         ! A denormal (nonzero mantissa) → do bitwise compare
    tst r5, r5                     ! A mantissa_lo == 0?
    bf      .L_cmp_compare         ! A denormal → do bitwise compare
    tst r6, r6                     ! B mantissa_hi == 0?
    bf      .L_cmp_not_equal       ! B denormal but A is zero → not equal
    tst r7, r7                     ! B mantissa_lo == 0?
    bf      .L_cmp_not_equal       ! B denormal but A is zero → not equal
    bra     .L_cmp_done            ! both are zero (regardless of sign) → equal (+0 == -0)
    mov #0x0, r0                   ! r0 = 0 (equal)
.L_cmp_exp_field:
    .4byte  0x7FF00000             ! exponent+sign field mask (bits [30:20] shifted)
.L_cmp_mant_field:
    .4byte  0x000FFFFF             ! mantissa field mask (high 20 bits)

    .global sym_06035BC8
sym_06035BC8:
    mov.l r1, @-r15                ! save r1 (int_to_fp_stack: int → IEEE 754 double)
    mov.l r2, @-r15                ! save r2
    tst r0, r0                     ! input == 0?
    bt      .L_i2f_zero            ! yes → return +0.0
    mov.l   .L_i2f_bias_max, r1   ! r1 = 0x41F (bias+31 = 1054, max biased exponent)
.L_i2f_normalize:
    shll r0                        ! shift left to find leading 1 bit
    bf/s    .L_i2f_normalize       ! T=0 → still leading zeros, keep shifting
    add #-0x1, r1                  ! decrement exponent for each leading zero
    mov r0, r2                     ! r2 = shifted mantissa (for double_lo)
    shll16 r2                      ! shift to form low word of double
    shll2 r2                       !   (shll16 + shll2 + shll2 = shift left 20)
    shll2 r2                       !   r2 = mantissa bits for double_lo
    shlr8 r0                       ! shift mantissa to position for double_hi
    shlr2 r0                       !   (shlr8 + shlr2 + shlr2 = shift right 12)
    shlr2 r0                       !   r0 = mantissa_hi (20 bits, implicit 1 stripped by shll)
    shll16 r1                      ! pack exponent into bits [30:20]
    shll2 r1                       !   (shll16 + shll2 + shll2 = shift left 20)
    shll2 r1                       !   r1 = biased_exp << 20
    or r1, r0                      ! r0 = exponent | mantissa_hi (unsigned, sign=0)
.L_i2f_store:
    mov.l @(8, r15), r1            ! r1 = output pointer (from stack, offset 8)
    mov.l r0, @r1                  ! store double_hi to output
    mov.l r2, @(4, r1)             ! store double_lo to output+4
    mov.l @r15+, r2                ! restore r2
    mov.l @r15+, r1                ! restore r1
    rts                            ! return to caller
    add #0x4, r15                  ! deallocate stack frame (1 word for return addr)
.L_i2f_zero:
    mov #0x0, r2                   ! double_lo = 0
    bra     .L_i2f_store           ! store +0.0 result
    mov #0x0, r0                   ! double_hi = 0
    .2byte  0x0009                 ! alignment padding (nop encoding)
.L_i2f_bias_max:
    .4byte  0x0000041F             ! exponent bias + 31 = 1023 + 31 = 1054 (0x41E + 1)
