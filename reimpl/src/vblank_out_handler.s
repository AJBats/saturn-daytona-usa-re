/* vblank_out_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06007268 - 0x060072E6
 * Auto-generated by tools/generate_l3_tu.py
 */

/*
 * vblank_out_handler (FUN_06007268)
 *
 * VBlank-OUT interrupt handler, registered as SCU vector 0x41.
 * Called by hardware at the end of every vertical blanking period (~60 Hz).
 *
 * Responsibilities:
 *   1. Increment the VBlank-OUT counter (sym_06059F44)
 *   2. Set the phase flag to 3 — "VBlank-OUT started" (sym_06059F54)
 *   3. Call controller_input_update — display list processing / VDP2 updates
 *   4. Adaptive frame timing: compare the OUT count against the per-state
 *      target byte in sym_06059F58[game_state].  The game state index comes
 *      from g_game_state.  When count < target the swap is skipped entirely.
 *   5. When count >= target and sym_06063F58 (display/VDP mode state) != 0:
 *        - OR bits 0+1 into the cached FBCR shadow (sym_060A4C92) then write
 *          to VDP1 FBCR (0x25D00002) — triggers framebuffer swap.
 *        - Clear the frame-ready flag (sym_060635C4) and the display mode
 *          state (sym_06063F58).
 *   6. Set phase flag to 4 — "VBlank-OUT complete" (sym_06059F54), then RTS.
 *
 * Register usage (volatile — not callee-saved):
 *   r1  = VBlank-OUT counter value / scratch
 *   r2  = various data addresses / scratch
 *   r3  = various function/data addresses / scratch
 *   r4  = zero constant for clearing flags
 *   r5  = &sym_06063F58 (display mode state, kept live across the swap block)
 *
 * Pool constants:
 *   .L_pool_vblank_out_ctr  -> sym_06059F44  (VBlank-OUT counter, long)
 *   .L_pool_phase_flag      -> sym_06059F54  (phase flag, long)
 *   .L_pool_viewport_calc   -> controller_input_update
 *   .L_pool_game_state      -> g_game_state  (current game state index, long)
 *   .L_pool_frame_targets   -> sym_06059F58  (per-state frame target table, byte[])
 *   .L_pool_display_mode    -> sym_06063F58  (display/VDP mode state, long)
 *   .L_pool_fbcr_shadow     -> sym_060A4C92  (cached FBCR value, half-word)
 *   .L_vdp1_fbcr            -> 0x25D00002   (VDP1 FBCR hardware register)
 *   .L_pool_frame_ready     -> sym_060635C4  (frame-ready flag, long)
 */

    .section .text.FUN_06007268


    .global vblank_out_handler
    .type vblank_out_handler, @function
vblank_out_handler:
    sts.l pr, @-r15                    ! save return address (PR) onto stack
    mov.l   .L_pool_vblank_out_ctr, r3 ! r3 = &vblank_out_counter (sym_06059F44)
    mov.l   .L_pool_vblank_out_ctr, r2 ! r2 = &vblank_out_counter (sym_06059F44) [address for store]
    mov.l @r3, r3                      ! r3 = current VBlank-OUT count
    add #0x1, r3                       ! r3 = count + 1
    mov.l r3, @r2                      ! vblank_out_counter++ (write back)
    mov #0x3, r3                       ! r3 = 3 (phase = VBlank-OUT started)
    mov.l   .L_pool_phase_flag, r2     ! r2 = &phase_flag (sym_06059F54)
    mov.l r3, @r2                      ! phase_flag = 3
    mov.l   .L_pool_viewport_calc, r3  ! r3 = controller_input_update function ptr
    jsr @r3                            ! call controller_input_update() — display list / VDP2 updates
    nop                                ! [delay slot]
    mov.l   .L_pool_game_state, r2     ! r2 = &game_state (g_game_state)
    mov.l   .L_pool_frame_targets, r3  ! r3 = frame_target_table base (sym_06059F58)
    mov.l   .L_pool_vblank_out_ctr, r1 ! r1 = &vblank_out_counter (sym_06059F44)
    mov.l @r2, r2                      ! r2 = current game state index
    mov.l @r1, r1                      ! r1 = current VBlank-OUT count
    add r3, r2                         ! r2 = &frame_target_table[state]
    mov.b @r2, r2                      ! r2 = per-state frame target (byte)
    extu.b r2, r2                      ! zero-extend target to 32-bit
    cmp/ge r2, r1                      ! T = (out_count >= target)
    bt      .check_swap                ! if count >= target, check framebuffer swap
    bra     .done                      ! else skip swap entirely
    nop                                ! [delay slot]
.check_swap:
    mov.l   .L_pool_display_mode, r5   ! r5 = &display_mode_state (sym_06063F58)
    mov.l @r5, r0                      ! r0 = current display/VDP mode state
    tst r0, r0                         ! test if mode state is zero
    bt      .done                      ! if mode state == 0, skip swap (nothing pending)
    mov.l   .L_pool_fbcr_shadow, r0    ! r0 = &fbcr_shadow (sym_060A4C92)
    mov.w @r0, r0                      ! r0 = cached FBCR value (half-word)
    extu.w r0, r0                      ! zero-extend to 32-bit
    or #0x3, r0                        ! set bits 0+1: manual swap enable + change mode
    extu.w r0, r0                      ! mask back to 16-bit
    mov.l   .L_vdp1_fbcr, r3          ! r3 = 0x25D00002 (VDP1 FBCR hardware register)
    mov.w r0, @r3                      ! write FBCR — triggers framebuffer swap
    mov #0x0, r4                       ! r4 = 0 (clear value)
    mov.l   .L_pool_frame_ready, r3    ! r3 = &frame_ready_flag (sym_060635C4)
    mov.l r4, @r3                      ! frame_ready = 0 (clear ready flag)
    mov.l r4, @r5                      ! display_mode_state = 0 (clear mode state)
.done:
    mov #0x4, r2                       ! r2 = 4 (phase = VBlank-OUT complete)
    mov.l   .L_pool_phase_flag, r3     ! r3 = &phase_flag (sym_06059F54)
    lds.l @r15+, pr                    ! restore return address from stack
    rts                                ! return to interrupt dispatcher
    mov.l r2, @r3                      ! [delay slot] phase_flag = 4
.L_pool_vblank_out_ctr:
    .4byte  sym_06059F44               ! VBlank-OUT counter (long)
.L_pool_phase_flag:
    .4byte  sym_06059F54               ! VBlank phase flag (1=IN, 3=OUT-start, 4=OUT-end)
.L_pool_viewport_calc:
    .4byte  controller_input_update        ! display list processing / VDP2 update function
.L_pool_game_state:
    .4byte  g_game_state               ! current game state index (long)
.L_pool_frame_targets:
    .4byte  sym_06059F58               ! per-state frame timing target table (byte[])
.L_pool_display_mode:
    .4byte  sym_06063F58               ! display/VDP mode state (long; 0 = no swap pending)
.L_pool_fbcr_shadow:
    .4byte  sym_060A4C92               ! cached FBCR value — software shadow of VDP1 FBCR
.L_vdp1_fbcr:
    .4byte  0x25D00002                  /* VDP1 FBCR — framebuffer control */
.L_pool_frame_ready:
    .4byte  sym_060635C4               ! frame-ready flag (cleared after swap)

    .global sym_060072E4
sym_060072E4:
    mov.l r15, @-r15                   ! FRT compare-match handler stub: push SP
