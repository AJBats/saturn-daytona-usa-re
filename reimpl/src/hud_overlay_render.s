/* hud_overlay_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E2B4 - 0x0601E37C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * HUD overlay render — clears the geometry output buffer, then dispatches
 * the HUD render pipeline bracketed by SMPC Reset-Disable / Reset-Enable.
 *
 * Called from geom_output_main as part of the per-frame geometry output phase.
 *
 * Flow:
 *   1. If geom_busy_flag (sym_06087080) is nonzero, skip the buffer clear.
 *   2. Otherwise, zero-fill the geom output buffer (sym_0605E068, deref'd)
 *      for course_size_table[player_index] bytes.
 *   3. Issue SMPC RESDISA (0x1A) — disable the reset button during HUD work.
 *   4. Call the HUD dispatch function (sym_06000358, deref'd) with:
 *        r4 = *sym_0605E060 (VDP1 VRAM base A)
 *        r5 = *sym_0605E064 (VDP1 VRAM base B)
 *        r6 = sym_06087086  (HUD element status array)
 *   5. BSR to hud_large_element — processes large HUD overlay elements.
 *   6. Issue SMPC RESENAB (0x19) — re-enable the reset button.
 *   7. Return.
 *
 * Key data:
 *   sym_060877D8 = current player/car index (byte)
 *   sym_0604A5C0 = course size table (4 bytes per entry, indexed by player)
 *   sym_0605E068 = geom output buffer pointer (deref'd → actual buffer)
 *   sym_06087080 = geom busy flag (byte; nonzero = busy, skip clear)
 *   sym_06000358 = HUD dispatch function pointer (deref'd → function address)
 *   sym_06087086 = HUD element status array (word per element)
 *   sym_0605E064 = VDP1 VRAM parameter B (loaded into r5 for dispatch)
 *   sym_0605E060 = VDP1 VRAM parameter A (loaded into r4 for dispatch)
 */

    .section .text.FUN_0601E2B4


    .global hud_overlay_render
    .type hud_overlay_render, @function
hud_overlay_render:
    mov.l r14, @-r15                ! save r14
    mov.l r13, @-r15                ! save r13
    mov.l r12, @-r15                ! save r12
    mov #0x0, r12                   ! r12 = 0 (zero fill value)
    mov.l r11, @-r15                ! save r11
    mov.l r10, @-r15                ! save r10
    mov.l r9, @-r15                 ! save r9
    sts.l pr, @-r15                 ! save PR (return address)
    mov.l   .L_ptr_player_index, r9 ! r9 = &player_index (sym_060877D8)
    mov.l   .L_ptr_course_size_table, r10 ! r10 = course_size_table base (sym_0604A5C0)
    mov.l   .L_ptr_geom_output_buf, r11 ! r11 = &geom_output_buf_ptr (sym_0605E068)
    mov.l   .L_smpc_sf, r13        ! r13 = SMPC SF register (0x20100063, cache-through)
    mov.l   .L_ptr_geom_busy_flag, r3 ! r3 = &geom_busy_flag (sym_06087080)
    mov.b @r3, r3                   ! r3 = geom_busy_flag byte
    extu.b r3, r3                   ! zero-extend to 32-bit
    tst r3, r3                      ! test if busy flag == 0
    bf/s    .L_smpc_resdisa_poll    ! if busy (nonzero), skip buffer clear
    mov #0x1, r14                   ! r14 = 1 (SMPC SF bit mask / constant)
    bra     .L_clear_loop_check     ! enter clear loop
    mov r12, r4                     ! r4 = 0 (byte offset into buffer)
.L_clear_store:
    mov.l @r11, r2                  ! r2 = *geom_output_buf_ptr (buffer base address)
    add r4, r2                      ! r2 = &buffer[offset]
    extu.b r12, r3                  ! r3 = 0 (zero byte to write)
    mov.b r3, @r2                   ! buffer[offset] = 0
    add #0x1, r4                    ! offset++
.L_clear_loop_check:
    mov.b @r9, r0                   ! r0 = player_index (byte)
    extu.b r0, r0                   ! zero-extend player_index
    shll2 r0                        ! r0 = player_index * 4 (table stride)
    mov.l @(r0, r10), r3            ! r3 = course_size_table[player_index] (buffer size)
    cmp/hs r3, r4                   ! offset >= buffer_size?
    bf      .L_clear_store          ! if not, continue clearing
.L_smpc_resdisa_poll:
    mov.b @r13, r2                  ! r2 = SMPC SF register value
    extu.b r2, r2                   ! zero-extend SF
    and r14, r2                     ! r2 = SF & 1 (busy bit)
    cmp/eq r14, r2                  ! SF busy bit == 1?
    bt      .L_smpc_resdisa_poll    ! spin while SMPC is busy
    extu.b r14, r2                  ! r2 = 1
    mov.b r2, @r13                  ! SF = 1 (set busy before issuing command)
    mov #0x1A, r3                   ! r3 = 0x1A (SMPC RESDISA — Reset Disable)
    mov.l   .L_smpc_comreg_ct, r2   ! r2 = SMPC COMREG (0x2010001F, cache-through)
    mov.b r3, @r2                   ! write RESDISA command to COMREG
.L_smpc_resdisa_wait:
    mov.b @r13, r2                  ! r2 = SMPC SF register value
    extu.b r2, r2                   ! zero-extend SF
    and r14, r2                     ! r2 = SF & 1 (busy bit)
    tst r2, r2                      ! SF busy bit == 0? (command complete?)
    bf      .L_smpc_resdisa_wait    ! spin until SMPC command completes
    mov.l   .L_ptr_dispatch_fn, r3  ! r3 = &dispatch_fn_ptr (sym_06000358)
    mov.l   .L_hud_status_array, r6 ! r6 = HUD element status array (sym_06087086, arg3)
    mov.l   .L_ptr_vdp1_param_b, r5 ! r5 = &VDP1 param B (sym_0605E064)
    mov.l   .L_ptr_vdp1_param_a, r4 ! r4 = &VDP1 param A (sym_0605E060)
    mov.l @r3, r3                   ! r3 = *dispatch_fn_ptr (actual function address)
    mov.l @r5, r5                   ! r5 = *VDP1_param_B (deref'd value)
    jsr @r3                         ! call HUD dispatch function
    mov.l @r4, r4                   ! (delay slot) r4 = *VDP1_param_A (deref'd value)
    .byte   0xB0, 0x2C    /* bsr 0x0601E37C (external) — hud_large_element */
    nop                             ! delay slot
.L_smpc_resenab_poll:
    mov.b @r13, r2                  ! r2 = SMPC SF register value
    extu.b r2, r2                   ! zero-extend SF
    and r14, r2                     ! r2 = SF & 1 (busy bit)
    cmp/eq r14, r2                  ! SF busy bit == 1?
    bt      .L_smpc_resenab_poll    ! spin while SMPC is busy
    extu.b r14, r2                  ! r2 = 1
    mov.b r2, @r13                  ! SF = 1 (set busy before issuing command)
    mov #0x19, r3                   ! r3 = 0x19 (SMPC RESENAB — Reset Enable)
    mov.l   .L_smpc_comreg_ct, r2   ! r2 = SMPC COMREG (0x2010001F, cache-through)
    mov.b r3, @r2                   ! write RESENAB command to COMREG
.L_smpc_resenab_wait:
    mov.b @r13, r2                  ! r2 = SMPC SF register value
    extu.b r2, r2                   ! zero-extend SF
    and r14, r2                     ! r2 = SF & 1 (busy bit)
    tst r2, r2                      ! SF busy bit == 0? (command complete?)
    bf      .L_smpc_resenab_wait    ! spin until SMPC command completes
    lds.l @r15+, pr                 ! restore PR
    mov.l @r15+, r9                 ! restore r9
    mov.l @r15+, r10                ! restore r10
    mov.l @r15+, r11                ! restore r11
    mov.l @r15+, r12                ! restore r12
    mov.l @r15+, r13                ! restore r13
    rts                             ! return
    mov.l @r15+, r14                ! (delay slot) restore r14
    .2byte  0xFFFF                  ! alignment padding
.L_ptr_player_index:
    .4byte  sym_060877D8
.L_ptr_course_size_table:
    .4byte  sym_0604A5C0
.L_ptr_geom_output_buf:
    .4byte  sym_0605E068
.L_smpc_sf:
    .4byte  0x20100063                  /* SMPC SF — status flag */
.L_ptr_geom_busy_flag:
    .4byte  sym_06087080
.L_smpc_comreg_ct:
    .4byte  0x2010001F                  /* SMPC COMREG (cache-through) */
.L_ptr_dispatch_fn:
    .4byte  sym_06000358
.L_hud_status_array:
    .4byte  sym_06087086
.L_ptr_vdp1_param_b:
    .4byte  sym_0605E064
.L_ptr_vdp1_param_a:
    .4byte  sym_0605E060
