/* evt_state_dispatch -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040C10 - 0x06040C5C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Dispatches an event state update by extracting fields from the
 * event descriptor and state pointer, calling evt_field_update to
 * enqueue the event, then polling state_field_read until completion.
 *
 * Entry: evt_state_dispatch(r4 = event_desc, r5 = state_ptr)
 *   r4 -- event descriptor struct
 *   r5 -- state pointer struct
 *
 * Flow:
 *   1. Extract callback (state_ptr[+0x10]), section_id (event_desc[+0x0C]),
 *      and event_type (event_desc[+0x04]) from the input structs.
 *   2. Call evt_field_update(state_ptr, event_type, callback, section_id).
 *   3. If evt_field_update returns non-zero (error), return 0.
 *   4. Call state_field_read to poll until event processing completes.
 *   5. If state_field_read returns non-zero (still pending), return 0.
 *   6. If both calls succeed, return 1.
 *
 * Returns: r0 = 1 if dispatch completed, 0 otherwise
 *
 * sym_06040C50: trivial stub, always returns 0.
 */

    .section .text.FUN_06040C10


    .global evt_state_dispatch
    .type evt_state_dispatch, @function
evt_state_dispatch:
    sts.l pr, @-r15                          ! save return address
    add #-0x8, r15                           ! allocate 8-byte stack frame
    mov.l r4, @(4, r15)                      ! stack[+0x04] = event_desc (r4)
    mov.l r5, @r15                           ! stack[+0x00] = state_ptr (r5)
    mov.l @(4, r15), r6                      ! r6 = event_desc
    mov.l @(16, r5), r5                      ! r5 = state_ptr[+0x10] (callback)
    mov.l @r15, r4                           ! r4 = state_ptr (reload from stack)
    mov.l   .L_pool_evt_field_update, r3     ! r3 = &evt_field_update
    mov.l @(12, r6), r6                      ! r6 = event_desc[+0x0C] (section_id)
    jsr @r3                                  ! call evt_field_update(state_ptr, event_type, callback, section_id)
    mov.l @(4, r4), r4                       ! r4 = state_ptr[+0x04] (event_type) [delay slot]
    mov r0, r4                               ! r4 = update result
    tst r4, r4                               ! result == 0? (success)
    bt      .L_update_ok                     ! if success -> proceed to poll
    add #0x8, r15                            ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return (update failed)
    mov #0x0, r0                             ! r0 = 0 (dispatch failed) [delay slot]
.L_update_ok:
    mov.l   .L_pool_state_field_read, r3     ! r3 = &state_field_read
    jsr @r3                                  ! call state_field_read (poll for completion)
    nop                                      ! delay slot
    tst r0, r0                               ! result == 0? (completed)
    bt      .L_poll_done                     ! if completed -> return success
    add #0x8, r15                            ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return (poll returned non-zero)
    mov #0x0, r0                             ! r0 = 0 (dispatch failed) [delay slot]
.L_poll_done:
    mov #0x1, r0                             ! r0 = 1 (dispatch completed successfully)
    add #0x8, r15                            ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return success
    nop                                      ! delay slot

    .global sym_06040C50
sym_06040C50:
    rts                                      ! return immediately
    mov #0x0, r0                             ! r0 = 0 (always returns zero) [delay slot]
.L_pool_evt_field_update:
    .4byte  evt_field_update                 ! -> evt_field_update function
.L_pool_state_field_read:
    .4byte  state_field_read                 ! -> state_field_read function
