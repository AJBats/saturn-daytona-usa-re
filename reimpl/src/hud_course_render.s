/* hud_course_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06011094 - 0x060111E2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Course name HUD renderer -- draws the course identifier elements on the
 * racing HUD using VDP1 sprite commands. Renders 3 groups of 2 elements
 * each (6 total), selecting course-specific sprite data from lookup tables
 * indexed by the current course type.
 *
 * Element count logic (same pattern as position_ranking_display):
 *   - If game_mode == 0x3 AND mode_flags bit 0 is set: elem_count = 3
 *   - If game_mode == 0x3 AND mode_flags bit 0 is clear: elem_count = 4
 *   - Otherwise: mask mode_flags & 3; if >= 2 then 4, else 3
 *   This selects between 3-block and 4-block VDP1 layouts.
 *
 * Each group renders two sub-elements:
 *   Sub-element A: VDP1 base from display_struct[+0xD4], num_cmds = 4
 *   Sub-element B: VDP1 base from display_struct[+0xE4], num_cmds = 8
 *
 * Sprite data sources (course_type selects entry in each table):
 *   Group 1: course_sprite_table_a[course_type] (offset +0)
 *            course_sprite_table_c[course_type] (offset +0)
 *   Group 2: course_sprite_table_a[course_type] (offset +12)
 *            course_sprite_table_c[course_type] (offset +12)
 *   Group 3: course_sprite_table_a[course_type] (offset +24)
 *            course_sprite_table_c[course_type] (offset +24)
 *
 * Between groups, transition_state is checked to decide whether to use
 * the default or alternate element count for the VDP1 block multiplier.
 *
 * Registers (preserved across calls):
 *   r8  = &course_type_b (sym_0605AD00)
 *   r9  = &transition_state (sym_0607EADC)
 *   r10 = display_struct[+0xE4] (VDP1 base B)
 *   r11 = display_struct[+0xD4] (VDP1 base A)
 *   r13 = &hud_elem_draw (sym_06028400)
 *
 * Stack layout (16 bytes allocated):
 *   [sp+0]  = current elem_count (modified between groups)
 *   [sp+4]  = block_offset (elem_count * 0x1000, cached)
 *   [sp+8]  = block_offset (for group 3)
 *   [sp+12] = &course_sprite_table_a (sym_0605AC70, cached)
 */

    .section .text.FUN_06011094


    .global hud_course_render
    .type hud_course_render, @function
hud_course_render:
    mov.l r14, @-r15                        ! save r14
    mov #0x3, r4                            ! r4 = 3 (default element count)
    mov.l r13, @-r15                        ! save r13
    mov.l r12, @-r15                        ! save r12
    mov.l r11, @-r15                        ! save r11
    mov.l r10, @-r15                        ! save r10
    mov.l r9, @-r15                         ! save r9
    mov.l r8, @-r15                         ! save r8
    sts.l pr, @-r15                         ! save return address
    add #-0x10, r15                         ! allocate 16 bytes on stack for locals
    mov.l   .L_mode_config_flags, r5        ! r5 = &mode_config_flags (sym_0607EBC8)
    mov.l   .L_game_mode_byte, r0           ! r0 = &game_mode_byte (sym_0607887F)
    mov.b @r0, r0                           ! r0 = game_mode (8-bit read)
    extu.b r0, r0                           ! zero-extend to 32-bit
    cmp/eq #0x3, r0                         ! game_mode == 0x3? (race mode)
    bf/s    .L_not_race_mode                ! if not race mode, branch to generic path
    mov r4, r14                             ! r14 = 3 (delay slot: save default count)
    mov.l @r5, r0                           ! r0 = mode_config_flags
    tst #0x1, r0                            ! test bit 0 of mode_flags
    bt      .L_race_mode_use_4              ! if bit 0 clear -> use 4 elements
    bra     .L_elem_count_chosen            ! bit 0 set -> use default (3)
    mov r14, r12                            ! r12 = 3 (delay slot)
.L_race_mode_use_4:
    bra     .L_elem_count_chosen            ! jump to common path
    mov #0x4, r12                           ! r12 = 4 elements (delay slot)
.L_not_race_mode:
    mov.l @r5, r12                          ! r12 = mode_config_flags (raw)
    mov #0x2, r3                            ! r3 = 2 (threshold)
    and r4, r12                             ! r12 = flags & 0x3 (mask low 2 bits)
    cmp/ge r3, r12                          ! masked_flags >= 2?
    bt      .L_generic_use_4                ! if so, use 4 elements
    bra     .L_elem_count_chosen            ! else use default (3)
    mov r14, r12                            ! r12 = 3 (delay slot)
.L_generic_use_4:
    mov #0x4, r12                           ! r12 = 4 elements
.L_elem_count_chosen:
    mov.l   .L_display_struct, r4           ! r4 = &display_struct (sym_06063750)
    mov.w   .L_struct_offset_a, r0          ! r0 = 0x00D4 (struct offset for VDP1 base A)
    mov.l   .L_transition_state, r9         ! r9 = &transition_state (sym_0607EADC, kept)
    mov.l @(r0, r4), r11                    ! r11 = display_struct[+0xD4] (VDP1 base A)
    add #0x10, r0                           ! r0 = 0x00E4 (struct offset for VDP1 base B)
    mov.l @(r0, r4), r10                    ! r10 = display_struct[+0xE4] (VDP1 base B)
    mov.l @r9, r0                           ! r0 = transition_state value
    tst r0, r0                              ! transition active?
    bt      .L_no_transition_g1             ! if zero -> no transition, use r12
    bra     .L_begin_group1                 ! transition active: use default r14
    mov.l r14, @r15                         ! [sp+0] = r14 = 3 (delay slot)
.L_no_transition_g1:
    mov.l r12, @r15                         ! [sp+0] = r12 (elem count from flags)
.L_begin_group1:
    mov.l   .L_fn_hud_elem_draw, r13       ! r13 = &hud_elem_draw (sym_06028400, kept)
    mov.l @r15, r7                          ! r7 = elem_count from stack
    shll8 r7                                ! r7 <<= 8
    shll2 r7                                ! r7 <<= 2
    shll2 r7                                ! r7 <<= 2  (total: elem_count * 0x1000)
    mov.l r7, @(4, r15)                     ! [sp+4] = block_offset (cached)
    add r11, r7                             ! r7 = VDP1_base_A + block_offset
    mov.w   .L_vdp1_cmd_offset_1a, r6      ! r6 = 0x0282 (VDP1 cmd table offset, group 1 elem A)
    mov.l   .L_course_type_a, r0           ! r0 = &course_type_a (sym_06078644)
    mov.l   .L_sprite_table_a, r3          ! r3 = &course_sprite_table_a (sym_0605AC70)
    mov.l @r0, r0                           ! r0 = course_type_a value
    shll2 r0                                ! r0 *= 4 (table entry stride)
    mov.l r3, @(12, r15)                    ! [sp+12] = &course_sprite_table_a (cached)
    mov.l @(r0, r3), r5                     ! r5 = sprite_table_a[course_type] (sprite data)
    jsr @r13                                ! call hud_elem_draw(4, sprite, 0x282, vdp1_base)
    mov #0x4, r4                            ! r4 = 4 (num VDP1 cmds, delay slot)
    mov.l   .L_course_type_b, r8           ! r8 = &course_type_b (sym_0605AD00, kept)
    mov.l @(4, r15), r7                     ! r7 = block_offset (reload from cache)
    mov.w   .L_vdp1_cmd_offset_1b, r6      ! r6 = 0x048C (VDP1 cmd offset, group 1 elem B)
    mov.l   .L_sprite_table_c, r3          ! r3 = &course_sprite_table_c (sym_0605AB98)
    mov.l @r8, r0                           ! r0 = course_type_b value
    add r10, r7                             ! r7 = VDP1_base_B + block_offset
    shll2 r0                                ! r0 *= 4 (table entry stride)
    mov.l r3, @r15                          ! [sp+0] = &course_sprite_table_c (temp store)
    mov.l @(r0, r3), r5                     ! r5 = sprite_table_c[course_type] (sprite data)
    jsr @r13                                ! call hud_elem_draw(8, sprite, 0x48C, vdp1_base)
    mov #0x8, r4                            ! r4 = 8 (num VDP1 cmds, delay slot)
    mov.l @r9, r0                           ! r0 = transition_state value
    cmp/eq #0x1, r0                         ! transition_state == 1?
    bt      .L_use_alt_count_g2             ! if so, use alt elem count for group 2
    bra     .L_begin_group2                 ! else use default (r14)
    mov.l r14, @(4, r15)                    ! [sp+4] = r14 = 3 (delay slot)

    .global DAT_0601112c
.L_struct_offset_a:
DAT_0601112c:
    .2byte  0x00D4                          /* display struct offset for VDP1 base A */
.L_vdp1_cmd_offset_1a:
    .2byte  0x0282                          /* VDP1 cmd offset: group 1 element A */
.L_vdp1_cmd_offset_1b:
    .2byte  0x048C                          /* VDP1 cmd offset: group 1 element B */
    .2byte  0xFFFF                          /* padding */
.L_mode_config_flags:
    .4byte  sym_0607EBC8                    /* mode configuration flags (32-bit) */
.L_game_mode_byte:
    .4byte  sym_0607887F                    /* game mode byte (0x3 = race) */
.L_display_struct:
    .4byte  sym_06063750                    /* display/object table base struct */
.L_transition_state:
    .4byte  sym_0607EADC                    /* transition state (32-bit) */
.L_fn_hud_elem_draw:
    .4byte  sym_06028400                    /* HUD element draw function */
.L_course_type_a:
    .4byte  sym_06078644                    /* course type index A (dword) */
.L_sprite_table_a:
    .4byte  sym_0605AC70                    /* course sprite table A (9 entries, 3 per course) */
.L_course_type_b:
    .4byte  sym_0605AD00                    /* course type index B (dword) */
.L_sprite_table_c:
    .4byte  sym_0605AB98                    /* course sprite table C (indexed by course_type) */
.L_use_alt_count_g2:
    mov.l r12, @(4, r15)                    ! [sp+4] = r12 (alt elem count from flags)
.L_begin_group2:
    mov.l @(4, r15), r7                     ! r7 = elem_count for group 2
    add #0x2, r7                            ! r7 += 2 (group 2 block starts 2 blocks later)
    shll8 r7                                ! r7 <<= 8
    shll2 r7                                ! r7 <<= 2
    shll2 r7                                ! r7 <<= 2  (total: (count+2) * 0x1000)
    mov.l r7, @(8, r15)                     ! [sp+8] = group 2 block_offset (cached)
    add r11, r7                             ! r7 = VDP1_base_A + group2_block_offset
    .byte   0x96, 0x4D    /* mov.w .L_vdp1_cmd_offset_2a, r6 */   ! r6 = VDP1 cmd offset, group 2 elem A
    .byte   0xD5, 0x29    /* mov.l .L_pool_sprite_table_a_2, r5 */  ! r5 = &course_sprite_table_a
    mov.l @(12, r15), r3                    ! r3 = &course_sprite_table_a (from cache)
    mov.l @r5, r5                           ! r5 = *course_sprite_table_a (course_type_a deref)
    shll2 r5                                ! r5 *= 4 (index into table)
    add r3, r5                              ! r5 = &sprite_table_a[course_type_a]
    mov.l @(12, r5), r5                     ! r5 = sprite_table_a[course_type_a + 3] (offset +12)
    jsr @r13                                ! call hud_elem_draw(4, sprite, cmd_off, vdp1_base)
    mov #0x4, r4                            ! r4 = 4 (num VDP1 cmds, delay slot)
    mov.l @(8, r15), r7                     ! r7 = group2_block_offset (reload)
    .byte   0x96, 0x44    /* mov.w .L_vdp1_cmd_offset_2b, r6 */   ! r6 = VDP1 cmd offset, group 2 elem B
    mov.l @r8, r5                           ! r5 = course_type_b value
    mov.l @r15, r3                          ! r3 = &course_sprite_table_c (from stack)
    add r10, r7                             ! r7 = VDP1_base_B + group2_block_offset
    shll2 r5                                ! r5 *= 4 (index into table)
    add r3, r5                              ! r5 = &sprite_table_c[course_type_b]
    mov.l @(12, r5), r5                     ! r5 = sprite_table_c[course_type_b + 3] (offset +12)
    jsr @r13                                ! call hud_elem_draw(8, sprite, cmd_off, vdp1_base)
    mov #0x8, r4                            ! r4 = 8 (num VDP1 cmds, delay slot)
    mov.l @r9, r0                           ! r0 = transition_state value
    cmp/eq #0x2, r0                         ! transition_state == 2?
    bt      .L_use_alt_count_g3             ! if so, use alt elem count for group 3
    bra     .L_begin_group3                 ! else use default (r14)
    mov.l r14, @(8, r15)                    ! [sp+8] = r14 = 3 (delay slot)
.L_use_alt_count_g3:
    mov.l r12, @(8, r15)                    ! [sp+8] = r12 (alt elem count from flags)
.L_begin_group3:
    mov.l @(8, r15), r7                     ! r7 = elem_count for group 3
    add #0x4, r7                            ! r7 += 4 (group 3 block starts 4 blocks later)
    shll8 r7                                ! r7 <<= 8
    shll2 r7                                ! r7 <<= 2
    shll2 r7                                ! r7 <<= 2  (total: (count+4) * 0x1000)
    mov.l r7, @(4, r15)                     ! [sp+4] = group 3 block_offset (cached)
    add r11, r7                             ! r7 = VDP1_base_A + group3_block_offset
    .byte   0x96, 0x2F    /* mov.w .L_vdp1_cmd_offset_3a, r6 */   ! r6 = VDP1 cmd offset, group 3 elem A
    .byte   0xD5, 0x19    /* mov.l .L_pool_sprite_table_a_3, r5 */  ! r5 = &course_sprite_table_a
    mov.l @(12, r15), r3                    ! r3 = &course_sprite_table_a (from cache)
    mov.l @r5, r5                           ! r5 = *course_sprite_table_a (course_type_a deref)
    shll2 r5                                ! r5 *= 4 (index into table)
    add r3, r5                              ! r5 = &sprite_table_a[course_type_a]
    mov.l @(24, r5), r5                     ! r5 = sprite_table_a[course_type_a + 6] (offset +24)
    jsr @r13                                ! call hud_elem_draw(4, sprite, cmd_off, vdp1_base)
    mov #0x4, r4                            ! r4 = 4 (num VDP1 cmds, delay slot)
    mov.l @(4, r15), r7                     ! r7 = group3_block_offset (reload)
    .byte   0x96, 0x26    /* mov.w .L_vdp1_cmd_offset_3b, r6 */   ! r6 = VDP1 cmd offset, group 3 elem B
    mov.l @r8, r5                           ! r5 = course_type_b value
    mov.l @r15, r3                          ! r3 = &course_sprite_table_c (from stack)
    add r10, r7                             ! r7 = VDP1_base_B + group3_block_offset
    shll2 r5                                ! r5 *= 4 (index into table)
    add r3, r5                              ! r5 = &sprite_table_c[course_type_b]
    mov.l @(24, r5), r5                     ! r5 = sprite_table_c[course_type_b + 6] (offset +24)
    jsr @r13                                ! call hud_elem_draw(8, sprite, cmd_off, vdp1_base)
    mov #0x8, r4                            ! r4 = 8 (num VDP1 cmds, delay slot)
    add #0x10, r15                          ! deallocate 16 bytes of locals
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r8                         ! restore r8
    mov.l @r15+, r9                         ! restore r9
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return
    mov.l @r15+, r14                        ! restore r14 (delay slot)
