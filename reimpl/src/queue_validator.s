/* queue_validator -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041128 - 0x06041180
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Validates a queued event slot before dispatching to track_boundary_check.
 *
 * Arguments:
 *   r4 = slot index (0xFF = wildcard/broadcast, bypasses slot check)
 *   r5 = expected sequence counter
 *
 * Returns:
 *   r0 = 0   success (slot validated, boundary check dispatched)
 *   r0 = -7  slot inactive (status byte != 1)
 *   r0 = -9  sequence counter mismatch
 *
 * Game state struct (base = *sym_060A5400):
 *   +0x18  = per-slot status byte array (1 = active)
 *   +0x38  = current sequence counter (long)
 *   +0x304 = validated flag (set to 1 on success)
 *   +0x308 = validated slot index (set to r4 on success)
 *
 * Calls:
 *   track_boundary_check (BSR 0x06041AA0) -- post-validation boundary handler
 */

    .section .text.FUN_06041128


    .global queue_validator
    .type queue_validator, @function
queue_validator:
    sts.l pr, @-r15                          ! save return address
    add #-0x4, r15                           ! allocate 4 bytes of stack space
    mov.w   DAT_06041174, r3                 ! r3 = 0x00FF (wildcard slot value)
    cmp/eq r3, r4                            ! is slot index == 0xFF (wildcard)?
    bt      .L_check_sequence                ! yes -> skip slot status check
    mov.l   .L_pool_state_base_ptr, r0       ! r0 = &sym_060A5400 (state base indirect ptr)
    mov.l @r0, r0                            ! r0 = *sym_060A5400 (state base address)
    add #0x18, r0                            ! r0 = &state[+0x18] (slot status array)
    mov.b @(r0, r4), r0                      ! r0 = state[+0x18 + r4] (status byte for slot)
    cmp/eq #0x1, r0                          ! is slot active (status == 1)?
    bt      .L_check_sequence               ! yes -> proceed to sequence check
    add #0x4, r15                            ! free stack space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return (slot inactive)
    mov #-0x7, r0                            ! r0 = -7 (slot not active error, delay slot)
.L_check_sequence:
    mov.l   .L_pool_state_base_ptr, r6       ! r6 = &sym_060A5400 (state base indirect ptr)
    mov.l @r6, r2                            ! r2 = state base address
    mov.l @(56, r2), r3                      ! r3 = state[+0x38] (current sequence counter)
    cmp/eq r5, r3                            ! does sequence counter match expected (r5)?
    bt      .L_validate_commit               ! yes -> commit validation
    add #0x4, r15                            ! free stack space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return (sequence mismatch)
    mov #-0x9, r0                            ! r0 = -9 (sequence mismatch error, delay slot)
.L_validate_commit:
    mov.l @r6, r3                            ! r3 = state base address
    mov #0x1, r2                             ! r2 = 1 (validated flag value)
    mov.w   .L_w_validated_flag_off, r0            ! r0 = 0x0304 (offset to validated flag)
    mov.l r2, @(r0, r3)                      ! state[+0x304] = 1 (mark slot as validated)
    mov.l @r6, r3                            ! r3 = state base address (reload)
    add #0x4, r0                             ! r0 = 0x0308 (offset to validated slot index)
    mov.l r4, @(r0, r3)                      ! state[+0x308] = r4 (store validated slot index)
    .byte   0xB4, 0x9B    /* bsr 0x06041AA0 (external) */  ! call track_boundary_check
    mov r15, r4                              ! r4 = stack pointer (arg for boundary check, delay slot)
    mov #0x0, r0                             ! r0 = 0 (success)
    add #0x4, r15                            ! free stack space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return
    nop                                      ! delay slot (padding)

    .global DAT_06041174
DAT_06041174:
    .2byte  0x00FF
.L_w_validated_flag_off:
    .2byte  0x0304                     /* [HIGH] state struct offset: validated flag (+0x304) */
    .4byte  ai_checkpoint_validate     /* (adjacent TU pool entry) */
.L_pool_state_base_ptr:
    .4byte  sym_060A5400               /* [HIGH] game state base pointer (indirect) */
