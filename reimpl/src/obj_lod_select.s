/* obj_lod_select -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036928 - 0x0603697C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Builds an 8-byte BIOS command buffer on the stack:
 *   buffer[0]   = 0x65  (command ID — LOD select / object detail level)
 *   buffer[1]   = r14   (object type, byte)
 *   buffer[2:3] = r11   (object ID / index, word)
 *   buffer[4]   = r13   (LOD level / detail flag, byte)
 *   buffer[6:7] = r12   (distance / threshold, word)
 * Calls input_proc_analog to initialize the buffer, fills parameters,
 * then calls input_proc_buttons(r4=0x0100, r5=buffer) to issue the command.
 */

    .section .text.FUN_06036928


    .global obj_lod_select
    .type obj_lod_select, @function
obj_lod_select:
    sts.l pr, @-r15                     ! save return address
    add #-0x8, r15                      ! allocate 8-byte stack buffer
    mov.l   .L_fn_input_proc_analog, r3 ! r3 = &input_proc_analog
    jsr @r3                             ! call input_proc_analog(buffer)
    mov r15, r4                         ! r4 = buffer ptr (delay slot)
    mov r15, r2                         ! r2 = buffer ptr
    mov #0x65, r3                       ! r3 = 0x65 (cmd: LOD select)
    extu.b r14, r14                     ! zero-extend r14 to byte (object type)
    extu.w r11, r11                     ! zero-extend r11 to word (object ID)
    extu.b r13, r13                     ! zero-extend r13 to byte (LOD level)
    extu.w r12, r12                     ! zero-extend r12 to word (distance)
    mov.b r3, @r2                       ! buffer[0] = 0x65 (command ID)
    mov r14, r0                         ! r0 = object type
    mov r15, r2                         ! r2 = buffer ptr
    mov r15, r3                         ! r3 = buffer ptr
    mov.b r0, @(1, r2)                  ! buffer[1] = object type (byte)
    mov r11, r0                         ! r0 = object ID
    mov.w r0, @(2, r3)                  ! buffer[2:3] = object ID (word)
    mov r15, r3                         ! r3 = buffer ptr
    mov r13, r0                         ! r0 = LOD level
    mov.b r0, @(4, r3)                  ! buffer[4] = LOD level (byte)
    mov r15, r3                         ! r3 = buffer ptr
    mov r12, r0                         ! r0 = distance
    mov.w r0, @(6, r3)                  ! buffer[6:7] = distance (word)
    mov.w   .L_cmd_param_mask, r4       ! r4 = 0x0100 (command parameter mask)
    mov.l   .L_fn_input_proc_buttons, r3 ! r3 = &input_proc_buttons
    jsr @r3                             ! call input_proc_buttons(0x0100, buffer)
    mov r15, r5                         ! r5 = buffer ptr (delay slot)
    mov r0, r4                          ! r4 = result (passed to caller via epilogue)
    add #0x8, r15                       ! free 8-byte stack buffer
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .2byte  0x0080                      /* alignment padding */
.L_cmd_param_mask:
    .2byte  0x0100                      /* [MEDIUM] command parameter mask — 0x100 (cf. 0x0080 in obj_visibility_check, 0x0200 in ai_master_update) */
.L_fn_input_proc_analog:
    .4byte  input_proc_analog           /* [HIGH] fn ptr: SMPC analog axis reader / buffer initializer */
.L_fn_input_proc_buttons:
    .4byte  input_proc_buttons          /* [HIGH] fn ptr: SMPC digital button reader / command dispatcher */
