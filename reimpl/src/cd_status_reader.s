/* cd_status_reader -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06012B58 - 0x06012BDC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Polls the CD subsystem to read APROG.BIN data into a sector buffer,
 * then validates the result via cmd_status_check.
 *
 * Retry loop: calls cmd_validate_exec (cmd_id=5) up to 5 times until
 * the return value is >2 (indicating a successful read status). On each
 * attempt the command struct at sym_06084360 is set up with:
 *   [+0x00] = 1            (command type / init flag)
 *   [+0x04] = 0x50         (sector count: 80 sectors)
 *   [+0x08] = sym_0608436C (data destination pointer)
 *
 * After the retry loop:
 *   - If status <= 2 (all retries failed): writes 1 to sym_06084AEC and returns.
 *   - If status  > 2 (read succeeded):     calls cmd_status_check(sym_060448C8)
 *       - If cmd_status_check returns < 0: writes 1 to sym_06084AEC (error flag).
 *       - If cmd_status_check returns >= 0: writes 0 to sym_06084AEC (success flag).
 *
 * Callee-saved: r10, r11, r12, r13, r14, pr
 * r10 = cmd_validate_exec (function pointer)
 * r11 = sym_06083274      (sector data buffer)
 * r12 = 0x1               (command init value / error flag value)
 * r13 = retry counter (0..4), then sym_06084AEC (status byte ptr)
 * r14 = 0x5               (retry limit)
 * r4  = last cmd_validate_exec return value (read status code)
 */

    .section .text.FUN_06012B58


    .global cd_status_reader
    .type cd_status_reader, @function
cd_status_reader:
    mov.l r14, @-r15                ! save r14 (callee-saved)
    mov.l r13, @-r15                ! save r13 (callee-saved)
    mov.l r12, @-r15                ! save r12 (callee-saved)
    mov.l r11, @-r15                ! save r11 (callee-saved)
    mov.l r10, @-r15                ! save r10 (callee-saved)
    sts.l pr, @-r15                 ! save return address
    mov.l   .L_pool_cmd_validate_exec, r10  ! r10 = &cmd_validate_exec (fn ptr)
    mov #0x1, r12                   ! r12 = 1 (command init value; also used as error flag)
    mov #0x5, r14                   ! r14 = 5 (max retry count)
    mov #-0x1, r4                   ! r4 = -1 (sentinel: initial status before first call)
    mov.l   .L_pool_cd_cmd_struct, r3       ! r3 = sym_06084360 (CD command struct ptr)
    mov.l r12, @r3                  ! cmd_struct[+0x00] = 1 (command init/type)
    mov r3, r2                      ! r2 = cmd_struct base address
    mov.l   .L_pool_cd_data_dest, r3        ! r3 = sym_0608436C (data destination ptr)
    mov.l r3, @(8, r2)              ! cmd_struct[+0x08] = sym_0608436C (data dest)
    mov #0x50, r3                   ! r3 = 0x50 = 80 (sector count)
    mov.l r3, @(4, r2)              ! cmd_struct[+0x04] = 80 (sectors to read)
    mov.l   .L_pool_cd_sector_buf, r11      ! r11 = sym_06083274 (sector data buffer, r5 arg)
    bra     .L_retry_check          ! jump into loop at counter-check (skip the loop body for first iter)
    mov #0x0, r13                   ! r13 = 0 (retry counter, delay slot)
.L_retry_loop:
    mov.l   .L_pool_cd_cmd_struct, r6       ! r6 = sym_06084360 (cmd struct ptr, 3rd arg)
    mov r11, r5                     ! r5 = sym_06083274 (sector buffer ptr, 2nd arg)
    jsr @r10                        ! call cmd_validate_exec(r4=5, r5=sector_buf, r6=cmd_struct)
    mov #0x5, r4                    ! r4 = 5 (command ID, delay slot)
    mov r0, r4                      ! r4 = return value (CD read status code)
.L_retry_check:
    add #0x1, r13                   ! ++retry_counter
    cmp/ge r14, r13                 ! T = (retry_counter >= 5)?
    bf      .L_retry_loop           ! if not done, loop back
    mov #0x2, r3                    ! r3 = 2 (threshold: status must be > 2 to succeed)
    mov.l   .L_pool_cd_status_flag, r13     ! r13 = sym_06084AEC (status byte ptr)
    cmp/gt r3, r4                   ! T = (last status > 2)?
    bt      .L_read_ok              ! if status > 2, validate via cmd_status_check
    bra     .L_return               ! all retries failed: write error flag and return
    mov.b r12, @r13                 ! sym_06084AEC = 1 (read error, delay slot)
.L_read_ok:
    mov.l   .L_pool_aprog_filename, r4      ! r4 = sym_060448C8 ("APROG.BIN" filename ptr)
    mov.l   .L_pool_cmd_status_check, r3    ! r3 = &cmd_status_check (fn ptr)
    jsr @r3                         ! call cmd_status_check(r4="APROG.BIN")
    nop                             ! delay slot
    cmp/pz r0                       ! T = (result >= 0)? (0 = OK, negative = error)
    bt      .L_status_ok            ! if cmd_status_check succeeded, mark success
    bra     .L_return               ! status check failed: write error flag and return
    mov.b r12, @r13                 ! sym_06084AEC = 1 (status error, delay slot)
.L_status_ok:
    mov #0x0, r2                    ! r2 = 0 (success flag)
    mov.b r2, @r13                  ! sym_06084AEC = 0 (read+validate succeeded)
.L_return:
    lds.l @r15+, pr                 ! restore return address
    mov.l @r15+, r10                ! restore r10
    mov.l @r15+, r11                ! restore r11
    mov.l @r15+, r12                ! restore r12
    mov.l @r15+, r13                ! restore r13
    rts                             ! return to caller
    mov.l @r15+, r14                ! restore r14 (delay slot)
    .2byte  0xFFFF                  ! padding for pool alignment
.L_pool_cmd_validate_exec:
    .4byte  cmd_validate_exec       ! fn ptr: poll-based CD command executor
.L_pool_cd_cmd_struct:
    .4byte  sym_06084360            ! CD command request struct base address
.L_pool_cd_data_dest:
    .4byte  sym_0608436C            ! CD data destination pointer (stored into cmd struct)
.L_pool_cd_sector_buf:
    .4byte  sym_06083274            ! sector data buffer address (passed as r5 to cmd_validate_exec)
.L_pool_cd_status_flag:
    .4byte  sym_06084AEC            ! byte flag: 0 = read OK, 1 = read/validate error
.L_pool_aprog_filename:
    .4byte  sym_060448C8            ! string ptr: "APROG.BIN" (CD filename for status check)
.L_pool_cmd_status_check:
    .4byte  cmd_status_check        ! fn ptr: verifies CD file read completed successfully
