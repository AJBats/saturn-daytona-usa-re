/* palette_fade_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602E61C - 0x0602E678
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Palette fade calculator — prologue and dispatch.
 *
 * Continues from scroll_render_prologue (which pushes r8-r13).
 * This function loads the car array base, reads the current palette
 * index (offset +0x08) and the target palette index (offset +0x238),
 * then dispatches based on which saved scroll parameter the target
 * matches:
 *
 *   - If target == DAT_06083264 (scroll param A): skip fade, branch
 *     to epilogue at 0x0602E78C (palette already matches).
 *   - If target == DAT_06083268 (scroll param B): begin computing
 *     color component deltas between current and target palettes,
 *     then fall through into the next TU for the fade loop.
 *   - If target matches neither: branch to alternate path at
 *     0x0602E6E8 (different fade/blend logic in next TU).
 *
 * The fade setup reads color components at struct offsets indexed
 * by the current (r9) and target (r10) palette pointers, computes
 * absolute differences, and prepares registers for the interpolation
 * loop that follows in the next TU.
 */

    .section .text.FUN_0602E61C


    .global palette_fade_calc
    .type palette_fade_calc, @function
palette_fade_calc:
    mov.l r14, @-r15                           ! save r14 (callee-saved, part of prologue chain)
    mov.l   .L_pool_car_array_base, r9         ! r9 = &car_array_base_ptr
    mov.l @r9, r9                              ! r9 = car_array_base (dereference pointer)
    mov.l   .L_pool_current_pal_offset, r0     ! r0 = 0x08 (current palette index offset)
    mov.l @(r0, r9), r7                        ! r7 = car[+0x08] (current palette index)
    mov.l   .L_pool_target_pal_offset, r0      ! r0 = 0x0238 (target palette offset)
    mov.l @(r0, r9), r10                       ! r10 = car[+0x0238] (target palette index)
    mov.l   .L_pool_scroll_param_a, r3         ! r3 = &DAT_06083264 (scroll param A)
    mov.l @r3, r3                              ! r3 = scroll_param_A value
    cmp/eq r10, r3                             ! T = (target_palette == scroll_param_A)?
    bf      .L_check_param_b                   ! if not equal, check scroll param B
    .byte   0xA0, 0xAB    /* bra 0x0602E78C (external) */  ! target matches param A — skip fade, jump to epilogue
    nop                                        ! delay slot
    .2byte  0x0000                             ! alignment padding
.L_pool_car_array_base:
    .4byte  sym_0607E944
.L_pool_current_pal_offset:
    .4byte  0x00000008
.L_pool_target_pal_offset:
    .4byte  0x00000238
.L_pool_scroll_param_a:
    .4byte  DAT_06083264
.L_check_param_b:
    mov.l   .L_pool_scroll_param_b, r3         ! r3 = &DAT_06083268 (scroll param B)
    mov.l @r3, r3                              ! r3 = scroll_param_B value
    cmp/eq r10, r3                             ! T = (target_palette == scroll_param_B)?
    bt      .L_begin_fade_calc                 ! if equal, begin computing fade deltas
    .byte   0xA0, 0x4A    /* bra 0x0602E6E8 (external) */  ! neither param matches — branch to alternate path
    nop                                        ! delay slot
.L_pool_scroll_param_b:
    .4byte  DAT_06083268
.L_begin_fade_calc:
    .byte   0xD0, 0x14    /* mov.l .L_pool_0602E6AC, r0 */ ! r0 = color component A offset (from next TU pool)
    mov.l @(r0, r10), r8                       ! r8 = target[+offset] (target color component A)
    sub r7, r8                                 ! r8 = target_color_A - current_palette_idx (delta A)
    cmp/pz r8                                  ! T = (delta_A >= 0)?
    bt      .L_delta_a_positive                ! if non-negative, skip negation
    neg r8, r8                                 ! r8 = abs(delta_A)
.L_delta_a_positive:
    .byte   0xD0, 0x12    /* mov.l .L_pool_0602E6B0, r0 */ ! r0 = color component B offset (from next TU pool)
    mov.l @(r0, r9), r3                        ! r3 = current[+offset] (current color component B)
    mov.l @(r0, r10), r5                       ! r5 = target[+offset] (target color component B)
    .byte   0xD0, 0x12    /* mov.l .L_pool_0602E6B4, r0 */ ! r0 = color component C offset (from next TU pool)
    mov.l @(r0, r9), r6                        ! r6 = current[+offset] (current color component C)
    mov.l @(r0, r10), r4                       ! r4 = target[+offset] (target color component C)
    mov.l r4, @-r15                            ! push target_color_C onto stack (save for later)
    sub r3, r5                                 ! r5 = target_B - current_B (delta B)
    mov r5, r4                                 ! r4 = delta_B (copy for abs calc)
    .byte   0xDD, 0x10    /* mov.l .L_pool_0602E6B8, r13 */ ! r13 = fade step function ptr (from next TU pool)
