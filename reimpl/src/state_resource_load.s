/* state_resource_load -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06008C14 - 0x06008C76
 * Auto-generated by tools/generate_l3_tu.py
 *
 * State handler: resource loading gate.
 *
 * state_resource_load (0x06008C14):
 *   Checks whether the geometry output pipeline is ready (via geom_output_ctrl).
 *   If not ready (r0 == 0), sets game_state = 0x1F (stall/wait) and writes
 *   display_mode = 3, then returns.
 *
 *   If ready (r0 != 0), reads the preview_camera_flag (sym_0605E0A2, byte):
 *     - If flag == 0 (normal path):
 *         Set game_state = 4 (loading complete).
 *     - If flag != 0 (preview/alternate path):
 *         Set game_state = 7 (preview resource load).
 *
 *   In both ready cases, clears preview_camera_flag to 0 and writes
 *   display_mode = 3 before returning.
 *
 * Data references:
 *   sym_0605AD10 = game_state_dispatch (32-bit, controls game flow)
 *   sym_0605E0A2 = preview_camera_flag (byte, set by preview_camera_path)
 *   sym_0605A016 = display_mode (16-bit, fb resolution mode selector)
 *
 * Pool entries shared with state_memory_route (cross-TU pool references):
 *   .L_pool_06008CB4 = &preview_camera_flag (sym_0605E0A2)
 *   .L_pool_06008CB8 = &display_mode (sym_0605A016)
 */

    .section .text.FUN_06008C14


    .global state_resource_load
    .type state_resource_load, @function
state_resource_load:
    mov.l r14, @-r15                      ! save r14 to stack (callee-saved)
    sts.l pr, @-r15                       ! save return address to stack
    mov.l   .L_pool_game_state, r14       ! r14 = &game_state_dispatch (sym_0605AD10)
    mov.l   .L_pool_fn_geom_output, r3    ! r3 = &geom_output_ctrl
    jsr @r3                               ! call geom_output_ctrl â€” check geometry pipeline
    nop                                   ! delay slot
    tst r0, r0                            ! test return value: 0 = not ready
    bt      .L_not_ready                  ! if not ready, branch to stall path
    mov.l   .L_pool_preview_flag, r0      ! r0 = &preview_camera_flag (sym_0605E0A2)
    mov.b @r0, r0                         ! r0 = preview_camera_flag value (byte)
    extu.b r0, r0                         ! zero-extend byte to 32-bit
    tst r0, r0                            ! test if preview flag == 0
    bf      .L_preview_active             ! if flag != 0, take preview path (state 7)
    mov #0x4, r3                          ! r3 = 4 (normal loading-complete state)
    mov.l r3, @r14                        ! game_state_dispatch = 4
    bra     .L_clear_flag                 ! skip preview path, go to flag clear
    nop                                   ! delay slot
    .2byte  0xFFFF
.L_pool_game_state:
    .4byte  sym_0605AD10
    .4byte  disc_course_data_load
    .4byte  sym_06026CE0
    .4byte  sym_06059F44
    .4byte  sym_0605A016
    .4byte  disc_load_complete_check
.L_pool_fn_geom_output:
    .4byte  geom_output_ctrl
.L_pool_preview_flag:
    .4byte  sym_0605E0A2
.L_preview_active:
    mov #0x7, r2                          ! r2 = 7 (preview resource-load state)
    mov.l r2, @r14                        ! game_state_dispatch = 7
.L_clear_flag:
    mov #0x0, r3                          ! r3 = 0 (clear value)
    .byte   0xD2, 0x15    /* mov.l .L_pool_06008CB4, r2 */  ! r2 = &preview_camera_flag (sym_0605E0A2, cross-TU pool)
    mov.b r3, @r2                         ! preview_camera_flag = 0
    bra     .L_set_display_mode           ! jump to common exit path
    nop                                   ! delay slot
.L_not_ready:
    mov #0x1F, r2                         ! r2 = 0x1F (stall/wait state)
    mov.l r2, @r14                        ! game_state_dispatch = 0x1F
.L_set_display_mode:
    mov #0x3, r3                          ! r3 = 3 (display mode value)
    .byte   0xD2, 0x12    /* mov.l .L_pool_06008CB8, r2 */  ! r2 = &display_mode (sym_0605A016, cross-TU pool)
    mov.w r3, @r2                         ! display_mode = 3 (16-bit write)
    lds.l @r15+, pr                       ! restore return address from stack
    rts                                   ! return to caller
    mov.l @r15+, r14                      ! restore r14 from stack (delay slot)
