/* cmd_queue_process -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603AEE8 - 0x0603AF94
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Command queue entry processor.
 *
 * Validates a queue index, allocates a buffer slot, computes the byte
 * offset for the entry (using 12-byte or 24-byte stride depending on
 * queue mode), and writes the entry via save_field_write.
 *
 * Args:
 *   r4 = queue entry index
 *
 * Returns:
 *   r0 = result from save_field_write (nonzero on success), or 0 on error
 *
 * Error codes reported via save_checksum_calc:
 *   -0xA  (-10)  = index out of range or write failed
 *   -0x13 (-19)  = buffer slot allocation failed
 *    0x0         = success
 *
 * Calls:
 *   0x0603B81E  = buffer slot allocator (in sys_timer_config TU)
 *   0x0603B93C  = save_checksum_calc (set status/error code)
 *   0x0603BA2C  = save_field_write (write entry to queue)
 *   sym_0603F1E0 = index_mul12(idx, base) → idx*12 + base
 *   sym_0603F1F0 = index_mul24(idx, base) → idx*24 + base
 */

    .section .text.FUN_0603AEE8


    .global cmd_queue_process
    .type cmd_queue_process, @function
cmd_queue_process:
    mov.l r14, @-r15                    ! save r14
    mov.l r13, @-r15                    ! save r13
    mov.l r12, @-r15                    ! save r12
    sts.l pr, @-r15                     ! save return address
    mov.l   .L_pool_state_ptr, r14      ! r14 = &sym_060A4D14 (global state pointer)
    mov.w   .L_wpool_off_active_count, r0 ! r0 = 0x00A0 (offset to active count field)
    mov.l @r14, r3                      ! r3 = state struct base pointer
    mov.l @(r0, r3), r0                 ! r0 = struct[0xA0] (queue active count)
    tst r0, r0                          ! is active count zero?
    bt/s    .L_alloc_entry              ! if zero, skip index validation → allocate
    mov r4, r13                         ! r13 = index parameter (delay slot, always exec)
    cmp/pz r13                          ! is index >= 0?
    bf      .L_error_bad_index          ! if negative, report error
    mov.l @r14, r2                      ! r2 = state struct base pointer
    mov.w   DAT_0603af72, r0            ! r0 = 0x00A4 (offset to queue capacity field)
    mov.l @(r0, r2), r3                 ! r3 = struct[0xA4] (queue capacity)
    cmp/ge r3, r13                      ! is index >= capacity?
    bf      .L_alloc_entry              ! if index < capacity, proceed to allocate
.L_error_bad_index:
    .byte   0xB5, 0x16    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc
    mov #-0xA, r4                       ! error code = -0xA (index out of range)
    bra     .L_return_zero              ! jump to epilogue
    mov #0x0, r0                        ! return value = 0 (delay slot)
.L_alloc_entry:
    .byte   0xB4, 0x83    /* bsr 0x0603B81E (external) */  ! call buffer slot allocator
    nop                                 ! delay slot
    mov r0, r12                         ! r12 = allocated buffer handle
    tst r12, r12                        ! did allocation succeed?
    bf      .L_check_active             ! if nonzero (success), check queue state
    .byte   0xB5, 0x0D    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc
    mov #-0x13, r4                      ! error code = -0x13 (alloc failed)
    bra     .L_return_zero              ! jump to epilogue
    mov #0x0, r0                        ! return value = 0 (delay slot)
.L_check_active:
    mov.l @r14, r2                      ! r2 = state struct base pointer
    mov.w   .L_wpool_off_active_count, r0 ! r0 = 0x00A0 (offset to active count)
    mov.l @(r0, r2), r0                 ! r0 = struct[0xA0] (queue active count)
    tst r0, r0                          ! is active count zero?
    bf      .L_has_entries              ! if nonzero, compute entry offset
    bra     .L_submit_entry             ! queue is empty, skip offset calc
    mov #0x0, r5                        ! offset = 0 (delay slot)
.L_has_entries:
    mov.l @r14, r2                      ! r2 = state struct base pointer
    mov.w   .L_wpool_off_mode_flag, r0  ! r0 = 0x0098 (offset to mode flag)
    mov.l @(r0, r2), r0                 ! r0 = struct[0x98] (queue mode: 0=narrow, else=wide)
    tst r0, r0                          ! is mode zero (narrow/12-byte entries)?
    bf      .L_wide_mode                ! if nonzero, use 24-byte stride
    mov.l @r14, r5                      ! r5 = state struct base pointer
    mov.w   .L_wpool_off_active_count, r0 ! r0 = 0x00A0
    mov.l   .L_pool_index_mul12, r3     ! r3 = &index_mul12 function
    mov.l @(r0, r5), r5                 ! r5 = struct[0xA0] (active count as base offset)
    jsr @r3                             ! call index_mul12(r4=index, r5=active_count)
    mov r13, r4                         ! r4 = index (delay slot)
    bra     .L_store_offset             ! skip wide path
    nop                                 ! delay slot
.L_wide_mode:
    mov.l @r14, r5                      ! r5 = state struct base pointer
    mov.w   .L_wpool_off_active_count, r0 ! r0 = 0x00A0
    mov.l   .L_pool_index_mul24, r3     ! r3 = &index_mul24 function
    mov.l @(r0, r5), r5                 ! r5 = struct[0xA0] (active count as base offset)
    jsr @r3                             ! call index_mul24(r4=index, r5=active_count)
    mov r13, r4                         ! r4 = index (delay slot)
.L_store_offset:
    mov r0, r5                          ! r5 = computed byte offset for entry
.L_submit_entry:
    mov r13, r6                         ! r6 = index (3rd arg to save_field_write)
    .byte   0xB5, 0x65    /* bsr 0x0603BA2C (external) */  ! call save_field_write(buf, offset, index)
    mov r12, r4                         ! r4 = allocated buffer handle (delay slot)
    mov r0, r14                         ! r14 = write result
    tst r14, r14                        ! did write succeed?
    bf      .L_write_ok                 ! if nonzero, success
    .byte   0xB4, 0xE8    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc
    mov #-0xA, r4                       ! error code = -0xA (write failed)
    bra     .L_return_result            ! jump to epilogue
    nop                                 ! delay slot
.L_wpool_off_active_count:
    .2byte  0x00A0

    .global DAT_0603af72
DAT_0603af72:
    .2byte  0x00A4
.L_wpool_off_mode_flag:
    .2byte  0x0098
    .2byte  0xFFFF
.L_pool_state_ptr:
    .4byte  sym_060A4D14
.L_pool_index_mul12:
    .4byte  sym_0603F1E0
.L_pool_index_mul24:
    .4byte  sym_0603F1F0
.L_write_ok:
    .byte   0xB4, 0xDA    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc
    mov #0x0, r4                        ! error code = 0 (success)
.L_return_result:
    mov r14, r0                         ! r0 = write result (return value)
.L_return_zero:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! restore r14 (delay slot)
