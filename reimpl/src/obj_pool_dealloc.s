/* obj_pool_dealloc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06020284 - 0x06020330
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Race start object pool selector — reads button input flags and updates
 * a pool selection counter (lap_init_counter) and animation state bytes.
 *
 * Steps:
 *   1. Allocate 8 bytes on stack; copy 4 bytes from sym_0605F526 (pool
 *      data table) into stack+4 using memcpy_byte.
 *   2. Read button flags word at sym_06063D98+2.
 *      - Bit 0x8000 set (e.g. up/right): increment lap_init_counter,
 *        clamped to max 0x19 (25 entries).
 *      - Bit 0x4000 set (e.g. down/left): decrement lap_init_counter,
 *        clamped to min 0.
 *      - Bit 0x0200 set: read the byte at pool_data[lap_init_counter]
 *        from the stack copy; if it equals anim_state_A (sym_06087826),
 *        increment anim_state_A.
 *   3. If anim_state_A (sym_06087826) == 4: set anim_state_B
 *      (sym_06087824) = 1 (signals pool selection complete).
 *
 * Registers on entry: (none required — reads globals)
 * Calls: memcpy_byte (sym_06035228)
 */

    .section .text.FUN_06020284


    .global obj_pool_dealloc
    .type obj_pool_dealloc, @function
obj_pool_dealloc:
    sts.l pr, @-r15                      ! save return address
    add #-0x8, r15                       ! allocate 8 bytes on stack
    mov r15, r7                          ! r7 = stack base (dst for memcpy)
    mov r15, r1                          ! r1 = stack base (will become dst+4)
    mov.l   .L_pool_obj_data_src, r2     ! r2 = &pool_data_table (sym_0605F526)
    mov.l   .L_pool_input_state, r6      ! r6 = &input_state struct (sym_06063D98)
    mov.l   .L_pool_anim_state_a, r5     ! r5 = &anim_state_A (sym_06087826)
    mov.l   .L_pool_lap_counter, r4      ! r4 = &lap_init_counter (sym_06087825)
    mov.l   .L_pool_memcpy_byte, r3      ! r3 = memcpy_byte function (sym_06035228)
    add #0x4, r7                         ! r7 = stack+4 (memcpy dst)
    add #0x4, r1                         ! r1 = stack+4 (memcpy dst, matches r7)
    jsr @r3                              ! call memcpy_byte(r0=4, r1=dst, r2=src)
    mov #0x4, r0                         ! r0 = 4 bytes to copy (delay slot)
    mov.w @(2, r6), r0                   ! r0 = button flags word (input_state+2)
    mov.l   .L_fp_half, r3              ! r3 = 0x00008000 (bit mask for flag check)
    mov r0, r2                           ! r2 = button flags copy
    extu.w r2, r2                        ! zero-extend flags to 32-bit
    and r3, r2                           ! r2 &= 0x8000 (isolate bit 15)
    tst r2, r2                           ! test: bit 0x8000 clear?
    bt      _no_increment                ! if bit 0x8000 not set: skip increment
    mov.b @r4, r3                        ! r3 = lap_init_counter (byte)
    add #0x1, r3                         ! r3++ (increment counter)
    mov.b r3, @r4                        ! lap_init_counter = r3
    mov.b @r4, r2                        ! r2 = updated lap_init_counter
    mov #0x19, r3                        ! r3 = 25 (maximum counter value)
    cmp/ge r3, r2                        ! test: counter >= 25?
    bf      _no_increment                ! if counter < 25: skip clamp
    mov #0x19, r3                        ! r3 = 25 (clamp value)
    mov.b r3, @r4                        ! lap_init_counter = 25 (clamp to max)
_no_increment:
    mov.w @(2, r6), r0                   ! r0 = button flags word (re-read)
    mov.w   .L_wpool_mask_decrement, r3  ! r3 = 0x4000 (decrement button mask)
    mov r0, r2                           ! r2 = button flags copy
    extu.w r2, r2                        ! zero-extend flags to 32-bit
    and r3, r2                           ! r2 &= 0x4000 (isolate bit 14)
    tst r2, r2                           ! test: bit 0x4000 clear?
    bt      _no_decrement                ! if bit 0x4000 not set: skip decrement
    mov.b @r4, r3                        ! r3 = lap_init_counter (byte)
    add #-0x1, r3                        ! r3-- (decrement counter)
    mov.b r3, @r4                        ! lap_init_counter = r3
    mov.b @r4, r2                        ! r2 = updated lap_init_counter
    cmp/pl r2                            ! test: counter > 0?
    bt      _no_decrement                ! if counter > 0: skip clamp
    mov #0x0, r2                         ! r2 = 0 (minimum counter value)
    mov.b r2, @r4                        ! lap_init_counter = 0 (clamp to min)
_no_decrement:
    mov.w @(2, r6), r0                   ! r0 = button flags word (re-read)
    mov.w   .L_wpool_mask_confirm, r2    ! r2 = 0x0200 (confirm/select button mask)
    mov r0, r3                           ! r3 = button flags copy
    extu.w r3, r3                        ! zero-extend flags to 32-bit
    and r2, r3                           ! r3 &= 0x0200 (isolate bit 9)
    tst r3, r3                           ! test: bit 0x0200 clear?
    bt      _no_confirm                  ! if bit 0x0200 not set: skip confirm
    mov.b @r4, r3                        ! r3 = lap_init_counter (pool index)
    mov.b @r5, r0                        ! r0 = anim_state_A (byte offset)
    mov.b @(r0, r7), r2                  ! r2 = pool_data[anim_state_A] (from stack copy)
    extu.b r2, r2                        ! zero-extend pool data byte
    cmp/eq r2, r3                        ! test: pool_data[anim_state_A] == lap_init_counter?
    bf      _no_confirm                  ! if not equal: skip state advance
    mov.b @r5, r2                        ! r2 = anim_state_A (current value)
    add #0x1, r2                         ! r2++ (advance animation state)
    mov.b r2, @r5                        ! anim_state_A = r2
_no_confirm:
    mov.b @r5, r0                        ! r0 = anim_state_A (byte)
    cmp/eq #0x4, r0                      ! test: anim_state_A == 4 (all slots confirmed)?
    bf      _not_complete                ! if not 4: pool selection not yet complete
    mov #0x1, r2                         ! r2 = 1 (completion flag)
    mov.l   .L_pool_anim_state_b, r3     ! r3 = &anim_state_B (sym_06087824)
    mov.b r2, @r3                        ! anim_state_B = 1 (signal selection complete)
_not_complete:
    add #0x8, r15                        ! deallocate stack frame
    lds.l @r15+, pr                      ! restore return address
    rts                                  ! return to caller
    nop                                  ! delay slot
.L_wpool_mask_decrement:
    .2byte  0x4000                       /* bit 14: decrement button flag */
.L_wpool_mask_confirm:
    .2byte  0x0200                       /* bit 9: confirm/select button flag */
.L_pool_input_state:
    .4byte  sym_06063D98                 /* &input_state struct (+2 = button flags) */
.L_pool_anim_state_a:
    .4byte  sym_06087826                 /* &anim_state_A byte (pool slot index) */
.L_pool_lap_counter:
    .4byte  sym_06087825                 /* &lap_init_counter byte (0..25) */
.L_pool_obj_data_src:
    .4byte  sym_0605F526                 /* &pool_data_table (4 bytes, src for copy) */
.L_pool_memcpy_byte:
    .4byte  sym_06035228                 /* memcpy_byte(r0=count, r1=dst, r2=src) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_anim_state_b:
    .4byte  sym_06087824                 /* &anim_state_B byte (completion flag) */
