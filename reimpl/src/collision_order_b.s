/* collision_order_b -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060316D0 - 0x06031A34
 * Auto-generated by tools/generate_l3_tu.py
 *
 * ==========================================================================
 * Car-Car Collision Response System (Elastic Impulse)
 * ==========================================================================
 *
 * Called from car_collision proximity detection (FUN_0600A914) when two cars
 * are within Manhattan distance threshold. Applies physics-based elastic
 * collision impulse in the XZ plane.
 *
 * FUNCTIONS:
 *   collision_impulse (0x060316D0)
 *       Main body of collision response. Determines car ordering by Y
 *       position, then dispatches to one of two mirrored code paths.
 *       Entry point for the register-save wrapper sym_060316C4 (in the
 *       preceding TU, position_lap_display.s), which saves r8-r13 and
 *       falls through here.
 *       Args: r4 = car_A ptr, r5 = car_B ptr, r6 = collision parameter
 *
 *   collision_order_a (0x06031700)
 *       First ordering path — used when car_A.Y > car_B.Y (A is above B).
 *       Computes atan2 of displacement, looks up collision force from table,
 *       applies Y momentum transfer and XZ impulse via sin/cos.
 *
 *   collision_order_b (0x06031898)
 *       Second ordering path — used when car_A.Y <= car_B.Y (A is below B).
 *       Mirror of collision_order_a with r14/r13 roles swapped in some
 *       operations. Both cars receive collision flags (not just one).
 *
 *   sym_06031A24 (0x06031A24)
 *       4-byte data word (padding/unknown).
 *
 *   sym_06031A28 (0x06031A28)
 *       Callee-save register push fragment (r8-r13). Identical pattern to
 *       sym_060316C4. This is a register-save wrapper for the next TU.
 *
 * CAR STRUCT OFFSETS:
 *   +0x00  flags     (bit 27 = 0x08000000 = collision occurred)
 *   +0x0C  Y pos     (vertical — determines car ordering)
 *   +0x10  X pos     (horizontal)
 *   +0x18  Z pos     (depth)
 *   +0x20  heading   (primary rotation around Y axis)
 *   +0x28  heading2  (secondary heading angle)
 *   +0x38  X backup  (pre-collision X saved for rollback)
 *   +0x3C  Z backup  (pre-collision Z saved for rollback)
 *
 * PHYSICS MODEL:
 *   Elastic collision in the XZ plane. Force applied along the line
 *   connecting car centers. Magnitude from a lookup table indexed by
 *   heading difference. Equal and opposite forces (Newton's 3rd law)
 *   via 180-degree rotation of impulse angle.
 *
 * CALL CHAIN:
 *   car_collision detection → sym_060316C4 (reg save) → collision_impulse
 *     → atan2 (collision angle from dx/dz)
 *     → cos_lookup / sin_lookup (impulse decomposition)
 *     → force table @ sym_0605BCC8 (heading-dependent collision force)
 *
 * REGISTER ALLOCATION (after ordering):
 *   r14 = car_A ptr (higher Y car in path A, lower in path B)
 *   r13 = car_B ptr (lower Y car in path A, higher in path B)
 *   r12 = collision parameter / force from table
 *   r10 = collision angle (negated atan2 result, sign-extended 16-bit)
 *   r9  = force magnitude for impulse
 *   r8  = cos(angle) result for Z impulse
 *   r11 = temp for xtrct (64-bit fixed-point multiply extraction)
 */

    .section .text.FUN_060316D0


    .global collision_impulse
    .type collision_impulse, @function
collision_impulse:
    mov.l r14, @-r15            ! save r14 (callee-saved)
    sts.l pr, @-r15             ! save return address
    mov r4, r14                 ! r14 = car_A ptr
    mov r5, r13                 ! r13 = car_B ptr
    mov r6, r12                 ! r12 = collision parameter (force multiplier)
    /* --- Step 1: determine car ordering by Y position --- */
    mov.l @(12, r14), r1       ! r1 = car_A->Y
    mov.l @(12, r13), r2       ! r2 = car_B->Y
    cmp/gt r2, r1              ! car_A.Y > car_B.Y ?
    bt      .L_a_above_b       ! yes: A is above B -> first path
    /* A is below or equal to B: load positions for second path (swapped roles) */
    mov.l @(16, r14), r8       ! r8 = car_A->X (lower car X)
    mov.l @(24, r14), r9       ! r9 = car_A->Z (lower car Z)
    mov.l @(16, r13), r6       ! r6 = car_B->X (higher car X)
    bra     .L_second_path_entry ! -> second ordering path
    mov.l @(24, r13), r7       ! r7 = car_B->Z (higher car Z) [delay slot]
.L_a_above_b:
    /* A is above B: normal ordering */
    mov.l @(16, r14), r6       ! r6 = car_A->X (higher car X)
    mov.l @(24, r14), r7       ! r7 = car_A->Z (higher car Z)
    mov.l @(16, r13), r8       ! r8 = car_B->X (lower car X)
    mov.l @(24, r13), r9       ! r9 = car_B->Z (lower car Z)
    /* --- Step 2: compute collision angle --- */
    mov.l r0, @-r15            ! save r0 on stack
    mov r8, r4                 ! r4 = lower.X
    sub r6, r4                 ! r4 = dx = lower.X - higher.X
    mov r9, r5                 ! r5 = lower.Z
    sub r7, r5                 ! r5 = dz = lower.Z - higher.Z
    mov.l   .L_pool_atan2_a, r0 ! r0 = &atan2 function

    .global collision_order_a
    .type collision_order_a, @function
collision_order_a:
    /* Call atan2(dz, dx) to get collision angle */
    sts.l pr, @-r15             ! save PR (nested call)
    jsr @r0                     ! call atan2(r4=dx, r5=dz)
    nop                         ! delay slot
    lds.l @r15+, pr             ! restore PR
    neg r0, r10                 ! r10 = -atan2_result
    exts.w r10, r10             ! sign-extend 16-bit angle to 32-bit
    mov.l @r15+, r0             ! restore saved r0
    /* --- Step 3: heading comparison / force table lookup --- */
    mov.l @(32, r14), r1       ! r1 = car_A->heading
    mov.w   DAT_06031750, r4   ! r4 = 0x8000 (half-circle threshold)
    extu.w r4, r4              ! zero-extend to 32-bit
    sub r10, r1                ! r1 = heading_A - collision_angle
    extu.w r1, r1              ! unsigned 16-bit wrap
    cmp/gt r1, r4              ! heading_diff_A < 0x8000 ?
    bt/s    .L_a_heading_ok    ! yes: heading within threshold
    mov.l @(32, r13), r2       ! r2 = car_B->heading [delay slot]
    sub r4, r1                 ! reduce by half-circle (wrap to other half)
.L_a_heading_ok:
    mov.w   DAT_06031750, r4   ! r4 = 0x8000 (half-circle threshold)
    sub r10, r2                ! r2 = heading_B - collision_angle
    extu.w r4, r4              ! zero-extend to 32-bit
    extu.w r2, r2              ! unsigned 16-bit wrap
    cmp/gt r2, r4              ! heading_diff_B < 0x8000 ?
    bt/s    .L_headings_indexed_a ! yes: both headings OK
    shlr8 r1                   ! r1 >>= 8 (table index step 1) [delay slot]
    sub r4, r2                 ! reduce by half-circle
.L_headings_indexed_a:
    /* Convert heading differences to force table indices */
    shlr r1                    ! r1 >>= 1 (total: >>9 from 16-bit angle)
    shll2 r1                   ! r1 <<= 2 (word index -> byte offset)
    shlr8 r2                   ! r2 >>= 8 (table index step 1)
    shlr r2                    ! r2 >>= 1 (total: >>9)
    shll2 r2                   ! r2 <<= 2 (word index -> byte offset)
    mov.l   .L_pool_force_table_a, r3 ! r3 = collision force table base
    add r3, r1                 ! r1 = &table[heading_diff_A]
    add r3, r2                 ! r2 = &table[heading_diff_B]
    mov.l @r1, r4              ! r4 = force_A = table[heading_diff_A]
    sub r12, r4                ! r4 -= collision_param (adjust force)
    mov.l @r2, r12             ! r12 = force_B = table[heading_diff_B]
    add r12, r4                ! r4 = force_A - param + force_B (net force)
    cmp/pl r4                  ! net force > 0 ?
    bt      .L_force_positive_a ! yes: apply collision
    bra     .L_epilogue        ! no force -> skip collision entirely
    nop                        ! delay slot

    .global DAT_06031750
DAT_06031750:
    .2byte  0x8000              /* half-circle angle constant (180 deg in 16-bit) */
    .2byte  0x0000              /* alignment padding */
.L_pool_atan2_a:
    .4byte  atan2               /* atan2 function ptr */
.L_pool_force_table_a:
    .4byte  sym_0605BCC8        /* collision force lookup table base */
.L_force_positive_a:
    /* --- Step 4: secondary heading angle range check --- */
    mov.l @(40, r14), r1       ! r1 = car_A->heading2
    mov.l @(40, r13), r2       ! r2 = car_B->heading2
    sub r2, r1                 ! r1 = heading2_diff = A.heading2 - B.heading2
    extu.w r1, r1              ! unsigned 16-bit wrap
    mov.w   DAT_0603178c, r3   ! r3 = 0x4000 (quarter-circle range)
    cmp/ge r1, r3              ! heading2_diff <= quarter-circle ?
    bt      .L_in_angle_range_a ! yes: within normal range
    /* Check extended range (3x quarter-circle) */
    mov r3, r2                 ! r2 = 0x4000
    shll r2                    ! r2 = 0x8000 (2x threshold)
    add r2, r3                 ! r3 = 0xC000 (3x threshold)
    cmp/ge r3, r1              ! heading2_diff >= 3x threshold ?
    bt      .L_in_angle_range_a ! yes: in complementary range (wraps around)
    /* Out of angle range: check combined height */
    mov.l @(12, r14), r1      ! r1 = car_A->Y
    mov.l @(12, r13), r3      ! r3 = car_B->Y
    mov.l   .L_pool_height_thresh_a, r2 ! r2 = 0x0001638E (height threshold ~91K)
    add r3, r1                 ! r1 = combined_Y = A.Y + B.Y
    cmp/ge r1, r2              ! combined_Y <= threshold ?
    bt      .L_apply_xz_impulse_a ! yes: skip flag, go to XZ impulse
    /* Combined height exceeds threshold: set collision flag on car_B only */
    mov.l @(0, r13), r0       ! r0 = car_B->flags
    mov.l   .L_pool_collision_flag_a, r3 ! r3 = 0x08000000 (COLLISION_BIT)
    or r3, r0                  ! set bit 27
    mov.l r0, @(0, r13)       ! store car_B->flags |= COLLISION_BIT
    bra     .L_apply_xz_impulse_a ! -> apply XZ impulse (skip Y transfer)
    nop                        ! delay slot

    .global DAT_0603178c
DAT_0603178c:
    .2byte  0x4000              /* quarter-circle angle constant (90 deg in 16-bit) */
    .2byte  0x0000              /* alignment padding */
.L_pool_height_thresh_a:
    .4byte  0x0001638E          /* height threshold (~91,022 fixed-point) */
.L_pool_collision_flag_a:
    .4byte  0x08000000          /* COLLISION_BIT (bit 27 of car flags) */
.L_in_angle_range_a:
    /* Within angle range: check height difference for collision flag */
    mov.l @(12, r14), r1      ! r1 = car_A->Y
    mov.l @(12, r13), r3      ! r3 = car_B->Y
    mov.l   .L_pool_height_thresh_b, r2 ! r2 = 0x0001638E (height threshold)
    sub r3, r1                 ! r1 = height_diff = A.Y - B.Y
    cmp/ge r1, r2              ! height_diff <= threshold ?
    bt      .L_check_sec_heading_a ! yes: no flag needed, check secondary heading
    /* Height diff exceeds threshold: set collision flag on car_B */
    mov.l @(0, r13), r0       ! r0 = car_B->flags
    mov.l   .L_pool_collision_flag_b, r3 ! r3 = 0x08000000 (COLLISION_BIT)
    or r3, r0                  ! set bit 27
    mov.l r0, @(0, r13)       ! store car_B->flags |= COLLISION_BIT
.L_check_sec_heading_a:
    /* --- Step 5: check secondary heading angle for Y impulse eligibility --- */
    mov.l @(40, r14), r3      ! r3 = car_A->heading2
    sub r10, r3                ! r3 = heading2_A - collision_angle
    mov.w   DAT_060317c6, r2  ! r2 = 0x4000 (quarter-circle range)
    extu.w r3, r3              ! unsigned 16-bit wrap
    cmp/ge r3, r2              ! sec_angle <= quarter-circle ?
    bt      .L_apply_y_impulse_a ! yes: apply Y momentum transfer
    /* Check extended range (3x quarter-circle) */
    mov r2, r1                 ! r1 = 0x4000
    shll r1                    ! r1 = 0x8000 (2x threshold)
    add r1, r2                 ! r2 = 0xC000 (3x threshold)
    cmp/ge r2, r3              ! sec_angle >= 3x threshold ?
    bt      .L_apply_y_impulse_a ! yes: in complementary range
    bra     .L_apply_xz_impulse_a ! out of range: skip Y impulse
    nop                        ! delay slot

    .global DAT_060317c6
DAT_060317c6:
    .2byte  0x4000              /* quarter-circle angle constant */
.L_pool_height_thresh_b:
    .4byte  0x0001638E          /* height threshold (~91,022 fixed-point) */
.L_pool_collision_flag_b:
    .4byte  0x08000000          /* COLLISION_BIT (bit 27 of car flags) */
.L_apply_y_impulse_a:
    /* --- Step 5b: apply Y-axis momentum transfer --- */
    mov.l r4, @-r15            ! save net force on stack
    mov.l @(32, r14), r4      ! r4 = car_A->heading
    mov.l r4, @(32, r13)      ! car_B->heading = car_A->heading (copy heading)
    mov r3, r4                 ! r4 = sec_angle (for cos_lookup arg)
    mov.l   .L_pool_cos_lookup_a, r0 ! r0 = &cos_lookup
    jsr @r0                    ! r0 = cos_lookup(sec_angle)
    nop                        ! delay slot
    /* Compute Y position transfer: dY * cos(sec_angle) */
    mov.l @(12, r14), r1      ! r1 = car_A->Y
    mov.l @(12, r13), r2      ! r2 = car_B->Y
    sub r2, r1                 ! r1 = dY = A.Y - B.Y
    dmuls.l r0, r1             ! MACH:MACL = cos(angle) * dY (64-bit)
    sts mach, r0               ! r0 = high 32 bits
    sts macl, r1               ! r1 = low 32 bits
    xtrct r0, r1               ! r1 = fixed-point Y transfer amount
    add r1, r2                 ! r2 = B.Y + Y_transfer
    mov.l r2, @(12, r13)      ! store car_B->Y (updated)
    mov.l @(12, r14), r4      ! r4 = car_A->Y (re-read)
    sub r1, r4                 ! r4 = A.Y - Y_transfer (Newton's 3rd law)
    mov.l r4, @(12, r14)      ! store car_A->Y (updated)
    mov.l @r15+, r4            ! restore net force
.L_apply_xz_impulse_a:
    /* --- Step 6: apply XZ position impulse to car_B --- */
    shlr r4                    ! r4 = net_force / 2
    mov r4, r3                 ! r3 = halved force (magnitude)
    mov.l r4, @-r15            ! save halved force on stack
    neg r10, r4                ! r4 = -collision_angle (arg for cos_lookup)
    mov r3, r9                 ! r9 = force magnitude
    /* Backup car_B position before applying impulse */
    mov.l @(16, r13), r5      ! r5 = car_B->X
    mov.l @(24, r13), r6      ! r6 = car_B->Z
    mov.l r5, @(56, r13)      ! car_B->X_backup = X (pre-collision)
    mov.l r6, @(60, r13)      ! car_B->Z_backup = Z (pre-collision)
    /* Get cos(angle) for X impulse component */
    mov.l   .L_pool_cos_lookup_a, r0 ! r0 = &cos_lookup
    jsr @r0                    ! r0 = cos_lookup(-collision_angle)
    nop                        ! delay slot
    mov r0, r8                 ! r8 = cos(angle) (saved for Z impulse)
    /* Get sin(angle) for Z impulse component */
    neg r10, r4                ! r4 = -collision_angle (arg for sin_lookup)
    mov.l   .L_pool_sin_lookup_a, r0 ! r0 = &sin_lookup
    jsr @r0                    ! r0 = sin_lookup(-collision_angle)
    nop                        ! delay slot
    /* Apply X impulse: B.X += sin(angle) * force */
    dmuls.l r0, r3             ! MACH:MACL = sin(angle) * force (64-bit)
    sts mach, r11              ! r11 = high 32 bits
    sts macl, r3               ! r3 = low 32 bits
    xtrct r11, r3              ! r3 = fixed-point X impulse
    add r3, r5                 ! r5 = B.X + X_impulse
    mov.l r5, @(16, r13)      ! store car_B->X (updated)
    /* Apply Z impulse: B.Z += cos(angle) * force */
    dmuls.l r8, r9             ! MACH:MACL = cos(angle) * force (64-bit)
    sts mach, r8               ! r8 = high 32 bits
    sts macl, r9               ! r9 = low 32 bits
    xtrct r8, r9               ! r9 = fixed-point Z impulse
    add r9, r6                 ! r6 = B.Z + Z_impulse
    mov.l r6, @(24, r13)      ! store car_B->Z (updated)
    /* --- Step 7: apply opposite impulse to car_A (Newton's 3rd law) --- */
    mov.l @r15+, r3            ! restore halved force
    mov.l   .L_fp_half, r5    ! r5 = 0x00008000 (180 deg in 16-bit fixed)
    add r5, r10                ! collision_angle += 180 deg (reverse direction)
    neg r10, r4                ! r4 = -(angle+180) (arg for cos_lookup)
    mov r3, r9                 ! r9 = same force magnitude
    /* Backup car_A position before applying opposite impulse */
    mov.l @(16, r14), r5      ! r5 = car_A->X
    mov.l @(24, r14), r6      ! r6 = car_A->Z
    mov.l r5, @(56, r14)      ! car_A->X_backup = X (pre-collision)
    mov.l r6, @(60, r14)      ! car_A->Z_backup = Z (pre-collision)
    /* Get cos(angle+180) */
    mov.l   .L_pool_cos_lookup_a, r0 ! r0 = &cos_lookup
    jsr @r0                    ! r0 = cos_lookup(-(angle+180))
    nop                        ! delay slot
    mov r0, r8                 ! r8 = cos(angle+180)
    /* Get sin(angle+180) */
    neg r10, r4                ! r4 = -(angle+180) (arg for sin_lookup)
    mov.l   .L_pool_sin_lookup_a, r0 ! r0 = &sin_lookup
    jsr @r0                    ! r0 = sin_lookup(-(angle+180))
    nop                        ! delay slot
    /* Apply opposite X impulse: A.X += sin(angle+180) * force */
    dmuls.l r0, r3             ! MACH:MACL = sin(angle+180) * force (64-bit)
    sts mach, r11              ! r11 = high 32 bits
    sts macl, r3               ! r3 = low 32 bits
    xtrct r11, r3              ! r3 = fixed-point opposite X impulse
    add r3, r5                 ! r5 = A.X + opposite_X_impulse
    mov.l r5, @(16, r14)      ! store car_A->X (updated)
    /* Apply opposite Z impulse: A.Z += cos(angle+180) * force */
    dmuls.l r8, r9             ! MACH:MACL = cos(angle+180) * force (64-bit)
    sts mach, r8               ! r8 = high 32 bits
    sts macl, r9               ! r9 = low 32 bits
    xtrct r8, r9               ! r9 = fixed-point opposite Z impulse
    add r9, r6                 ! r6 = A.Z + opposite_Z_impulse
    mov.l r6, @(24, r14)      ! store car_A->Z (updated)
.L_epilogue:
    /* Common epilogue: restore callee-saved registers and return */
    lds.l @r15+, pr            ! restore return address
    mov.l @r15+, r14           ! restore r14
    mov.l @r15+, r13           ! restore r13
    mov.l @r15+, r12           ! restore r12
    mov.l @r15+, r11           ! restore r11
    mov.l @r15+, r10           ! restore r10
    mov.l @r15+, r9            ! restore r9
    rts                        ! return to caller
    mov.l @r15+, r8            ! restore r8 [delay slot]
    .2byte  0x0000              /* alignment padding */
.L_pool_cos_lookup_a:
    .4byte  cos_lookup          /* cos lookup function ptr (path A) */
.L_pool_sin_lookup_a:
    .4byte  sin_lookup          /* sin lookup function ptr (path A) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) / 180 deg */
.L_second_path_entry:
    /* ===== SECOND PATH: A below or equal to B (swapped roles) ===== */
    mov.l r0, @-r15            ! save r0 on stack
    mov r8, r4                 ! r4 = lower.X (car_A, which is below)
    sub r6, r4                 ! r4 = dx = lower.X - higher.X
    mov r9, r5                 ! r5 = lower.Z
    sub r7, r5                 ! r5 = dz = lower.Z - higher.Z
    mov.l   .L_pool_atan2_b, r0 ! r0 = &atan2 function

    .global collision_order_b
    .type collision_order_b, @function
collision_order_b:
    /* Call atan2(dz, dx) to get collision angle (second path) */
    sts.l pr, @-r15             ! save PR (nested call)
    jsr @r0                     ! call atan2(r4=dx, r5=dz)
    nop                         ! delay slot
    lds.l @r15+, pr             ! restore PR
    neg r0, r10                 ! r10 = -atan2_result
    exts.w r10, r10             ! sign-extend 16-bit angle to 32-bit
    mov.l @r15+, r0             ! restore saved r0
    /* --- Heading comparison / force table lookup (path B) --- */
    mov.l @(32, r14), r1       ! r1 = car_A->heading
    mov.w   DAT_060318e4, r4   ! r4 = 0x8000 (half-circle threshold)
    extu.w r4, r4              ! zero-extend to 32-bit
    sub r10, r1                ! r1 = heading_A - collision_angle
    extu.w r1, r1              ! unsigned 16-bit wrap
    cmp/gt r1, r4              ! heading_diff_A < 0x8000 ?
    bt/s    .L_b_heading_ok    ! yes: heading within threshold
    mov.l @(32, r13), r2       ! r2 = car_B->heading [delay slot]
    sub r4, r1                 ! reduce by half-circle (wrap)
.L_b_heading_ok:
    sub r10, r2                ! r2 = heading_B - collision_angle
    extu.w r2, r2              ! unsigned 16-bit wrap
    cmp/gt r2, r4              ! heading_diff_B < 0x8000 ?
    bt/s    .L_headings_indexed_b ! yes: both headings OK
    shlr8 r1                   ! r1 >>= 8 (table index step 1) [delay slot]
    sub r4, r2                 ! reduce by half-circle
.L_headings_indexed_b:
    /* Convert heading differences to force table indices */
    shlr r1                    ! r1 >>= 1 (total: >>9 from 16-bit angle)
    shll2 r1                   ! r1 <<= 2 (word index -> byte offset)
    shlr8 r2                   ! r2 >>= 8 (table index step 1)
    shlr r2                    ! r2 >>= 1 (total: >>9)
    shll2 r2                   ! r2 <<= 2 (word index -> byte offset)
    mov.l   .L_pool_force_table_b, r3 ! r3 = collision force table base
    add r3, r1                 ! r1 = &table[heading_diff_A]
    add r3, r2                 ! r2 = &table[heading_diff_B]
    mov.l @r1, r4              ! r4 = force_A = table[heading_diff_A]
    sub r12, r4                ! r4 -= collision_param (adjust force)
    mov.l @r2, r12             ! r12 = force_B = table[heading_diff_B]
    add r12, r4                ! r4 = net force (force_A - param + force_B)
    cmp/pl r4                  ! net force > 0 ?
    bt      .L_force_positive_b ! yes: apply collision
    bra     .L_epilogue        ! no force -> skip collision
    nop                        ! delay slot

    .global DAT_060318e4
DAT_060318e4:
    .2byte  0x8000              /* half-circle angle constant (180 deg in 16-bit) */
    .2byte  0x0000              /* alignment padding */
.L_pool_atan2_b:
    .4byte  atan2               /* atan2 function ptr (path B) */
.L_pool_force_table_b:
    .4byte  sym_0605BCC8        /* collision force lookup table base (path B) */
.L_force_positive_b:
    /* --- Secondary heading angle range check (path B) --- */
    mov.l @(40, r14), r1       ! r1 = car_A->heading2
    mov.l @(40, r13), r2       ! r2 = car_B->heading2
    sub r2, r1                 ! r1 = heading2_diff = A.heading2 - B.heading2
    extu.w r1, r1              ! unsigned 16-bit wrap
    mov.w   DAT_06031918, r3   ! r3 = 0x4000 (quarter-circle range)
    cmp/ge r1, r3              ! heading2_diff <= quarter-circle ?
    bt      .L_in_angle_range_b ! yes: within normal range
    /* Check extended range (3x quarter-circle) */
    mov r3, r2                 ! r2 = 0x4000
    shll r2                    ! r2 = 0x8000 (2x threshold)
    add r2, r3                 ! r3 = 0xC000 (3x threshold)
    cmp/ge r3, r1              ! heading2_diff >= 3x threshold ?
    bt      .L_in_angle_range_b ! yes: in complementary range
    /* Out of angle range: check combined height */
    mov.l @(12, r14), r1      ! r1 = car_A->Y
    mov.l @(12, r13), r3      ! r3 = car_B->Y
    mov.l   .L_pool_height_thresh_c, r2 ! r2 = 0x0001638E (height threshold)
    add r3, r1                 ! r1 = combined_Y = A.Y + B.Y
    cmp/ge r1, r2              ! combined_Y <= threshold ?
    bf      .L_set_both_flags  ! no: exceeds threshold -> flag both cars
    bra     .L_apply_xz_impulse_b ! yes: skip flags, go to XZ impulse
    nop                        ! delay slot

    .global DAT_06031918
DAT_06031918:
    .2byte  0x4000              /* quarter-circle angle constant */
    .2byte  0x0000              /* alignment padding */
.L_pool_height_thresh_c:
    .4byte  0x0001638E          /* height threshold (~91,022 fixed-point) */
.L_set_both_flags:
    /* Combined height exceeds threshold: set collision flag on BOTH cars */
    mov.l @(0, r13), r0       ! r0 = car_B->flags
    mov.l @(0, r14), r1       ! r1 = car_A->flags
    mov.l   .L_pool_collision_flag_c, r3 ! r3 = 0x08000000 (COLLISION_BIT)
    or r3, r0                  ! set bit 27 on car_B
    or r3, r1                  ! set bit 27 on car_A
    mov.l r0, @(0, r13)       ! store car_B->flags |= COLLISION_BIT
    mov.l r1, @(0, r14)       ! store car_A->flags |= COLLISION_BIT
    bra     .L_apply_xz_impulse_b ! -> apply XZ impulse (skip Y transfer)
    nop                        ! delay slot
    .2byte  0x0000              /* alignment padding */
.L_pool_collision_flag_c:
    .4byte  0x08000000          /* COLLISION_BIT (bit 27 of car flags) */
.L_in_angle_range_b:
    /* Within angle range: check height difference for collision flags */
    mov.l @(12, r13), r1      ! r1 = car_B->Y
    mov.l @(12, r14), r3      ! r3 = car_A->Y
    mov.l   .L_pool_height_thresh_d, r2 ! r2 = 0x0001638E (height threshold)
    sub r3, r1                 ! r1 = height_diff = B.Y - A.Y
    cmp/ge r1, r2              ! height_diff <= threshold ?
    bt      .L_check_sec_heading_b ! yes: no flags needed
    /* Height diff exceeds threshold: set collision flag on BOTH cars */
    mov.l @(0, r13), r0       ! r0 = car_B->flags
    mov.l @(0, r14), r1       ! r1 = car_A->flags
    mov.l   .L_pool_collision_flag_d, r3 ! r3 = 0x08000000 (COLLISION_BIT)
    or r3, r0                  ! set bit 27 on car_B
    or r3, r1                  ! set bit 27 on car_A
    mov.l r0, @(0, r13)       ! store car_B->flags |= COLLISION_BIT
    mov.l r1, @(0, r14)       ! store car_A->flags |= COLLISION_BIT
.L_check_sec_heading_b:
    /* --- Check secondary heading angle for Y impulse eligibility (path B) --- */
    mov.l @(40, r13), r3      ! r3 = car_B->heading2
    sub r10, r3                ! r3 = heading2_B - collision_angle
    mov.w   DAT_0603196c, r2  ! r2 = 0x4000 (quarter-circle range)
    extu.w r3, r3              ! unsigned 16-bit wrap
    cmp/ge r3, r2              ! sec_angle <= quarter-circle ?
    bt      .L_apply_y_impulse_b ! yes: apply Y momentum transfer
    /* Check extended range (3x quarter-circle) */
    mov r2, r1                 ! r1 = 0x4000
    shll r1                    ! r1 = 0x8000 (2x threshold)
    add r1, r2                 ! r2 = 0xC000 (3x threshold)
    cmp/ge r2, r3              ! sec_angle >= 3x threshold ?
    bt      .L_apply_y_impulse_b ! yes: in complementary range
    bra     .L_apply_xz_impulse_b ! out of range: skip Y impulse
    nop                        ! delay slot

    .global DAT_0603196c
DAT_0603196c:
    .2byte  0x4000              /* quarter-circle angle constant */
    .2byte  0x0000              /* alignment padding */
.L_pool_height_thresh_d:
    .4byte  0x0001638E          /* height threshold (~91,022 fixed-point) */
.L_pool_collision_flag_d:
    .4byte  0x08000000          /* COLLISION_BIT (bit 27 of car flags) */
.L_apply_y_impulse_b:
    /* --- Apply Y-axis momentum transfer (path B — swapped roles) --- */
    mov.l r4, @-r15            ! save net force on stack
    mov.l @(32, r13), r4      ! r4 = car_B->heading
    mov.l r4, @(32, r14)      ! car_A->heading = car_B->heading (copy heading)
    mov.l r4, @(40, r14)      ! car_A->heading2 = car_B->heading (copy to secondary)
    mov r3, r4                 ! r4 = sec_angle (for cos_lookup arg)
    mov.l   .L_pool_cos_lookup_b, r0 ! r0 = &cos_lookup
    jsr @r0                    ! r0 = cos_lookup(sec_angle)
    nop                        ! delay slot
    /* Compute Y position transfer: dY * cos(sec_angle) */
    mov.l @(12, r13), r1      ! r1 = car_B->Y
    mov.l @(12, r14), r2      ! r2 = car_A->Y
    sub r2, r1                 ! r1 = dY = B.Y - A.Y
    dmuls.l r0, r1             ! MACH:MACL = cos(angle) * dY (64-bit)
    sts mach, r0               ! r0 = high 32 bits
    sts macl, r1               ! r1 = low 32 bits
    xtrct r0, r1               ! r1 = fixed-point Y transfer amount
    add r1, r2                 ! r2 = A.Y + Y_transfer
    mov.l r2, @(12, r14)      ! store car_A->Y (updated)
    mov.l @(12, r13), r4      ! r4 = car_B->Y (re-read)
    sub r1, r4                 ! r4 = B.Y - Y_transfer (Newton's 3rd law)
    mov.l r4, @(12, r13)      ! store car_B->Y (updated)
    mov.l @r15+, r4            ! restore net force
.L_apply_xz_impulse_b:
    /* --- Apply XZ position impulse to car_A (path B) --- */
    shlr r4                    ! r4 = net_force / 2
    mov r4, r3                 ! r3 = halved force (magnitude)
    mov.l r4, @-r15            ! save halved force on stack
    neg r10, r4                ! r4 = -collision_angle (arg for cos_lookup)
    mov r3, r9                 ! r9 = force magnitude
    /* Backup car_A position before applying impulse */
    mov.l @(16, r14), r5      ! r5 = car_A->X
    mov.l @(24, r14), r6      ! r6 = car_A->Z
    mov.l r5, @(56, r14)      ! car_A->X_backup = X (pre-collision)
    mov.l r6, @(60, r14)      ! car_A->Z_backup = Z (pre-collision)
    /* Get cos(angle) for X impulse component */
    mov.l   .L_pool_cos_lookup_b, r0 ! r0 = &cos_lookup
    jsr @r0                    ! r0 = cos_lookup(-collision_angle)
    nop                        ! delay slot
    mov r0, r8                 ! r8 = cos(angle) (saved for Z impulse)
    /* Get sin(angle) for Z impulse component */
    neg r10, r4                ! r4 = -collision_angle (arg for sin_lookup)
    mov.l   .L_pool_sin_lookup_b, r0 ! r0 = &sin_lookup
    jsr @r0                    ! r0 = sin_lookup(-collision_angle)
    nop                        ! delay slot
    /* Apply X impulse: A.X += sin(angle) * force */
    dmuls.l r0, r3             ! MACH:MACL = sin(angle) * force (64-bit)
    sts mach, r11              ! r11 = high 32 bits
    sts macl, r3               ! r3 = low 32 bits
    xtrct r11, r3              ! r3 = fixed-point X impulse
    add r3, r5                 ! r5 = A.X + X_impulse
    mov.l r5, @(16, r14)      ! store car_A->X (updated)
    /* Apply Z impulse: A.Z += cos(angle) * force */
    dmuls.l r8, r9             ! MACH:MACL = cos(angle) * force (64-bit)
    sts mach, r8               ! r8 = high 32 bits
    sts macl, r9               ! r9 = low 32 bits
    xtrct r8, r9               ! r9 = fixed-point Z impulse
    add r9, r6                 ! r6 = A.Z + Z_impulse
    mov.l r6, @(24, r14)      ! store car_A->Z (updated)
    /* --- Apply opposite impulse to car_B (Newton's 3rd law, path B) --- */
    mov.l @r15+, r3            ! restore halved force
    mov.l   .L_fp_half_b, r5  ! r5 = 0x00008000 (180 deg in 16-bit fixed)
    add r5, r10                ! collision_angle += 180 deg (reverse direction)
    neg r10, r4                ! r4 = -(angle+180) (arg for cos_lookup)
    mov r3, r9                 ! r9 = same force magnitude
    /* Backup car_B position before applying opposite impulse */
    mov.l @(16, r13), r5      ! r5 = car_B->X
    mov.l @(24, r13), r6      ! r6 = car_B->Z
    mov.l r5, @(56, r13)      ! car_B->X_backup = X (pre-collision)
    mov.l r6, @(60, r13)      ! car_B->Z_backup = Z (pre-collision)
    /* Get cos(angle+180) */
    mov.l   .L_pool_cos_lookup_b, r0 ! r0 = &cos_lookup
    jsr @r0                    ! r0 = cos_lookup(-(angle+180))
    nop                        ! delay slot
    mov r0, r8                 ! r8 = cos(angle+180)
    /* Get sin(angle+180) */
    neg r10, r4                ! r4 = -(angle+180) (arg for sin_lookup)
    mov.l   .L_pool_sin_lookup_b, r0 ! r0 = &sin_lookup
    jsr @r0                    ! r0 = sin_lookup(-(angle+180))
    nop                        ! delay slot
    /* Apply opposite X impulse: B.X += sin(angle+180) * force */
    dmuls.l r0, r3             ! MACH:MACL = sin(angle+180) * force (64-bit)
    sts mach, r11              ! r11 = high 32 bits
    sts macl, r3               ! r3 = low 32 bits
    xtrct r11, r3              ! r3 = fixed-point opposite X impulse
    add r3, r5                 ! r5 = B.X + opposite_X_impulse
    mov.l r5, @(16, r13)      ! store car_B->X (updated)
    /* Apply opposite Z impulse: B.Z += cos(angle+180) * force */
    dmuls.l r8, r9             ! MACH:MACL = cos(angle+180) * force (64-bit)
    sts mach, r8               ! r8 = high 32 bits
    sts macl, r9               ! r9 = low 32 bits
    xtrct r8, r9               ! r9 = fixed-point opposite Z impulse
    add r9, r6                 ! r6 = B.Z + opposite_Z_impulse
    bra     .L_epilogue        ! -> common epilogue
    mov.l r6, @(24, r13)      ! store car_B->Z (updated) [delay slot]
.L_pool_cos_lookup_b:
    .4byte  cos_lookup          /* cos lookup function ptr (path B) */
.L_pool_sin_lookup_b:
    .4byte  sin_lookup          /* sin lookup function ptr (path B) */
.L_fp_half_b:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) / 180 deg */

    .global sym_06031A24
sym_06031A24:
    .word 0x0000                /* data padding / unknown */
    .word 0x0000                /* data padding / unknown */

    /* Register-save wrapper for the next TU. Saves r8-r13 (callee-saved),
     * then falls through into the following translation unit's main body. */
    .global sym_06031A28
sym_06031A28:
    mov.l r8, @-r15            ! save r8 (callee-saved)
    mov.l r9, @-r15            ! save r9 (callee-saved)
    mov.l r10, @-r15           ! save r10 (callee-saved)
    mov.l r11, @-r15           ! save r11 (callee-saved)
    mov.l r12, @-r15           ! save r12 (callee-saved)
    mov.l r13, @-r15           ! save r13 (callee-saved)
    /* falls through to next TU */
