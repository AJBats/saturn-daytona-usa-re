/* shadow_color_alpha -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06036AF8 - 0x06036B64
 * Auto-generated by tools/generate_l3_tu.py
 *
 * shadow_color_alpha -- Build a shadow display command with alpha masking
 *
 * Builds a display command struct on the stack:
 *   [+0x0C] byte 0 = 0x73 (shadow command opcode)
 *   [+0x10]        = r14  (color/parameter word)
 *   [+0x10] byte 4 = 0x00 (alpha = fully transparent)
 *
 * Calls input_proc_analog to initialize the struct, then
 * input_proc_digital with arg 0. If digital returns nonzero,
 * returns that value directly. Otherwise loads the color word
 * from sp[+4], strips the alpha channel via AND 0x00FFFFFF,
 * stores the masked RGB to sp[0], and dispatches through a
 * cross-TU function with the masked color as argument.
 *
 * Args:
 *   r5  = parameter (saved to r13)
 *   r14 = color/parameter word (stored into command struct)
 *
 * Returns:
 *   r0 = result from input_proc_digital or cross-TU dispatch
 *
 * Calls:
 *   input_proc_analog    -- initialize analog command struct
 *   input_proc_digital   -- process digital input / dispatch
 *   (cross-TU via .byte) -- final dispatch with masked color
 *
 * Pool references:
 *   .L_pool_analog_fn    -- input_proc_analog function pointer
 *   .L_pool_digital_fn   -- input_proc_digital function pointer
 *   .L_pool_rgb_mask     -- 0x00FFFFFF: alpha strip mask
 */

    .section .text.FUN_06036AF8


    .global shadow_color_alpha
    .type shadow_color_alpha, @function
shadow_color_alpha:
    sts.l pr, @-r15                            ! save return address
    mov r5, r13                                ! r13 = param (callee-saved copy)
    add #-0x14, r15                            ! allocate 20-byte stack frame
    mov r15, r4                                ! r4 = stack pointer (struct base)
    mov.l   .L_pool_analog_fn, r3              ! r3 = &input_proc_analog
    jsr @r3                                    ! call input_proc_analog(sp)
    add #0xC, r4                               ! (delay) r4 = sp+0xC (command struct)
    mov r15, r2                                ! r2 = sp
    mov #0x73, r3                              ! r3 = 0x73 (shadow command opcode)
    mov r15, r6                                ! r6 = sp
    mov r15, r5                                ! r5 = sp
    add #0xC, r2                               ! r2 = sp+0xC (struct byte 0)
    add #0x4, r6                               ! r6 = sp+0x4 (color output slot)
    add #0xC, r5                               ! r5 = sp+0xC (struct base for digital)
    mov.b r3, @r2                              ! struct[+0xC] byte 0 = 0x73 (opcode)
    mov r15, r2                                ! r2 = sp
    mov r15, r3                                ! r3 = sp
    add #0xC, r2                               ! r2 = sp+0xC (struct longword offset)
    add #0xC, r3                               ! r3 = sp+0xC (struct byte offset)
    mov.l r14, @(4, r2)                        ! struct[+0x10] = r14 (color/param word)
    mov #0x0, r2                               ! r2 = 0
    mov r2, r0                                 ! r0 = 0 (alpha value)
    mov.b r0, @(4, r3)                         ! struct[+0x10] byte 4 = 0x00 (alpha = transparent)
    mov.l   .L_pool_digital_fn, r3             ! r3 = &input_proc_digital
    jsr @r3                                    ! call input_proc_digital(0)
    mov #0x0, r4                               ! (delay) r4 = 0 (arg: no input)
    mov r0, r4                                 ! r4 = digital result
    tst r4, r4                                 ! test: digital result == 0?
    bt      .L_digital_zero                    ! if zero, go to alpha-mask path
    bra     .L_epilogue                        ! nonzero -- return digital result directly
    mov r4, r0                                 ! (delay) r0 = digital result
    .2byte  0xFFFF                             ! padding (alignment)
.L_pool_analog_fn:
    .4byte  input_proc_analog                  ! pool: input_proc_analog address
.L_pool_digital_fn:
    .4byte  input_proc_digital                 ! pool: input_proc_digital address
.L_pool_rgb_mask:
    .4byte  0x00FFFFFF                         ! pool: RGB mask (strips alpha byte)
.L_digital_zero:
    mov r15, r3                                ! r3 = sp
    mov r13, r5                                ! r5 = saved param (from r5 on entry)
    add #0x4, r3                               ! r3 = sp+0x4 (color word slot)
    mov.l @r3, r2                              ! r2 = color word from sp[+4]
    .byte   0xD3, 0x20    /* mov.l .L_pool_06036BD0, r3 */  ! r3 = 0x00FFFFFF (RGB mask, cross-TU pool)
    and r3, r2                                 ! r2 = color & 0x00FFFFFF (strip alpha)
    mov.l r2, @r15                             ! sp[0] = masked RGB color
    .byte   0xD3, 0x20    /* mov.l .L_pool_06036BD4, r3 */  ! r3 = cross-TU dispatch function address
    jsr @r3                                    ! call dispatch(masked_color)
    mov r2, r4                                 ! (delay) r4 = masked RGB color (arg)
    mov r0, r4                                 ! r4 = dispatch result (for caller if needed)
.L_epilogue:
    add #0x14, r15                             ! deallocate 20-byte stack frame
    lds.l @r15+, pr                            ! restore return address
    mov.l @r15+, r13                           ! restore r13
    rts                                        ! return to caller
    mov.l @r15+, r14                           ! (delay) restore r14
