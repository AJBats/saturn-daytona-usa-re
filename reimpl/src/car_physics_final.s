/* car_physics_final -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601A3F4 - 0x0601A574
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Table-driven geometry rendering dispatch — final phase of per-car physics
 * pipeline. Submits rendering commands for car geometry based on lookup tables.
 *
 * Two rendering modes (selected by r5 parameter):
 *   Mode A (r5 == 0x00A8): Uses table set A (sym_06049CD4/CCC/C28)
 *   Mode B (r5 != 0x00A8): Uses table set B (sym_06049C1E/C14/B36)
 *
 * Each mode follows the same pattern:
 *   1. Read start offset from start_table[car_slot]
 *   2. Classify start offset → render class (2 or 3)
 *   3. Read iteration count from count_table[car_slot]
 *   4. Loop: for each iteration, read byte pair from lookup_table,
 *      compute index = (high_byte << 6 | low_byte) * 2,
 *      call render_dispatch(class*4, index, 0, render_params)
 *   5. After loop: read final byte pair from final_params[car_slot*2],
 *      compute final index same way,
 *      tail-call final_dispatch(class*4, index, 0x60, final_params)
 *
 * Parameters:
 *   r4 = car slot index (0-based, stored as 16-bit)
 *   r5 = rendering mode (0x00A8 = mode A, other = mode B)
 *
 * Persistent registers:
 *   r8  = render table base (mode B lookup)
 *   r10 = render class (2 or 3, determines dispatch sub-mode)
 *   r11 = render dispatch function (sym_060283E0)
 *   r12 = render parameter table (sym_06049E54)
 *   r13 = loop counter
 *   r14 = car slot index
 */

    .section .text.FUN_0601A3F4


    .global car_physics_final
    .type car_physics_final, @function
car_physics_final:
    mov.l r14, @-r15
    mov #0x3, r6
    extu.w r5, r5
    mov r4, r14
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0xC, r15
    mov.l   .L_render_table_b, r8       /* r8 = mode B lookup table base */
    mov.l   .L_fn_render_dispatch, r11  /* r11 = render dispatch function */
    mov.l   .L_render_params, r12       /* r12 = render parameter table */
    mov.w   .L_mode_a_id, r3            /* 0x00A8 = mode A identifier */
    cmp/eq r3, r5
    bf/s    .L_0601A496                  /* not mode A → mode B path */
    mov #0x2, r4
    extu.w r14, r3                       /* === Mode A path === */
    mov.l   .L_start_table_a, r2
    add r2, r3
    mov.b @r3, r1                        /* start_offset = start_table_a[slot] */
    mov r1, r0
    mov.b r0, @(8, r15)                 /* save start_offset on stack */
    bra     .L_0601A442                  /* → classify start offset */
    extu.w r14, r0
.L_0601A42A:                              /* --- class 2: start == 1 or 4 --- */
    bra     .L_0601A430
    extu.b r4, r10                       /* r10 = 2 (render class) */
.L_0601A42E:                              /* --- class 3: other start values --- */
    extu.b r6, r10                       /* r10 = 3 (render class) */
.L_0601A430:                              /* --- setup mode A loop --- */
    mov #0x0, r13                        /* loop counter = 0 */
    extu.w r14, r2
    mov.l   .L_count_table_a, r3
    add r3, r2
    mov.l r2, @(4, r15)                 /* save &count_table_a[slot] */
    extu.b r10, r1
    shll2 r1                             /* class * 4 */
    bra     .L_0601A47C                  /* → loop condition check */
    mov.l r1, @r15                       /* save class*4 on stack */
.L_0601A442:                              /* --- classify start offset for mode A --- */
    cmp/eq #0x1, r0
    bt      .L_0601A42A                  /* start == 1 → class 2 */
    cmp/eq #0x4, r0
    bt      .L_0601A42A                  /* start == 4 → class 2 */
    bra     .L_0601A42E                  /* other → class 3 */
    nop
.L_0601A44E:                              /* === Mode A render loop body === */
    mov r12, r7                          /* r7 = render params */
    mov #0x0, r6                         /* r6 = 0 (no flags) */
    extu.b r13, r3
    mov.l   .L_lookup_table_a, r2
    mov.b @(8, r15), r0                  /* start_offset */
    mov r0, r9
    extu.b r9, r9
    add r3, r9                           /* table_idx = start + counter */
    shll r9                              /* table_idx *= 2 (byte pair) */
    add r2, r9                           /* &lookup_table_a[table_idx] */
    mov.b @(1, r9), r0                   /* high_byte */
    mov.b @r9, r3                        /* low_byte */
    mov r0, r5
    extu.b r3, r3
    extu.b r5, r5
    shll2 r5                             /* high << 2 */
    shll2 r5                             /* high << 4 */
    shll2 r5                             /* high << 6 */
    add r3, r5                           /* index = (high << 6) | low */
    shll r5                              /* index *= 2 (word table) */
    jsr @r11                             /* render_dispatch(class*4, index, 0, params) */
    mov.l @r15, r4                       /* r4 = class*4 */
    add #0x1, r13                        /* counter++ */
.L_0601A47C:                              /* --- mode A loop condition --- */
    extu.b r13, r3
    mov.l @(4, r15), r2
    mov.b @r2, r2                        /* iteration_count = count_table_a[slot] */
    extu.b r2, r2
    cmp/ge r2, r3
    bf      .L_0601A44E                  /* counter < count → loop */
    extu.w r14, r5                       /* === Mode A final dispatch === */
    mov.l   .L_final_params_a, r7       /* r7 = final param table */
    shll r5                              /* slot * 2 */
    mov.l   .L_final_offset_a, r3
    add r3, r5                           /* &final_offset_a[slot*2] */
    bra     .L_0601A532                  /* → shared final dispatch */
    mov #0x60, r6                        /* r6 = 0x60 (final render flags) */
.L_0601A496:                              /* === Mode B path === */
    extu.w r14, r2
    mov.l   .L_start_table_b, r3
    add r3, r2
    mov.b @r2, r1                        /* start_offset = start_table_b[slot] */
    mov.b r1, @r15                       /* save start_offset on stack */
    bra     .L_0601A4E4                  /* → classify start offset */
    extu.w r14, r0
.L_0601A4A4:                              /* --- class 2: start == 5 or 8 --- */
    bra     .L_0601A4D2
    extu.b r4, r10                       /* r10 = 2 (render class) */
.L_mode_a_id:
    .2byte  0x00A8                        /* mode A identifier value */
    .2byte  0xFFFF
.L_render_table_b:
    .4byte  sym_06049B36               /* mode B lookup table base */
.L_fn_render_dispatch:
    .4byte  sym_060283E0               /* geometry render dispatch function */
.L_render_params:
    .4byte  sym_06049E54               /* render parameter table */
.L_start_table_a:
    .4byte  sym_06049CD4               /* mode A start offset table (per slot) */
.L_count_table_a:
    .4byte  sym_06049CCC               /* mode A iteration count table (per slot) */
.L_lookup_table_a:
    .4byte  sym_06049C28               /* mode A byte-pair lookup table */
.L_final_params_a:
    .4byte  sym_06049E58               /* mode A final render parameters */
.L_final_offset_a:
    .4byte  sym_06059084               /* mode A final byte-pair offset base */
.L_start_table_b:
    .4byte  sym_06049C1E               /* mode B start offset table (per slot) */
.L_0601A4D0:                              /* --- class 3: other start values --- */
    extu.b r6, r10                       /* r10 = 3 (render class) */
.L_0601A4D2:                              /* --- setup mode B loop --- */
    mov #0x0, r13                        /* loop counter = 0 */
    extu.w r14, r2
    mov.l   .L_count_table_b, r3
    add r3, r2
    mov.l r2, @(4, r15)                 /* save &count_table_b[slot] */
    extu.b r10, r1
    shll2 r1                             /* class * 4 */
    bra     .L_0601A51A                  /* → loop condition check */
    mov.l r1, @(8, r15)                 /* save class*4 on stack */
.L_0601A4E4:                              /* --- classify start offset for mode B --- */
    cmp/eq #0x5, r0
    bt      .L_0601A4A4                  /* start == 5 → class 2 */
    cmp/eq #0x8, r0
    bt      .L_0601A4A4                  /* start == 8 → class 2 */
    bra     .L_0601A4D0                  /* other → class 3 */
    nop
.L_0601A4F0:                              /* === Mode B render loop body === */
    mov r12, r7                          /* r7 = render params */
    mov #0x0, r6                         /* r6 = 0 (no flags) */
    mov.b @r15, r9                       /* start_offset */
    extu.b r13, r3
    extu.b r9, r9
    add r3, r9                           /* table_idx = start + counter */
    shll r9                              /* table_idx *= 2 (byte pair) */
    add r8, r9                           /* &render_table_b[table_idx] */
    mov.b @(1, r9), r0                   /* high_byte */
    mov.b @r9, r3                        /* low_byte */
    mov r0, r5
    extu.b r3, r3
    extu.b r5, r5
    shll2 r5                             /* high << 2 */
    shll2 r5                             /* high << 4 */
    shll2 r5                             /* high << 6 */
    add r3, r5                           /* index = (high << 6) | low */
    shll r5                              /* index *= 2 (word table) */
    jsr @r11                             /* render_dispatch(class*4, index, 0, params) */
    mov.l @(8, r15), r4                  /* r4 = class*4 */
    add #0x1, r13                        /* counter++ */
.L_0601A51A:                              /* --- mode B loop condition --- */
    extu.b r13, r3
    mov.l @(4, r15), r2
    mov.b @r2, r2                        /* iteration_count = count_table_b[slot] */
    extu.b r2, r2
    cmp/ge r2, r3
    bf      .L_0601A4F0                  /* counter < count → loop */
    mov.l   .L_final_params_b, r7       /* === Mode B final dispatch === */
    mov #0x60, r6                        /* r6 = 0x60 (final render flags) */
    extu.w r14, r5
    shll r5                              /* slot * 2 */
    mov.l   .L_final_offset_b, r3
    add r3, r5                           /* &final_offset_b[slot*2] */
.L_0601A532:                              /* === Shared final dispatch === */
    mov.l r5, @r15                       /* save pair pointer */
    mov.b @(1, r5), r0                   /* high_byte */
    mov.l @r15, r2
    mov r0, r5
    mov.b @r2, r2                        /* low_byte */
    extu.b r5, r5
    extu.b r2, r2
    shll2 r5                             /* high << 2 */
    shll2 r5                             /* high << 4 */
    shll2 r5                             /* high << 6 */
    add r2, r5                           /* index = (high << 6) | low */
    shll r5                              /* index *= 2 */
    extu.b r10, r4
    shll2 r4                             /* r4 = class * 4 */
    add #0xC, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    mov.l   .L_fn_final_dispatch, r2
    jmp @r2                              /* → final_dispatch(class*4, index, flags, params) */
    mov.l @r15+, r14
.L_count_table_b:
    .4byte  sym_06049C14               /* mode B iteration count table (per slot) */
.L_final_params_b:
    .4byte  sym_06049E58               /* mode B final render parameters */
.L_final_offset_b:
    .4byte  sym_06059060               /* mode B final byte-pair offset base */
.L_fn_final_dispatch:
    .4byte  sym_060284AE               /* final geometry dispatch (tail call) */
