/* cmd_status_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603AE08 - 0x0603AE74
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Validates command readiness and performs a directory entry lookup.
 *
 * Loads the global command state struct (sym_060A4D14), checks that the
 * active count field (+0xA0) is nonzero and the mode flag (+0x98) equals 1.
 * If either check fails, reports error -8 via save_checksum_calc.
 *
 * When both preconditions pass, calls slave_sh2_setup (directory entry
 * lookup) with the entry count from +0xA0, the caller's buffer from r4,
 * and the max-entries field from +0x9C.  If the lookup returns a negative
 * result, reports error -9; otherwise reports success (0) and returns the
 * lookup result (entry index) in r0.
 *
 * Args:
 *   r4 = command buffer pointer (passed through to directory lookup as r5)
 *
 * Returns:
 *   r0 = directory entry index on success, or does not return here on
 *        error (tail-calls save_checksum_calc instead)
 *
 * Calls:
 *   save_checksum_calc  0x0603B93C  set status/error code and return
 *   slave_sh2_setup     0x0603F148  directory entry lookup by name
 */

    .section .text.FUN_0603AE08


    .global cmd_status_check
    .type cmd_status_check, @function
cmd_status_check:
    mov.l r14, @-r15                        ! save r14 (callee-saved, used for state base)
    sts.l pr, @-r15                         ! save return address on stack
    add #-0x4, r15                          ! allocate 4 bytes of stack for local storage
    mov.l r4, @r15                          ! save r4 (command buffer ptr) to stack local
    mov.l   .L_pool_state_ptr, r14          ! r14 = &sym_060A4D14 (global command state pointer)
    mov.w   .L_woff_active_count, r0        ! r0 = 0x00A0 (offset to active count field)
    mov.l @r14, r3                          ! r3 = state struct base address
    mov.l @(r0, r3), r0                     ! r0 = state[0xA0] (queue active count)
    tst r0, r0                              ! is active count zero?
    bt      .L_not_ready                    ! if zero, command not ready — branch to error
    mov.l @r14, r0                          ! r0 = state struct base address (reload)
    mov.w   .L_woff_mode_flag, r1           ! r1 = 0x0098 (offset to mode flag field)
    mov.l @(r0, r1), r0                     ! r0 = state[0x98] (mode flag)
    cmp/eq #0x1, r0                         ! is mode flag == 1?
    bt      .L_do_lookup                    ! if yes, proceed to directory lookup
.L_not_ready:
    mov #-0x8, r4                           ! r4 = -8 (error: not ready or wrong mode)
    add #0x4, r15                           ! deallocate stack local
    lds.l @r15+, pr                         ! restore return address
    .byte   0xA5, 0x86    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-8)
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_do_lookup:
    mov.l @r14, r6                          ! r6 = state struct base address
    mov.w   .L_woff_max_entries, r0         ! r0 = 0x009C (offset to max-entries field)
    mov.l @r15, r5                          ! r5 = saved command buffer ptr (lookup name arg)
    mov.l @r14, r4                          ! r4 = state struct base address (for entry array)
    mov.l   .L_pool_dir_lookup_fn, r3       ! r3 = &slave_sh2_setup (directory lookup function)
    mov.l @(r0, r6), r6                     ! r6 = state[0x9C] (max entries for lookup)
    mov.w   .L_woff_active_count, r0        ! r0 = 0x00A0 (offset to active count)
    jsr @r3                                 ! call slave_sh2_setup(r4=entry_array, r5=name, r6=max_entries)
    mov.l @(r0, r4), r4                     ! r4 = state[0xA0] (entry count) (delay slot)
    mov r0, r14                             ! r14 = lookup result (entry index or -1)
    cmp/pz r14                              ! is result >= 0? (found?)
    bt      .L_lookup_ok                    ! if non-negative, lookup succeeded
    mov #-0x9, r4                           ! r4 = -9 (error: directory entry not found)
    add #0x4, r15                           ! deallocate stack local
    lds.l @r15+, pr                         ! restore return address
    .byte   0xA5, 0x75    /* bra 0x0603B93C (external) */  ! tail-call save_checksum_calc(r4=-9)
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_lookup_ok:
    .byte   0xB5, 0x73    /* bsr 0x0603B93C (external) */  ! call save_checksum_calc(r4=0) — report success
    mov #0x0, r4                            ! r4 = 0 (success code) (delay slot)
    mov r14, r0                             ! r0 = lookup result (return value = entry index)
    add #0x4, r15                           ! deallocate stack local
    lds.l @r15+, pr                         ! restore return address
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
.L_woff_active_count:
    .2byte  0x00A0                          /* [HIGH] struct offset: active entry count (+0xA0) */
.L_woff_mode_flag:
    .2byte  0x0098                          /* [HIGH] struct offset: mode flag (+0x98) */
.L_woff_max_entries:
    .2byte  0x009C                          /* [HIGH] struct offset: max entries for lookup (+0x9C) */
    .2byte  0xFFFF                          /* alignment padding */
    .4byte  sym_06035168                    /* [HIGH] memcpy_long — unreferenced dead pool entry */
.L_pool_state_ptr:
    .4byte  sym_060A4D14                    /* [HIGH] global command state struct pointer */
.L_pool_dir_lookup_fn:
    .4byte  slave_sh2_setup                 /* [HIGH] directory entry lookup function */
