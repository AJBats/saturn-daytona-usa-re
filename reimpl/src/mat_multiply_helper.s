/* mat_multiply_helper -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E636 - 0x0601E6A4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * SMPC-bracketed dispatch helper — issues RESDISA (0x1A) before calling
 * a vtable function, then issues RESENAB (0x19) afterward.
 *
 * Flow:
 *   1. Polls SMPC SF until ready, issues RESDISA (0x1A) to disable
 *      the hardware reset button during the dispatch.
 *   2. Waits for RESDISA to complete (SF clears).
 *   3. Dereferences the function dispatch table (sym_06000354), reads
 *      vtable slot 7 (offset +28), and calls it with:
 *        r6 = 0x10 (parameter)
 *        r7 = sym_060870F4 (data pointer)
 *   4. Saves the dispatch result in r6.
 *   5. Polls SMPC SF until ready, issues RESENAB (0x19) to re-enable
 *      the hardware reset button.
 *   6. Waits for RESENAB to complete and returns the result.
 *
 * Arguments: none (self-contained)
 *
 * Returns:
 *   r0 = result from vtable dispatch call
 *
 * Key data:
 *   sym_06000354 = function dispatch table pointer
 *   sym_060870F4 = data pointer passed as r7 to dispatch function
 */

    .section .text.FUN_0601E636


    .global mat_multiply_helper
    .type mat_multiply_helper, @function
mat_multiply_helper:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    mov.l r13, @-r15                    ! save r13 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    .byte   0xDD, 0x15    /* mov.l .L_smpc_sf, r13 */
    mov #0x1, r14                       ! r14 = 1 (SF busy-bit mask, used throughout)
/* --- SMPC sync: wait for SF ready, issue RESDISA (0x1A) command --- */
.L_poll_sf_resdisa:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend to 32 bits
    and r14, r2                         ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                      ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_resdisa          ! spin while SMPC is busy
    extu.b r14, r2                      ! r2 = 1 (SF busy flag value)
    mov.b r2, @r13                      ! SF = 1 (set busy before issuing new command)
    mov #0x1A, r3                       ! 0x1A = SMPC RESDISA command (Reset Disable)
    .byte   0xD2, 0x11    /* mov.l .L_smpc_comreg_ct, r2 */
    mov.b r3, @r2                       ! write RESDISA command to COMREG
/* --- Wait for RESDISA completion --- */
.L_poll_resdisa_done:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend to 32 bits
    and r14, r2                         ! isolate bit 0 (busy flag)
    tst r2, r2                          ! SF.bit0 == 0? (command completed)
    bf      .L_poll_resdisa_done        ! spin while busy
/* --- Read dispatch table and call vtable slot 7 --- */
    .byte   0xD3, 0x0F    /* mov.l .L_dispatch_table_ptr, r3 — load &dispatch_table_ptr */
    .byte   0xD7, 0x0F    /* mov.l .L_dispatch_data_ptr, r7 — load data pointer for dispatch */
    mov.l @r3, r3                       ! r3 = *dispatch_table_ptr (actual dispatch table)
    mov.l @(28, r3), r2                 ! r2 = dispatch_table[7] (vtable slot 7, offset +28)
    jsr @r2                             ! call vtable_slot7(r6=0x10, r7=data_ptr)
    mov #0x10, r6                       ! (delay) r6 = 0x10 (parameter for dispatch)
    mov r0, r6                          ! r6 = dispatch result (saved across RESENAB)
/* --- SMPC sync: wait for SF ready, issue RESENAB (0x19) command --- */
.L_poll_sf_resenab:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend to 32 bits
    and r14, r2                         ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                      ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_resenab          ! spin while SMPC is busy
    extu.b r14, r2                      ! r2 = 1 (SF busy flag value)
    mov.b r2, @r13                      ! SF = 1 (set busy before issuing new command)
    mov #0x19, r3                       ! 0x19 = SMPC RESENAB command (Reset Enable)
    .byte   0xD2, 0x06    /* mov.l .L_smpc_comreg_ct, r2 */
    mov.b r3, @r2                       ! write RESENAB command to COMREG
/* --- Wait for RESENAB completion, then return --- */
.L_poll_resenab_done:
    mov.b @r13, r2                      ! read SMPC SF register
    extu.b r2, r2                       ! zero-extend to 32 bits
    and r14, r2                         ! isolate bit 0 (busy flag)
    tst r2, r2                          ! SF.bit0 == 0? (command completed)
    bf      .L_poll_resenab_done        ! spin while busy
    mov r6, r0                          ! r0 = dispatch result (return value)
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r14                    ! (delay) restore r14
/* --- Constant pool --- */
.L_smpc_sf:
    .4byte  0x20100063                  /* SMPC SF — status flag */
.L_smpc_comreg_ct:
    .4byte  0x2010001F                  /* SMPC COMREG (cache-through) */
.L_dispatch_table_ptr:
    .4byte  sym_06000354                /* function dispatch table pointer */
.L_dispatch_data_ptr:
    .4byte  sym_060870F4                /* data pointer passed as r7 to dispatch */
