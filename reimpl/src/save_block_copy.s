/* save_block_copy -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BAC6 - 0x0603BB86
 * Auto-generated by tools/generate_l3_tu.py
 *
 * save_block_copy -- Validate and copy a save block from storage
 *
 * Tests whether save conditions are met via evt_condition_test. If not,
 * returns 0 immediately. Otherwise, resolves the save region base address
 * through evt_boundary_check, adding offset 0x00A6. Builds a 16-byte
 * local descriptor on the stack:
 *   [+0]  = base address (boundary_result + 0x00A6)
 *   [+4]  = block size (0x0800)
 *   [+8]  = 0 (status byte 0)
 *   [+9]  = 0 (status byte 1)
 *   [+10] = 0 (status byte 2)
 *   [+11] = 0 (status byte 3)
 *
 * Allocates a buffer slot, writes the descriptor via save_field_write,
 * then validates the written data via cmd_multi_validate. If validation
 * returns the expected block size (0x0800), sets result to 1 (success).
 * Finally commits via save_commit_write and returns the result.
 *
 * Args:
 *   r4 = pointer to save block context (stored at sp[0])
 *
 * Returns:
 *   r0 = 1 on success (block copied and validated)
 *        0 on failure (condition test failed or write error)
 *
 * Calls:
 *   evt_condition_test     (0x06040680)  -- check save preconditions
 *   evt_boundary_check     (cross-TU pool at 0x0603BBB8) -- resolve save region
 *   buffer_slot_alloc      (0x0603B81E)  -- allocate buffer slot
 *   save_field_write       (0x0603BA2C)  -- write descriptor to save block
 *   cmd_multi_validate     (0x0603B21C)  -- validate written data
 *   save_commit_write      (0x0603BF22)  -- commit save to storage
 *
 * Pool references:
 *   .L_pool_evt_condition_test -- evt_condition_test function pointer
 *   .L_pool_0603BBB8 (cross-TU) -- evt_boundary_check function pointer
 *   .L_wpool_0603BBB0 (cross-TU) -- 0x00A6: offset from boundary to save region
 *   .L_wpool_0603BBB2 (cross-TU) -- 0x0800: save block size
 */

    .section .text.FUN_0603BAC6


    .global save_block_copy
    .type save_block_copy, @function
save_block_copy:
    mov.l r14, @-r15                            ! save r14 (callee-saved, will hold write result ptr)
    mov.l r13, @-r15                            ! save r13 (callee-saved, will hold alloc handle)
    mov #0x0, r14                               ! r14 = 0 (init result flag to failure)
    mov.l r12, @-r15                            ! save r12 (callee-saved, will hold success flag)
    mov.l r11, @-r15                            ! save r11 (callee-saved, will hold block size 0x0800)
    mov.l r8, @-r15                             ! save r8 (callee-saved, will hold descriptor ptr)
    sts.l pr, @-r15                             ! save return address
    add #-0x10, r15                             ! allocate 16 bytes of stack frame
    mov.l r4, @r15                              ! sp[0] = save block context pointer (original arg)
    .byte   0xD3, 0x0B    /* mov.l .L_pool_evt_condition_test, r3 */  ! r3 = &evt_condition_test
    jsr @r3                                     ! call evt_condition_test()
    mov r14, r12                                ! (delay) r12 = 0 (init success flag)
    tst r0, r0                                  ! test result: conditions met?
    bf      .L_condition_passed                 ! if nonzero, conditions passed -- continue
    bra     .L_epilogue                         ! conditions failed -- return 0
    mov #0x0, r0                                ! (delay) r0 = 0 (return failure)

    .global DAT_0603bae6
DAT_0603bae6:
    mov.b r13, @(r0, r0)                       ! data: embedded function pointer table (not executed)
    .4byte  sym_0603EF34                        ! data: function pointer entry 0
    .4byte  sym_0603F070                        ! data: function pointer entry 1
    .4byte  sym_0603F036                        ! data: function pointer entry 2
    .4byte  sym_0603EFE6                        ! data: function pointer entry 3
    .4byte  sym_0603EFD4                        ! data: function pointer entry 4
    .4byte  attract_init_setup                  ! data: function pointer entry 5
    .4byte  sym_0603F8B8                        ! data: function pointer entry 6
    .4byte  attract_replay_loader               ! data: function pointer entry 7
.L_pool_evt_condition_test:
    .4byte  evt_condition_test                  ! pool: evt_condition_test function address
.L_condition_passed:
    mov r15, r3                                 ! r3 = stack pointer
    add #0x4, r3                                ! r3 = sp+4 (local descriptor buffer)
    mov r3, r8                                  ! r8 = descriptor ptr (saved for later stores)
    .byte   0xD3, 0x29    /* mov.l .L_pool_0603BBB8, r3 */  ! r3 = &evt_boundary_check (cross-TU pool)
    jsr @r3                                     ! call evt_boundary_check()
    nop                                         ! delay slot
    .byte   0x92, 0x4A    /* mov.w .L_wpool_0603BBB0, r2 */  ! r2 = 0x00A6 (save region offset)
    mov r15, r3                                 ! r3 = stack pointer
    add r2, r0                                  ! r0 = boundary_result + 0x00A6 (save region base)
    add #0x4, r3                                ! r3 = sp+4 (descriptor buffer)
    mov.l r0, @r8                               ! descriptor[+0] = save region base address
    mov r15, r2                                 ! r2 = stack pointer
    .byte   0x9B, 0x45    /* mov.w .L_wpool_0603BBB2, r11 */  ! r11 = 0x0800 (save block size)
    add #0x4, r2                                ! r2 = sp+4 (descriptor buffer)
    mov.l r11, @(4, r3)                         ! descriptor[+4] = 0x0800 (block size)
    extu.b r14, r3                              ! r3 = 0 (zero-extend r14 byte, r14=0)
    mov r3, r0                                  ! r0 = 0
    mov r15, r3                                 ! r3 = stack pointer
    mov.b r0, @(10, r2)                         ! descriptor[+10] = 0 (clear status byte 2)
    add #0x4, r3                                ! r3 = sp+4 (descriptor buffer)
    extu.b r14, r0                              ! r0 = 0
    mov.b r0, @(11, r3)                         ! descriptor[+11] = 0 (clear status byte 3)
    mov r15, r3                                 ! r3 = stack pointer
    extu.b r14, r0                              ! r0 = 0
    add #0x4, r3                                ! r3 = sp+4 (descriptor buffer)
    mov.b r0, @(8, r3)                          ! descriptor[+8] = 0 (clear status byte 0)
    mov r15, r3                                 ! r3 = stack pointer
    extu.b r14, r0                              ! r0 = 0
    add #0x4, r3                                ! r3 = sp+4 (descriptor buffer)
    mov.b r0, @(9, r3)                          ! descriptor[+9] = 0 (clear status byte 1)
    .byte   0xBE, 0x69    /* bsr 0x0603B81E (external) */  ! call buffer_slot_alloc()
    nop                                         ! delay slot
    mov r0, r13                                 ! r13 = allocated buffer slot handle
    mov #0x0, r6                                ! r6 = 0 (flags: no special options)
    mov r15, r5                                 ! r5 = stack pointer
    add #0x4, r5                                ! r5 = sp+4 (descriptor buffer as source)
    .byte   0xBF, 0x6A    /* bsr 0x0603BA2C (external) */  ! call save_field_write(slot, descriptor, flags)
    mov r0, r4                                  ! (delay) r4 = slot handle
    mov r0, r14                                 ! r14 = write result (data pointer or 0)
    tst r14, r14                                ! write succeeded?
    bt      .L_commit                           ! if zero (failed), skip validation -- go to commit
    mov r11, r7                                 ! r7 = 0x0800 (expected block size)
    mov #0x1, r5                                ! r5 = 1 (validation mode flag)
    mov.l @r15, r6                              ! r6 = sp[0] (original save block context pointer)
    .byte   0xBB, 0x5A    /* bsr 0x0603B21C (external) */  ! call cmd_multi_validate(result, mode, context, size)
    mov r14, r4                                 ! (delay) r4 = write result
    cmp/eq r11, r0                              ! validate result == 0x0800 (expected size)?
    bf      .L_commit                           ! if mismatch, validation failed -- skip success
    mov #0x1, r12                               ! r12 = 1 (mark success)
.L_commit:
    mov r14, r5                                 ! r5 = write result (field data pointer)
    .byte   0xB1, 0xD7    /* bsr 0x0603BF22 (external) */  ! call save_commit_write(alloc_handle, field_data)
    mov r13, r4                                 ! (delay) r4 = allocated slot handle
    mov r12, r0                                 ! r0 = success flag (0 or 1)
.L_epilogue:
    add #0x10, r15                              ! deallocate stack frame
    lds.l @r15+, pr                             ! restore return address
    mov.l @r15+, r8                             ! restore r8
    mov.l @r15+, r11                            ! restore r11
    mov.l @r15+, r12                            ! restore r12
    mov.l @r15+, r13                            ! restore r13
    rts                                         ! return to caller
    mov.l @r15+, r14                            ! (delay) restore r14
