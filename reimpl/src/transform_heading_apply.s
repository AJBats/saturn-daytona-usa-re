/* transform_heading_apply -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060262C0 - 0x06026362
 * Auto-generated by tools/generate_l3_tu.py
 *
 * For each of up to 10 opponent slots (skipping the one at r4), reads the
 * slot's heading word (+6 in the 8-byte slot_data entry), subtracts 0x8A,
 * and dispatches through a 12-entry switch table to classify the heading
 * into course_id_a (sym_06089ED6) or course_id_b (sym_06089ED4).
 *
 * Argument:
 *   r4 = skip_slot  â€” index of the player-selected slot to skip
 *
 * Persistent registers:
 *   r10 = slot_data_table base (sym_06060F2C, 8-byte stride)
 *   r12 = 10 (slot count limit)
 *   r13 = &course_id_a (sym_06089ED6, written as word)
 *   r14 = &course_id_b (sym_06089ED4, written as word)
 *   r7  = 1 (heading class 1 constant)
 *   r6  = 2 (heading class 2 constant)
 *   r5  = current slot index (loop variable, 0..9)
 *
 * Jump table (12 entries, heading_adjusted 0..11):
 *   0,1  -> course_id_a = 1
 *   2,3  -> course_id_a = slot_idx; course_id_b = 1
 *   4-7  -> course_id_a = 2
 *   8-11 -> course_id_b = 2
 */

    .section .text.FUN_060262C0


    .global transform_heading_apply
    .type transform_heading_apply, @function
transform_heading_apply:
    mov.l r14, @-r15                        ! save r14 (callee-saved)
    mov.l r13, @-r15                        ! save r13 (callee-saved)
    mov.l r12, @-r15                        ! save r12 (callee-saved)
    mov.l r10, @-r15                        ! save r10 (callee-saved)
    mov.l   .L_pool_slot_data_table, r10    ! r10 = slot_data_table base (sym_06060F2C)
    mov #0xA, r12                           ! r12 = 10 (slot count limit)
    mov.l   .L_pool_course_id_a_ptr, r13    ! r13 = &course_id_a (sym_06089ED6)
    mov.l   .L_pool_course_id_b_ptr, r14    ! r14 = &course_id_b (sym_06089ED4)
    mov #0x1, r7                            ! r7 = 1 (heading class 1 constant)
    mov #0x2, r6                            ! r6 = 2 (heading class 2 constant)
    mov #0x0, r0                            ! r0 = 0 (zero initializer)
    extu.w r0, r3                           ! r3 = 0 (zero-extended for course_id_a init)
    mov.w r3, @r13                          ! course_id_a = 0 (clear output)
    extu.w r0, r2                           ! r2 = 0 (zero-extended for course_id_b init)
    mov.w r2, @r14                          ! course_id_b = 0 (clear output)
    bra     .L_loop_check                   ! enter loop at condition check
    extu.w r0, r5                           ! [delay] r5 = 0 (slot index = 0, loop start)
.L_loop_body:                              ! === Per-slot heading classification ===
    extu.w r5, r2                           ! r2 = slot_idx (zero-extended word)
    cmp/eq r4, r2                           ! slot_idx == skip_slot?
    bf      .L_not_skip_slot               ! no -> process this slot
    bra     .L_loop_next                   ! yes -> skip: increment and loop
    nop
.L_not_skip_slot:                          ! === Compute slot_data entry offset ===
    extu.w r5, r0                           ! r0 = slot_idx (zero-extended)
    shll2 r0                                ! r0 = slot_idx * 4
    shll r0                                 ! r0 = slot_idx * 8 (8-byte stride)
    add r10, r0                             ! r0 -> slot_data_table[slot_idx]
    mov.w @(6, r0), r0                      ! r0 = heading word (slot_data[slot_idx]+6)
    bra     .L_dispatch_heading            ! jump to switch dispatch
    extu.w r0, r0                           ! [delay] r0 = heading (zero-extended word)
    .2byte  0xA001                          /* bra .L_case_23_store_id_b: store then bra loop */
    .4byte  0x627D626D                      /* extu.w r7,r2 / extu.w r6,r2 */
    .4byte  0xA0262D21                      /* bra .L_loop_next / mov.w r2,@r13 [delay] */
    .4byte  0xA001627D                      /* bra .L_case_811_store_id_b: bra / extu.w r7,r2 [delay] */
    .4byte  0x626DA021                      /* extu.w r6,r2 / bra .L_loop_next */
    .2byte  0x2E21                          /* mov.w r2,@r14 [delay: store r2 to course_id_b] */
.L_out_of_range:                           ! heading out of jump table bounds -> skip slot
    bra     .L_loop_next                   ! skip classification, continue loop
    nop
    .2byte  0xFFFF                          /* alignment padding */
.L_pool_slot_data_table:
    .4byte  sym_06060F2C                    /* [MEDIUM] slot_data_table base (8-byte stride, up to 10 slots) */
.L_pool_course_id_a_ptr:
    .4byte  sym_06089ED6                    /* [HIGH] &course_id_a (word) */
.L_pool_course_id_b_ptr:
    .4byte  sym_06089ED4                    /* [HIGH] &course_id_b (word) */
.L_dispatch_heading:                       ! === Switch: heading_adjusted -> course id ===
    mov.w   .L_wpool_heading_base, r1           ! r1 = 0x008A (heading base offset)
    sub r1, r0                              ! r0 = heading - 0x8A (adjusted index)
    mov #0xC, r1                            ! r1 = 12 (table size)
    cmp/hs r1, r0                           ! heading_adjusted >= 12? (unsigned)
    bt      .L_out_of_range               ! yes -> out of range, skip slot
    shll r0                                 ! r0 = adjusted_index * 2 (word offset into table)
    mov r0, r1                              ! r1 = adjusted_index * 2 (index copy)
    .word 0xC702 /* UNKNOWN */              /* mova @(0x8,PC),r0 -> r0 = base of jump offset table */
    mov.w @(r0, r1), r0                     ! r0 = signed jump offset from table[adjusted_index]
    braf r0                                 ! PC-relative indirect branch -> dispatch case
    nop
.L_wpool_heading_base:
    .2byte  0x008A                          /* [HIGH] heading base value to subtract (0x8A) */
    .4byte  0xFFC4FFC4                      /* jump offsets: index 0 (-60), index 1 (-60) -> course_id_a=1 */
    .4byte  0xFFCEFFCE                      /* jump offsets: index 2 (-50), index 3 (-50) -> course_id_a=slot_idx, course_id_b=1 */
    .4byte  0xFFC8FFC8                      /* jump offsets: index 4 (-56), index 5 (-56) -> course_id_a=2 */
    .4byte  0xFFC8FFC8                      /* jump offsets: index 6 (-56), index 7 (-56) -> course_id_a=2 */
    .4byte  0xFFD2FFD2                      /* jump offsets: index 8 (-46), index 9 (-46) -> course_id_b=2 */
    .4byte  0xFFD2FFD2                      /* jump offsets: index 10 (-46), index 11 (-46) -> course_id_b=2 */
.L_loop_next:                              ! === Loop increment ===
    add #0x1, r5                            ! slot_idx++
.L_loop_check:                             ! === Loop condition ===
    extu.w r5, r2                           ! r2 = slot_idx (zero-extended)
    cmp/ge r12, r2                          ! r2 >= 10 (slot_limit)?
    bf      .L_loop_body                   ! no -> process next slot
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! [delay] restore r14
