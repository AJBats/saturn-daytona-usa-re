/* anim_data_loader -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601B6F0 - 0x0601B7F4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Animation frame selection and display list loader for car models.
 *
 * Called from disc_anim_data_load, which pre-sets callee-saved registers:
 *   r8  = 1 (default frame select value for non-button case)
 *   r10 = 3 (number of cars to process)
 *   r13 = 2 (frame counter reset/wrap value)
 *
 * Copies two 3-byte animation timing lookup tables from ROM to the stack
 * via memcpy_byte:
 *   stack[+8..+10] = sym_0605DF20 (frame count table: 0x10, 0x10, 0x10)
 *   stack[+4..+6]  = sym_0605DF23 (texture slot table: 0x05, 0x12, 0x18)
 *
 * Reads input button state from g_pad_state (+2 = button flags word):
 *   - Bit 12 (0x1000) pressed: decrement frame counter at sym_0608600E;
 *     if counter goes negative, wrap to r13 (=2).
 *   - Bit 13 (0x2000) pressed: increment frame counter at sym_0608600E;
 *     if counter >= r10 (=3), wrap to 0.
 *   - Neither bit set: counter unchanged.
 *
 * Then loops over r10 cars (indices 0..2). For each car:
 *   1. Checks if the car index matches the current frame counter;
 *      if so, reads texture_load_state (sym_0605D4F8) bit 2 to pick
 *      between r8 (=1) or r13 (=2) as the frame select value.
 *      Non-matching cars always use r13 (=2).
 *   2. Computes a display list table offset from the frame select value
 *      and the texture slot from the stack lookup table.
 *   3. Reads the frame count from the stack lookup table to compute
 *      the animation data source offset.
 *   4. Looks up the car's display list base from the car object table
 *      (sym_06063750), then calls display_list_loader (sym_06028400)
 *      with mode 0x8 to transfer the animation data.
 *
 * Key symbols:
 *   sym_0608600E  = frame counter byte (current animation frame selection)
 *   sym_0605DF20  = frame count table (3 bytes: per-car frame counts)
 *   sym_0605DF23  = texture slot table (3 bytes: per-car slot indices)
 *   sym_06035228  = memcpy_byte(r0=count, r1=dst, r2=src)
 *   g_pad_state  = input button state struct (+2 = button flags word)
 *   sym_0605D4F8  = texture load state flags (word)
 *   sym_06063750  = car object table base (per-car struct, 8 bytes each)
 *   sym_06028400  = display_list_loader(r4=mode, r5=dlist_base, r6=src_offset, r7=tex_data)
 */

    .section .text.FUN_0601B6F0


    .global anim_data_loader
    .type anim_data_loader, @function
anim_data_loader:
    sts.l pr, @-r15                         ! save return address
    add #-0xC, r15                          ! allocate 12 bytes on stack (3 locals)
    mov.l   _pool_frame_counter_ptr, r12    ! r12 -> &frame_counter byte (sym_0608600E)
    mov r15, r1                             ! r1 = sp (memcpy dst base)
    mov.l   _pool_frame_count_table, r2     ! r2 -> frame count table (sym_0605DF20, 3 bytes)
    mov.l   _pool_memcpy_byte, r3           ! r3 -> memcpy_byte function (sym_06035228)
    add #0x8, r1                            ! r1 = sp+8 (dst for frame count table)
    jsr @r3                                 ! call memcpy_byte(r0=3, r1=sp+8, r2=src)
    mov r10, r0                             ! r0 = 3 (byte count) (delay slot)
    mov r15, r1                             ! r1 = sp (memcpy dst base)
    mov.l   _pool_tex_slot_table, r2        ! r2 -> texture slot table (sym_0605DF23, 3 bytes)
    mov.l   _pool_memcpy_byte, r3           ! r3 -> memcpy_byte function
    add #0x4, r1                            ! r1 = sp+4 (dst for texture slot table)
    jsr @r3                                 ! call memcpy_byte(r0=3, r1=sp+4, r2=src)
    mov r10, r0                             ! r0 = 3 (byte count) (delay slot)
    mov.l   _pool_input_state_ptr, r4       ! r4 -> input button state struct (g_pad_state)
    mov.w   DAT_0601b76c, r3                ! r3 = 0x1000 (button bit 12: anim frame down)
    mov.w @(2, r4), r0                      ! r0 = button_flags word (struct +2)
    mov r0, r2                              ! r2 = button_flags (copy)
    extu.w r2, r2                           ! r2 = zero-extend to 32-bit
    and r3, r2                              ! r2 = button_flags & 0x1000 (isolate bit 12)
    tst r2, r2                              ! test if bit 12 is clear
    bt      .check_btn_up                   ! if bit 12 clear: check the other button
    /* --- Bit 12 set: decrement frame counter --- */
    mov.b @r12, r3                          ! r3 = current frame counter
    add #-0x1, r3                           ! r3-- (decrement)
    mov.b r3, @r12                          ! store decremented counter
    exts.b r3, r3                           ! sign-extend to test negative
    cmp/pz r3                               ! test counter >= 0
    bt      .begin_car_loop                 ! if non-negative: proceed to car loop
    /* counter went negative — wrap to r13 (=2) */
    exts.b r13, r3                          ! r3 = 2 (wrap value, sign-extended)
    mov.b r3, @r12                          ! store wrapped counter
    bra     .begin_car_loop                 ! proceed to car loop
    nop                                     ! delay slot
.check_btn_up:
    /* --- Check bit 13 (0x2000): increment frame counter --- */
    mov.w @(2, r4), r0                      ! r0 = button_flags word (re-read)
    mov.w   DAT_0601b76e, r3                ! r3 = 0x2000 (button bit 13: anim frame up)
    mov r0, r2                              ! r2 = button_flags (copy)
    extu.w r2, r2                           ! r2 = zero-extend to 32-bit
    and r3, r2                              ! r2 = button_flags & 0x2000 (isolate bit 13)
    tst r2, r2                              ! test if bit 13 is clear
    bt      .begin_car_loop                 ! if bit 13 clear: no button pressed, skip
    /* --- Bit 13 set: increment frame counter --- */
    mov.b @r12, r3                          ! r3 = current frame counter
    add #0x1, r3                            ! r3++ (increment)
    mov.b r3, @r12                          ! store incremented counter
    exts.b r3, r3                           ! sign-extend for comparison
    cmp/ge r10, r3                          ! test counter >= 3 (num_cars)
    bf      .begin_car_loop                 ! if counter < 3: proceed
    /* counter hit max — wrap to 0 */
    mov #0x0, r3                            ! r3 = 0 (reset)
    mov.b r3, @r12                          ! store reset counter
.begin_car_loop:
    mov #0x0, r14                           ! r14 = 0 (car loop index)
.car_loop_top:
    /* --- Per-car loop body: select frame and load display list --- */
    extu.b r14, r3                          ! r3 = car_index (zero-extended)
    mov.b @r12, r2                          ! r2 = current frame counter
    cmp/eq r3, r2                           ! test car_index == frame_counter
    bf      .car_not_selected               ! if not matching: use default frame select
    /* --- This car matches the frame counter --- */
    mov.l   _pool_tex_load_state, r0        ! r0 -> texture_load_state flags (sym_0605D4F8)
    mov.w @r0, r0                           ! r0 = texture_load_state word
    extu.w r0, r0                           ! r0 = zero-extend to 32-bit
    tst #0x4, r0                            ! test bit 2 of load_state
    bt      .use_default_frame              ! if bit 2 clear: use r13 (=2)
    bra     .frame_selected                 ! bit 2 set: use r8 (=1)
    extu.b r8, r11                          ! r11 = 1 (frame select from r8) (delay slot)
.use_default_frame:
    bra     .frame_selected                 ! use r13 (=2) as frame select
    extu.b r13, r11                         ! r11 = 2 (frame select from r13) (delay slot)

    .global DAT_0601b76c
DAT_0601b76c:
    .2byte  0x1000

    .global DAT_0601b76e
DAT_0601b76e:
    .2byte  0x2000
_pool_frame_counter_ptr:
    .4byte  sym_0608600E
_pool_frame_count_table:
    .4byte  sym_0605DF20
_pool_memcpy_byte:
    .4byte  sym_06035228
_pool_tex_slot_table:
    .4byte  sym_0605DF23
_pool_input_state_ptr:
    .4byte  g_pad_state
_pool_tex_load_state:
    .4byte  sym_0605D4F8
.car_not_selected:
    /* car_index != frame_counter: always use r13 (=2) */
    extu.b r13, r11                         ! r11 = 2 (default frame select)
.frame_selected:
    /* --- Compute display list table offset and source data offset --- */
    extu.b r11, r7                          ! r7 = frame_select (1 or 2)
    extu.b r14, r2                          ! r2 = car_index
    extu.b r14, r9                          ! r9 = car_index (saved copy)
    mov r15, r6                             ! r6 = sp (stack base for table lookups)
    shll8 r7                                ! r7 = frame_select << 8
    add #0x36, r2                           ! r2 = car_index + 0x36 (table base offset)
    add #0x4, r6                            ! r6 = sp+4 (texture slot table on stack)
    shll2 r7                                ! r7 = frame_select << 10
    mov r2, r3                              ! r3 = car_index + 0x36
    add r9, r6                              ! r6 = sp+4+car_index (tex slot for this car)
    shll2 r7                                ! r7 = frame_select << 12 (0x1000 or 0x2000)
    shll2 r3                                ! r3 = (car_index + 0x36) << 2
    mov.l   _pool_car_obj_table, r2         ! r2 -> car object table (sym_06063750)
    shll r3                                 ! r3 = (car_index + 0x36) << 3 (8-byte struct stride)
    add r3, r2                              ! r2 -> car_obj_table[car_index + 0x36]
    mov.l r2, @r15                          ! stack[0] = &car_obj_entry (save for later)
    mov.l @(4, r2), r3                      ! r3 = car_obj_entry.field4 (dlist data offset)
    mov.b @r6, r6                           ! r6 = tex_slot_table[car_index] (byte)
    add r3, r7                              ! r7 = (frame_select << 12) + dlist_data_offset
    extu.b r6, r6                           ! r6 = tex_slot (zero-extended)
    mov r15, r3                             ! r3 = sp (stack base)
    shll2 r6                                ! r6 = tex_slot << 2
    add #0x8, r3                            ! r3 = sp+8 (frame count table on stack)
    shll2 r6                                ! r6 = tex_slot << 4
    add r9, r3                              ! r3 = sp+8+car_index (frame count for this car)
    shll2 r6                                ! r6 = tex_slot << 6
    mov.b @r3, r2                           ! r2 = frame_count_table[car_index] (byte)
    extu.b r2, r2                           ! r2 = frame_count (zero-extended)
    add r2, r6                              ! r6 = (tex_slot << 6) + frame_count
    shll r6                                 ! r6 = ((tex_slot << 6) + frame_count) << 1 (word offset)
    mov.l @r15, r5                          ! r5 = &car_obj_entry (reload from stack)
    mov.l @r5, r5                           ! r5 = car_obj_entry.field0 (dlist base ptr)
    mov.l   _pool_dlist_loader, r3          ! r3 -> display_list_loader (sym_06028400)
    jsr @r3                                 ! call display_list_loader(r4=0x8, r5=dlist_base, r6=src_off, r7=tex_data)
    mov #0x8, r4                            ! r4 = 0x8 (copy mode) (delay slot)
    /* --- Advance to next car --- */
    add #0x1, r14                           ! r14++ (next car index)
    extu.b r14, r2                          ! r2 = car_index (zero-extended)
    cmp/ge r10, r2                          ! test car_index >= 3 (num_cars)
    bf      .car_loop_top                   ! if more cars: loop back
    /* --- Epilogue: deallocate stack and restore callee-saved regs --- */
    add #0xC, r15                           ! deallocate 12 bytes of stack locals
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r8                         ! restore r8
    mov.l @r15+, r9                         ! restore r9
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
_pool_car_obj_table:
    .4byte  sym_06063750
_pool_dlist_loader:
    .4byte  sym_06028400
