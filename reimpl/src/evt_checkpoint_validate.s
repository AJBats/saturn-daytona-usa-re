/* evt_checkpoint_validate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060412B2 - 0x06041330
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Registers a checkpoint validation request into the game state struct.
 *
 * Checks whether the checkpoint slot (+0x0338) is already occupied and
 * whether the lock flag (+0x34) is set. If either guard fails, returns
 * an error code. Otherwise, locks the slot, stores the caller's key,
 * sub-param, and value into consecutive fields, then delegates to
 * ai_checkpoint_validate for the actual AI-level processing.
 *
 * Arguments:
 *   r4 = checkpoint key (event identifier)
 *   r5 = sub-parameter (usually 0)
 *   r6 = checkpoint value / mask
 *
 * Game state struct layout (base = *sym_060A5400):
 *   +0x0034 (52)   lock flag: 0 = free, 1 = locked
 *   +0x0338        validation slot (0 = empty, 1 = active)
 *   +0x033C        stored key (r4)
 *   +0x0340        stored sub-param (r5)
 *   +0x0344        stored value (r6)
 *
 * Returns:
 *   r0 =  0  success (checkpoint registered)
 *   r0 = -1  slot already occupied
 *   r0 = -5  lock flag already set
 *
 * Calls: ai_checkpoint_validate
 */

    .section .text.FUN_060412B2


    .global evt_checkpoint_validate
    .type evt_checkpoint_validate, @function
evt_checkpoint_validate:
    sts.l pr, @-r15                          ! save return address
    add #-0x4, r15                           ! allocate 4 bytes for local stack frame
    .byte   0xD7, 0x15    /* mov.l .L_pool_state_base_ptr, r7 */ ! r7 = &sym_060A5400 (ptr to game state base)
    mov.w   .L_wpool_06041306, r0            ! r0 = 0x0338 (offset of validation slot)
    mov.l @r7, r3                            ! r3 = game state base pointer
    mov.l @(r0, r3), r0                      ! r0 = state[+0x0338] (validation slot contents)
    tst r0, r0                               ! is validation slot empty (== 0)?
    bt      .L_slot_free                     ! yes — slot is free, continue
    add #0x4, r15                            ! no — deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return early
    mov #-0x1, r0                            ! return -1: slot already occupied (delay slot)
.L_slot_free:
    mov.l @r7, r0                            ! r0 = game state base pointer
    mov.l @(52, r0), r0                      ! r0 = state[+0x34] (lock flag)
    cmp/eq #0x1, r0                          ! is lock flag already set?
    bf      .L_register_checkpoint           ! no — proceed to register
    add #0x4, r15                            ! yes — deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return early
    mov #-0x5, r0                            ! return -5: already locked (delay slot)
.L_register_checkpoint:
    mov #0x1, r3                             ! r3 = 1 (lock / active marker)
    mov.l @r7, r2                            ! r2 = game state base pointer
    mov.l r3, @(52, r2)                      ! state[+0x34] = 1 (set lock flag)
    mov.l @r7, r2                            ! r2 = game state base pointer (reload)
    mov.w   .L_wpool_06041306, r0            ! r0 = 0x0338 (validation slot offset)
    mov.l r3, @(r0, r2)                      ! state[+0x0338] = 1 (mark slot active)
    add #0x4, r0                             ! r0 = 0x033C (key field offset)
    mov.l @r7, r3                            ! r3 = game state base pointer (reload)
    mov.l r4, @(r0, r3)                      ! state[+0x033C] = r4 (store checkpoint key)
    mov.l @r7, r3                            ! r3 = game state base pointer (reload)
    add #0x4, r0                             ! r0 = 0x0340 (sub-param field offset)
    mov.l r5, @(r0, r3)                      ! state[+0x0340] = r5 (store sub-parameter)
    add #0x4, r0                             ! r0 = 0x0344 (value field offset)
    mov.l @r7, r3                            ! r3 = game state base pointer (reload)
    mov.l r6, @(r0, r3)                      ! state[+0x0344] = r6 (store checkpoint value)
    .byte   0xB5, 0x38    /* bsr 0x06041D6C (external) */ ! call ai_checkpoint_validate
    mov r15, r4                              ! r4 = stack pointer (output buffer, delay slot)
    mov #0x0, r0                             ! r0 = 0 (success return value)
    add #0x4, r15                            ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return to caller
    nop                                      ! delay slot (no work needed)
.L_wpool_06041306:
    .2byte  0x0338
    .4byte  ai_checkpoint_validate
.L_pool_state_base_ptr:
    .4byte  sym_060A5400
    .4byte  0xD5149025
    .4byte  0x6352003E
    .4byte  0x20088906
    .4byte  0x63529020
    .4byte  0x023E3240
    .4byte  0x8B01000B
    .4byte  0xE000E001
    .4byte  0x000B0009
