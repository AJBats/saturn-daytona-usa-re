/* scene_render_alt -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06027EDE - 0x0602834A
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Scene rendering — alternate plane visibility checker.
 *
 * scene_render_alt (FUN_06027EDE):
 *   Tests up to 4 rendering planes (X/Y/Z/W) for visibility against
 *   a scale factor and offset.  For each plane, computes:
 *     result = (scale * coeff) >> 16 + offset [+ camera_offset]
 *   If result < 0, the plane is culled.  If all 4 pass, the object
 *   is visible and gets an interpolated position written out.
 *   Two code paths: mode 2 (special car list lookup) vs normal
 *   (direct index into tile set tables).
 *
 * sym_060280C4: VDP1 command builder — copies 7-field display cmd
 *   from a source struct to a destination cmd slot.
 *
 * sym_060280F8: VDP1 command setup — builds a display command from
 *   object data with texture index lookup and color bank selection.
 *
 * sym_06028218 / sym_06028230 / sym_06028248: Interrupt-context
 *   display list builders — push all regs, build VDP1 command
 *   chains, then loop-halt via sett+bt and rte.
 *
 * Data at end (0x060282C0+): raw VDP1 command table entries
 *   (opaque byte blobs, not disassembled).
 */

    .section .text.FUN_06027EDE


    .global scene_render_alt
    .type scene_render_alt, @function
scene_render_alt:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    mov.l r6, @-r15                    ! save r6 (output ptr, restored later)
    mov r5, r13                         ! r13 = param struct ptr
    mov.l @r5, r14                      ! r14 = scale factor
    mov.l @(8, r5), r12                 ! r12 = camera offset
    .byte   0xDB, 0x07    /* mov.l .L_tile_index_table, r11 */
    .byte   0xDA, 0x08    /* mov.l .L_tile_data_base, r10 */
    .byte   0xD0, 0x08    /* mov.l .L_race_mode_ptr, r0 */
    mov.l @r0, r0                       ! r0 = race mode
    cmp/eq #0x2, r0                     ! mode == 2? (special car lookup)
    bt      .L_mode2_car_lookup
    mov r4, r0                          ! normal path: index into tile table
    shll r0                             ! r0 = r4 * 2
    add #0x1, r0                        ! r0 = r4 * 2 + 1
    shll r0                             ! r0 = (r4 * 2 + 1) * 2
    mov.w @(r0, r11), r9               ! r9 = plane count
    mov r4, r0
    shll2 r0                            ! r0 = r4 * 4
    mov.w @(r0, r11), r8               ! r8 = start index (packed)
    bra     .L_start_plane_loop
    shlr r8                             ! r8 >>= 1 (unpack)
.L_tile_index_table:
    .4byte  sym_060C2000                ! tile set C index table
.L_tile_data_base:
    .4byte  sym_060BF000                ! tile set B data base
.L_race_mode_ptr:
    .4byte  sym_0607EAD8                ! race end state (0/1/2)
.L_mode2_car_lookup:                    ! mode 2: search car ID list
    .byte   0xD1, 0x04    /* mov.l .L_car_id_list, r1 */
    xor r9, r9                          ! r9 = byte offset into list (0)
.L_scan_car_list:
    mov.w @r1+, r0                      ! r0 = next car ID from list
    tst r0, r0                          ! end of list? (0 terminator)
    bt      .L_car_not_found
    cmp/eq r0, r4                       ! match our car ID?
    bt      .L_car_id_found
    bra     .L_scan_car_list
    add #0x2, r9                        ! advance offset (delay slot)
    .2byte  0x0000
.L_car_id_list:
    .4byte  sym_06061270                ! car ID lookup table (word-per-entry, 0-terminated)
.L_car_id_found:
    .byte   0xD1, 0x07    /* mov.l .L_car_struct_ptr, r1 */
    mov.l @r1, r1                       ! r1 = car struct base
    mov.w   DAT_06027f56, r0            ! r0 = 0x01EC (offset to frame counter)
    mov.l @(r0, r1), r1                 ! r1 = car_struct[0x1EC]
    mov #0x46, r0                       ! threshold = 0x46
    cmp/gt r0, r1                       ! frame count > 0x46?
    bt      .L_car_not_found            ! too old, skip this car
    shll r9                             ! r9 *= 2 (word offset -> dword offset)
    .byte   0xD0, 0x04    /* mov.l .L_car_render_table, r0 */
    add r9, r0                          ! index into render table
    .byte   0xD1, 0x04    /* mov.l .L_active_cmd_slot, r1 */
    mov.w @r0+, r2                      ! r2 = first render param
    mov.w @r0, r9                       ! r9 = plane count (override)
    bra     .L_check_override
    mov.w r2, @r1                       ! write cmd slot selector

    .global DAT_06027f56
DAT_06027f56:
    .2byte  0x01EC                      ! offset to frame counter in car struct
.L_car_struct_ptr:
    .4byte  sym_0607E940                ! current car struct pointer
.L_car_render_table:
    .4byte  sym_06061240                ! car render parameter table
.L_active_cmd_slot:
    .4byte  sym_06063F50                ! active VDP1 command slot
.L_car_not_found:
    xor r9, r9                          ! no match: plane count = 0
.L_check_override:
    tst r9, r9                          ! have override plane count?
    bf      .L_use_override_entry       ! yes, use override start index
    mov r4, r0                          ! fallback: use normal tile table
    shll r0
    add #0x1, r0
    shll r0
    mov.w @(r0, r11), r9               ! r9 = plane count
    mov r4, r0
    shll2 r0
    mov.w @(r0, r11), r8               ! r8 = start index (packed)
    bra     .L_start_plane_loop
    shlr r8                             ! r8 >>= 1 (unpack)
.L_use_override_entry:
    .byte   0xD0, 0x11    /* mov.l .L_active_cmd_slot_b, r0 */
    mov.w @r0, r8                       ! r8 = override start index (packed)
    shlr r8                             ! r8 >>= 1 (unpack)
.L_start_plane_loop:
    xor r7, r7                          ! r7 = loop counter (0)
.L_plane_loop_top:
    mov r8, r0                          ! r0 = current plane index
    shll r0                             ! word offset
    mov.w @(r0, r10), r1               ! r1 = obj index from tile data
    .byte   0xD0, 0x0E    /* mov.l .L_obj_struct_size, r0 */
    mulu.w r0, r1                       ! offset = obj_index * 0x34
    sts macl, r5
    .byte   0xD0, 0x0E    /* mov.l .L_obj_array_base, r0 */
    add r0, r5                          ! r5 = &obj_array[obj_index]
    mov r5, r0
    mov.l @(0, r0), r4                  ! r4 = obj.flags
    mov.l @(16, r0), r6                 ! r6 = obj.plane_x_coeff
    mov.l @(20, r0), r2                 ! r2 = obj.plane_x_offset
    dmuls.l r14, r6                     ! scale * coeff (64-bit result)
    sts mach, r0
    sts macl, r3
    xtrct r0, r3                        ! r3 = (scale * coeff) >> 16
    add r2, r3                          ! r3 += offset
    .byte   0xD0, 0x09    /* mov.l .L_minit, r0 */
    tst r4, r0                          ! flags & 0x01000000?
    bf      .L_plane_x_no_offset        ! set: skip camera offset
    add r12, r3                         ! r3 += camera offset
.L_plane_x_no_offset:
    mov.w   .L_flag_negate_x, r0        ! r0 = 0x0100
    tst r0, r4                          ! flags & 0x0100? (negate X)
    bt      .L_plane_x_check_neg
    neg r3, r3                          ! negate result
.L_plane_x_check_neg:
    cmp/pz r3                           ! result >= 0?
    bt      .L_test_plane_y             ! pass: test next plane
    bra     .L_plane_culled             ! fail: cull this object
    nop
.L_flag_negate_x:
    .2byte  0x0100                      ! negate-X flag mask
    .2byte  0x0000                      ! (padding)
.L_active_cmd_slot_b:
    .4byte  sym_06063F50                ! active VDP1 command slot (dup)
.L_obj_struct_size:
    .4byte  0x00000034                  ! sizeof(render_obj) = 0x34
.L_obj_array_base:
    .4byte  sym_060A6000                ! render object array base
.L_minit:
    .4byte  0x01000000                  /* MINIT — primary SH-2 init comm */
.L_test_plane_y:                        ! --- plane Y visibility test ---
    mov r5, r0
    mov.l @(24, r0), r6                 ! r6 = obj.plane_y_coeff
    mov.l @(28, r0), r2                 ! r2 = obj.plane_y_offset
    dmuls.l r14, r6                     ! scale * coeff
    sts mach, r0
    sts macl, r3
    xtrct r0, r3                        ! r3 = (scale * coeff) >> 16
    add r2, r3                          ! r3 += offset
    .byte   0xD0, 0x06    /* mov.l .L_flag_plane_y, r0 */
    tst r0, r4                          ! flags & 0x02000000?
    bf      .L_plane_y_no_offset
    add r12, r3                         ! r3 += camera offset
.L_plane_y_no_offset:
    mov.w   .L_flag_negate_y, r0        ! r0 = 0x0200
    tst r0, r4                          ! flags & 0x0200? (negate Y)
    bt      .L_plane_y_check_neg
    neg r3, r3
.L_plane_y_check_neg:
    cmp/pz r3                           ! result >= 0?
    bt      .L_test_plane_z
    bra     .L_plane_culled
    nop
.L_flag_negate_y:
    .2byte  0x0200                      ! negate-Y flag mask
    .2byte  0x0000                      ! (padding)
.L_flag_plane_y:
    .4byte  0x02000000                  ! plane-Y camera-skip flag
.L_test_plane_z:                        ! --- plane Z visibility test ---
    mov r5, r0
    mov.l @(32, r0), r6                 ! r6 = obj.plane_z_coeff
    mov.l @(36, r0), r2                 ! r2 = obj.plane_z_offset
    dmuls.l r14, r6                     ! scale * coeff
    sts mach, r0
    sts macl, r3
    xtrct r0, r3                        ! r3 = (scale * coeff) >> 16
    add r2, r3                          ! r3 += offset
    .byte   0xD0, 0x06    /* mov.l .L_flag_plane_z, r0 */
    tst r0, r4                          ! flags & 0x04000000?
    bf      .L_plane_z_no_offset
    add r12, r3                         ! r3 += camera offset
.L_plane_z_no_offset:
    mov.w   .L_flag_negate_z, r0        ! r0 = 0x0400
    tst r0, r4                          ! flags & 0x0400? (negate Z)
    bt      .L_plane_z_check_neg
    neg r3, r3
.L_plane_z_check_neg:
    cmp/pz r3                           ! result >= 0?
    bt      .L_test_plane_w
    bra     .L_plane_culled
    nop
.L_flag_negate_z:
    .2byte  0x0400                      ! negate-Z flag mask
    .2byte  0x0000                      ! (padding)
.L_flag_plane_z:
    .4byte  0x04000000                  ! plane-Z camera-skip flag
.L_test_plane_w:                        ! --- plane W visibility test ---
    mov r5, r0
    mov.l @(40, r0), r6                 ! r6 = obj.plane_w_coeff
    mov.l @(44, r0), r2                 ! r2 = obj.plane_w_offset
    dmuls.l r14, r6                     ! scale * coeff
    sts mach, r0
    sts macl, r3
    xtrct r0, r3                        ! r3 = (scale * coeff) >> 16
    add r2, r3                          ! r3 += offset
    .byte   0xD0, 0x06    /* mov.l .L_flag_plane_w, r0 */
    tst r0, r4                          ! flags & 0x08000000?
    bf      .L_plane_w_no_offset
    add r12, r3                         ! r3 += camera offset
.L_plane_w_no_offset:
    mov.w   DAT_0602805c, r0            ! r0 = 0x0800
    tst r0, r4                          ! flags & 0x0800? (negate W)
    bt      .L_plane_w_check_neg
    neg r3, r3
.L_plane_w_check_neg:
    cmp/pz r3                           ! result >= 0?
    bf      .L_plane_culled             ! fail: cull
    bra     .L_all_planes_passed        ! all 4 planes passed
    mov #0x1, r6                        ! r6 = 1 (visible flag)

    .global DAT_0602805c
DAT_0602805c:
    .2byte  0x0800                      ! negate-W flag mask
    .2byte  0x0000                      ! (padding)
.L_flag_plane_w:
    .4byte  0x08000000                  ! plane-W camera-skip flag
.L_plane_culled:
    add #0x1, r7                        ! r7++ (loop counter)
    add #0x1, r8                        ! r8++ (plane index)
    cmp/ge r9, r7                       ! tested all planes?
    bt      .L_all_planes_passed        ! yes, done (some culled)
    bra     .L_plane_loop_top           ! no, test next plane
    nop
.L_all_planes_passed:
    mov.l @r15+, r6                     ! r6 = original output ptr (or 0)
    tst r6, r6                          ! output ptr null?
    bt      .L_epilogue                 ! no output, just return
    cmp/eq r7, r9                       ! all planes were culled?
    bt      .L_epilogue                 ! yes, nothing visible
    .byte   0xD0, 0x0F    /* mov.l .L_off_field_x, r0 */
    mov.l @(r0, r5), r1                 ! r1 = obj.interp_x
    dmuls.l r14, r1                     ! scale * interp_x
    sts mach, r0
    sts macl, r1
    xtrct r0, r1                        ! r1 = (scale * interp_x) >> 16
    .byte   0xD0, 0x0D    /* mov.l .L_off_field_y, r0 */
    mov.l @(r0, r5), r2                 ! r2 = obj.interp_y
    dmuls.l r12, r2                     ! camera_offset * interp_y
    sts mach, r0
    sts macl, r2
    xtrct r0, r2                        ! r2 = (cam * interp_y) >> 16
    .byte   0xD0, 0x0B    /* mov.l .L_off_field_z, r0 */
    mov.l @(r0, r5), r3                 ! r3 = obj.interp_z
    add r2, r1                          ! r1 += y component
    add r3, r1                          ! r1 += z component
    mov r13, r0
    mov.l r1, @(4, r0)                  ! param_struct[4] = interpolated pos
    mov r8, r0
    shll r0                             ! word offset
    mov.w @(r0, r10), r1               ! r1 = final tile index
    mov.w r1, @r6                       ! write to output
.L_epilogue:
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    mov.l @r15+, r14
    rts
    nop
.L_off_field_x:
    .4byte  0x00000004                  ! struct offset: interp X field
.L_off_field_y:
    .4byte  0x00000008                  ! struct offset: interp Y field
.L_off_field_z:
    .4byte  0x0000000C                  ! struct offset: interp Z field

    .global sym_060280C4
sym_060280C4:                           ! VDP1 cmd builder A (r4=src, r5=dst)
    .byte   0xD3, 0x0A    /* mov.l .L_vdp1_cmd_template_a, r3 */
    mov r4, r2                          ! r2 = source struct
    mov.w @r3+, r4                      ! r4 = template CMDCTRL word
    mov r5, r1                          ! r1 = dest cmd slot
    mov.w r4, @r1                       ! dst[0] = CMDCTRL
    mov #0x4, r0
    mov.w @r3, r4                       ! r4 = template CMDLINK word
    mov.w r4, @(r0, r1)                 ! dst[4] = CMDLINK
    mov #0x6, r0
    mov.w @(r0, r2), r4                 ! r4 = src[6] (CMDPMOD)
    mov #0x6, r0
    mov.w r4, @(r0, r1)                 ! dst[6] = CMDPMOD
    mov.l @(8, r2), r0                  ! copy src[8..11] -> dst[12..15]
    mov.l r0, @(12, r1)
    mov.l @(12, r2), r0                 ! copy src[12..15] -> dst[16..19]
    mov.l r0, @(16, r1)
    mov.l @(16, r2), r0                 ! copy src[16..19] -> dst[20..23]
    mov.l r0, @(20, r1)
    mov.l @(20, r2), r0                 ! copy src[20..23] -> dst[24..27]
    rts
    mov.l r0, @(24, r1)
    .2byte  0x0000
.L_vdp1_cmd_template_a:
    .4byte  sym_060280F4                ! template data: CMDCTRL + CMDLINK

    .global sym_060280F4
sym_060280F4:                           ! inline data: VDP1 cmd template A
    mov.b r0, @(r0, r0)                ! (data: CMDCTRL word)
    mov.l r12, @(0, r4)                ! (data: CMDLINK word)

    .global sym_060280F8
sym_060280F8:                           ! VDP1 cmd setup (r4=obj, r5=dst cmd)
    mov #0x5, r0
    mov.b @(r0, r4), r6                 ! r6 = obj[5] (texture bank)
    .byte   0xD1, 0x18    /* mov.l .L_tex_index_table, r1 */
    extu.b r6, r6                       ! zero-extend bank byte
    shll8 r6                            ! r6 <<= 8 (bank * 256)
    shlr2 r6                            ! r6 >>= 2 (bank * 64)
    mov.w @(6, r4), r0                  ! r0 = obj[6] (texture index)
    mov #0x8, r2                        ! slot struct size = 8
    add r6, r0                          ! r0 = bank_offset + tex_index
    shll r0                             ! word index -> byte offset
    mov.w @(r0, r1), r7                 ! r7 = tex_table[idx] (VRAM slot)
    mulu.w r2, r7                       ! slot_offset = r7 * 8
    .byte   0xD1, 0x14    /* mov.l .L_slot_data_base, r1 */
    mov #0x6, r0
    sts macl, r2                        ! r2 = slot_offset
    add r2, r1                          ! r1 = &slot_data[slot]
    mov.w @(r0, r1), r6                 ! r6 = slot_data[slot].tex_offset
    .byte   0xD3, 0x13    /* mov.l .L_draw_mode_table, r3 */
    mov.b @(4, r4), r0                  ! r0 = obj[4] (draw mode flags)
    and #0xC, r0                        ! isolate mode bits [3:2]
    add r0, r3                          ! index into draw mode table
    mov.l @r3, r0                       ! r0 = CMDCTRL value
    mov.w r0, @(0, r5)                  ! dst[0] = CMDCTRL
    mov.b @(4, r4), r0                  ! r0 = obj[4] again
    .byte   0xD2, 0x10    /* mov.l .L_color_mode_table, r2 */
    and #0x1, r0                        ! isolate color bank bit [0]
    shll r0                             ! word offset
    add r2, r0                          ! &color_mode[bit]
    mov.w @r0, r0                       ! r0 = CMDCOLR value
    mov.w r0, @(4, r5)                  ! dst[4] = CMDCOLR
    .byte   0xD3, 0x0E    /* mov.l .L_tex_base_addr, r3 */
    mov.l @r3, r0                       ! r0 = texture base address
    mov #0x8, r3
    mulu.w r3, r7                       ! recalc slot_offset (r7 * 8)
    add r6, r0                          ! r0 = tex_base + tex_offset
    mov.w r0, @(6, r5)                  ! dst[6] = CMDSRCA
    .byte   0xD2, 0x08    /* mov.l .L_slot_data_base, r2 */
    sts macl, r3
    add r3, r2                          ! r2 = &slot_data[slot]
    mov.l @(0, r2), r0                  ! r0 = slot_data.width_height
    mov.l @(20, r4), r1                 ! r1 = obj[20] (vertex D)
    mov.w r0, @(8, r5)                  ! dst[8] = CMDSIZE
    mov.w @(4, r2), r0                  ! r0 = slot_data.grda
    mov.l @(16, r4), r3                 ! r3 = obj[16] (vertex C)
    mov.w r0, @(10, r5)                 ! dst[10] = CMDGRDA
    mov.l @(8, r4), r0                  ! r0 = obj[8]  (vertex A)
    mov.l @(12, r4), r2                 ! r2 = obj[12] (vertex B)
    mov.l r0, @(12, r5)                 ! dst[12] = CMDXA/CMDYA
    mov.l r2, @(16, r5)                 ! dst[16] = CMDXB/CMDYB
    mov.l r3, @(20, r5)                 ! dst[20] = CMDXC/CMDYC
    rts
    mov.l r1, @(24, r5)                 ! dst[24] = CMDXD/CMDYD
.L_tex_index_table:
    .4byte  sym_060684EC                ! texture index -> VRAM slot table
.L_slot_data_base:
    .4byte  sym_06063F64                ! per-slot data (size, grda, offset)
.L_draw_mode_table:
    .4byte  sym_06028178                ! draw mode CMDCTRL lookup (4 entries)
.L_color_mode_table:
    .4byte  sym_06028174                ! color bank CMDCOLR lookup (2 entries)
.L_tex_base_addr:
    .4byte  sym_06059FFC                ! texture VRAM base address ptr

    .global sym_06028174
sym_06028174:                           ! inline data: CMDCOLR table (2 words)
    mov.l r12, @(32, r4)               ! (data word 0)
    mov.l r8, @(32, r4)                ! (data word 1)

    .global sym_06028178
sym_06028178:                           ! inline data: CMDCTRL draw mode table
    .word 0x0000 /* UNKNOWN */          ! (data: mode 0 — normal sprite)
    stc sr, r0                          ! (data bytes, not code)
    .word 0x0000 /* UNKNOWN */          ! (data: mode 1)
    stc vbr, r0                         ! (data bytes, not code)
    .word 0x0000 /* UNKNOWN */          ! (data: mode 2)
    stc gbr, r0                         ! (data bytes, not code)
    .word 0x0000 /* UNKNOWN */          ! (data: mode 3)
    .word 0x0032 /* UNKNOWN */
    .byte   0xD3, 0x09    /* mov.l .L_vdp1_cmd_template_b, r3 */
    mov r4, r2                          ! VDP1 cmd builder B (r4=src, r5=dst, r6=CMDPMOD)
    mov.w @r3+, r4                      ! r4 = template CMDCTRL
    mov r5, r1
    mov.w r4, @r1                       ! dst[0] = CMDCTRL
    mov #0x4, r0
    mov.w @r3, r4                       ! r4 = template CMDLINK
    mov.w r4, @(r0, r1)                 ! dst[4] = CMDLINK
    mov #0x6, r0
    mov.w r6, @(r0, r1)                 ! dst[6] = CMDPMOD (from r6)
    mov.l @(8, r2), r0
    mov.l r0, @(12, r1)                 ! copy vertex A
    mov.l @(12, r2), r0
    mov.l r0, @(16, r1)                 ! copy vertex B
    mov.l @(16, r2), r0
    mov.l r0, @(20, r1)                 ! copy vertex C
    mov.l @(20, r2), r0
    rts
    mov.l r0, @(24, r1)                 ! copy vertex D
    .2byte  0x0000
.L_vdp1_cmd_template_b:
    .4byte  sym_060281B4                ! template data: CMDCTRL + CMDLINK

    .global sym_060281B4
sym_060281B4:                           ! inline data: VDP1 cmd template B
    mov.w r0, @(r0, r0)                ! (data: CMDCTRL word)
    mov.l r12, @(0, r4)                ! (data: CMDLINK word)

    .global sym_060281B8
sym_060281B8:                           ! VDP1 cmd builder C (r4=src, r5=dst, r6=CMDPMOD)
    .byte   0xD3, 0x09    /* mov.l .L_vdp1_cmd_template_c, r3 */
    mov r4, r2
    mov.w @r3+, r4                      ! r4 = template CMDCTRL
    mov r5, r1
    mov.w r4, @r1                       ! dst[0] = CMDCTRL
    mov #0x4, r0
    mov.w @r3, r4
    mov.w r4, @(r0, r1)                 ! dst[4] = CMDLINK
    mov #0x6, r0
    mov.w r6, @(r0, r1)                 ! dst[6] = CMDPMOD
    mov.l @(8, r2), r0
    mov.l r0, @(12, r1)                 ! copy vertex A
    mov.l @(12, r2), r0
    mov.l r0, @(16, r1)                 ! copy vertex B
    mov.l @(16, r2), r0
    mov.l r0, @(20, r1)                 ! copy vertex C
    mov.l @(20, r2), r0
    rts
    mov.l r0, @(24, r1)                 ! copy vertex D
    .2byte  0x0000
.L_vdp1_cmd_template_c:
    .4byte  sym_060281E4                ! template data: CMDCTRL + CMDLINK

    .global sym_060281E4
sym_060281E4:                           ! inline data: VDP1 cmd template C
    mov.b r0, @(r0, r0)                ! (data: CMDCTRL word)
    .word 0x05C0 /* UNKNOWN */          ! (data: CMDLINK word)
    .byte   0xD3, 0x09    /* mov.l .L_vdp1_cmd_template_d, r3 */
    mov r4, r2                          ! VDP1 cmd builder D (r4=src, r5=dst, r6=CMDPMOD)
    mov.w @r3+, r4                      ! r4 = template CMDCTRL
    mov r5, r1
    mov.w r4, @r1                       ! dst[0] = CMDCTRL
    mov #0x4, r0
    mov.w @r3, r4
    mov.w r4, @(r0, r1)                 ! dst[4] = CMDLINK
    mov #0x6, r0
    mov.w r6, @(r0, r1)                 ! dst[6] = CMDPMOD
    mov.l @(8, r2), r0
    mov.l r0, @(12, r1)                 ! copy vertex A
    mov.l @(12, r2), r0
    mov.l r0, @(16, r1)                 ! copy vertex B
    mov.l @(16, r2), r0
    mov.l r0, @(20, r1)                 ! copy vertex C
    mov.l @(20, r2), r0
    rts
    mov.l r0, @(24, r1)                 ! copy vertex D
    .2byte  0x0000
.L_vdp1_cmd_template_d:
    .4byte  sym_06028214                ! template data: CMDCTRL + CMDLINK

    .global sym_06028214
sym_06028214:                           ! inline data: VDP1 cmd template D
    mov.b r0, @(r0, r0)                ! (data: CMDCTRL word)
    .word 0x04C2 /* UNKNOWN */          ! (data: CMDLINK word)

    .global sym_06028218
sym_06028218:                           ! IRQ handler: display list builder (variant A)
    mov.l r7, @-r15                     ! push all regs (interrupt context)
    mov.l r6, @-r15
    mov.l r5, @-r15
    mov.l r4, @-r15
    mov.l r3, @-r15
    mov.l r2, @-r15
    mov.l r1, @-r15
    mov.l r0, @-r15
    sts.l pr, @-r15
    .byte   0xD6, 0x21    /* mov.l .L_dlist_data_a, r6 */
    bra     .L_int_build_dlist
    mov #0x9, r4                        ! r4 = 9 (cmd count)

    .global sym_06028230
sym_06028230:                           ! IRQ handler: display list builder (variant B)
    mov.l r7, @-r15
    mov.l r6, @-r15
    mov.l r5, @-r15
    mov.l r4, @-r15
    mov.l r3, @-r15
    mov.l r2, @-r15
    mov.l r1, @-r15
    mov.l r0, @-r15
    sts.l pr, @-r15
    .byte   0xD6, 0x1D    /* mov.l .L_dlist_data_c, r6 */
    bra     .L_int_build_dlist
    mov #0xC, r4                        ! r4 = 12 (cmd count)

    .global sym_06028248
sym_06028248:                           ! IRQ handler: display list builder (variant C)
    mov.l r7, @-r15
    mov.l r6, @-r15
    mov.l r5, @-r15
    mov.l r4, @-r15
    mov.l r3, @-r15
    mov.l r2, @-r15
    mov.l r1, @-r15
    mov.l r0, @-r15
    sts.l pr, @-r15
    .byte   0xD6, 0x18    /* mov.l .L_dlist_data_d, r6 */
    mov #0x9, r4                        ! r4 = 9 (cmd count)
.L_int_build_dlist:                     ! common entry for all 3 IRQ variants
    mov.w   .L_sr_irq_mask, r0         ! r0 = 0x00F0 (mask all IRQs)
    mov #0x1, r5                        ! r5 = write mode 1
    .byte   0xB1, 0xCD    /* bsr 0x06028600 (external) */
    ldc r0, sr                          ! disable interrupts (delay slot)
    .byte   0xD6, 0x13    /* mov.l .L_dlist_data_b, r6 */
    mov #0xD, r4                        ! r4 = 13 (cmd count)
    .byte   0xB1, 0xC9    /* bsr 0x06028600 (external) */
    mov #0x2, r5                        ! r5 = write mode 2
    mov #0x13, r4                       ! r4 = 19 (cmd count)
    mov #0x2, r5                        ! r5 = write mode 2
    .byte   0xB1, 0xB5    /* bsr 0x060285E0 (external) */
    mov.l @(36, r15), r6               ! r6 = saved r0 from stack
    .byte   0xD4, 0x0A    /* mov.l .L_vram_cfg_src, r4 */
    .byte   0xD5, 0x0A    /* mov.l .L_vram_cfg_dst, r5 */
    mov.w   .L_copy_word_count, r6     ! r6 = 0x0180 (word count)
    .byte   0xD7, 0x0A    /* mov.l .L_fn_memcpy_word, r7 */
    jsr @r7                             ! memcpy_word_idx(src, dst, count)
    mov.l @r4, r4                       ! deref src ptr (delay slot)
    lds.l @r15+, pr                     ! restore all regs
    mov.l @r15+, r0
    mov.l @r15+, r1
    mov.l @r15+, r2
    mov.l @r15+, r3
    mov.l @r15+, r4
    mov.l @r15+, r5
    mov.l @r15+, r6
    mov.l @r15+, r7
    sett                                ! set T flag
.L_halt_loop:
    bt      .L_halt_loop               ! infinite loop (halt CPU)
    rte                                 ! return from exception (unreachable)
    nop
.L_copy_word_count:
    .2byte  0x0180                      ! word count for VRAM config copy
    .2byte  0x0000                      ! (padding)
.L_vram_cfg_src:
    .4byte  sym_060612B8                ! VRAM config source (channel 32)
.L_vram_cfg_dst:
    .4byte  sym_060612C4                ! VRAM config destination
.L_fn_memcpy_word:
    .4byte  memcpy_word_idx             ! word-indexed memcpy function
.L_sr_irq_mask:
    .2byte  0x00F0                      ! SR value: all IRQs masked
    .2byte  0x0009                      ! (padding / adjacent data)
.L_dlist_data_a:
    .4byte  sym_06059C5C               ! display list command data A
.L_dlist_data_b:
    .4byte  sym_06059C74               ! display list command data B
.L_dlist_data_c:
    .4byte  sym_06059C7B               ! display list command data C
.L_dlist_data_d:
    .4byte  sym_06059C8C               ! display list command data D
    .4byte  0xD20ED00F
    .4byte  0x12001201
    .4byte  0x1202E000
    .4byte  0x802B4411
    .4byte  0x8D02E720
    .4byte  0x644BE72D
    .4byte  0x72029113
    .4byte  0xE00A1100
    .4byte  0x24488906
    .4byte  0x11410009
    .4byte  0x53164010
    .4byte  0x02348FF7
    .4byte  0x541772FE
    .4byte  0x0274000B
    .4byte  0x60230009
    .4byte  sym_060620C4
    .4byte  0x20202020
    .4byte  0xFF00D20E
    .4byte  0xD00E1200
    .4byte  0x12011202
    .4byte  0xE000802B
    .4byte  0x44118D02
    .4byte  0xE70A644B
    .4byte  0xE72D7202
    .4byte  0x9112E00A
    .4byte  0x11002448
    .4byte  0x89061141
    .4byte  0x00095316
    .4byte  0x40100234
    .4byte  0x8FF75417
    .4byte  0x72FE0274
    .4byte  0x000B6023
    .4byte  sym_060620C4
    .4byte  0x0A0A0A0A
    .2byte  0xFF00
