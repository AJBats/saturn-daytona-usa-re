/* color_material_blend -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602F5B6 - 0x0602F7EA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Step 11 of the per-car render orchestrator (render_orchestrator.s).
 * Called after distance_fog and before orientation_sincos.
 *
 * r0  = car struct base pointer (preserved in r14)
 * r14 = car struct base pointer (saved on entry)
 *
 * Contains three functions:
 *
 * color_material_blend (0x0602F5B6):
 *   Computes per-car color/material blending for VDP1 rendering.
 *   Algorithm:
 *     1. Load weight value from weight table (sym_06045AEC) indexed by
 *        car+0x68 (heading index). Multiply by blend factor 0x00016666
 *        (~1.4 in 16.16 FP), subtract bias 0x00006666 (~0.4).
 *        Result r1 = adjusted blend weight.
 *     2. Load drive_speed (car+0xE0), clamp to [0, 0x2134].
 *        Shift right 7 (4x shlr2 + shlr) to normalize to table index.
 *     3. Load display_flag (car+0xDC) as column index into weight table.
 *        Load color_base (car+0xC8) as row base into material table
 *        (sym_060477BC). Look up material reflectance and multiply
 *        by blend weight, then multiply by adjusted weight from step 1.
 *     4. Compute fog division: car+0xE8 (light_param) << 16 as numerator,
 *        0x00019999 (~1.6 FP) as denominator, via fpdiv_setup.
 *        Subtract result from blended color, store to car+0x11C (decel_coeff).
 *     5. Load secondary speed (car+0x84), index into weight table
 *        (sym_06045AEC) again. Square the value, then apply two blend
 *        factors: 0x0B400000 (70%) and 0x07800000 (50%) via chained
 *        dmuls.l. Store results to car+0xEC and car+0xF0.
 *     6. If car+0x1C (vertical position) < 0, halve it (shar).
 *     7. Call sin_lookup with heading factor 0x06400000. Multiply result,
 *        halve, store to car+0xF4 (force_aux).
 *     8. Look up acceleration curve (sym_060454CC) by car speed index
 *        (car+0x08). If fog_timer (car+0xD6) > 0, scale by 0x7333
 *        (~0.45 in 16.16 FP).
 *     9. Call activation_weight_calc to get activation weight from
 *        car+0x120 flag words. Add to curve value, halve, store to
 *        car+0xF8 (final blend output).
 *
 * activation_weight_calc (0x0602F71C):
 *   Subroutine that scans 4 flag words at car+0x120..0x12C for bit 0x4.
 *   Counts how many slots have the bit set, OR-accumulates all flags
 *   into r12. Then dispatches based on render type (car+0x7C) and
 *   flag count to select a weight from one of two tables:
 *     sym_0604679C (weight table A) - used for high flag counts or
 *       render types 8-9 (doubled via shll)
 *     sym_06046F9C (weight table B) - used for low flag counts (<=2)
 *   Special render types (>=0xA, ==4, ==5) or bit 0x10 in accumulated
 *   flags return zero weight. Returns halved weight in r4 (via shar).
 *
 * sym_0602F7BC / timer_tick (0x0602F7BC):
 *   Decrements 3 independent per-car animation timers each frame.
 *   LEAF function -- no subroutine calls.
 *     Timer A (car+0x166): 16-bit word, animation frame counter
 *     Timer B (car+0x152): 16-bit word, effect duration counter
 *     Timer C (car+0x208): 32-bit long, extended cooldown timer
 *   Each timer: if (timer != 0) timer--; zero-check prevents underflow.
 */

    .section .text.FUN_0602F5B6


    .global color_material_blend
    .type color_material_blend, @function
color_material_blend:
    sts.l pr, @-r15                     ! save return address
    mov r0, r14                         ! r14 = car struct base (preserved)
    mov.w   DAT_0602f5e8, r1            ! r1 = 0x0068 (heading index offset)
    mov.l @(r0, r1), r2                 ! r2 = car[0x68] (heading index value)
    .byte   0xD3, 0x0B    /* mov.l _pool_weight_table_a, r3 */
    shll2 r2                            ! r2 *= 4 (longword index into table)
    .byte   0xD4, 0x0B    /* mov.l _pool_blend_factor, r4 */
    add r2, r3                          ! r3 = &weight_table[heading_index]
    mov.l @r3, r5                       ! r5 = weight_table[heading_index]
    dmuls.l r4, r5                      ! MAC = weight * 0x00016666 (~1.4 FP)
    .byte   0xD1, 0x0A    /* mov.l _pool_blend_bias, r1 */
    sts mach, r4                        ! r4 = MAC high 32 bits
    sts macl, r5                        ! r5 = MAC low 32 bits
    xtrct r4, r5                        ! r5 = middle 32 bits (16.16 product)
    sub r1, r5                          ! r5 -= 0x00006666 (subtract bias)
    mov r5, r1                          ! r1 = adjusted blend weight (saved)
    mov.w   DAT_0602f5ea, r11           ! r11 = 0x00E0 (drive_speed offset)
    mov.l @(r0, r11), r5               ! r5 = car[0xE0] (drive_speed, 16.16 FP)
    .byte   0xD3, 0x07    /* mov.l _pool_clamp_lower, r3 */
    .byte   0xD4, 0x07    /* mov.l _pool_clamp_upper, r4 */
    cmp/gt r3, r5                       ! drive_speed > 0? (lower clamp)
    bt      .L_check_upper_clamp        ! yes: check upper bound
    mov r3, r5                          ! no: clamp to 0 (lower bound)
    bra     .L_after_clamp              ! skip upper check
    nop                                 ! delay slot

    .global DAT_0602f5e8
DAT_0602f5e8:
    .2byte  0x0068                      /* car+0x68: heading index */

    .global DAT_0602f5ea
DAT_0602f5ea:
    .2byte  0x00E0                      /* car+0xE0: drive_speed (16.16 FP) */
_pool_weight_table_a:
    .4byte  sym_06045AEC               /* weight table (per-car type) */
_pool_blend_factor:
    .4byte  0x00016666                  /* ~1.4 in 16.16 FP (blend multiplier) */
_pool_blend_bias:
    .4byte  0x00006666                  /* ~0.4 in 16.16 FP (blend bias) */
_pool_clamp_lower:
    .4byte  0x00000000                  /* lower clamp bound (0) */
_pool_clamp_upper:
    .4byte  0x00002134                  /* upper clamp bound (8500 decimal) */
.L_check_upper_clamp:
    cmp/gt r5, r4                       ! 0x2134 > drive_speed?
    bt      .L_after_clamp              ! yes: within range, keep value
    mov r4, r5                          ! no: clamp to 0x2134 (upper bound)
.L_after_clamp:
    shlr2 r5                            ! r5 >>= 2
    shlr2 r5                            ! r5 >>= 2 (total >>4)
    shlr2 r5                            ! r5 >>= 2 (total >>6)
    shlr r5                             ! r5 >>= 1 (total >>7, normalize to index)
    mov.w   DAT_0602f6e0, r2            ! r2 = 0x00DC (display_flag offset)
    mov.w @(r0, r2), r4                 ! r4 = car[0xDC] (display_flag, column idx)
    mov.w   DAT_0602f6e2, r2            ! r2 = 0x00C8 (color_base offset)
    mov.l @(r0, r2), r6                 ! r6 = car[0xC8] (color_base / row ptr)
    shll2 r5                            ! r5 *= 4 (longword index)
    .byte   0xD7, 0x37    /* mov.l _pool_material_table, r7 */
    shll2 r4                            ! r4 *= 4 (longword column index)
    add r5, r6                          ! r6 = color_base + row_index
    add r4, r7                          ! r7 = material_table + col_index
    mov.l @r6, r5                       ! r5 = color_base[row_index]
    mov.l @r7, r4                       ! r4 = material_table[col_index]
    dmuls.l r4, r5                      ! MAC = material * color (64-bit)
    sts mach, r4                        ! r4 = MAC high
    sts macl, r0                        ! r0 = MAC low
    xtrct r4, r0                        ! r0 = material_color (16.16 extract)
    dmuls.l r0, r1                      ! MAC = material_color * blend_weight
    sts mach, r4                        ! r4 = MAC high
    sts macl, r2                        ! r2 = MAC low
    xtrct r4, r2                        ! r2 = blended_color (16.16 extract)
    mov r14, r0                         ! r0 = car struct base (restore)
    mov.w   DAT_0602f6e4, r1            ! r1 = 0x00E8 (light_param offset)
    .byte   0xD5, 0x30    /* mov.l _pool_fog_divisor, r5 */
    mov.l @(r0, r1), r4                 ! r4 = car[0xE8] (light_param)
    shll16 r4                           ! r4 <<= 16 (numerator for divide)
    .byte   0xD0, 0x30    /* mov.l _pool_fn_fpdiv, r0 */
    jsr @r0                             ! r0 = fpdiv_setup(r4, r5) -- 16.16 divide
    mov.l r2, @-r15                     ! (delay) push blended_color to stack
    mov r0, r4                          ! r4 = fog_factor (divide result)
    mov.l @r15+, r2                     ! r2 = pop blended_color from stack
    mov r14, r0                         ! r0 = car struct base (restore)
    mov.w   DAT_0602f6e6, r1            ! r1 = 0x011C (decel_coeff offset)
    sub r4, r2                          ! r2 = blended_color - fog_factor
    mov.l r2, @(r0, r1)                 ! car[0x11C] = fog-adjusted blend result
    mov.w   DAT_0602f6e8, r1            ! r1 = 0x0084 (secondary_speed offset)
    mov.l @(r0, r1), r2                 ! r2 = car[0x84] (secondary speed index)
    .byte   0xD3, 0x2B    /* mov.l _pool_weight_table_b, r3 */
    shll2 r2                            ! r2 *= 4 (longword index)
    add r2, r3                          ! r3 = &weight_table[sec_speed_idx]
    mov.l @r3, r4                       ! r4 = weight_table[sec_speed_idx]
    .byte   0xD7, 0x2A    /* mov.l _pool_weight_70pct, r7 */
    .byte   0xD8, 0x2B    /* mov.l _pool_weight_50pct, r8 */
    mov r4, r5                          ! r5 = weight value (copy for squaring)
    dmuls.l r4, r5                      ! MAC = weight^2 (self-multiply)
    sts mach, r4                        ! r4 = MAC high
    sts macl, r0                        ! r0 = MAC low
    xtrct r4, r0                        ! r0 = weight_squared (16.16)
    mov r0, r10                         ! r10 = weight_squared (save)
    mov r0, r4                          ! r4 = weight_squared
    mov r7, r5                          ! r5 = 0x0B400000 (70% factor)
    dmuls.l r4, r5                      ! MAC = weight_squared * 70%
    sts mach, r4                        ! r4 = MAC high
    sts macl, r0                        ! r0 = MAC low
    xtrct r4, r0                        ! r0 = 70% blend result
    mov r10, r4                         ! r4 = weight_squared (restore)
    mov r0, r10                         ! r10 = 70% blend (save for store)
    dmuls.l r4, r8                      ! MAC = weight_squared * 50%
    sts mach, r8                        ! r8 = MAC high
    sts macl, r4                        ! r4 = MAC low
    xtrct r8, r4                        ! r4 = 50% blend result
    mov r14, r0                         ! r0 = car struct base (restore)
    mov.w   DAT_0602f6ea, r1            ! r1 = 0x00EC (blend_result_a offset)
    mov.l r10, @(r0, r1)                ! car[0xEC] = 70% blend result
    mov.w   DAT_0602f6ec, r2            ! r2 = 0x00F0 (blend_result_b offset)
    mov.l r4, @(r0, r2)                 ! car[0xF0] = 50% blend result
    mov #0x0, r10                       ! r10 = 0 (for sign comparison)
    mov.w   DAT_0602f6ee, r1            ! r1 = 0x001C (vertical_pos offset)
    mov.l @(r0, r1), r4                 ! r4 = car[0x1C] (vertical position)
    cmp/ge r4, r10                      ! 0 >= vertical_pos? (is negative?)
    bt      .L_after_vert_adjust        ! no (positive): skip halving
    shar r4                             ! r4 >>= 1 (halve if negative)
.L_after_vert_adjust:
    .byte   0xD5, 0x1D    /* mov.l _pool_heading_factor, r5 */
    .byte   0xD0, 0x1D    /* mov.l _pool_fn_sin_lookup, r0 */
    jsr @r0                             ! r0 = sin_lookup(r4=angle, r5=factor)
    nop                                 ! delay slot
    dmuls.l r0, r5                      ! MAC = sin_result * heading_factor
    sts mach, r4                        ! r4 = MAC high
    sts macl, r0                        ! r0 = MAC low
    xtrct r4, r0                        ! r0 = heading contribution (16.16)
    shar r0                             ! r0 >>= 1 (halve heading contribution)
    mov r0, r8                          ! r8 = halved heading contribution
    mov.w   DAT_0602f6f0, r1            ! r1 = 0x00F4 (force_aux offset)
    mov r14, r0                         ! r0 = car struct base (restore)
    mov.l r8, @(r0, r1)                 ! car[0xF4] = heading contribution
    mov.l @(8, r0), r3                  ! r3 = car[0x08] (speed index)
    .byte   0xD1, 0x18    /* mov.l _pool_accel_curve, r1 */
    shll2 r3                            ! r3 *= 4 (longword index)
    add r3, r1                          ! r1 = &accel_curve[speed_index]
    mov.l @r1, r5                       ! r5 = accel_curve[speed_index]
    mov.w   DAT_0602f6f2, r2            ! r2 = 0x00D6 (fog_timer offset)
    mov.w @(r0, r2), r3                 ! r3 = car[0xD6] (fog countdown timer)
    cmp/pl r3                           ! fog_timer > 0?
    bf      .L_skip_fog_scale           ! no: skip fog scaling
    mov.w   DAT_0602f6f4, r4            ! r4 = 0x7333 (~0.45 in 16.16 FP)
    dmuls.l r4, r5                      ! MAC = accel_curve * fog_scale
    sts mach, r4                        ! r4 = MAC high
    sts macl, r5                        ! r5 = MAC low
    xtrct r4, r5                        ! r5 = fog-scaled curve value
.L_skip_fog_scale:
    bsr     .L_activation_weight_calc   ! call activation weight subroutine
    nop                                 ! delay slot
    add r4, r5                          ! r5 = curve_value + activation_weight
    shar r5                             ! r5 >>= 1 (average of curve + weight)
    mov.w   DAT_0602f6f6, r1            ! r1 = 0x00F8 (final blend output offset)
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return to caller
    mov.l r5, @(r0, r1)                 ! (delay) car[0xF8] = final blend output

    .global DAT_0602f6e0
DAT_0602f6e0:
    .2byte  0x00DC                      /* car+0xDC: display_flag (table column index) */

    .global DAT_0602f6e2
DAT_0602f6e2:
    .2byte  0x00C8                      /* car+0xC8: color_base (row pointer) */

    .global DAT_0602f6e4
DAT_0602f6e4:
    .2byte  0x00E8                      /* car+0xE8: light_param (fog numerator) */

    .global DAT_0602f6e6
DAT_0602f6e6:
    .2byte  0x011C                      /* car+0x11C: decel_coeff (fog-adjusted output) */

    .global DAT_0602f6e8
DAT_0602f6e8:
    .2byte  0x0084                      /* car+0x84: secondary_speed index */

    .global DAT_0602f6ea
DAT_0602f6ea:
    .2byte  0x00EC                      /* car+0xEC: blend_result_a (70% output) */

    .global DAT_0602f6ec
DAT_0602f6ec:
    .2byte  0x00F0                      /* car+0xF0: blend_result_b (50% output) */

    .global DAT_0602f6ee
DAT_0602f6ee:
    .2byte  0x001C                      /* car+0x1C: vertical_pos */

    .global DAT_0602f6f0
DAT_0602f6f0:
    .2byte  0x00F4                      /* car+0xF4: force_aux (heading contribution) */

    .global DAT_0602f6f2
DAT_0602f6f2:
    .2byte  0x00D6                      /* car+0xD6: fog_timer (countdown) */

    .global DAT_0602f6f4
DAT_0602f6f4:
    .2byte  0x7333                      /* ~0.45 in 16.16 FP (fog scale factor) */

    .global DAT_0602f6f6
DAT_0602f6f6:
    .2byte  0x00F8                      /* car+0xF8: final blend output */
_pool_material_table:
    .4byte  sym_060477BC               /* material/reflectance lookup table */
_pool_fog_divisor:
    .4byte  0x00019999                  /* ~1.6 in 16.16 FP (fog divisor) */
_pool_fn_fpdiv:
    .4byte  fpdiv_setup                /* 16.16 fixed-point hardware divide */
_pool_weight_table_b:
    .4byte  sym_06045AEC               /* weight table (per-car type, 2nd ref) */
_pool_weight_70pct:
    .4byte  0x0B400000                  /* 70% blend factor (16.16 FP) */
_pool_weight_50pct:
    .4byte  0x07800000                  /* 50% blend factor (16.16 FP) */
_pool_heading_factor:
    .4byte  0x06400000                  /* heading angle factor (16.16 FP) */
_pool_fn_sin_lookup:
    .4byte  sin_lookup                 /* sine table lookup function */
_pool_accel_curve:
    .4byte  sym_060454CC               /* acceleration curve table B */
.L_activation_weight_calc:
    mov #0x0, r4                        ! r4 = 0 (flag count, counts active slots)
    mov.w   _wpool_flag_bit_mask, r3    ! r3 = 0x0004 (bit mask to test)
    mov.w   _wpool_flag_base_offset, r1 ! r1 = 0x0120 (flag array base offset)
    add r0, r1                          ! r1 = car + 0x0120 (absolute flag addr)
    mov.l @r1, r2                       ! r2 = car[0x120] (flag word slot 0)
    tst r3, r2                          ! bit 0x4 set in slot 0?
    mov r2, r12                         ! r12 = slot 0 flags (accumulator)
    bt      .L_check_slot_1             ! not set: skip increment
    add #0x1, r4                        ! count++ (slot 0 has active bit)
.L_check_slot_1:
    mov.l @(4, r1), r2                  ! r2 = car[0x124] (flag word slot 1)
    tst r3, r2                          ! bit 0x4 set in slot 1?
    or r2, r12                          ! r12 |= slot 1 flags
    bt      .L_check_slot_2             ! not set: skip increment
    add #0x1, r4                        ! count++ (slot 1 has active bit)
.L_check_slot_2:
    mov.l @(8, r1), r2                  ! r2 = car[0x128] (flag word slot 2)
    tst r3, r2                          ! bit 0x4 set in slot 2?
    or r2, r12                          ! r12 |= slot 2 flags
    bt      .L_check_slot_3             ! not set: skip increment
    add #0x1, r4                        ! count++ (slot 2 has active bit)
.L_check_slot_3:
    mov.l @(12, r1), r2                 ! r2 = car[0x12C] (flag word slot 3)
    tst r3, r2                          ! bit 0x4 set in slot 3?
    or r2, r12                          ! r12 |= slot 3 flags
    bt      .L_after_flag_scan          ! not set: skip increment
    add #0x1, r4                        ! count++ (slot 3 has active bit)
.L_after_flag_scan:
    tst r4, r4                          ! any active flags found?
    bt      .L_return_halved            ! no: return zero weight (halved)
    mov #0x10, r1                       ! r1 = 0x10 (override bit mask)
    tst r1, r12                         ! override bit set in accumulated flags?
    bf      .L_return_zero_weight       ! yes: return zero weight
    mov.w   _wpool_render_type_offset, r1 ! r1 = 0x007C (render_type offset)
    mov.w @(r0, r1), r2                 ! r2 = car[0x7C] (render type)
    mov #0xA, r1                        ! r1 = 0xA (threshold: special types)
    cmp/ge r1, r2                       ! render_type >= 0xA?
    bt      .L_return_zero_weight       ! yes: special type, zero weight
    mov #0x8, r1                        ! r1 = 0x8 (threshold: doubled range)
    cmp/ge r1, r2                       ! render_type >= 8?
    bt      .L_return_doubled_weight    ! yes: types 8-9, use doubled weight
    mov #0x4, r1                        ! r1 = 0x4 (exact match: skip type)
    cmp/eq r1, r2                       ! render_type == 4?
    bt      .L_return_zero_weight       ! yes: skip type, zero weight
    mov #0x5, r1                        ! r1 = 0x5 (exact match: skip type)
    cmp/eq r1, r2                       ! render_type == 5?
    bt      .L_return_zero_weight       ! yes: skip type, zero weight
    mov #0x2, r7                        ! r7 = 2 (count threshold)
    cmp/ge r4, r7                       ! 2 >= flag_count? (count <= 2?)
    bt      .L_use_table_b              ! yes: few flags, use smaller table
    mov.l @(8, r0), r2                  ! r2 = car[0x08] (speed index)
    .byte   0xD3, 0x04    /* mov.l _pool_weight_tbl_a, r3 */
    shll2 r2                            ! r2 *= 4 (longword index)
    add r2, r3                          ! r3 = &weight_tbl_a[speed_idx]
    mov.l @r3, r4                       ! r4 = weight_tbl_a[speed_idx]
    rts                                 ! return (many flags path)
    shar r4                             ! (delay) r4 >>= 1 (halve weight)
_wpool_flag_bit_mask:
    .2byte  0x0004                      /* bit mask: activation flag bit 2 */
_wpool_flag_base_offset:
    .2byte  0x0120                      /* car+0x120: activation flag array base */
_wpool_render_type_offset:
    .2byte  0x007C                      /* car+0x7C: render type selector */
_pool_weight_tbl_a:
    .4byte  sym_0604679C               /* weight table A (high-count path) */
.L_use_table_b:
    mov.l @(8, r0), r2                  ! r2 = car[0x08] (speed index)
    .byte   0xD3, 0x03    /* mov.l _pool_weight_tbl_b, r3 */
    shll2 r2                            ! r2 *= 4 (longword index)
    add r2, r3                          ! r3 = &weight_tbl_b[speed_idx]
    mov.l @r3, r4                       ! r4 = weight_tbl_b[speed_idx]
.L_return_halved:
    rts                                 ! return (few flags or zero path)
    shar r4                             ! (delay) r4 >>= 1 (halve weight)
    .2byte  0x0000                      /* alignment padding */
_pool_weight_tbl_b:
    .4byte  sym_06046F9C               /* weight table B (low-count path) */
.L_return_zero_weight:
    rts                                 ! return with zero weight
    mov #0x0, r4                        ! (delay) r4 = 0 (no contribution)
.L_return_doubled_weight:
    mov.l @(8, r0), r2                  ! r2 = car[0x08] (speed index)
    .byte   0xD3, 0x03    /* mov.l _pool_weight_tbl_a_dup, r3 */
    shll2 r2                            ! r2 *= 4 (longword index)
    add r2, r3                          ! r3 = &weight_tbl_a[speed_idx]
    mov.l @r3, r4                       ! r4 = weight_tbl_a[speed_idx]
    rts                                 ! return (types 8-9 doubled path)
    shll r4                             ! (delay) r4 <<= 1 (double weight)
    .2byte  0x0000                      /* alignment padding */
_pool_weight_tbl_a_dup:
    .4byte  sym_0604679C               /* weight table A (doubled path, dup) */

    .global sym_0602F7BC
sym_0602F7BC:
    mov.w   DAT_0602f7e4, r1            ! r1 = 0x0166 (timer A offset)
    mov.w @(r0, r1), r2                 ! r2 = car[0x166] (animation frame timer)
    tst r2, r2                          ! timer A == 0?
    bt      .L_check_timer_b            ! yes: skip decrement
    add #-0x1, r2                       ! timer A--
    mov.w r2, @(r0, r1)                 ! store decremented timer A
.L_check_timer_b:
    mov.w   DAT_0602f7e6, r1            ! r1 = 0x0152 (timer B offset)
    mov.w @(r0, r1), r2                 ! r2 = car[0x152] (effect duration timer)
    tst r2, r2                          ! timer B == 0?
    bt      .L_check_timer_c            ! yes: skip decrement
    add #-0x1, r2                       ! timer B--
    mov.w r2, @(r0, r1)                 ! store decremented timer B
.L_check_timer_c:
    mov.w   DAT_0602f7e8, r1            ! r1 = 0x0208 (timer C offset)
    mov.l @(r0, r1), r2                 ! r2 = car[0x208] (extended cooldown timer)
    tst r2, r2                          ! timer C == 0?
    bt      .L_timers_done              ! yes: skip decrement
    add #-0x1, r2                       ! timer C--
    mov.l r2, @(r0, r1)                 ! store decremented timer C
.L_timers_done:
    rts                                 ! return to caller
    nop                                 ! delay slot

    .global DAT_0602f7e4
DAT_0602f7e4:
    .2byte  0x0166                      /* car+0x166: timer A (anim frame counter) */

    .global DAT_0602f7e6
DAT_0602f7e6:
    .2byte  0x0152                      /* car+0x152: timer B (effect duration) */

    .global DAT_0602f7e8
DAT_0602f7e8:
    .2byte  0x0208                      /* car+0x208: timer C (extended cooldown) */
