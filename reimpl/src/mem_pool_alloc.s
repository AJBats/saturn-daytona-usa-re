/* mem_pool_alloc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601F464 - 0x0601F4B4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Geometry element dispatch -- sets up per-player geometry data, dispatches
 * the HUD element via mat_euler_rotate, initializes the normal buffer via
 * geom_normal_compute, then tail-chains into geom_output_handler.
 *
 * Flow:
 *   1. Load player index from sym_060877D8.
 *   2. Compute entry pointer: string_table + index * 12 -> r5.
 *   3. Load element state byte from sym_060877D9[index] -> r4.
 *   4. Call mat_euler_rotate (HUD element dispatch, vtable slot 6).
 *   5. Call geom_normal_compute (reset geometry output buffer).
 *   6. Tail-branch to geom_output_handler.
 *
 * Key symbols:
 *   sym_060877D8 = current player/car index (byte)
 *   sym_0604A57C = course name string table (12 bytes per entry)
 *   sym_060877D9 = player element state array (indexed by player)
 *
 * Called functions:
 *   mat_euler_rotate     (0x0601E6E0) -- HUD element dispatch helper
 *   geom_normal_compute  (0x0601EB70) -- geometry normal buffer initializer
 *   geom_output_handler  (0x0601F40C) -- geometry output handler (tail call)
 *
 * Arguments: none (reads global state)
 * Returns: does not return directly (tail-chains to geom_output_handler)
 */

    .section .text.FUN_0601F464


    .global mem_pool_alloc
    .type mem_pool_alloc, @function
mem_pool_alloc:
    sts.l pr, @-r15                        ! save return address
    mov.l   .L_pool_player_index, r5       ! r5 -> sym_060877D8 (player index byte)
    mov.l   .L_pool_string_table, r2       ! r2 -> sym_0604A57C (string table base)
    mov.l   .L_pool_player_index, r4       ! r4 -> sym_060877D8 (player index byte, second load)
    mov.b @r5, r5                          ! r5 = player index (signed byte)
    mov.b @r4, r4                          ! r4 = player index (signed byte)
    extu.b r5, r5                          ! r5 = player index (unsigned)
    extu.b r4, r4                          ! r4 = player index (unsigned)
    mov r5, r3                             ! r3 = index copy (for stride calc)
    shll2 r5                               ! r5 = index * 4
    shll2 r3                               ! r3 = index * 4
    shll r3                                ! r3 = index * 8
    add r3, r5                             ! r5 = index * 12 (entry stride)
    add r2, r5                             ! r5 -> string table entry for this player
    mov.l   .L_pool_elem_state, r3         ! r3 -> sym_060877D9 (element state array)
    add r3, r4                             ! r4 -> element_state[player_index]
    mov.b @r4, r4                          ! r4 = element state (signed byte)
    .byte   0xB9, 0x2B    /* bsr 0x0601E6E0 (mat_euler_rotate) */
    extu.b r4, r4                          ! r4 = element state (unsigned, delay slot)
    .byte   0xBB, 0x71    /* bsr 0x0601EB70 (geom_normal_compute) */
    nop                                    ! delay slot (no setup needed)
    .byte   0xAF, 0xBD    /* bra 0x0601F40C (geom_output_handler, tail call) */
    lds.l @r15+, pr                        ! restore return address (delay slot)
    .2byte  0xFFFF                         ! padding
.L_pool_player_index:
    .4byte  sym_060877D8                   ! pool: current player/car index byte
    .4byte  sym_060877DD                   ! pool: player status flags array (used by geom_output_handler)
    .4byte  sym_0605E098                   ! pool: geom output buffer ptr (used by geom_output_handler)
.L_pool_string_table:
    .4byte  sym_0604A57C                   ! pool: course name string table base (12 bytes per entry)
.L_pool_elem_state:
    .4byte  sym_060877D9                   ! pool: player element state array
    .4byte  sym_0605E05C                   ! pool: secondary geom buffer ptr (used by geom_output_handler)
    .4byte  sym_0601F8BC                   ! pool: geom output main entry (used by geom_output_handler)
    .4byte  0x000B0009                     ! pool: packed constants (unreferenced in this TU)
