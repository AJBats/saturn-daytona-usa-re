/* track_segment_interp -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060414D0 - 0x060415C8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * track_road_edge_c: validate and enqueue a vehicle interpolation entry.
 *
 * Called by player_vehicle_interp to add a new entry to the queue stored in
 * game_state (pointed to by sym_060A5400).  Each entry records a target car
 * (r4), a source-flag byte (r5), and two optional source car indices (r6/r7).
 *
 * Arguments:
 *   r4 = carID / segment ID    (0..0x17, -2 = "no-car sentinel A", 0xFF = sentinel)
 *   r5 = source flags          (0..0x17; bitmask: 1=has srcA, 2=has srcB)
 *   r6 = srcA car index        (0..0x17, -2 = no source, 0xFF = sentinel)
 *   r7 = srcB car index        (0..0x17, -2 = no source, 0xFF = sentinel)
 *
 * Returns:
 *    r0 =  0   success (entry enqueued, player_vehicle_interp called)
 *    r0 = -6   invalid argument (r4/r5/r6 out of range or inconsistent)
 *    r0 = -7   inactive car (state[+0x18+carID] != 1 for r4 or r6, or state[+r5] != 1)
 *    r0 = -8   queue full (entry count already >= 24)
 *
 * Game state fields (base = *sym_060A5400):
 *   +0x18 + idx  byte   car_active[idx]   — 1 if car idx is in use
 *   +0x01DC      long   entry_count        — number of pending queue entries
 *   +0x01E0      long   queue_active_flag  — non-zero while queue has entries
 *   +0x01E4      byte[] entry_array        — 12-byte entries (carID, flags, srcA)
 */

    .section .text.FUN_060414D0


    .global track_segment_interp
    .type track_segment_interp, @function
track_segment_interp:
    mov.l r14, @-r15                         ! push r14 (callee-save; will hold game_state indirect ptr)
    sts.l pr, @-r15                          ! push return address
    add #-0x4, r15                           ! allocate 4-byte stack scratch space
    mov.l   .L_pool_game_state_ptr, r14      ! r14 = &sym_060A5400 (pointer to game state pointer)
    mov.w   DAT_0604155c, r0                 ! r0 = 0x01DC (entry_count field offset)
    mov.w   DAT_0604155e, r7                 ! r7 = 0x00FF (sentinel: no source car / invalid)
    mov.l @r14, r1                           ! r1 = game_state_base (dereference ptr)
    cmp/eq r7, r4                            ! r4 == 0xFF sentinel?
    bt/s    .L_r4_valid                      ! if sentinel, skip range check (treat as valid placeholder)
    mov.l @(r0, r1), r1                      ! r1 = game_state[+0x01DC] = current entry count (delay slot)
    mov r4, r0                               ! r0 = r4 (copy for compare)
    cmp/eq #-0x2, r0                         ! r4 == -2 (no-car sentinel)?
    bt      .L_r4_valid                      ! if -2, also treat as valid (skip range check)
    cmp/pz r4                                ! r4 >= 0?
    bf      .L_ret_invalid_arg               ! if negative (but not -2), fail: invalid car ID
    mov #0x18, r2                            ! r2 = 0x18 (24: max car count)
    cmp/ge r2, r4                            ! r4 >= 24?
    bt      .L_ret_invalid_arg               ! if r4 >= 24, fail: out-of-range car ID
.L_r4_valid:
    cmp/pz r5                                ! r5 (source flags) >= 0?
    bf      .L_ret_invalid_arg               ! if negative, fail: invalid flags
    mov #0x18, r3                            ! r3 = 0x18 (24: max value for flags field)
    cmp/ge r3, r5                            ! r5 >= 24?
    bt      .L_ret_invalid_arg               ! if flags >= 24, fail: out-of-range
    cmp/eq r7, r6                            ! r6 == 0xFF sentinel?
    bt      .L_r6_valid                      ! if sentinel, skip srcA range check
    mov r6, r0                               ! r0 = r6 (copy for compare)
    cmp/eq #-0x2, r0                         ! r6 == -2 (no-car sentinel)?
    bt      .L_r6_valid                      ! if -2, srcA absent but valid
    cmp/pz r6                                ! r6 >= 0?
    bf      .L_ret_invalid_arg               ! if negative (not -2), fail: invalid srcA
    mov #0x18, r2                            ! r2 = 0x18 (24: max car count)
    cmp/ge r2, r6                            ! r6 >= 24?
    bf      .L_r6_valid                      ! r6 < 24 → in-range, continue
.L_ret_invalid_arg:
    mov #-0x6, r0                            ! r0 = -6 (error: invalid argument)
    add #0x4, r15                            ! pop scratch space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return -6
    mov.l @r15+, r14                         ! restore r14 (delay slot)
.L_r6_valid:
    cmp/eq r7, r4                            ! r4 == 0xFF (target is sentinel)?
    bt      .L_skip_r4_active_check          ! if sentinel, no active-car check needed for r4
    mov r4, r0                               ! r0 = r4 (copy for compare)
    cmp/eq #-0x2, r0                         ! r4 == -2?
    bt      .L_skip_r4_active_check          ! if -2, skip active check for r4
    mov.l   .L_pool_game_state_ptr, r0       ! r0 = &game_state_ptr
    mov.l @r0, r0                            ! r0 = game_state_base
    add #0x18, r0                            ! r0 = &game_state[+0x18] (car_active array base)
    mov.b @(r0, r4), r0                      ! r0 = car_active[r4] (is target car active?)
    cmp/eq #0x1, r0                          ! car_active[r4] == 1?
    bf      .L_ret_inactive_car              ! if not 1, fail: target car not active
.L_skip_r4_active_check:
    cmp/eq r7, r6                            ! r6 == 0xFF (srcA is sentinel)?
    bt      .L_skip_r6_active_check          ! if sentinel, skip active check for srcA
    mov r6, r0                               ! r0 = r6 (copy for compare)
    cmp/eq #-0x2, r0                         ! r6 == -2?
    bt      .L_skip_r6_active_check          ! if -2, skip active check for srcA
    mov.l   .L_pool_game_state_ptr, r0       ! r0 = &game_state_ptr
    mov.l @r0, r0                            ! r0 = game_state_base
    add #0x18, r0                            ! r0 = &game_state[+0x18] (car_active array base)
    mov.b @(r0, r6), r0                      ! r0 = car_active[r6] (is srcA car active?)
    cmp/eq #0x1, r0                          ! car_active[r6] == 1?
    bf      .L_ret_inactive_car              ! if not 1, fail: srcA car not active
.L_skip_r6_active_check:
    mov.l   .L_pool_game_state_ptr, r0       ! r0 = &game_state_ptr
    mov.l @r0, r0                            ! r0 = game_state_base
    mov.b @(r0, r5), r0                      ! r0 = game_state[r5] (flags-indexed byte: car active?)
    cmp/eq #0x1, r0                          ! game_state[r5] == 1 (flags-indexed car active)?
    bt      .L_all_valid                     ! if 1, all checks pass → proceed to enqueue
.L_ret_inactive_car:
    mov #-0x7, r0                            ! r0 = -7 (error: required car not active)
    add #0x4, r15                            ! pop scratch space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return -7
    mov.l @r15+, r14                         ! restore r14 (delay slot)

    .global DAT_0604155c
DAT_0604155c:
    .2byte  0x01DC

    .global DAT_0604155e
DAT_0604155e:
    .2byte  0x00FF
.L_pool_game_state_ptr:
    .4byte  sym_060A5400
.L_all_valid:
    mov #0x18, r2                            ! r2 = 0x18 (24: max queue depth)
    cmp/ge r2, r1                            ! entry_count >= 24?
    bf      .L_queue_not_full                ! if count < 24, queue has space
    mov #-0x8, r0                            ! r0 = -8 (error: queue full)
    add #0x4, r15                            ! pop scratch space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return -8
    mov.l @r15+, r14                         ! restore r14 (delay slot)
.L_queue_not_full:
    mov.l @r14, r2                           ! r2 = game_state_base
    .byte   0x90, 0x39    /* mov.w .L_wpool_060415EC, r0 */   ! r0 = 0x01E0 (queue_active_flag offset)
    mov.l @(r0, r2), r0                      ! r0 = game_state[+0x01E0] (queue_active_flag)
    tst r0, r0                               ! queue_active_flag == 0?
    bf      .L_flag_already_set              ! if non-zero, flag already set — skip
    mov.l @r14, r3                           ! r3 = game_state_base
    mov #0x1, r2                             ! r2 = 1
    .byte   0x90, 0x33    /* mov.w .L_wpool_060415EC, r0 */   ! r0 = 0x01E0 (queue_active_flag offset)
    mov.l r2, @(r0, r3)                      ! game_state[+0x01E0] = 1 (mark queue as active)
.L_flag_already_set:
    exts.w r1, r7                            ! r7 = sign-extend(entry_count) (slot index)
    mov.l @r14, r3                           ! r3 = game_state_base
    mov r7, r2                               ! r2 = entry_count (copy for stride calc)
    shll2 r7                                 ! r7 = count * 4
    shll2 r2                                 ! r2 = count * 4
    shll r2                                  ! r2 = count * 8
    add r2, r7                               ! r7 = count*4 + count*8 = count*12 (12-byte stride)
    exts.w r7, r7                            ! r7 = sign-extend(count*12) (entry byte offset)
    .byte   0x92, 0x2A    /* mov.w .L_wpool_060415EE, r2 */   ! r2 = 0x01E4 (entry_array base offset)
    add r2, r3                               ! r3 = &game_state[+0x01E4] (entry array base)
    add r7, r3                               ! r3 = &entry_array[entry_count] (new entry slot)
    mov.l r4, @r3                            ! entry[+0] = r4 (carID / target segment)
    mov.l @r14, r3                           ! r3 = game_state_base (reload)
    add r3, r2                               ! r2 = &game_state[+0x01E4] (entry array base)
    add r7, r2                               ! r2 = &entry_array[entry_count]
    mov.l r5, @(4, r2)                       ! entry[+4] = r5 (source flags)
    mov.l @r14, r3                           ! r3 = game_state_base (reload)
    .byte   0x92, 0x21    /* mov.w .L_wpool_060415EE, r2 */   ! r2 = 0x01E4 (entry_array base offset)
    add r3, r2                               ! r2 = &game_state[+0x01E4] (entry array base)
    add r2, r7                               ! r7 = &entry_array[entry_count]
    mov.l r6, @(8, r7)                       ! entry[+8] = r6 (srcA car index)
    mov.l @r14, r3                           ! r3 = game_state_base
    .byte   0x90, 0x1D    /* mov.w .L_wpool_060415F0, r0 */   ! r0 = 0x01DC (entry_count field offset)
    mov.l @(r0, r3), r2                      ! r2 = game_state[+0x01DC] (entry_count)
    add #0x1, r2                             ! r2 = entry_count + 1
    mov.l r2, @(r0, r3)                      ! game_state[+0x01DC] = entry_count + 1 (commit new entry)
    .byte   0xB5, 0xBB    /* bsr 0x06042134 (external) */     ! call player_vehicle_interp(&local[0])
    mov r15, r4                              ! r4 = stack pointer (output buffer ptr; delay slot)
    mov #0x0, r0                             ! r0 = 0 (return success)
    add #0x4, r15                            ! pop scratch space
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return 0 (success)
    mov.l @r15+, r14                         ! restore r14 (delay slot)
