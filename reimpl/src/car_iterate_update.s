/* car_iterate_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600D8A4 - 0x0600D92C
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0600D8A4

/* ================================================================
 * car_iterate_update — Iterate all cars, trigger lap flag for matches
 * ================================================================
 *
 * Called from: FUN_0600D780 single-step path (falls through after
 *              player checkpoint tracking).
 * Parameter: r4 = condition flag (non-zero enables lap flag setting)
 *
 * Iterates over all active cars (count from course data).
 * For each car, reads that car's checkpoint parameter (offset 0x01EC)
 * and compares it against the reference car's checkpoint parameter.
 * If they match AND the condition flag (r4) is non-zero, calls
 * FUN_0600D9BC to set the lap completion flag for that car.
 *
 * After setting the lap flag, checks byte+3 bit 3 of the car struct
 * pointed to by sym_0607E944 (the "other car" pointer). If bit 3 is
 * set, records a result flag at sym_060786AC.
 *
 * Global addresses:
 *   sym_0607E944 — other/iterated car struct pointer
 *   sym_0607E940 — current car struct pointer
 *   sym_060786AC — result flag (camera enable / lap-related state)
 *   sym_06063F3C — course data entry pointer (car count via deref)
 *
 * Car struct offsets used:
 *   +0x0004  car array base pointer (from course data[4])
 *   +0x01EC  checkpoint parameter (from checkpoint table entry[0x16])
 * ================================================================ */

    .global car_iterate_update
    .type car_iterate_update, @function
car_iterate_update:
    mov.l r14, @-r15                         ! save r14 (loop counter)
    mov #0x0, r5                             ! r5 = 0 (initial comparison value)
    mov.l r13, @-r15                         ! save r13 (constant 1)
    mov r5, r14                              ! r14 = 0 (loop index i)
    mov.l r12, @-r15                         ! save r12 (car count)
    mov #0x1, r13                            ! r13 = 1 (value to store in result flag)
    mov.l r11, @-r15                         ! save r11
    mov.l r10, @-r15                         ! save r10
    mov.l r9, @-r15                          ! save r9
    mov.l r8, @-r15                          ! save r8
    sts.l pr, @-r15                          ! save return address
    add #-0x4, r15                           ! allocate 4 bytes on stack for condition flag
    mov.l   .L_other_car_ptr, r8             ! r8 = &other_car_ptr (sym_0607E944)
    mov.l   .L_current_car_ptr, r9           ! r9 = &current_car_ptr (sym_0607E940)
    mov.l   .L_result_flag, r10              ! r10 = &result_flag (sym_060786AC)
    mov.l   .L_course_data_ptr, r11          ! r11 = &course_data_entry_ptr (sym_06063F3C)
    mov.l @r11, r12                          ! r12 = course_data_entry_ptr
    mov.l @r12, r12                          ! r12 = *course_data_entry = car_count
    tst r4, r4                               ! test condition flag (r4)
    .word 0x0029 /* UNKNOWN */
    cmp/hs r12, r5                           ! if 0 >= car_count (unsigned), skip loop
    bt/s    .L_epilogue
    mov.l r0, @r15                           ! store condition flag (movt result) on stack
.L_loop_top:
    mov r14, r3                              ! r3 = loop index i
    mov.l @r9, r1                            ! r1 = current_car_ptr
    mov.l @r11, r0                           ! r0 = course_data_entry_ptr
    shll2 r3                                 ! r3 = i * 4 (index into car pointer array)
    mov.l @(4, r0), r2                       ! r2 = course_data[4] = car_array_base
    mov.w   .L_wpool_0600D91A, r0            ! r0 = 0x01EC (checkpoint param offset)
    add r2, r3                               ! r3 = &car_array[i] (pointer into car array)
    mov.l @r3, r3                            ! r3 = car_array[i] (car's checkpoint param)
    mov.l @(r0, r1), r2                      ! r2 = current_car[0x01EC] (reference param)
    cmp/eq r2, r3                            ! if car[i] checkpoint param == reference param
    bf      .L_next_car                      ! no match, skip to next car
    mov.l @r15, r0                           ! r0 = condition flag from stack
    tst r0, r0                               ! test condition flag
    bt      .L_next_car                      ! if zero, skip lap flag setting
    mov r14, r4                              ! r4 = car index i
    .byte   0xB0, 0x64    /* bsr 0x0600D9BC (external) */
    add #0x1, r4                             ! r4 = i + 1 (1-based car index, delay slot)
    mov.l @r8, r2                            ! r2 = other_car_ptr (sym_0607E944)
    mov r2, r0                               ! r0 = other_car_ptr (for byte access)
    mov.b @(3, r0), r0                       ! r0 = other_car[byte+3] (flag byte)
    tst #0x8, r0                             ! test bit 3 (proximity/lap result flag)
    bt      .L_next_car                      ! if bit 3 clear, skip
    mov.l r13, @r10                          ! *result_flag = 1 (set sym_060786AC)
.L_next_car:
    add #0x1, r14                            ! i++
    cmp/hs r12, r14                          ! if i >= car_count (unsigned)
    bf      .L_loop_top                      ! loop back if more cars
.L_epilogue:
    add #0x4, r15                            ! deallocate stack space
    lds.l @r15+, pr                          ! restore return address
    mov.l @r15+, r8                          ! restore r8
    mov.l @r15+, r9                          ! restore r9
    mov.l @r15+, r10                         ! restore r10
    mov.l @r15+, r11                         ! restore r11
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    rts                                      ! return
    mov.l @r15+, r14                         ! restore r14 (delay slot)
.L_wpool_0600D91A:
    .2byte  0x01EC
.L_other_car_ptr:
    .4byte  sym_0607E944
.L_current_car_ptr:
    .4byte  sym_0607E940
.L_result_flag:
    .4byte  sym_060786AC
.L_course_data_ptr:
    .4byte  sym_06063F3C
