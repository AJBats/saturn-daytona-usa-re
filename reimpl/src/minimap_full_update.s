/* minimap_full_update -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015754 - 0x060158DE
 * Auto-generated by tools/generate_l3_tu.py
 *
 * minimap_full_update(slot_index):
 *   Updates a minimap HUD element slot's position by integrating velocity
 *   into position, then clamping each axis within bounds.
 *
 *   The slot struct (68 bytes, base sym_06084FC8) has:
 *     +0x04  x_pos      (32-bit, 16.16 fixed-point)
 *     +0x08  y_pos      (32-bit, 16.16 fixed-point)
 *     +0x0C  z_pos / scale (32-bit, 16.16 fixed-point)
 *     +0x10  x_vel      (32-bit, per-frame delta)
 *     +0x14  y_vel      (32-bit, per-frame delta)
 *     +0x18  z_vel / scale_vel (32-bit, per-frame delta)
 *     +0x29  anim_timer (byte, offset 0x41 from base)
 *     +0x02  element_type (byte)
 *     +0x34  x_limit    (32-bit, max for x_pos)
 *
 *   Steps:
 *     1. Add velocity to position for x, y, z axes
 *     2. Check direction flags (r14 byte) to decide clamping mode
 *     3. If growing: clamp x_pos to <= x_limit
 *        If decaying: clamp x_pos to >= x_limit (minimum bound)
 *     4. Clamp y_pos to >= 0 (floor at zero)
 *     5. Clamp z_pos/scale to <= 1.0 (16.16 fixed-point ceiling)
 *     6. Call track_vtx_builder to recompute minimap vertices
 *     7. Decrement anim_timer; if expired, advance element_type
 *
 *   Input:  r4  = slot index (byte), r14 = direction flags (byte, callee-saved)
 *   Output: slot fields updated in-place; minimap vertices rebuilt
 *
 *   Persistent registers:
 *     r13 = sym_06084FC8 (slot data array base)
 *     r14 = direction flags (restored from callee-saved value)
 *
 * loc_060158A4:
 *   Stub — immediate return (no-op handler for unused minimap slots).
 *
 * loc_060158B0:
 *   Minimap slot dispatch — reads the element type byte from a slot struct,
 *   indexes into a function pointer table, and jumps to the selected handler.
 *   Pool references are in the next TU's constant pool (cross-TU mov.l).
 *
 *   Input:  r4 = slot index (byte)
 *   Output: tail-jumps to the handler for this slot's current element type
 */

    .section .text.FUN_06015754


    .global minimap_full_update
    .type minimap_full_update, @function
minimap_full_update:
    sts.l pr, @-r15                        ! save return address
    mov r4, r3                             ! r3 = slot_index (copy for stride calc)
    mov.l   .L_slot_data_base, r13         ! r13 = sym_06084FC8 (slot array base)
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68 (slot struct stride)
    exts.w r4, r4                          ! sign-extend offset to longword
    add r13, r4                            ! r4 = &slot_data[idx] (struct base ptr)
    /* --- integrate velocity into position for all 3 axes --- */
    mov.l @(16, r4), r2                    ! r2 = slot[+0x10] (x_vel)
    mov.l @(4, r4), r3                     ! r3 = slot[+0x04] (x_pos)
    add r2, r3                             ! r3 = x_pos + x_vel
    mov.l r3, @(4, r4)                     ! slot[+0x04] = updated x_pos
    mov.l @(20, r4), r2                    ! r2 = slot[+0x14] (y_vel)
    mov.l @(8, r4), r3                     ! r3 = slot[+0x08] (y_pos)
    add r2, r3                             ! r3 = y_pos + y_vel
    mov.l r3, @(8, r4)                     ! slot[+0x08] = updated y_pos
    mov.l @(24, r4), r2                    ! r2 = slot[+0x18] (z_vel / scale_vel)
    mov.l @(12, r4), r3                    ! r3 = slot[+0x0C] (z_pos / scale)
    add r2, r3                             ! r3 = z_pos + z_vel
    mov.l r3, @(12, r4)                    ! slot[+0x0C] = updated z_pos
    /* --- determine clamping direction from flags in r14 --- */
    extu.b r14, r4                         ! r4 = direction_flags (zero-extended byte)
    mov r4, r0                             ! r0 = direction_flags
    cmp/eq #0x1, r0                        ! T = (flags == 1)?  (growing mode)
    .word 0x0029 /* MOVT R0 */             ! r0 = T (1 if growing, else 0)
    mov r0, r3                             ! r3 = is_growing
    mov r4, r0                             ! r0 = direction_flags
    cmp/eq #0x3, r0                        ! T = (flags == 3)?  (also growing mode)
    .word 0x0129 /* MOVT R1 */             ! r1 = T (1 if flags==3, else 0)
    or r1, r3                              ! r3 = is_growing || is_flags_3
    tst r3, r3                             ! test combined flag
    bt      .L_decay_clamp                 ! if zero → not growing, use decay clamping
    /* --- growing mode: clamp x_pos to <= x_limit --- */
    extu.b r14, r4                         ! r4 = direction_flags (slot index source)
    mov r4, r3                             ! r3 = copy for stride calc
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(4, r4), r2                     ! r2 = x_pos (current)
    mov.l @(52, r4), r3                    ! r3 = slot[+0x34] (x_limit)
    cmp/ge r3, r2                          ! T = (x_pos >= x_limit)?
    bf      .L_clamp_x_done                ! if x_pos < limit → no clamping needed
    /* x_pos exceeded upper bound — clamp to x_limit */
    extu.b r14, r4                         ! r4 = slot index
    mov r4, r3                             ! r3 = copy for stride calc
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(52, r4), r2                    ! r2 = x_limit
    bra     .L_clamp_x_done               ! skip decay path
    mov.l r2, @(4, r4)                     ! slot[+0x04] = x_limit (delay slot: clamp)
.L_slot_data_base:
    .4byte  sym_06084FC8
.L_decay_clamp:
    /* --- decay mode: clamp x_pos to >= x_limit (minimum bound) --- */
    extu.b r14, r4                         ! r4 = slot index
    mov r4, r3                             ! r3 = copy for stride calc
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(4, r4), r2                     ! r2 = x_pos (current)
    mov.l @(52, r4), r3                    ! r3 = x_limit (lower bound)
    cmp/gt r3, r2                          ! T = (x_pos > x_limit)?
    bt      .L_clamp_x_done               ! if x_pos > limit → no clamping needed
    /* x_pos fell below lower bound — clamp to x_limit */
    extu.b r14, r4                         ! r4 = slot index
    mov r4, r3                             ! r3 = copy for stride calc
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.l @(52, r4), r2                    ! r2 = x_limit
    mov.l r2, @(4, r4)                     ! slot[+0x04] = x_limit (clamp to lower bound)
.L_clamp_x_done:
    /* --- clamp y_pos: floor at zero --- */
    extu.b r14, r3                         ! r3 = slot index
    mov r3, r2                             ! r2 = copy for stride calc
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68
    exts.w r3, r3                          ! sign-extend offset
    add r13, r3                            ! r3 = &slot_data[idx]
    mov.l @(8, r3), r3                     ! r3 = slot[+0x08] (y_pos)
    cmp/pz r3                              ! T = (y_pos >= 0)?
    bf      .L_clamp_y_done               ! if y_pos < 0 → need to clamp
    /* y_pos is non-negative — clamp to zero (floor) */
    extu.b r14, r3                         ! r3 = slot index
    mov r3, r2                             ! r2 = copy for stride calc
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68
    exts.w r3, r3                          ! sign-extend offset
    add r13, r3                            ! r3 = &slot_data[idx]
    mov #0x0, r1                           ! r1 = 0
    mov.l r1, @(8, r3)                     ! slot[+0x08] = 0 (clamp y_pos to zero)
.L_clamp_y_done:
    /* --- clamp z_pos/scale: ceiling at 1.0 (16.16 FP) --- */
    extu.b r14, r3                         ! r3 = slot index
    mov.l   .L_fp_one, r4                  ! r4 = 0x10000 (1.0 in 16.16 fixed-point)
    mov r3, r2                             ! r2 = copy for stride calc
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68
    exts.w r3, r3                          ! sign-extend offset
    add r13, r3                            ! r3 = &slot_data[idx]
    mov.l @(12, r3), r3                    ! r3 = slot[+0x0C] (z_pos / scale)
    cmp/ge r4, r3                          ! T = (scale >= 1.0)?
    bf      .L_clamp_z_done               ! if scale < 1.0 → no clamping needed
    /* scale exceeded 1.0 — clamp to 1.0 */
    extu.b r14, r3                         ! r3 = slot index
    mov r3, r2                             ! r2 = copy for stride calc
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68
    exts.w r3, r3                          ! sign-extend offset
    add r13, r3                            ! r3 = &slot_data[idx]
    mov.l r4, @(12, r3)                    ! slot[+0x0C] = 0x10000 (clamp to 1.0)
.L_clamp_z_done:
    /* --- rebuild minimap vertices for this slot --- */
    mov.l   .L_track_vtx_builder, r3       ! r3 = &track_vtx_builder
    jsr @r3                                ! call track_vtx_builder(slot_index)
    extu.b r14, r4                         ! r4 = slot index (delay slot: arg)
    /* --- decrement animation timer --- */
    extu.b r14, r4                         ! r4 = slot index
    mov #0x41, r0                          ! r0 = 0x41 (offset of anim_timer byte)
    mov r4, r3                             ! r3 = copy for stride calc
    shll2 r4                               ! r4 = idx * 4
    shll2 r3                               ! r3 = idx * 4
    shll2 r3                               ! r3 = idx * 16
    shll2 r3                               ! r3 = idx * 64
    add r3, r4                             ! r4 = idx * 68
    exts.w r4, r4                          ! sign-extend offset
    add r13, r4                            ! r4 = &slot_data[idx]
    mov.b @(r0, r4), r2                    ! r2 = slot[+0x41] (anim_timer)
    add #-0x1, r2                          ! r2 = anim_timer - 1
    mov.b r2, @(r0, r4)                    ! slot[+0x41] = decremented timer
    mov.b @(r0, r4), r3                    ! r3 = re-read timer (for unsigned compare)
    extu.b r3, r3                          ! zero-extend timer byte
    cmp/pl r3                              ! T = (timer > 0)?
    bt      .L_epilogue                    ! if timer still positive → return normally
    /* --- timer expired: advance element type --- */
    extu.b r14, r14                        ! r14 = slot index (zero-extended)
    mov r14, r2                            ! r2 = copy for stride calc
    shll2 r14                              ! r14 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r14                            ! r14 = idx * 68
    exts.w r14, r14                        ! sign-extend offset
    add r13, r14                           ! r14 = &slot_data[idx]
    mov.b @(2, r14), r0                    ! r0 = slot[+0x02] (element_type)
    mov r0, r3                             ! r3 = element_type
    add #0x1, r3                           ! r3 = element_type + 1
    mov r3, r0                             ! r0 = new element_type
    mov.b r0, @(2, r14)                    ! slot[+0x02] = incremented element_type
.L_epilogue:
    lds.l @r15+, pr                        ! restore return address
    mov.l @r15+, r13                       ! restore r13
    rts                                    ! return to caller
    mov.l @r15+, r14                       ! restore r14 (delay slot)

    .global loc_060158A4
loc_060158A4:
    rts                                    ! immediate return (no-op stub)
    nop                                    ! (delay slot)
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_track_vtx_builder:
    .4byte  track_vtx_builder

    .global loc_060158B0
loc_060158B0:
    add #-0x4, r15                         ! allocate 4-byte stack frame
    mov.b r4, @r15                         ! sp[0] = slot_index (save arg)
    mov.b @r15, r3                         ! r3 = slot_index (re-read from stack)
    extu.b r3, r3                          ! zero-extend slot_index
    mov r3, r2                             ! r2 = copy for stride calc
    shll2 r3                               ! r3 = idx * 4
    shll2 r2                               ! r2 = idx * 4
    shll2 r2                               ! r2 = idx * 16
    shll2 r2                               ! r2 = idx * 64
    add r2, r3                             ! r3 = idx * 68 (slot struct stride)
    exts.w r3, r3                          ! sign-extend offset
    .byte   0xD1, 0x1B    /* mov.l .L_pool_06015934, r1 */  ! r1 = sym_06084FC8 (slot array base, cross-TU pool)
    add r1, r3                             ! r3 = &slot_data[idx] (struct base ptr)
    mov.b @(2, r3), r0                     ! r0 = slot[+0x02] (element_type)
    mov r0, r3                             ! r3 = element_type
    extu.b r3, r3                          ! zero-extend type byte
    shll2 r3                               ! r3 = type * 4 (function ptr table index)
    .byte   0xD2, 0x19    /* mov.l .L_pool_06015938, r2 */  ! r2 = handler table base (cross-TU pool)
    add r2, r3                             ! r3 = &handler_table[type]
    mov.l @r3, r3                          ! r3 = handler function pointer
    mov.b @r15, r4                         ! r4 = slot_index (restore from stack, arg for handler)
    jmp @r3                                ! tail-jump to handler(slot_index)
    add #0x4, r15                          ! deallocate stack frame (delay slot)
