/* audio_dist_calc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600DD88 - 0x0600DE40
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Compute audio distance values from car position data.
 *
 * Structurally mirrors checkpoint_time_calc (0x0600DCC8): both index into
 * per-car timing data, compute a Manhattan distance (|dX| + |dZ|) between
 * current and reference positions, call sym_06034FE0 to scale/divide, and
 * store three output values (elapsed, remaining, delta).
 *
 * Algorithm:
 *   1. Decrement car_index and multiply by 4 to form a byte offset into
 *      the car-index array at car_struct[+0x04].
 *   2. Load car struct pointer (sym_0607E940) and course data pointer
 *      (sym_06063F3C); dereference both.
 *   3. Read reference X from car_struct[+0x10] (r6).
 *   4. Read timing-data array pointer from car_struct[+0x04], index into
 *      it with the (car_index * 4) offset to get car_data_entry.
 *   5. Read audio data pointer from car_struct[+0x1E0] (word offset 0x01E0),
 *      index with car_entry stride (8*idx + 16*idx = 24 bytes per entry).
 *   6. Compute |audio_pos_X - ref_X| → r3 (abs X distance).
 *   7. Compute |audio_pos_Y - ref_Y| → r1 (abs Y/Z distance), using
 *      car_struct[+0x18] as the reference.
 *   8. Sum the two absolute differences; call sym_06034FE0 with r0 =
 *      car_struct[+0x0C] (scale divisor) and r1 = total distance.
 *   9. Store result (elapsed) to sym_0607869C.
 *  10. Load frame_counter (sym_0607EBD0), compute remaining = counter*5 - elapsed;
 *      store to sym_060786B0.
 *  11. Load previous remaining (sym_0605A21C), compute delta = remaining - prev;
 *      store to sym_060786A0.
 *  12. Write updated remaining back to sym_0605A21C.
 *
 * Inputs (globals):
 *   sym_0607E940  = pointer to current car struct
 *   sym_06063F3C  = current course data entry pointer
 *   sym_0607EBD0  = frame counter (32-bit)
 *   sym_0605A21C  = previous remaining value
 *
 * Outputs (globals):
 *   sym_0607869C  = audio elapsed distance (scaled)
 *   sym_060786B0  = audio remaining (frame_counter*5 - elapsed)
 *   sym_060786A0  = delta remaining (remaining - prev_remaining)
 *   sym_0605A21C  = updated to current remaining
 */

    .section .text.FUN_0600DD88


    .global audio_dist_calc
    .type audio_dist_calc, @function
audio_dist_calc:
    sts.l pr, @-r15                          ! save return address to stack
    add #-0x1, r4                            ! r4 = car_index - 1 (zero-based)
    add #-0x10, r15                          ! allocate 16 bytes of stack frame
    shll2 r4                                 ! r4 = (car_index-1) * 4 (byte offset)
    mov.l   .L_car_struct_ptr, r5            ! r5 = &car_struct_ptr (sym_0607E940)
    mov.l   .L_course_data_ptr, r0           ! r0 = &course_data_ptr (sym_06063F3C)
    mov.l @r5, r5                            ! r5 = car_struct (dereference)
    mov.l @r0, r0                            ! r0 = course_data (dereference)
    mov.l @(16, r5), r6                      ! r6 = car_struct[+0x10] = reference X position
    mov.l @(4, r0), r3                       ! r3 = course_data[+0x04] = timing array base
    mov.w   DAT_0600de1e, r0                 ! r0 = 0x01E0 (offset to audio data ptr in car_struct)
    add r3, r4                               ! r4 = timing_array_base + (car_index-1)*4 = entry ptr
    mov.l @r4, r2                            ! r2 = car_data_entry value (per-car index/offset)
    mov r2, r3                               ! r3 = car_data_entry (copy for stride multiply)
    mov.l @(r0, r5), r4                      ! r4 = car_struct[+0x1E0] = audio data array base
    shll2 r2                                 ! r2 = car_data_entry * 4
    shll2 r3                                 ! r3 = car_data_entry * 4
    shll r2                                  ! r2 = car_data_entry * 8
    shll2 r3                                 ! r3 = car_data_entry * 16
    add r3, r2                               ! r2 = car_data_entry * 24 (stride = 24 bytes/entry)
    add r2, r4                               ! r4 = &audio_data[car_data_entry] (entry pointer)
    mov.l @r4, r7                            ! r7 = audio_entry[+0] = audio pos X (current)
    mov r7, r2                               ! r2 = audio_pos_X (copy)
    sub r6, r2                               ! r2 = audio_pos_X - ref_X (signed diff)
    cmp/pz r2                                ! is (audio_pos_X - ref_X) >= 0?
    bt/s    .L_x_diff_positive               ! yes → diff is already the absolute value
    mov.l r2, @(12, r15)                     ! sp[12] = audio_pos_X - ref_X (delay slot)
    mov r6, r3                               ! r3 = ref_X
    bra     .L_x_abs_done                    ! skip positive path
    sub r7, r3                               ! r3 = ref_X - audio_pos_X = |dX| (delay slot)
.L_x_diff_positive:
    mov.l @(12, r15), r3                     ! r3 = audio_pos_X - ref_X (already >= 0, abs dX)
.L_x_abs_done:
    mov.l @(4, r4), r2                       ! r2 = audio_entry[+0x04] = audio pos Y/Z (current)
    mov.l r2, @(4, r15)                      ! sp[4] = audio_pos_Y (save for abs calc)
    mov.l @(24, r5), r2                      ! r2 = car_struct[+0x18] = reference Y/Z position
    mov.l r2, @(8, r15)                      ! sp[8] = ref_Y (save for abs calc)
    mov.l @(4, r15), r2                      ! r2 = audio_pos_Y (reload)
    mov.l @(8, r15), r1                      ! r1 = ref_Y (reload)
    sub r1, r2                               ! r2 = audio_pos_Y - ref_Y (signed diff)
    cmp/pz r2                                ! is (audio_pos_Y - ref_Y) >= 0?
    bt/s    .L_y_diff_positive               ! yes → diff is already the absolute value
    mov.l r2, @r15                           ! sp[0] = audio_pos_Y - ref_Y (delay slot)
    mov.l @(8, r15), r1                      ! r1 = ref_Y (reload)
    mov.l @(4, r15), r2                      ! r2 = audio_pos_Y (reload)
    sub r2, r1                               ! r1 = ref_Y - audio_pos_Y = |dY| (negate)
    bra     .L_y_abs_done                    ! skip positive path
    nop
.L_y_diff_positive:
    mov.l @r15, r1                           ! r1 = audio_pos_Y - ref_Y (already >= 0, abs dY)
.L_y_abs_done:
    mov r3, r4                               ! r4 = |dX| (Manhattan distance accumulator)
    mov.l   .L_p_audio_elapsed, r6           ! r6 = &audio_elapsed (sym_0607869C)
    add r1, r4                               ! r4 = |dX| + |dY| = total Manhattan distance
    mov.l   .L_fn_scale_divide, r3           ! r3 = &sym_06034FE0 (scale/divide function)
    mov r4, r1                               ! r1 = total_distance (dividend argument)
    jsr @r3                                  ! call scale_divide(r0=scale, r1=total_dist) → r0=elapsed
    mov.l @(12, r5), r0                      ! r0 = car_struct[+0x0C] = scale divisor (delay slot)
    mov.l r0, @r6                            ! audio_elapsed = result (store to sym_0607869C)
    mov r0, r1                               ! r1 = elapsed (keep for remaining calc)
    mov.l   .L_p_audio_remaining, r4         ! r4 = &audio_remaining (sym_060786B0)
    mov.l   .L_p_frame_counter, r2           ! r2 = &frame_counter (sym_0607EBD0)
    mov.l @r2, r2                            ! r2 = frame_counter (current frame count)
    mov r2, r3                               ! r3 = frame_counter (copy)
    shll2 r2                                 ! r2 = frame_counter * 4
    add r3, r2                               ! r2 = frame_counter * 5
    sub r1, r2                               ! r2 = frame_counter*5 - elapsed = remaining
    mov r2, r3                               ! r3 = remaining (copy for delta calc)
    mov.l r2, @r4                            ! audio_remaining = remaining (store to sym_060786B0)
    mov.l   .L_p_prev_remaining, r5          ! r5 = &prev_remaining (sym_0605A21C)
    mov.l @r5, r2                            ! r2 = prev_remaining (load previous value)
    sub r2, r3                               ! r3 = remaining - prev_remaining = delta
    mov.l   .L_p_remaining_delta, r2         ! r2 = &remaining_delta (sym_060786A0)
    mov.l r3, @r2                            ! remaining_delta = delta (store to sym_060786A0)
    mov.l @r4, r3                            ! r3 = audio_remaining (reload current remaining)
    add #0x10, r15                           ! deallocate stack frame
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return
    mov.l r3, @r5                            ! prev_remaining = audio_remaining (update sym_0605A21C, delay slot)

    .global DAT_0600de1e
DAT_0600de1e:
    .2byte  0x01E0                           /* car_struct offset to audio data array pointer */
.L_car_struct_ptr:
    .4byte  sym_0607E940                     /* → current car struct pointer */
.L_course_data_ptr:
    .4byte  sym_06063F3C                     /* → current course data entry pointer */
.L_p_audio_elapsed:
    .4byte  sym_0607869C                     /* → audio_elapsed output (scaled distance) */
.L_fn_scale_divide:
    .4byte  sym_06034FE0                     /* → scale/divide function */
.L_p_audio_remaining:
    .4byte  sym_060786B0                     /* → audio_remaining output (frame_counter*5 - elapsed) */
.L_p_frame_counter:
    .4byte  sym_0607EBD0                     /* → frame counter (32-bit) */
.L_p_prev_remaining:
    .4byte  sym_0605A21C                     /* → previous remaining value (in/out) */
.L_p_remaining_delta:
    .4byte  sym_060786A0                     /* → remaining_delta output (remaining - prev_remaining) */
