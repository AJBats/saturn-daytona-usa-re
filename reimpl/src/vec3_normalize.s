/* vec3_normalize -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06027498 - 0x06027552
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06027498


    .global vec3_normalize
    .type vec3_normalize, @function
vec3_normalize:
    mov.l r14, @-r15                    ! save r14 (callee-saved)
    sts.l pr, @-r15                     ! save return address
    mov r4, r14                         ! r14 = vec3 pointer
    bsr     .L_vec3_dot_self            ! mag_sq = dot(vec, vec)
    mov r4, r5                          ! r5 = r4 (dot product with itself)
    .byte   0xBF, 0xE8    /* bsr 0x06027476 (external: isqrt) */
    mov r0, r4                          ! r4 = mag_sq (delay slot)
    cmp/pl r0                           ! magnitude > 0?
    bf      .L_norm_done                ! zero vector: skip normalization
    mov.l   .L_fp_one, r4              ! r4 = 0x00010000 (1.0 in 16.16 fixed-point)
    .byte   0xB0, 0x56    /* bsr 0x0602755C (external: fpdiv_setup) */
    mov r0, r5                          ! r5 = magnitude (delay slot)
    mov.l @(0, r14), r1                 ! r1 = vec->X
    mov.l @(4, r14), r2                 ! r2 = vec->Y
    dmuls.l r0, r1                      ! mach:macl = X * inv_mag (signed 64-bit)
    mov.l @(8, r14), r3                 ! r3 = vec->Z
    sts mach, r4                        ! r4 = high 32 bits of X * inv_mag
    sts macl, r1                        ! r1 = low 32 bits
    xtrct r4, r1                        ! r1 = (X * inv_mag) >> 16
    dmuls.l r0, r2                      ! mach:macl = Y * inv_mag
    mov.l r1, @(0, r14)                 ! store normalized X
    sts mach, r4                        ! r4 = high 32 bits of Y * inv_mag
    sts macl, r2                        ! r2 = low 32 bits
    xtrct r4, r2                        ! r2 = (Y * inv_mag) >> 16
    dmuls.l r0, r3                      ! mach:macl = Z * inv_mag
    mov.l r2, @(4, r14)                 ! store normalized Y
    sts mach, r4                        ! r4 = high 32 bits of Z * inv_mag
    sts macl, r3                        ! r3 = low 32 bits
    xtrct r4, r3                        ! r3 = (Z * inv_mag) >> 16
    mov.l r3, @(8, r14)                 ! store normalized Z
.L_norm_done:
    lds.l @r15+, pr                     ! restore return address
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_vec3_dot_self:
    clrmac                              ! clear MAC accumulator
    mac.l @r4+, @r5+                    ! acc += A.X * B.X
    mac.l @r4+, @r5+                    ! acc += A.Y * B.Y
    mac.l @r4+, @r5+                    ! acc += A.Z * B.Z
    sts mach, r1                        ! r1 = high 32 bits of accumulator
    sts macl, r0                        ! r0 = low 32 bits of accumulator
    rts                                 ! return dot product in r0
    xtrct r1, r0                        ! r0 = (mach<<16)|(macl>>16) = result >> 16
    .2byte  0x0009                      ! padding (nop)
    .4byte  0x002F2F20                  ! isqrt lookup table (external, used by isqrt)
    .4byte  0x002F0000
    .4byte  0x00008000
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
    .4byte  0x40003FFC                  ! isqrt iteration table (packed 16-bit pairs)
    .4byte  0x0FFC4000
    .4byte  0x3FEB3FD6
    .4byte  0x3FBA3F97
    .4byte  0x3F6A3F2F
    .4byte  0x3EFB3EA4
    .4byte  0x3D7403E8                  ! transition: isqrt step sizes follow
    .4byte  0x001E0028
    .4byte  0x00320046
    .4byte  0x00640096
    .4byte  0x00FA01F4
    .4byte  0x00000AC0                  ! isqrt threshold table (32-bit entries)
    .4byte  0x00001581
    .4byte  0x000047AE
    .4byte  0x0000B333
    .4byte  0x00018000
    .4byte  0x0002F333
    .4byte  0x00053333
    .4byte  0x0008B333
    .4byte  0x0015B6DB

    .global swap_sign_ext
swap_sign_ext:
    swap.w r4, r0                       ! swap upper/lower 16-bit halves
    rts                                 ! return sign-extended result in r0
    exts.w r0, r0                       ! sign-extend lower 16 bits (delay slot)
