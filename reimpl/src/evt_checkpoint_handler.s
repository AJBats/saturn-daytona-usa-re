/* evt_checkpoint_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060409E6 - 0x06040AF8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Checkpoint event handler â€” processes a car crossing a checkpoint boundary.
 *
 * Called from the event dispatch system when a checkpoint event fires.
 * Determines whether the car's current position (r5) has crossed the
 * checkpoint range defined in the event descriptor, and if so, enqueues
 * the appropriate command and validates the checkpoint transition.
 *
 * Arguments:
 *   r4 = event descriptor pointer (struct with checkpoint parameters)
 *   r5 = current checkpoint position (signed; negative means use 0)
 *   r6 = mode: 0 = normal update, 1 = absolute set (skip range check)
 *
 * Event descriptor layout (r14):
 *   +0x04  command queue key (passed to cmd_enqueue / evt_checkpoint_validate)
 *   +0x08  checkpoint base position (start of valid range)
 *   +0x10  checkpoint span (range size from base)
 *   +0x24  direction flag: 0 = forward, 1 = reverse
 *
 * Returns:
 *   r0 = new effective position (base + span) on success
 *   r0 = -1 on validation failure (cmd_enqueue or state_field_read error)
 *   r0 = current position (unchanged) if already at target
 *
 * Calls: cmd_enqueue, evt_checkpoint_validate, state_field_read
 */

    .section .text.FUN_060409E6


    .global evt_checkpoint_handler
    .type evt_checkpoint_handler, @function
evt_checkpoint_handler:
    mov.l r14, @-r15              ! save r14 (will hold event descriptor ptr)
    mov.l r13, @-r15              ! save r13 (will hold current checkpoint pos)
    mov r5, r13                   ! r13 = checkpoint_pos argument
    mov.l r12, @-r15              ! save r12 (will hold zero constant)
    mov #0x0, r12                 ! r12 = 0 (used as zero / cleared span)
    mov.l r11, @-r15              ! save r11 (will hold &state_field_read)
    sts.l pr, @-r15               ! save return address
    add #-0x8, r15                ! allocate 8 bytes on stack: [sp+0]=local_pos, [sp+4]=scratch
    .byte   0xDB, 0x0D    /* mov.l .L_ptr_state_field_read, r11 */ ! r11 = &state_field_read
    cmp/pz r13                    ! is checkpoint_pos >= 0?
    bt/s    .L_check_mode         ! if yes, keep r13 as-is
    mov r4, r14                   ! r14 = event descriptor pointer (delay slot)
    mov r12, r13                  ! checkpoint_pos was negative: clamp to 0
.L_check_mode:
    mov r6, r0                    ! r0 = mode argument
    cmp/eq #0x1, r0               ! mode == 1 (absolute set)?
    bf      .L_range_check        ! if not, do normal range-based update
    mov.l r13, @r15               ! [sp+0] = current checkpoint_pos (local_pos)
    mov.l @(8, r14), r13          ! r13 = desc->base_pos
    mov.l @(16, r14), r3          ! r3 = desc->span
    add r3, r13                   ! r13 = base_pos + span (target position)
    mov.l @r15, r2                ! r2 = local_pos (saved checkpoint_pos)
    bra     .L_forward_update     ! jump to forward update logic
    add r2, r13                   ! r13 += local_pos (absolute offset, delay slot)
.L_range_check:
    mov.l @(8, r14), r2           ! r2 = desc->base_pos
    mov.l @(16, r14), r3          ! r3 = desc->span
    add r3, r2                    ! r2 = base_pos + span (target position)
    cmp/eq r13, r2                ! is current pos already at target?
    bf      .L_not_at_target      ! if not equal, proceed with update
    bra     .L_epilogue           ! already at target: return current pos
    mov r13, r0                   ! r0 = current pos (return value, delay slot)
    .2byte  0xFFFF                                      /* padding */
    .4byte  0x0000FFFF                                  /* padding / alignment */
    .4byte  evt_checkpoint_validate                     /* pool: &evt_checkpoint_validate */
.L_ptr_state_field_read:
    .4byte  state_field_read                            /* pool: &state_field_read */
.L_not_at_target:
    mov.l r12, @-r15              ! push 0 onto stack (output slot for cmd_enqueue)
    mov #0x0, r5                  ! r5 = 0 (cmd_enqueue arg: sub-command = 0)
    mov r15, r7                   ! r7 = sp (pointer to output slot)
    .byte   0xD6, 0x26    /* mov.l .L_mask_low16, r6 */ ! r6 = 0x0000FFFF (16-bit mask)
    .byte   0xD3, 0x26    /* mov.l .L_ptr_cmd_enqueue, r3 */ ! r3 = &cmd_enqueue
    add #0x4, r7                  ! r7 = sp+4 (adjust output pointer past pushed value)
    jsr @r3                       ! call cmd_enqueue(queue_key, 0, 0xFFFF, &out)
    mov.l @(4, r14), r4           ! r4 = desc->queue_key (delay slot)
    mov r0, r4                    ! r4 = cmd_enqueue result
    tst r4, r4                    ! did cmd_enqueue succeed (r4 == 0)?
    bt/s    .L_enqueue_ok         ! if success, continue
    add #0x4, r15                 ! pop the pushed zero (delay slot)
    bra     .L_epilogue           ! enqueue failed
    mov #-0x1, r0                 ! return -1 (delay slot)
.L_enqueue_ok:
    jsr @r11                      ! call state_field_read()
    nop                           ! delay slot
    tst r0, r0                    ! did state_field_read succeed (r0 == 0)?
    bt      .L_state_ok           ! if success, continue
    bra     .L_epilogue           ! state read failed
    mov #-0x1, r0                 ! return -1 (delay slot)
.L_state_ok:
    mov.l @r15, r3                ! r3 = [sp+0] = local_pos
    cmp/pz r3                     ! is local_pos >= 0?
    bt      .L_forward_update     ! if yes, use it as-is
    mov.l r12, @r15               ! local_pos was negative: reset to 0
.L_forward_update:
    mov.l @(36, r14), r0          ! r0 = desc->direction_flag
    tst r0, r0                    ! is direction_flag == 0 (forward)?
    bf      .L_reverse_direction  ! if nonzero, handle reverse direction
    mov.l @(8, r14), r4           ! r4 = desc->base_pos
    cmp/gt r13, r4                ! is base_pos > current_pos?
    bt      .L_fwd_check_range    ! if so, skip (pos below base, needs clamping)
    mov.l @(16, r14), r2          ! r2 = desc->span
    add r4, r2                    ! r2 = base_pos + span (upper bound)
    cmp/ge r2, r13                ! is current_pos >= upper bound?
    bt      .L_fwd_check_range    ! if so, skip (pos beyond range)
    mov.l @(8, r14), r2           ! r2 = desc->base_pos
    mov r13, r3                   ! r3 = current checkpoint pos
    sub r2, r3                    ! r3 = current_pos - base_pos (offset within range)
    mov.l r3, @r15                ! [sp+0] = offset within checkpoint range
.L_fwd_check_range:
    mov.l @r15, r3                ! r3 = local offset (within range or clamped)
    cmp/pl r3                     ! is offset > 0?
    bf      .L_fwd_store_result   ! if not positive, skip validate call
    mov.l @r15, r6                ! r6 = offset (passed to evt_checkpoint_validate)
    mov #0x0, r5                  ! r5 = 0 (sub-param)
    .byte   0xD3, 0x14    /* mov.l .L_ptr_validate, r3 */ ! r3 = &evt_checkpoint_validate
    jsr @r3                       ! call evt_checkpoint_validate(queue_key, 0, offset)
    mov.l @(4, r14), r4           ! r4 = desc->queue_key (delay slot)
    jsr @r11                      ! call state_field_read() to commit
    nop                           ! delay slot
    tst r0, r0                    ! did state_field_read return 0 (success)?
    bt      .L_fwd_store_result   ! if success, store result
    bra     .L_epilogue           ! validation failed
    mov #-0x1, r0                 ! return -1 (delay slot)
.L_fwd_store_result:
    mov.l r13, @(8, r14)          ! desc->base_pos = current checkpoint pos
    bra     .L_compute_return     ! go compute return value
    mov.l r12, @(16, r14)         ! desc->span = 0 (consumed, delay slot)
.L_reverse_direction:
    mov.l @(36, r14), r0          ! r0 = desc->direction_flag
    cmp/eq #0x1, r0               ! is direction_flag == 1 (reverse)?
    bf      .L_compute_return     ! if not exactly 1, skip to return
    mov.l @(8, r14), r4           ! r4 = desc->base_pos
    cmp/ge r4, r13                ! is current_pos >= base_pos?
    bf      .L_rev_out_of_range   ! if below base, out of range
    mov.l @(16, r14), r2          ! r2 = desc->span
    add r4, r2                    ! r2 = base_pos + span
    add #0x1, r2                  ! r2 = base_pos + span + 1 (inclusive upper bound)
    cmp/gt r2, r13                ! is current_pos > (base + span + 1)?
    bf      .L_rev_update_span    ! if within range, update span
.L_rev_out_of_range:
    mov.l r14, @(4, r15)          ! [sp+4] = event descriptor pointer (save)
    mov #0x0, r5                  ! r5 = 0 (sub-param)
    mov r14, r4                   ! r4 = event descriptor (used to load queue_key)
    .byte   0xD6, 0x05    /* mov.l .L_mask_low16, r6 */ ! r6 = 0x0000FFFF (16-bit mask)
    .byte   0xD3, 0x06    /* mov.l .L_ptr_validate, r3 */ ! r3 = &evt_checkpoint_validate
    jsr @r3                       ! call evt_checkpoint_validate(queue_key, 0, 0xFFFF)
    mov.l @(4, r4), r4            ! r4 = desc->queue_key (delay slot, via r4=r14)
    jsr @r11                      ! call state_field_read() to commit
    nop                           ! delay slot
    mov r0, r4                    ! r4 = state_field_read result
    tst r4, r4                    ! did state_field_read return 0?
    bf      .L_rev_store_base     ! if nonzero (success for reverse?), store base
    bra     .L_epilogue           ! validation failed
    mov #-0x1, r0                 ! return -1 (delay slot)
.L_mask_low16:
    .4byte  0x0000FFFF                  /* low 16-bit mask */
.L_ptr_cmd_enqueue:
    .4byte  cmd_enqueue                 /* pool: &cmd_enqueue */
.L_ptr_validate:
    .4byte  evt_checkpoint_validate     /* pool: &evt_checkpoint_validate */
.L_rev_store_base:
    mov.l r13, @(8, r14)          ! desc->base_pos = current checkpoint pos
.L_rev_update_span:
    mov.l @(8, r14), r3           ! r3 = desc->base_pos (possibly just updated)
    sub r3, r13                   ! r13 = current_pos - base_pos (new span)
    mov.l r13, @(16, r14)         ! desc->span = new span
.L_compute_return:
    mov.l @(8, r14), r0           ! r0 = desc->base_pos
    mov.l @(16, r14), r2          ! r2 = desc->span
    add r2, r0                    ! r0 = base_pos + span (effective position)
.L_epilogue:
    add #0x8, r15                 ! deallocate 8 bytes of stack locals
    lds.l @r15+, pr               ! restore return address
    mov.l @r15+, r11              ! restore r11
    mov.l @r15+, r12              ! restore r12
    mov.l @r15+, r13              ! restore r13
    rts                           ! return to caller
    mov.l @r15+, r14              ! restore r14 (delay slot)
