/* dma_channel_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06040980 - 0x060409C8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Copies a 6-byte data block into the game state struct and stores a
 * long parameter, then attempts to allocate a buffer slot. If allocation
 * returns zero (success), tail-calls state_field_read to poll for DMA
 * completion; otherwise returns immediately.
 *
 * Parameters (register convention from caller):
 *   r14 = game state struct pointer (callee-saved frame pointer)
 *   r5  = long parameter stored at state[+0x20]
 *   r1/r2 implicit: src data set up by caller for memcpy_byte
 *
 * Flow:
 *   1. Save PR, store r5 at state[+0x20]
 *   2. Call memcpy_byte(count=6, dst=state+0x18, src=r2) — copy 6 bytes
 *   3. Call buffer_slot_alloc(r4=state[+0x14], r5=param, r6=src, r7=0, stack=0)
 *   4. If alloc result != 0 → return (allocation failed or complete)
 *   5. If alloc result == 0 → tail-call state_field_read (poll DMA)
 *
 * Calls:
 *   sym_06035228      — memcpy_byte(r0=count, r1=dst, r2=src)
 *   buffer_slot_alloc — slot array allocation
 *   state_field_read  — DMA poll (tail-call on alloc success)
 */

    .section .text.FUN_06040980


    .global dma_channel_setup
    .type dma_channel_setup, @function
dma_channel_setup:
    sts.l pr, @-r15                          ! save return address
    mov r14, r1                              ! r1 = state struct base (dst for memcpy)
    mov.l r5, @(32, r14)                     ! state[+0x20] = r5 (store long parameter)
    add #0x18, r1                            ! r1 = state + 0x18 (memcpy destination)
    mov.l   .L_pool_memcpy_byte, r3          ! r3 = memcpy_byte function address
    jsr @r3                                  ! call memcpy_byte(r0=6, r1=state+0x18, r2=src)
    mov #0x6, r0                             ! r0 = 0x6 byte count (delay slot)
    mov #0x0, r2                             ! r2 = 0x0 (will be pushed as stack arg)
    mov.l r2, @-r15                          ! push 0 onto stack (stack arg for alloc)
    mov r2, r7                               ! r7 = 0x0 (fourth arg for alloc)
    mov.l   .L_pool_buffer_slot_alloc, r3    ! r3 = buffer_slot_alloc function address
    jsr @r3                                  ! call buffer_slot_alloc
    mov.l @(20, r14), r4                     ! r4 = state[+0x14] slot index (delay slot)
    mov r0, r4                               ! r4 = alloc result
    tst r4, r4                               ! test if result == 0
    bt/s    .L_alloc_zero                    ! if result == 0 → tail-call state_field_read
    add #0x4, r15                            ! pop stack arg (delay slot)
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return (alloc non-zero → done)
    mov.l @r15+, r14                         ! restore r14 (delay slot)
.L_alloc_zero:
    lds.l @r15+, pr                          ! restore return address (for tail-call frame)
    mov.l   .L_pool_state_field_read, r3     ! r3 = state_field_read function address
    jmp @r3                                  ! tail-call state_field_read (poll DMA)
    mov.l @r15+, r14                         ! restore r14 (delay slot)
    .4byte  track_surface_check
.L_pool_memcpy_byte:
    .4byte  sym_06035228
.L_pool_buffer_slot_alloc:
    .4byte  buffer_slot_alloc
.L_pool_state_field_read:
    .4byte  state_field_read
    .4byte  0x4F26000B
    .4byte  0x6EF6E500
