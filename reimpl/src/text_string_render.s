/* text_string_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06016A60 - 0x06016C6A
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_06016A60


    .global text_string_render
    .type text_string_render, @function
text_string_render:
    /* r4 = char_idx (text object slot index, byte) */
    mov.l r14, @-r15                    ! save r14
    mov r4, r14                         ! r14 = char_idx argument
    mov.l r13, @-r15                    ! save r13
    extu.b r14, r3                      ! r3 = char_idx (zero-extend byte)
    mov.l   .L_pool_text_obj_array, r13       ! r13 = &text_obj_array (sym_06084FC8, 68-byte entries)
    mov.l   .L_fp_one, r5               ! r5 = 1.0 (16.16 fixed-point, 0x00010000)
    mov r3, r2                          ! r2 = char_idx copy (for stride multiply)
    shll2 r3                            ! r3 = idx*4
    shll2 r2                            ! r2 = idx*4
    shll2 r2                            ! r2 = idx*16
    shll2 r2                            ! r2 = idx*64
    add r2, r3                          ! r3 = idx*68 (stride: each text object is 68 bytes)
    exts.w r3, r3                       ! sign-extend 16-bit offset
    add r13, r3                         ! r3 = &text_obj_array[char_idx]
    mov.l @(12, r3), r3                 ! r3 = obj.scroll_pos (16.16 fixed-point scroll position)
    cmp/gt r5, r3                       ! is scroll_pos > 1.0?
    bf      .L_not_yet_scrolling        ! branch if scroll_pos <= 1.0 (not started yet)
    extu.b r14, r4                      ! r4 = char_idx (re-zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l @(16, r4), r2                 ! r2 = obj.scroll_step (per-frame scroll increment)
    mov.l @(4, r4), r3                  ! r3 = obj.accum (accumulated scroll value)
    add r2, r3                          ! r3 = accum + scroll_step (advance accumulator)
    mov.l r3, @(4, r4)                  ! obj.accum = updated accumulator
    extu.b r14, r2                      ! r2 = char_idx (zero-extend, for type check)
    mov #0x4, r3                        ! r3 = 4 (threshold: low-type indices use floor clamp)
    cmp/ge r3, r2                       ! is char_idx >= 4?
    bt      .L_check_accum_high         ! branch if idx >= 4 (use ceiling clamp)
    /* idx < 4: clamp accumulator to floor (lower bound) */
    extu.b r14, r4                      ! r4 = char_idx (re-zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l @(4, r4), r2                  ! r2 = obj.accum
    mov.l @(52, r4), r3                 ! r3 = obj.accum_limit (floor/ceiling clamp value)
    cmp/ge r3, r2                       ! is accum >= limit?
    bf      .L_apply_accum_clamp        ! branch if accum < limit (clamp needed)
    extu.b r14, r4                      ! r4 = char_idx (re-zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l @(52, r4), r2                 ! r2 = obj.accum_limit
    bra     .L_apply_accum_clamp        ! jump to clamp write
    mov.l r2, @(4, r4)                  ! (delay slot) obj.accum = accum_limit (clamp to limit)
    .2byte  0xFFFF
.L_pool_text_obj_array:
    .4byte  sym_06084FC8                /* base address of text object array (68 bytes/entry) */
    .4byte  0x000B0000                  /* 11.0 (16.16 fixed-point) */
    .4byte  0x00040000                  /* 4.0 (16.16 fixed-point) */
    .4byte  0x0000C000                  /* 0.75 (16.16 fixed-point) */
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_check_accum_high:
    /* idx >= 4: clamp accumulator to ceiling (upper bound) */
    extu.b r14, r4                      ! r4 = char_idx (zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l @(4, r4), r2                  ! r2 = obj.accum
    mov.l @(52, r4), r3                 ! r3 = obj.accum_limit
    cmp/gt r3, r2                       ! is accum > limit?
    bt      .L_apply_accum_clamp        ! branch if accum exceeds ceiling (clamp needed)
    extu.b r14, r4                      ! r4 = char_idx (re-zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l @(52, r4), r2                 ! r2 = obj.accum_limit (ceiling value)
    mov.l r2, @(4, r4)                  ! obj.accum = accum_limit (clamp to ceiling)
.L_apply_accum_clamp:
    /* Reduce scroll_pos and scroll_step_b by their respective deltas */
    extu.b r14, r4                      ! r4 = char_idx (zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l @(24, r4), r2                 ! r2 = obj.scroll_step_b (secondary step value)
    mov.l @(12, r4), r3                 ! r3 = obj.scroll_pos (current scroll position)
    sub r2, r3                          ! r3 = scroll_pos - scroll_step_b
    mov.l r3, @(12, r4)                 ! obj.scroll_pos = reduced scroll position
    mov.l @(36, r4), r2                 ! r2 = obj.vel (velocity decrement value)
    mov.l @(24, r4), r3                 ! r3 = obj.scroll_step_b
    sub r2, r3                          ! r3 = scroll_step_b - vel
    mov.l r3, @(24, r4)                 ! obj.scroll_step_b = reduced step
    mov r3, r2                          ! r2 = updated scroll_step_b (for range check)
    mov.l   .L_fp_two, r3               ! r3 = 2.0 (16.16 fixed-point)
    cmp/gt r3, r2                       ! is scroll_step_b > 2.0?
    bt      .L_done_update              ! branch if still large (no reset needed)
    /* scroll_step_b <= 2.0: reset step to base value and clear increment */
    extu.b r14, r4                      ! r4 = char_idx (zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.w   .L_wpool_base_scroll_step, r2       ! r2 = 0x0600 (base scroll step value, short pool load)
    mov.l r2, @(24, r4)                 ! obj.scroll_step_b = 0x0600 (reset to base)
    mov #0x0, r3                        ! r3 = 0
    mov.l r3, @(16, r4)                 ! obj.scroll_step = 0 (clear per-frame increment)
    bra     .L_done_update              ! jump to tail
    nop                                 ! (delay slot)
.L_not_yet_scrolling:
    /* scroll_pos <= 1.0: first activation -- set initial scroll state */
    extu.b r14, r4                      ! r4 = char_idx (zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r13, r4                         ! r4 = &text_obj_array[char_idx]
    mov.l r5, @(12, r4)                 ! obj.scroll_pos = 1.0 (initialize scroll position)
    mov #0x0, r2                        ! r2 = 0
    mov.l r2, @(36, r4)                 ! obj.vel = 0 (clear velocity)
    mov r2, r3                          ! r3 = 0
    mov.l r2, @(24, r4)                 ! obj.scroll_step_b = 0 (clear secondary step)
    mov #0x2, r2                        ! r2 = 2 (state value: actively scrolling)
    mov r2, r0                          ! r0 = 2
    mov.b r0, @(2, r4)                  ! obj.state = 2 (mark as active/scrolling)
.L_done_update:
    /* tail: restore saved registers and tail-call external text handler */
    extu.b r14, r4                      ! r4 = char_idx (zero-extend; becomes arg for tail call)
    mov.l @r15+, r13                    ! restore r13
    .byte   0xA1, 0x25    /* bra 0x06016DD8 (external) */ ! tail-call to external text handler
    mov.l @r15+, r14                    ! (delay slot) restore r14

    .global loc_06016B8E
loc_06016B8E:
    /* Simple return stub -- called when state requires no action */
    rts                                 ! return to caller
    nop                                 ! (delay slot)
.L_wpool_base_scroll_step:
    .2byte  0x0600                      /* [MEDIUM] base scroll step value for text animation reset */
.L_fp_two:
    .4byte  0x00020000                  /* 2.0 (16.16 fixed-point) */

    .global loc_06016B98
loc_06016B98:
    /* Decrement per-slot active counter; mark slot done when counter reaches zero */
    /* r4 = char_idx */
    mov.l   .L_pool_text_obj_base, r6        ! r6 = &text_obj_array (sym_06084FC8)
    extu.b r4, r5                       ! r5 = char_idx (zero-extend byte)
    mov #0x41, r0                       ! r0 = 0x41 = 65 (byte offset of active-count field)
    mov r5, r3                          ! r3 = char_idx copy
    shll2 r5                            ! r5 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r5                          ! r5 = idx*68
    exts.w r5, r5                       ! sign-extend
    add r6, r5                          ! r5 = &text_obj_array[char_idx]
    mov.b @(r0, r5), r2                 ! r2 = obj.active_count (byte at offset 0x41 = 65)
    add #-0x1, r2                       ! r2 = active_count - 1 (decrement)
    mov.b r2, @(r0, r5)                 ! obj.active_count = decremented value
    mov.b @(r0, r5), r3                 ! r3 = active_count (re-read to confirm zero test)
    extu.b r3, r3                       ! zero-extend byte
    tst r3, r3                          ! is active_count == 0?
    bf      .L_active_count_nonzero     ! branch if count != 0 (still active entries remain)
    /* active_count == 0: all entries retired, mark slot as finished */
    extu.b r4, r4                       ! r4 = char_idx (re-zero-extend)
    mov r4, r3                          ! r3 = char_idx copy
    shll2 r4                            ! r4 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r4                          ! r4 = idx*68
    exts.w r4, r4                       ! sign-extend
    add r6, r4                          ! r4 = &text_obj_array[char_idx]
    mov #0x7, r2                        ! r2 = 7 (state: finished/completed)
    mov r2, r0                          ! r0 = 7
    mov.b r0, @(2, r4)                  ! obj.state = 7 (mark slot as finished)
.L_active_count_nonzero:
    rts                                 ! return to caller
    nop                                 ! (delay slot)

    .global loc_06016BD8
loc_06016BD8:
    /* Dispatch: read obj.state, index into function table A (sym_0605BB1C), jump */
    /* r4 = char_idx */
    add #-0x4, r15                      ! reserve 4 bytes on stack (byte-safe temp slot)
    mov.b r4, @r15                      ! write char_idx byte to stack temp
    mov.b @r15, r3                      ! read back char_idx as byte
    extu.b r3, r3                       ! zero-extend
    mov r3, r2                          ! r2 = char_idx copy (for stride multiply)
    shll2 r3                            ! r3 = idx*4
    shll2 r2                            ! r2 = idx*4
    shll2 r2                            ! r2 = idx*16
    shll2 r2                            ! r2 = idx*64
    add r2, r3                          ! r3 = idx*68
    exts.w r3, r3                       ! sign-extend
    mov.l   .L_pool_text_obj_base, r1        ! r1 = &text_obj_array (sym_06084FC8)
    add r1, r3                          ! r3 = &text_obj_array[char_idx]
    mov.b @(2, r3), r0                  ! r0 = obj.state (byte dispatch key)
    mov r0, r3                          ! r3 = state
    extu.b r3, r3                       ! zero-extend state byte
    shll2 r3                            ! r3 = state*4 (longword-indexed into function table)
    mov.l   .L_pool_dispatch_table_a, r2        ! r2 = &dispatch_table_a (sym_0605BB1C)
    add r2, r3                          ! r3 = &dispatch_table_a[state]
    mov.l @r3, r3                       ! r3 = function pointer for this state
    mov.b @r15, r4                      ! restore char_idx into r4 (argument for dispatched fn)
    jmp @r3                             ! dispatch to state handler
    add #0x4, r15                       ! (delay slot) release stack temp

    .global loc_06016C06
loc_06016C06:
    /* Dispatch: read obj.state, index into function table B (sym_0605BB48), jump */
    /* r4 = char_idx */
    add #-0x4, r15                      ! reserve 4 bytes on stack
    mov.b r4, @r15                      ! write char_idx byte to stack temp
    mov.b @r15, r3                      ! read back char_idx as byte
    extu.b r3, r3                       ! zero-extend
    mov r3, r2                          ! r2 = char_idx copy
    shll2 r3                            ! r3 = idx*4
    shll2 r2                            ! r2 = idx*4
    shll2 r2                            ! r2 = idx*16
    shll2 r2                            ! r2 = idx*64
    add r2, r3                          ! r3 = idx*68
    exts.w r3, r3                       ! sign-extend
    mov.l   .L_pool_text_obj_base, r1        ! r1 = &text_obj_array (sym_06084FC8)
    add r1, r3                          ! r3 = &text_obj_array[char_idx]
    mov.b @(2, r3), r0                  ! r0 = obj.state (byte dispatch key)
    mov r0, r3                          ! r3 = state
    extu.b r3, r3                       ! zero-extend
    shll2 r3                            ! r3 = state*4 (longword-indexed)
    mov.l   .L_pool_dispatch_table_b, r2        ! r2 = &dispatch_table_b (sym_0605BB48)
    add r2, r3                          ! r3 = &dispatch_table_b[state]
    mov.l @r3, r3                       ! r3 = function pointer for this state
    mov.b @r15, r4                      ! restore char_idx into r4
    jmp @r3                             ! dispatch to state handler
    add #0x4, r15                       ! (delay slot) release stack temp
.L_pool_text_obj_base:
    .4byte  sym_06084FC8                /* text object array base (68 bytes/entry) */
.L_pool_dispatch_table_a:
    .4byte  sym_0605BB1C                /* dispatch table A: state->handler fn ptrs */
.L_pool_dispatch_table_b:
    .4byte  sym_0605BB48                /* dispatch table B: state->handler fn ptrs */

    .global loc_06016C40
loc_06016C40:
    /* Activate a text object slot: set active flag, write counter, advance state */
    /* r4 = char_idx */
    extu.b r4, r5                       ! r5 = char_idx (zero-extend)
    mov #0x1, r0                        ! r0 = 1 (active flag value)
    .byte   0xD2, 0x15    /* mov.l pool@0x06016C9C (external: text_obj_array base), r2 */
    mov r5, r3                          ! r3 = char_idx copy (for stride multiply)
    shll2 r5                            ! r5 = idx*4
    shll2 r3                            ! r3 = idx*4
    shll2 r3                            ! r3 = idx*16
    shll2 r3                            ! r3 = idx*64
    add r3, r5                          ! r5 = idx*68
    exts.w r5, r5                       ! sign-extend
    mov #0x27, r3                       ! r3 = 0x27 = 39 (initial counter value)
    add r2, r5                          ! r5 = &text_obj_array[char_idx]
    mov.b r0, @(1, r5)                  ! obj.active = 1 (byte offset 1: mark slot in-use)
    .byte   0xD2, 0x11    /* mov.l pool@0x06016CA0 (external: global entry-counter ptr), r2 */
    mov.b r3, @r2                       ! *global_counter = 0x27 (write initial counter value)
    mov.b @(2, r5), r0                  ! r0 = obj.state (read current state byte)
    mov r0, r3                          ! r3 = state
    add #0x1, r3                        ! r3 = state + 1 (advance to next state)
    mov r3, r0                          ! r0 = state + 1
    rts                                 ! return to caller
    mov.b r0, @(2, r5)                  ! (delay slot) obj.state = state + 1
