/* text_scroll_marquee -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06016CE6 - 0x06016DD8
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Configures a scrolling text marquee element for the HUD.
 *
 * Writes a character ID into the per-car slot data table, optionally
 * sets a scroll speed of 0.5 (fixed-point) when the race event bit 0
 * is active, then looks up glyph sprite coordinates from the character
 * glyph table (sym_0605BB74) and stores them as VDP1 sprite positions
 * in the slot data struct. Finally calls the sprite vertex builder
 * (FUN_06016DD8) and writes display element properties (enable flag,
 * priority/color bank, and glyph offset) into the scroll data table
 * (sym_06085490, 24-byte entries).
 *
 * Input:
 *   r4  = character ID (byte, stored at slot offset +1)
 *   r5  = glyph param (byte, saved on stack; added to 0x17 for tex offset)
 *   r3  = slot row index (used to compute 68-byte struct offset)
 *   r14 = car slot index (preserved callee-save, used for struct base)
 *
 * Output:
 *   Slot data fields updated (char ID, scroll speed, sprite coords).
 *   Scroll data entry enabled with glyph offset and color bank.
 *
 * Calls: FUN_06016DD8 (sprite vertex builder, via BSR)
 */

    .section .text.FUN_06016CE6


    .global text_scroll_marquee
    .type text_scroll_marquee, @function
text_scroll_marquee:
    sts.l pr, @-r15                     ! save return address
    extu.b r4, r1                       ! r1 = char_id (zero-extended byte)
    mov r3, r2                          ! r2 = row (copy for stride calc)
    add #-0x4, r15                      ! allocate 4 bytes of stack frame
    mov r1, r0                          ! r0 = char_id
    shll2 r3                            ! r3 = row * 4
    shll2 r2                            ! r2 = row * 4
    .byte   0xDD, 0x32    /* mov.l .L_pool_slot_data_base, r13 */  ! r13 = slot_data array base (sym_06084FC8)
    shll2 r2                            ! r2 = row * 16
    mov.b r5, @r15                      ! save glyph_param on stack
    shll2 r2                            ! r2 = row * 64
    add r2, r3                          ! r3 = row * 68 (struct stride)
    exts.w r3, r3                       ! sign-extend struct offset
    add r13, r3                         ! r3 = &slot_data[row]
    mov.b r0, @(1, r3)                  ! slot_data[row].char_id = char_id (byte offset +1)
    .byte   0xD0, 0x2F    /* mov.l .L_pool_bonus_mode_flag, r0 */  ! r0 = &bonus_mode_flag (sym_06085F89)
    mov.b @r0, r0                       ! r0 = bonus_mode_flag value
    tst r0, r0                          ! test if bonus mode is active
    .word 0x0029 /* movt r0 */          ! r0 = T bit (1 if bonus mode == 0)
    .byte   0xD3, 0x2E    /* mov.l .L_pool_race_event_bits, r3 */  ! r3 = &race_event_bitfield (sym_0607EBF4)
    mov.l @r3, r3                       ! r3 = race_event_bitfield value
    and r3, r0                          ! r0 = (bonus_inactive) & event_bits
    tst #0x1, r0                        ! test bit 0 of combined flags
    bt/s    .L_load_glyph_data          ! if bit 0 clear, skip scroll speed setup
    extu.b r4, r7                       ! r7 = char_id (delay slot; used if skipping)
    mov #0x28, r7                       ! r7 = 0x28 (40, overwritten -- char_id replaced)
    extu.b r14, r3                      ! r3 = slot_index
    mov r3, r2                          ! r2 = slot_index (copy for stride calc)
    shll2 r3                            ! r3 = slot * 4
    shll2 r2                            ! r2 = slot * 4
    shll2 r2                            ! r2 = slot * 16
    shll2 r2                            ! r2 = slot * 64
    add r2, r3                          ! r3 = slot * 68 (struct stride)
    exts.w r3, r3                       ! sign-extend struct offset
    add r13, r3                         ! r3 = &slot_data[slot]
    .byte   0xD1, 0x27    /* mov.l .L_fp_half, r1 */  ! r1 = 0x00008000 (0.5 in 16.16 fixed-point)
    mov.l r1, @(44, r3)                 ! slot_data[slot].scroll_speed = 0.5 (offset +44)
.L_load_glyph_data:
    .byte   0xD5, 0x27    /* mov.l .L_pool_glyph_table, r5 */  ! r5 = glyph table base (sym_0605BB74)
    extu.b r14, r6                      ! r6 = slot_index
    mov.b @r15, r4                      ! r4 = glyph_param (restored from stack)
    extu.b r7, r2                       ! r2 = char_id or 0x28 (scroll offset)
    mov r6, r3                          ! r3 = slot_index (copy)
    extu.b r4, r4                       ! r4 = glyph_param (zero-extended)
    shll2 r6                            ! r6 = slot * 4
    shll2 r3                            ! r3 = slot * 4
    shll2 r3                            ! r3 = slot * 16
    shll2 r3                            ! r3 = slot * 64
    add r3, r6                          ! r6 = slot * 68 (struct stride)
    exts.w r6, r6                       ! sign-extend struct offset
    mov r4, r3                          ! r3 = glyph_param
    add r13, r6                         ! r6 = &slot_data[slot]
    shll2 r4                            ! r4 = glyph_param * 4
    add r3, r4                          ! r4 = glyph_param * 5
    add r2, r4                          ! r4 = glyph_param * 5 + char_offset (glyph index)
    mov r4, r0                          ! r0 = glyph_index
    shll r0                             ! r0 = glyph_index * 2 (halfword offset into table)
    mov.w @(r0, r5), r3                 ! r3 = glyph_table[glyph_index] (16-bit sprite X0)
    mov r4, r0                          ! r0 = glyph_index
    shll16 r3                           ! r3 = sprite_X0 << 16 (position in high word)
    add #0x1, r0                        ! r0 = glyph_index + 1
    mov.l r3, @(4, r6)                  ! slot_data[slot].sprite_x0 = X0 (offset +4)
    shll r0                             ! r0 = (glyph_index + 1) * 2
    mov.w @(r0, r5), r3                 ! r3 = glyph_table[glyph_index+1] (sprite X1)
    mov r4, r0                          ! r0 = glyph_index
    shll16 r3                           ! r3 = sprite_X1 << 16
    add #0x2, r0                        ! r0 = glyph_index + 2
    mov.l r3, @(8, r6)                  ! slot_data[slot].sprite_x1 = X1 (offset +8)
    shll r0                             ! r0 = (glyph_index + 2) * 2
    mov.w @(r0, r5), r3                 ! r3 = glyph_table[glyph_index+2] (sprite Y0)
    mov r4, r0                          ! r0 = glyph_index
    shll16 r3                           ! r3 = sprite_Y0 << 16
    add #0x3, r0                        ! r0 = glyph_index + 3
    mov.l r3, @(12, r6)                 ! slot_data[slot].sprite_y0 = Y0 (offset +12)
    shll r0                             ! r0 = (glyph_index + 3) * 2
    mov.w @(r0, r5), r3                 ! r3 = glyph_table[glyph_index+3] (sprite Y1)
    mov r4, r0                          ! r0 = glyph_index
    shll16 r3                           ! r3 = sprite_Y1 << 16
    add #0x4, r0                        ! r0 = glyph_index + 4
    mov.l r3, @(16, r6)                 ! slot_data[slot].sprite_y1 = Y1 (offset +16)
    shll r0                             ! r0 = (glyph_index + 4) * 2
    mov.w @(r0, r5), r3                 ! r3 = glyph_table[glyph_index+4] (sprite extent)
    shll16 r3                           ! r3 = sprite_extent << 16
    mov.l r3, @(52, r6)                 ! slot_data[slot].sprite_extent = extent (offset +52)
    .byte   0xB0, 0x24    /* bsr 0x06016DD8 (external) */  ! call sprite vertex builder
    extu.b r14, r4                      ! r4 = slot_index (delay slot, arg for vertex builder)
    extu.b r14, r4                      ! r4 = slot_index (reload after return)
    .byte   0xD2, 0x10    /* mov.l .L_pool_scroll_data_base, r2 */  ! r2 = scroll data table base (sym_06085490)
    mov r4, r3                          ! r3 = slot_index
    shll2 r4                            ! r4 = slot * 4
    shll2 r3                            ! r3 = slot * 4
    shll r4                             ! r4 = slot * 8
    shll2 r3                            ! r3 = slot * 16
    add r3, r4                          ! r4 = slot * 24 (24-byte entry stride)
    exts.w r4, r4                       ! sign-extend entry offset
    mov.b @r15, r3                      ! r3 = glyph_param (restored from stack)
    add r2, r4                          ! r4 = &scroll_data[slot]
    extu.b r3, r3                       ! r3 = glyph_param (zero-extended)
    add #0x17, r3                       ! r3 = glyph_param + 0x17 (texture/glyph offset)
    extu.w r3, r0                       ! r0 = glyph offset as unsigned word
    mov.w r0, @(6, r4)                  ! scroll_data[slot].glyph_offset = param + 0x17 (offset +6)
    mov #0x1, r0                        ! r0 = 1
    mov.b r0, @(4, r4)                  ! scroll_data[slot].enabled = 1 (offset +4)
    mov #0x3A, r0                       ! r0 = 0x3A (58 = priority/color bank value)
    mov.b r0, @(5, r4)                  ! scroll_data[slot].color_bank = 0x3A (offset +5)
    add #0x4, r15                       ! deallocate stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
.L_pool_slot_data_base:
    .4byte  sym_06084FC8                /* slot data array base (68-byte structs) */
.L_pool_bonus_mode_flag:
    .4byte  sym_06085F89                /* bonus mode flag (byte) */
.L_pool_race_event_bits:
    .4byte  sym_0607EBF4                /* race event bitfield (32-bit) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_glyph_table:
    .4byte  sym_0605BB74                /* character glyph table (16-bit sprite coords) */
.L_pool_scroll_data_base:
    .4byte  sym_06085490                /* scroll data table (24-byte entries) */
