/* shadow_intensity -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602E7D4 - 0x0602E826
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Shadow intensity calculator for per-vertex lighting.
 *
 * Computes the angle between the surface normal and light direction
 * using atan2, then determines whether the vertex is in shadow or
 * lit based on the angular difference. The camera direction flip flag
 * inverts the comparison logic (bt vs bf) for backface handling.
 *
 * Called as a continuation from per_vtx_lighting after vertex deltas
 * are computed. The atan2 function pointer is pre-loaded in r0 by
 * the caller.
 *
 * Register convention on entry:
 *   r0  = function pointer to atan2
 *   r9  = pointer to current vertex structure
 *   r13 = scratch (overwritten with negated atan2 result)
 *   r15 = stack (r0 from per_vtx_lighting on top)
 *
 * Flow:
 *   1. Call atan2 to get surface-to-light angle
 *   2. Negate and sign-extend result â†’ angle offset in r13
 *   3. Combine half-circle (0x8000) with angle offset
 *   4. Subtract from light direction angle (vertex_struct[40])
 *   5. Take absolute value of angular difference
 *   6. Check camera direction flip flag to choose comparison sense
 *   7. Compare against half-circle threshold (0x8000)
 *   8. Branch to external shadow/lit path based on result
 */

    .section .text.FUN_0602E7D4


    .global shadow_intensity
    .type shadow_intensity, @function
shadow_intensity:
    sts.l pr, @-r15                     ! save return address to stack
    jsr @r0                             ! call atan2 (function pointer in r0)
    nop                                 ! delay slot
    lds.l @r15+, pr                     ! restore return address from stack
    neg r0, r13                         ! r13 = -atan2_result (negate angle)
    exts.w r13, r13                     ! r13 = sign-extend to 32-bit
    mov.l @r15+, r0                     ! r0 = pop saved r0 from per_vtx_lighting
    mov.w   DAT_0602e80a, r4            ! r4 = 0x8000 (half-circle angle constant)
    mov.l @(40, r9), r1                 ! r1 = vertex_struct[40] (light direction angle)
    extu.w r4, r4                       ! r4 = zero-extend 0x8000 to 32-bit
    mov r4, r3                          ! r3 = 0x8000 (copy for combining)
    extu.w r13, r6                      ! r6 = zero-extend negated angle offset
    shll r3                             ! r3 = 0x10000 (shift left 1 bit)
    or r3, r6                           ! r6 = 0x10000 | angle_offset (combined value)
    sub r6, r1                          ! r1 = light_angle - combined_offset (angular diff)
    cmp/pl r1                           ! T = (angular_diff > 0)?
    bt      .L_abs_done                 ! if positive, skip negation
    neg r1, r1                          ! r1 = abs(angular_diff)
.L_abs_done:
    mov.l   .L_pool_cam_dir_flip, r7    ! r7 = &camera_direction_flip_flag
    mov.b @r7, r7                       ! r7 = camera_direction_flip_flag value
    tst r7, r7                          ! T = (flip_flag == 0)?
    bf      .L_flipped_compare          ! if flip flag set, use inverted comparison
    extu.w r1, r1                       ! r1 = zero-extend abs angular diff
    cmp/gt r1, r4                       ! T = (0x8000 > abs_diff)? i.e. in lit zone
    .byte   0x89, 0x2E    /* bt 0x0602E864 (external) */ ! if in lit zone, branch to lit path
    bra     .L_shadow_calc_setup        ! otherwise fall through to shadow calc
    nop                                 ! delay slot

    .global DAT_0602e80a
DAT_0602e80a:
    .2byte  0x8000                      /* half-circle angle constant */
    .4byte  atan2                       /* pool: atan2 function address */
.L_pool_cam_dir_flip:
    .4byte  sym_06078663                /* pool: camera direction flip flag address */
.L_flipped_compare:
    extu.w r1, r1                       ! r1 = zero-extend abs angular diff
    cmp/gt r1, r4                       ! T = (0x8000 > abs_diff)? i.e. in lit zone
    .byte   0x8B, 0x24    /* bf 0x0602E864 (external) */ ! if NOT in lit zone, branch to shadow path
.L_shadow_calc_setup:
    .byte   0xD3, 0x06    /* mov.l .L_pool_0602E834, r3 */ ! r3 = shadow intensity scale factor
    cmp/ge r3, r8                       ! T = (r8 >= scale_factor)?
    .byte   0x89, 0x11    /* bt 0x0602E844 (external) */ ! if above scale, branch to clamped path
    .byte   0xD4, 0x05    /* mov.l .L_pool_0602E838, r4 */ ! r4 = shadow gradient base
    .byte   0xD5, 0x06    /* mov.l .L_pool_0602E83C, r5 */ ! r5 = shadow color mask
    .byte   0xDD, 0x06    /* mov.l .L_pool_0602E840, r13 */ ! r13 = shadow computation function
