/* state_abort -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06009508 - 0x0600955E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * State 28: Abort Processing
 * Handles the abort path after bit 0 of race_event_bitfield is set.
 * Runs a simplified update pipeline (no per-car physics loop).
 * Always transitions to state 29 (post-race menu).
 *
 * If abort flag is still set on re-entry, clears it and writes state=20,
 * but that is immediately overwritten by state=29 (dead write).
 */

    .section .text.FUN_06009508


    .global state_abort
    .type state_abort, @function
state_abort:
    sts.l pr, @-r15                                     ! save return address
    .byte   0xD4, 0x23    /* mov.l .L_p_race_event_bits, r4 */
    mov.l @r4, r0                                       ! r0 = race_event_bitfield
    tst #0x1, r0                                        ! abort flag (bit 0) set?
    bt      .L_no_abort                                 ! no -> check race end
    mov #-0x2, r3                                       ! r3 = 0xFFFFFFFE (clear mask)
    mov.l @r4, r2                                       ! r2 = race_event_bitfield
    and r3, r2                                          ! clear bit 0
    mov.l r2, @r4                                       ! store cleared flags
    mov #0x14, r3                                       ! r3 = 20 (dead write â€” overwritten below)
    .byte   0xD2, 0x1F    /* mov.l .L_p_game_state, r2 */
    mov.l r3, @r2                                       ! game_state = 20 (immediately overwritten)
    bra     .L_set_next_state                           ! jump to state 29 setup
    nop                                                 ! (delay slot)
.L_no_abort:
    .byte   0xD0, 0x1E    /* mov.l .L_p_race_end_flag, r0 */
    mov.l @r0, r0                                       ! r0 = race_end_flag
    tst r0, r0                                          ! race ended?
    bf      .L_set_next_state                           ! yes -> skip counter increment
    .byte   0xD4, 0x1D    /* mov.l .L_p_frame_counter, r4 */
    mov.l @r4, r3                                       ! r3 = frame_counter
    add #0x1, r3                                        ! r3++
    mov.l r3, @r4                                       ! frame_counter++
.L_set_next_state:
    mov #0x1D, r2                                       ! r2 = 29 (state 29: post-race menu)
    .byte   0xD3, 0x19    /* mov.l .L_p_game_state, r3 */
    mov.l r2, @r3                                       ! game_state = 29
    .byte   0xD3, 0x1B    /* mov.l .L_p_race_update_abort, r3 */
    jsr @r3                                             ! call race_update_abort (simplified car update)
    nop                                                 ! (delay slot)
    .byte   0xD3, 0x1A    /* mov.l .L_p_camera_system, r3 */
    jsr @r3                                             ! call camera_system (general camera update)
    nop                                                 ! (delay slot)
    .byte   0xD6, 0x1A    /* mov.l .L_p_camera_eye_pos, r6 */
    .byte   0xD5, 0x1A    /* mov.l .L_p_camera_target_vec, r5 */
    .byte   0xD4, 0x1B    /* mov.l .L_p_camera_up_vec, r4 */
    .byte   0xD3, 0x1B    /* mov.l .L_p_camera_orient_calc, r3 */
    jsr @r3                                             ! call camera_orient_calc (display commit)
    mov.l @r6, r6                                       ! r6 = *camera_eye_pos (delay slot)
    .byte   0xD3, 0x1B    /* mov.l .L_p_scene_update, r3 */
    jsr @r3                                             ! call scene_update (post-display update)
    nop                                                 ! (delay slot)
    .byte   0xD3, 0x1A    /* mov.l .L_p_frame_end_commit, r3 */
    jmp @r3                                             ! tail call frame_end_commit (frame sync)
    lds.l @r15+, pr                                     ! restore return address (delay slot)
