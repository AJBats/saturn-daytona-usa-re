/* results_time_column -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060162AC - 0x06016410
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Updates a single column in the results screen time display. Each column
 * represents one car's race time entry. Accumulates elapsed time into the
 * display struct, checks for time overflow against the target/limit, and
 * optionally clamps or resets the displayed value. If bonus mode is active,
 * applies a bonus countdown decrement. Finally calls the digit rendering
 * subroutine (0x06016DD8) and, if a state change was triggered, writes a
 * new animation phase byte to the entry struct.
 *
 * On entry:
 *   r3  = row index (into timing data table)
 *   r10 = new animation phase if state change (byte; 0 = no change)
 *   r12 = column index (car slot)
 *   r14 = car/entry index (byte — upper bits ignored)
 *
 * Data structure at sym_06084FC8:
 *   Array of entries, each 20 longwords (0x14 * 4 = 80 bytes).
 *   Index = (column * 4) + (row * 16), sign-extended to halfword offset.
 *   +0x04 (offset 1): current display value (accumulated time)
 *   +0x10 (offset 4): delta per frame (increment amount)
 *   +0x20 (offset 8): time limit / cap value
 *   +0x24 (offset 9): target time (for comparison)
 *   +0x30 (offset 12): bonus countdown timer
 *   +0x34 (offset 13): initial bonus time
 *   +0x02 (byte): animation phase / state byte
 */

    .section .text.FUN_060162AC


    .global results_time_column
    .type results_time_column, @function
results_time_column:
    sts.l pr, @-r15                      ! save return address
    shll2 r12                            ! r12 = column_index * 4
    shll2 r3                             ! r3 = row_index * 4
    mov.l   .L_p_entry_table, r13        ! r13 = &results_entry_table (sym_06084FC8)
    shll2 r3                             ! r3 = row_index * 16
    shll2 r3                             ! (continued shift -- not needed, already *16)
    add r3, r12                          ! r12 = (column*4) + (row*16) = struct offset
    exts.w r12, r12                      ! sign-extend offset to word
    add r13, r12                         ! r12 = &entry (base + offset)
    mov.l @(16, r12), r2                 ! r2 = entry.delta (per-frame increment)
    mov.l @(4, r12), r3                  ! r3 = entry.display_value (current time)
    add r2, r3                           ! r3 = display_value + delta
    mov.l r3, @(4, r12)                  ! store updated display_value
    mov r3, r4                           ! r4 = updated display_value
    mov.l @(52, r12), r2                 ! r2 = entry.initial_bonus
    mov.l   .L_p_abs_diff_fn, r3         ! r3 = &abs_diff function (sym_06035438)
    jsr @r3                              ! call abs_diff(r4=display_val, r2 used internally)
    sub r2, r4                           ! r4 = display_value - initial_bonus (delay slot)
    mov.l @(36, r12), r2                 ! r2 = entry.target_time
    cmp/gt r2, r0                        ! T = (abs_diff_result > target_time)?
    .word 0x0029 /* movt r0 */           ! r0 = T (1 if exceeded target)
    xor #0x1, r0                         ! r0 = !exceeded (1 if within target)
    mov.l   .L_p_state_flag, r3          ! r3 = &state_flag (sym_0605BAF8)
    mov.b @r3, r3                        ! r3 = state_flag value
    extu.b r3, r3                        ! zero-extend to word
    tst r3, r3                           ! test if state_flag == 0
    .word 0x0129 /* movt r1 */           ! r1 = T (1 if state_flag is zero)
    and r1, r0                           ! r0 = within_target AND state_is_zero
    tst r0, r0                           ! test combined condition
    bt      .L_check_overflow            ! if condition false, skip time-reached handling
    extu.b r14, r4                       ! r4 = entry_index (zero-extended byte)
    mov.l   .L_p_state_flag, r2          ! r2 = &state_flag
    mov.b r10, @r2                       ! write new anim phase to state_flag
    mov r4, r2                           ! r2 = entry_index
    shll2 r4                             ! r4 = entry_index * 4
    shll2 r2                             ! r2 = entry_index * 4
    shll2 r2                             ! r2 = entry_index * 16
    shll2 r2                             ! r2 = entry_index * 64 (unused? — shift chain)
    add r2, r4                           ! r4 = combined struct offset
    exts.w r4, r4                        ! sign-extend offset
    add r13, r4                          ! r4 = &target entry
    mov.l @(32, r4), r3                  ! r3 = entry.time_limit
    mov.l r3, @(4, r4)                   ! set display_value = time_limit (clamp)
    mov.l @(16, r4), r1                  ! r1 = entry.delta (old increment)
    mov.l   .L_p_scale_div_fn, r2        ! r2 = &scale_divide fn (sym_06034FE0)
    jsr @r2                              ! call scale_divide(r0=10, r1=old_delta)
    mov #0xA, r0                         ! r0 = 10 (scale divisor, delay slot)
    mov.l r0, @(16, r4)                  ! store scaled delta as new increment
.L_check_overflow:
    mov #0x4, r4                         ! r4 = 4 (max entry count)
    extu.b r14, r3                       ! r3 = entry_index
    cmp/ge r4, r3                        ! T = (entry_index >= 4)?
    .word 0x0029 /* movt r0 */           ! r0 = T (1 if past max entries)
    xor #0x1, r0                         ! r0 = !past_max (1 if within range)
    extu.b r14, r5                       ! r5 = entry_index
    mov r5, r3                           ! r3 = entry_index (copy)
    shll2 r5                             ! r5 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r5                           ! r5 = combined struct offset
    exts.w r5, r5                        ! sign-extend offset
    add r13, r5                          ! r5 = &entry for this car
    mov.l @(4, r5), r2                   ! r2 = entry.display_value
    mov.l @(52, r5), r3                  ! r3 = entry.initial_bonus
    cmp/gt r3, r2                        ! T = (display_value > initial_bonus)?
    .word 0x0129 /* movt r1 */           ! r1 = T (1 if display exceeded bonus)
    add #-0x1, r1                        ! r1 = (exceeded ? 0 : -1) (mask)
    neg r1, r1                           ! r1 = (exceeded ? 0 : 1) (inverted mask)
    and r1, r0                           ! r0 = within_range AND not_exceeded
    tst r0, r0                           ! test combined condition
    bt      .L_check_ge_clamp            ! if false, skip clamp-to-bonus handling
    extu.b r14, r4                       ! r4 = entry_index
    mov r4, r3                           ! r3 = entry_index
    shll2 r4                             ! r4 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r4                           ! r4 = combined struct offset
    exts.w r4, r4                        ! sign-extend
    add r13, r4                          ! r4 = &entry
    mov.l @(52, r4), r2                  ! r2 = entry.initial_bonus
    mov.l r2, @(4, r4)                   ! clamp display_value = initial_bonus
    bra     .L_after_clamp               ! skip to post-clamp
    extu.b r10, r11                      ! r11 = anim phase change flag (delay slot)
.L_p_entry_table:
    .4byte  sym_06084FC8                 /* → results entry table base address */
.L_p_abs_diff_fn:
    .4byte  sym_06035438                 /* → abs_diff / time subtraction function */
.L_p_state_flag:
    .4byte  sym_0605BAF8                 /* → results state flag byte */
.L_p_scale_div_fn:
    .4byte  sym_06034FE0                 /* → scale/divide function */
.L_check_ge_clamp:
    extu.b r14, r2                       ! r2 = entry_index
    cmp/ge r4, r2                        ! T = (entry_index >= 4)?
    .word 0x0029 /* movt r0 */           ! r0 = T (1 if past max)
    extu.b r14, r5                       ! r5 = entry_index
    mov r5, r3                           ! r3 = entry_index
    shll2 r5                             ! r5 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r5                           ! r5 = combined struct offset
    exts.w r5, r5                        ! sign-extend
    add r13, r5                          ! r5 = &entry
    mov.l @(4, r5), r2                   ! r2 = entry.display_value
    mov.l @(52, r5), r3                  ! r3 = entry.initial_bonus
    cmp/ge r3, r2                        ! T = (display_value >= initial_bonus)?
    .word 0x0129 /* movt r1 */           ! r1 = T (1 if >= bonus)
    and r1, r0                           ! r0 = past_max AND ge_bonus
    tst r0, r0                           ! test combined condition
    bt      .L_after_clamp               ! if false, skip clamp
    extu.b r14, r4                       ! r4 = entry_index
    mov r4, r3                           ! r3 = entry_index
    shll2 r4                             ! r4 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r4                           ! r4 = combined struct offset
    exts.w r4, r4                        ! sign-extend
    add r13, r4                          ! r4 = &entry
    mov.l @(52, r4), r2                  ! r2 = entry.initial_bonus
    mov.l r2, @(4, r4)                   ! clamp display_value = initial_bonus
    extu.b r10, r11                      ! r11 = anim phase change flag
.L_after_clamp:
    .byte   0xD0, 0x2E    /* mov.l .L_pool_0601645C, r0 */  ! r0 = &bonus_mode_flag (sym_06085F89)
    mov.b @r0, r0                        ! r0 = bonus_mode_flag value
    tst r0, r0                           ! test if bonus mode is active
    bt      .L_skip_bonus                ! if not active, skip bonus countdown
    extu.b r14, r4                       ! r4 = entry_index
    .byte   0x92, 0x55    /* mov.w .L_wpool_0601645A, r2 */  ! r2 = 0x0800 (bonus decrement step)
    mov r4, r3                           ! r3 = entry_index
    shll2 r4                             ! r4 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r4                           ! r4 = combined struct offset
    exts.w r4, r4                        ! sign-extend
    add r13, r4                          ! r4 = &entry
    mov.l @(48, r4), r3                  ! r3 = entry.bonus_countdown
    add r2, r3                           ! r3 = bonus_countdown + 0x0800 (decrement via unsigned add)
    mov.l r3, @(48, r4)                  ! store updated bonus_countdown
    mov r3, r2                           ! r2 = updated countdown
    cmp/pz r2                            ! T = (countdown >= 0)? (overflow check)
    bf      .L_skip_bonus                ! if negative, countdown still running — skip
    extu.b r14, r2                       ! r2 = entry_index
    mov r2, r3                           ! r3 = entry_index
    shll2 r2                             ! r2 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r2                           ! r2 = combined struct offset
    exts.w r2, r2                        ! sign-extend
    add r13, r2                          ! r2 = &entry
    mov #0x0, r1                         ! r1 = 0
    mov.l r1, @(48, r2)                  ! clear bonus_countdown (expired)
.L_skip_bonus:
    .byte   0xB4, 0xFA    /* bsr 0x06016DD8 (external) */  ! call digit_render subroutine
    extu.b r14, r4                       ! r4 = entry_index arg (delay slot)
    extu.b r11, r11                      ! zero-extend anim phase flag
    tst r11, r11                         ! test if state change occurred
    bt      .L_epilogue                  ! if no state change, skip phase write
    extu.b r14, r14                      ! r14 = entry_index (zero-extended)
    mov r14, r3                          ! r3 = entry_index
    shll2 r14                            ! r14 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 4
    shll2 r3                             ! r3 = entry_index * 16
    shll2 r3                             ! r3 = entry_index * 64
    add r3, r14                          ! r14 = combined struct offset
    exts.w r14, r14                      ! sign-extend
    add r13, r14                         ! r14 = &entry
    mov #0x7, r2                         ! r2 = 7 (new animation phase)
    mov r2, r0                           ! r0 = 7
    mov.b r0, @(2, r14)                  ! entry.anim_phase = 7 (transition state)
.L_epilogue:
    lds.l @r15+, pr                      ! restore return address
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    mov.l @r15+, r13                     ! restore r13
    rts                                  ! return
    mov.l @r15+, r14                     ! restore r14 (delay slot)
