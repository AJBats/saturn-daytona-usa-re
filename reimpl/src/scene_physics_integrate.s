/* scene_physics_integrate -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060256CC - 0x06025BF4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Scene physics integration for car select / preview screens.
 * Near-twin of scene_physics_variant â€” both manage up to 10 physics
 * slots (one per car on screen), each updated via car_physics_final.
 *
 * Two rendering paths based on available sprite slots:
 *   - Simple path (< 6 slots): loop car_physics_final for each slot
 *   - Detailed path (>= 6 slots): per-slot render record lookup with
 *     direction table indexing and layer_setup geometry dispatch
 *
 * Input handling (when variant_active_flag is set):
 *   - Advance buttons (0x8000): increment anim index (0-14 wrap)
 *   - Retreat buttons (0x4000): decrement anim index (14-0 wrap)
 *   - Course-specific limits skip invalid angle ranges
 *   - Start (0x0800): exit to game_state=5, mode=0x12
 *
 * Render record table (sym_060610BC): 12-byte stride per entry
 *   +0x00: .4byte render function ptr
 *   +0x04: .4byte render frame data ptr
 *   +0x08: .2byte render type ID
 *   +0x0A: .2byte padding
 *
 * Direction tables (sym_0605904C, sym_06059060): 2-byte stride
 *   byte[0] = direction high, byte[1] = direction low
 *   Combined: (low << 8) + high -> 16-bit direction index
 *
 * Persistent registers:
 *   r8  = render_base_table (sym_06063750)
 *   r9  = render_param (0x00A9)
 *   r10 = slot_data_table (sym_06060F2C, 8-byte stride)
 *   r12 = slot_limit (10)
 *   r13 = &active_slot_index (sym_06089ECC)
 *   r14 = &anim_frame_index (sym_06089ED0)
 */

    .section .text.FUN_060256CC


    .global scene_physics_integrate
    .type scene_physics_integrate, @function
scene_physics_integrate:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    mov.l r10, @-r15
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x20, r15                     ! allocate 32 bytes of stack locals
    mov.l   .L_render_base_table, r8    ! r8 = render base data array
    mov.w   DAT_06025746, r9            ! r9 = 0x00A9 (render param)
    mov.l   .L_slot_data_table, r10     ! r10 = slot data array (8-byte stride)
    mov.l   .L_active_slot_ptr, r13     ! r13 -> active slot index (persistent)
    mov.l   .L_anim_frame_ptr, r14      ! r14 -> anim frame index (persistent)
    mov.l   .L_variant_active_flag, r3
    mov.b @r3, r3                       ! read variant_active_flag
    extu.b r3, r3
    tst r3, r3
    bt/s    .L_variant_inactive         ! flag clear -> run physics loop
    mov #0xA, r12                       ! r12 = slot_limit (10) [delay slot]
    bra     .L_input_handler            ! flag set -> skip to input handler
    nop
.L_variant_inactive:                        ! === Physics update loop ===
    mov.l   .L_slot_count_word, r1
    mov.l   .L_fn_slot_check, r3
    mov.w @r1, r1                       ! r1 = slot count
    extu.w r1, r1
    jsr @r3                             ! slot_check(0x10, slot_count) -> r0
    mov #0x10, r0
    mov #0x6, r2
    cmp/ge r2, r0                       ! r0 >= 6?
    bt      .L_detailed_setup           ! yes -> detailed render path
    mov #0x0, r11                       ! no -> simple path, r11 = slot_idx
.L_simple_loop:                             ! === Simple path: loop car_physics_final ===
    extu.w r9, r5                       ! r5 = render_param
    mov.l   .L_fn_car_physics, r3
    jsr @r3                             ! car_physics_final(slot_idx, render_param)
    mov r11, r4                         ! r4 = slot_idx [delay slot]
    add #0x1, r11                       ! slot_idx++
    extu.w r11, r2
    cmp/ge r12, r2                      ! slot_idx >= slot_limit?
    bf      .L_simple_loop              ! no -> next slot
    bra     .L_post_physics
    nop
.L_detailed_setup:                          ! === Detailed path: render with direction tables ===
    mov #0x0, r11                       ! r11 = slot_idx
.L_detailed_loop:
    extu.w r9, r5                       ! r5 = render_param
    mov.l   .L_fn_car_physics, r3
    jsr @r3                             ! car_physics_final(slot_idx, render_param)
    mov r11, r4                         ! r4 = slot_idx [delay slot]
    extu.w r11, r3
    shll2 r3
    shll r3                             ! r3 = slot_idx * 8
    mov.l r3, @(20, r15)               ! sp[20] = slot_offset
    add r10, r3                         ! r3 -> slot_data[slot_idx]
    mov.l r3, @(16, r15)               ! sp[16] = &slot_data[slot_idx]
    mov.w @(6, r3), r0                  ! r0 = slot_data[slot_idx].render_type (+6)
    mov.w   .L_render_type_b4, r2      ! r2 = 0x00B4 (alternate render type)
    mov r0, r3
    extu.w r3, r3
    cmp/eq r2, r3                       ! render_type == 0xB4?
    bt      .L_use_type_9              ! yes -> base_count = 9
    bra     .L_use_type_8
    mov #0x8, r2                        ! no -> base_count = 8 [delay slot]

    .global DAT_06025746
DAT_06025746:
    .2byte  0x00A9                       /* render parameter (physics mode) */
.L_render_type_b4:
    .2byte  0x00B4                       /* alternate render type ID */
    .2byte  0xFFFF
.L_render_base_table:
    .4byte  sym_06063750                /* render base data (8-byte stride) */
.L_slot_data_table:
    .4byte  sym_06060F2C                /* slot data array (8-byte per slot) */
.L_active_slot_ptr:
    .4byte  sym_06089ECC                /* &active_slot_index (dword) */
.L_anim_frame_ptr:
    .4byte  sym_06089ED0                /* &anim_frame_index (dword) */
.L_variant_active_flag:
    .4byte  sym_06061199                /* variant active flag (byte) */
.L_slot_count_word:
    .4byte  sym_06089EC6                /* slot count (word) */
.L_fn_slot_check:
    .4byte  sym_06035C2C                /* slot availability check */
.L_fn_car_physics:
    .4byte  car_physics_final           /* per-car physics final update */
.L_use_type_9:                              ! render type 0xB4 -> base_count = 9
    mov #0x9, r2
.L_use_type_8:                              ! === Detailed slot render (pass A) ===
    extu.w r2, r2
    extu.w r11, r6                      ! r6 = slot_idx
    mov r2, r0
    mov.w r0, @(8, r15)                ! sp[8] = base_count
    mov.l @(20, r15), r7               ! r7 = slot_offset
    mov.l   .L_slot_offset_table, r3
    add r3, r7                          ! r7 -> slot_offset_table[slot_idx]
    mov.l r7, @r15                      ! sp[0] = &slot_offset_table[slot_idx]
    mov.l @r7, r7                       ! r7 = offset_entry value
    shll2 r7
    shll r7                             ! r7 = offset_entry * 8
    add r8, r7                          ! r7 -> render_base[offset_entry]
    mov.l r7, @(4, r15)               ! sp[4] = &render_base[offset_entry]
    mov.l @(4, r7), r7                  ! r7 = render_base[].frame_data_ptr
    mov.l   .L_fp_half, r3
    add r3, r7                          ! r7 += 0.5 (fixed-point round)
    shll r6                             ! r6 = slot_idx * 2
    mov.l r6, @(24, r15)               ! sp[24] = slot_idx * 2
    mov.l   .L_direction_table_a, r3
    add r3, r6                          ! r6 -> direction_a[slot_idx]
    mov.l r6, @(28, r15)               ! sp[28] = &direction_a[slot_idx]
    mov.b @(1, r6), r0                  ! r0 = direction_a[slot_idx].low
    mov r0, r6
    extu.b r6, r6
    shll2 r6
    shll2 r6
    shll2 r6                            ! r6 = dir_low * 256
    mov.l @(28, r15), r2
    mov.b @r2, r2                       ! r2 = direction_a[slot_idx].high
    extu.b r2, r2
    add r2, r6                          ! r6 = (dir_low << 8) + dir_high
    shll r6                             ! r6 = direction_index * 2
    mov.l @(4, r15), r5                ! r5 = &render_base[offset_entry]
    mov.l @r15, r4                      ! r4 = &slot_offset_table[slot_idx]
    mov.l @r5, r5                       ! r5 = render_fn_ptr
    add #0x4, r4
    mov.l r4, @(12, r15)               ! sp[12] = &slot_offset_table[slot_idx]+4
    mov.l @r4, r4                       ! r4 = slot_offset_table[slot_idx].count
    mov.l   .L_fn_layer_setup, r3
    jsr @r3                             ! layer_setup(count*4, render_fn, dir_idx*2, frame_data+0.5)
    shll2 r4                            ! r4 = count * 4 [delay slot]
    mov.w @(8, r15), r0                 ! === Detailed slot render (pass B) ===
    mov r8, r2                          ! r2 = render_base_table
    mov.l @(16, r15), r3               ! r3 = &slot_data[slot_idx]
    mov r0, r7
    extu.w r7, r7                       ! r7 = base_count
    mov.w @(6, r3), r0                  ! r0 = slot_data[slot_idx].render_type
    shll8 r7
    mov r0, r3
    shll2 r7
    extu.w r3, r3
    shll2 r7                            ! r7 = base_count * 4096
    shll2 r3
    shll r3                             ! r3 = render_type * 8
    add r3, r2                          ! r2 -> render_base[render_type]
    mov.l r2, @(4, r15)               ! sp[4] = &render_base[render_type]
    mov.l @(4, r2), r3                  ! r3 = render_base[type].frame_data_ptr
    mov.l @(24, r15), r6               ! r6 = slot_idx * 2
    add r3, r7                          ! r7 = frame_data_ptr + base_count*4096
    mov.l   .L_direction_table_b, r3
    add r3, r6                          ! r6 -> direction_b[slot_idx]
    mov.l r6, @r15                      ! sp[0] = &direction_b[slot_idx]
    mov.b @(1, r6), r0                  ! r0 = direction_b[slot_idx].low
    mov.l @r15, r2
    mov r0, r6
    mov.b @r2, r2                       ! r2 = direction_b[slot_idx].high
    extu.b r6, r6
    extu.b r2, r2
    shll2 r6
    shll2 r6
    shll2 r6                            ! r6 = dir_low * 256
    add r2, r6                          ! r6 = (dir_low << 8) + dir_high
    shll r6                             ! r6 = direction_index * 2
    mov.l @(4, r15), r5
    mov.l @(12, r15), r4
    mov.l   .L_fn_layer_setup, r3
    mov.l @r5, r5                       ! r5 = render_fn_ptr
    mov.l @r4, r4                       ! r4 = count
    jsr @r3                             ! layer_setup(count*4, render_fn, dir_idx*2, frame_data)
    shll2 r4                            ! r4 = count * 4 [delay slot]
    add #0x1, r11                       ! slot_idx++
    extu.w r11, r2
    cmp/ge r12, r2                      ! slot_idx >= slot_limit?
    bf      .L_detailed_loop            ! no -> next slot
.L_post_physics:                            ! === Check if nav buttons enter variant mode ===
    mov.l   .L_input_buttons, r5
    mov.w @r5, r5                       ! r5 = current input buttons
    extu.w r5, r4
    tst r4, r4
    bt      .L_input_handler            ! no input -> skip to handler
    mov.l   .L_btn_nav_only_mask, r3   ! 0xC000 = navigation buttons
    and r4, r3
    tst r3, r3
    bf      .L_input_handler            ! nav buttons pressed -> skip (only pure nav enters)
    mov #0x1, r3                        ! only non-nav buttons -> enter variant mode
    mov.l   .L_variant_active_flag_2, r2
    mov.b r3, @r2                       ! variant_active_flag = 1
.L_input_handler:                           ! === Input handler dispatch ===
    mov.l   .L_variant_active_flag_2, r3
    mov.b @r3, r3                       ! read variant_active_flag
    extu.b r3, r3
    tst r3, r3
    bf      .L_variant_mode_active      ! flag set -> process variant input
    bra     .L_exit                     ! flag clear -> exit
    nop
.L_slot_offset_table:
    .4byte  sym_06058FBC                /* per-slot offset entries */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_direction_table_a:
    .4byte  sym_0605904C                /* direction pair table A (2-byte stride) */
.L_fn_layer_setup:
    .4byte  sym_06028400                /* layer setup / geometry dispatch */
.L_direction_table_b:
    .4byte  sym_06059060                /* direction pair table B (2-byte stride) */
.L_input_buttons:
    .4byte  sym_06063D9A                /* current input buttons (word) */
.L_btn_nav_only_mask:
    .4byte  0x0000C000                  /* navigation button mask (bits 15:14) */
.L_variant_active_flag_2:
    .4byte  sym_06061199                /* variant active flag (same as above) */
.L_variant_mode_active:                     ! === Variant mode: read input ===
    mov.l   .L_input_buttons_3, r4
    mov.w @r4, r4                       ! r4 = current input buttons
    extu.w r4, r3
    tst r3, r3
    bf      .L_has_input                ! input present -> check button type
    bra     .L_post_race_render         ! no input -> post-race render
    nop
.L_has_input:
    extu.w r4, r3
    mov.l   .L_btn_action_mask, r2     ! 0xC000
    and r2, r3
    tst r3, r3
    bf      .L_has_action_buttons       ! action buttons pressed -> check which
    bra     .L_start_button_check       ! only nav buttons -> check start
    nop
.L_has_action_buttons:                      ! === Check advance buttons (0x8000) ===
    extu.w r4, r3
    mov.l   .L_btn_advance_mask, r2    ! 0x8000
    and r2, r3
    tst r3, r3
    bt      .L_retreat_check            ! not advance -> check retreat
    mov.l @r14, r3                      ! === Advance animation index ===
    add #0x1, r3                        ! index++
    mov.l r3, @r14
    mov r3, r2
    mov #0xE, r3
    cmp/gt r3, r2                       ! index > 14?
    bf      .L_adv_course_a_check
    mov #0x0, r3                        ! wrap to 0
    mov.l r3, @r14
.L_adv_course_a_check:                      ! --- Course A==1 limit: skip 4->8 on advance ---
    mov.l   .L_course_id_a, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x1, r0                     ! course_a == 1?
    bf      .L_adv_course_a2_check
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0x4, r0                     ! anim_index == 4?
    bf      .L_adv_course_a2_check
    mov #0x8, r3                        ! skip to index 8
    mov.l r3, @r14
.L_adv_course_a2_check:                     ! --- Course A==2 limit: skip 2->4 on advance ---
    mov.l   .L_course_id_a, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x2, r0                     ! course_a == 2?
    bf      .L_adv_course_b_check
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0x2, r0                     ! anim_index == 2?
    bf      .L_adv_course_b_check
    mov #0x4, r3                        ! skip to index 4
    mov.l r3, @r14
.L_adv_course_b_check:                      ! --- Course B==1 limit: skip 10->14 on advance ---
    mov.l   .L_course_id_b, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x1, r0                     ! course_b == 1?
    bf      .L_adv_course_b2_check
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0xA, r0                     ! anim_index == 10?
    bf      .L_adv_course_b2_check
    mov #0xE, r3                        ! skip to index 14
    mov.l r3, @r14
.L_adv_course_b2_check:                     ! --- Course B==2 limit: skip 8->10 on advance ---
    mov.l   .L_course_id_b, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x2, r0                     ! course_b == 2?
    bt      .L_adv_b2_frame_eq8
    bra     .L_commit_direction         ! no match -> commit
    nop
.L_adv_b2_frame_eq8:
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0x8, r0                     ! anim_index == 8?
    bt      .L_adv_skip_to_limit
    bra     .L_commit_direction
    nop
.L_adv_skip_to_limit:
    bra     .L_commit_direction
    mov.l r12, @r14                     ! skip to index 10 (r12) [delay slot]
.L_retreat_check:                           ! === Check retreat buttons (0x4000) ===
    extu.w r4, r4
    mov.w   DAT_0602596a, r2           ! r2 = 0x4000 (retreat button mask)
    and r2, r4
    tst r4, r4
    bt      .L_no_input                 ! no retreat buttons -> skip
    mov.l @r14, r3                      ! === Retreat animation index ===
    add #-0x1, r3                       ! index--
    mov.l r3, @r14
    mov r3, r2
    cmp/pz r2                           ! index >= 0?
    bt      .L_ret_course_b_check
    mov #0xE, r2                        ! wrap to 14
    mov.l r2, @r14
.L_ret_course_b_check:                      ! --- Course B==1 limit: skip 13->9 on retreat ---
    mov.l   .L_course_id_b, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x1, r0                     ! course_b == 1?
    bf      .L_ret_course_b2_check
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0xD, r0                     ! anim_index == 13?
    bf      .L_ret_course_b2_check
    mov #0x9, r3                        ! skip back to index 9
    mov.l r3, @r14
.L_ret_course_b2_check:                     ! --- Course B==2 limit: skip 9->7 on retreat ---
    mov.l   .L_course_id_b, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x2, r0                     ! course_b == 2?
    bf      .L_ret_course_a_check
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0x9, r0                     ! anim_index == 9?
    bf      .L_ret_course_a_check
    mov #0x7, r3                        ! skip back to index 7
    mov.l r3, @r14
.L_ret_course_a_check:                      ! --- Course A==1 limit: skip 7->3 on retreat ---
    mov.l   .L_course_id_a, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x1, r0                     ! course_a == 1?
    bf      .L_ret_course_a2_check
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0x7, r0                     ! anim_index == 7?
    bf      .L_ret_course_a2_check
    mov #0x3, r3                        ! skip back to index 3
    mov.l r3, @r14
.L_ret_course_a2_check:                     ! --- Course A==2 limit: skip 3->1 on retreat ---
    mov.l   .L_course_id_a, r0
    mov.w @r0, r0
    extu.w r0, r0
    cmp/eq #0x2, r0                     ! course_a == 2?
    bf      .L_no_input
    mov.l   .L_anim_frame_check, r0
    mov.l @r0, r0
    cmp/eq #0x3, r0                     ! anim_index == 3?
    bf      .L_no_input
    mov #0x1, r3                        ! skip back to index 1
    mov.l r3, @r14
.L_no_input:
    bra     .L_commit_direction
    nop

    .global DAT_0602596a
DAT_0602596a:
    .2byte  0x4000                       /* retreat button mask */
.L_input_buttons_3:
    .4byte  sym_06063D9A                /* current input buttons (word) */
.L_btn_action_mask:
    .4byte  0x0000C000                  /* action button mask (bits 15:14) */
.L_btn_advance_mask:
    .4byte  0x00008000                  /* advance button mask (bit 15) */
.L_course_id_a:
    .4byte  sym_06089ED6                /* course identifier A (word) */
.L_anim_frame_check:
    .4byte  sym_06089ED0                /* anim frame index (for course limit checks) */
.L_course_id_b:
    .4byte  sym_06089ED4                /* course identifier B (word) */
.L_start_button_check:                      ! === Check Start button (0x0800) -> exit variant mode ===
    extu.w r4, r2
    mov.w   DAT_06025a80, r3           ! r3 = 0x0800 (Start button mask)
    and r3, r2
    tst r2, r2
    bt      .L_button_search            ! not Start -> search button table
    mov #0x5, r3
    mov.l   .L_game_state_byte, r2
    mov.b r3, @r2                       ! game_state = 5
    mov #0x12, r3
    mov.l   .L_game_mode_word, r2
    mov.w r3, @r2                       ! game_mode = 0x12 (18)
    mov #0x0, r3
    mov.l   .L_variant_flag_exit, r2
    mov.b r3, @r2                       ! variant_active_flag = 0
    mov #0x4, r4                        ! --- Tail-call scene_process_a ---
    add #0x20, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    .byte   0xAC, 0x37    /* bra scene_process_a (external) */
    mov.l @r15+, r14
.L_button_search:                           ! === Find which button was pressed ===
    mov #0x0, r5                        ! r5 = button_table_idx
.L_button_search_loop:
    extu.w r5, r2
    extu.w r4, r1                       ! r1 = input buttons
    mov.l   .L_button_mask_table, r3
    shll r2                             ! r2 = idx * 2
    add r3, r2                          ! r2 -> button_mask_table[idx]
    mov.w @r2, r2                       ! r2 = button_mask[idx]
    extu.w r2, r2
    and r1, r2                          ! test: input & mask
    tst r2, r2
    bt      .L_button_next              ! no match -> next
    bra     .L_button_found             ! match -> found the button
    nop
.L_button_next:
    add #0x1, r5                        ! next button index
    extu.w r5, r2
    cmp/ge r12, r2                      ! idx >= 10?
    bf      .L_button_search_loop
.L_button_found:                            ! r5 = button index that was pressed
    extu.w r5, r5
    mov.l r5, @r13                      ! active_slot_index = button_idx
    .byte   0xB4, 0x70    /* bsr transform_heading_apply (external) */
    mov r5, r4
    mov #0x0, r4                        ! === Find matching anim frame ===
.L_anim_search_loop:
    extu.b r4, r2
    mov.l   .L_render_record_table, r1
    mov r2, r3
    shll2 r2                            ! r2 = idx * 4
    shll2 r3
    shll r3                             ! r3 = idx * 8
    add r3, r2                          ! r2 = idx * 12 (render record stride)
    extu.b r2, r2
    add r1, r2                          ! r2 -> render_record[idx]
    mov.w @(8, r2), r0                  ! r0 = render_record[idx].type_id (+8)
    mov r0, r3
    mov.l @r13, r2                      ! r2 = active_slot_index
    extu.w r3, r3
    shll2 r2
    shll r2                             ! r2 = slot_index * 8
    add r10, r2                         ! r2 -> slot_data[active_slot]
    mov.w @(6, r2), r0                  ! r0 = slot_data[active_slot].render_type
    mov r0, r1
    extu.w r1, r1
    cmp/eq r1, r3                       ! render_record[idx].type == slot render_type?
    bf      .L_anim_next                ! no match -> next
    bra     .L_anim_found               ! match -> found
    nop
.L_anim_next:
    add #0x1, r4                        ! next anim frame
    mov #0xE, r3
    extu.w r4, r2
    cmp/ge r3, r2                       ! idx >= 14?
    bf      .L_anim_search_loop
.L_anim_found:
    extu.w r4, r4
    mov.l r4, @r14                      ! anim_frame_index = matching frame
.L_commit_direction:                        ! === Commit direction/force data to display tables ===
    mov.l @r13, r3                      ! r3 = active_slot_index
    mov.l @r14, r2                      ! r2 = anim_frame_index
    mov.l   .L_render_record_table, r0
    shll2 r3
    extu.b r2, r2
    shll r3                             ! r3 = slot_index * 8
    mov r2, r1
    add r10, r3                         ! r3 -> slot_data[active_slot]
    shll2 r2                            ! r2 = frame * 4
    shll2 r1
    shll r1                             ! r1 = frame * 8
    add r1, r2                          ! r2 = frame * 12
    extu.b r2, r2
    add r0, r2                          ! r2 -> render_record[frame]
    mov.l @(4, r2), r1                  ! r1 = render_record[frame].frame_data_ptr
    mov.l r1, @r3                       ! slot_data[active_slot].ptr = frame_data_ptr
    mov.l @r13, r3
    mov.l @r13, r2
    mov.l   .L_button_mask_table, r1
    shll2 r3
    shll r2                             ! r2 = slot_index * 2
    shll r3                             ! r3 = slot_index * 8
    add r1, r2                          ! r2 -> button_mask_table[slot_index]
    add r10, r3                         ! r3 -> slot_data[active_slot]
    mov.w @r2, r0                       ! r0 = button_mask[slot_index]
    mov.w r0, @(4, r3)                  ! slot_data[active_slot].mask (+4) = button_mask
    mov.l @r13, r3
    shll2 r3
    shll r3                             ! r3 = slot_index * 8
    add r10, r3                         ! r3 -> slot_data[active_slot]
    mov.l @r14, r2                      ! r2 = anim_frame_index
    extu.b r2, r2
    mov.l   .L_render_record_table, r0
    mov r2, r1
    shll2 r2                            ! r2 = frame * 4
    shll2 r1
    shll r1                             ! r1 = frame * 8
    add r1, r2                          ! r2 = frame * 12
    extu.b r2, r2
    add r0, r2                          ! r2 -> render_record[frame]
    mov.w @(8, r2), r0                  ! r0 = render_record[frame].type_id
    mov.w r0, @(6, r3)                  ! slot_data[active_slot].render_type (+6) = type_id
    .byte   0xBB, 0xD7    /* bsr scene_process_a (external) */
    mov #0x4, r4
.L_post_race_render:                        ! === Post-race: render current selection ===
    mov.l @r13, r2                      ! r2 = active_slot_index
    cmp/pz r2                           ! valid slot? (>= 0)
    bt      .L_post_race_physics        ! yes -> render
    bra     .L_exit                     ! no -> exit
    nop

    .global DAT_06025a80
DAT_06025a80:
    .2byte  0x0800                       /* Start button mask */
    .2byte  0xFFFF
.L_game_state_byte:
    .4byte  sym_06061198                /* game state (byte) */
.L_game_mode_word:
    .4byte  sym_06089EDA                /* game mode (word) */
.L_variant_flag_exit:
    .4byte  sym_06061199                /* variant active flag (clear on exit) */
.L_button_mask_table:
    .4byte  sym_06059094                /* per-slot button mask table (2-byte stride) */
.L_render_record_table:
    .4byte  sym_060610BC                /* render record table (12-byte stride) */
.L_post_race_physics:                       ! === Post-race physics render (single pass) ===
    mov.l   .L_slot_count_word_2, r1
    mov.l   .L_fn_slot_check_2, r3
    mov.w @r1, r1                       ! r1 = slot count
    extu.w r1, r1
    jsr @r3                             ! slot_check(0x10, slot_count) -> r0
    mov #0x10, r0
    mov #0x6, r2
    cmp/ge r2, r0                       ! r0 >= 6?
    bt      .L_post_detailed            ! yes -> detailed render
    extu.w r9, r5                       ! === Simple post-race: tail-call car_physics_final ===
    mov.l @r13, r4                      ! r4 = active_slot_index
    extu.w r4, r4
    add #0x20, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    mov.l   .L_fn_car_physics_2, r3
    jmp @r3                             ! tail-call car_physics_final(active_slot, render_param)
    mov.l @r15+, r14
.L_post_detailed:                           ! === Detailed post-race render ===
    mov.l @r14, r3                      ! r3 = anim_frame_index
    mov.l   .L_render_record_table_2, r1
    extu.b r3, r3
    mov r3, r2
    shll2 r3                            ! r3 = frame * 4
    shll2 r2
    shll r2                             ! r2 = frame * 8
    add r2, r3                          ! r3 = frame * 12
    extu.b r3, r3
    mov.w   .L_render_type_b4_2, r2    ! r2 = 0x00B4
    add r1, r3                          ! r3 -> render_record[frame]
    mov.w @(8, r3), r0                  ! r0 = render_record[frame].type_id
    mov r0, r3
    extu.w r3, r3
    cmp/eq r2, r3                       ! type == 0xB4?
    bt      .L_post_use_type_9         ! yes -> base_count = 9
    bra     .L_post_use_type_8
    mov #0x8, r2                        ! no -> base_count = 8 [delay slot]
.L_post_use_type_9:                         ! type 0xB4 -> base_count = 9
    mov #0x9, r2
.L_post_use_type_8:                         ! === Post-race detailed render (pass A) ===
    extu.w r2, r2
    mov r2, r0
    mov.w r0, @(4, r15)               ! sp[4] = base_count
    mov.l @r13, r7                      ! r7 = active_slot_index
    mov.l   .L_slot_offset_table_2, r3
    shll2 r7
    shll r7                             ! r7 = slot_index * 8
    add r3, r7                          ! r7 -> slot_offset_table[active_slot]
    mov.l r7, @r15                      ! sp[0] = &slot_offset_table[active_slot]
    mov.l @r7, r7                       ! r7 = offset_entry value
    shll2 r7
    shll r7                             ! r7 = offset_entry * 8
    add r8, r7                          ! r7 -> render_base[offset_entry]
    mov.l r7, @(8, r15)               ! sp[8] = &render_base[offset_entry]
    mov.l @(4, r7), r7                  ! r7 = render_base[].frame_data_ptr
    mov.l   .L_fp_half_2, r3
    mov.l @r13, r6                      ! r6 = active_slot_index
    add r3, r7                          ! r7 += 0.5 (fixed-point round)
    shll r6                             ! r6 = slot_index * 2
    mov.l   .L_direction_table_a_2, r3
    add r3, r6                          ! r6 -> direction_a[active_slot]
    mov.l r6, @(12, r15)               ! sp[12] = &direction_a[active_slot]
    mov.b @(1, r6), r0                  ! r0 = direction_a[slot].low
    mov r0, r6
    extu.b r6, r6
    shll2 r6
    shll2 r6
    shll2 r6                            ! r6 = dir_low * 256
    mov.l @(12, r15), r2
    mov.b @r2, r2                       ! r2 = direction_a[slot].high
    extu.b r2, r2
    add r2, r6                          ! r6 = (dir_low << 8) + dir_high
    mov.l @(8, r15), r5
    mov.l @r15, r4
    mov.l   .L_fn_layer_setup_2, r3
    shll r6                             ! r6 = direction_index * 2
    mov.l @r5, r5                       ! r5 = render_fn_ptr
    mov.l @(4, r4), r4                  ! r4 = count
    jsr @r3                             ! layer_setup(count*4, render_fn, dir_idx*2, frame_data+0.5)
    shll2 r4                            ! r4 = count * 4 [delay slot]
    mov.w @(4, r15), r0                 ! === Post-race detailed render (pass B) ===
    mov.l @r14, r3                      ! r3 = anim_frame_index
    mov r0, r7
    extu.b r3, r3
    extu.w r7, r7                       ! r7 = base_count
    mov r3, r2
    shll8 r7
    shll2 r2
    shll2 r3
    shll2 r7
    shll r3
    shll2 r7                            ! r7 = base_count * 4096
    add r3, r2                          ! r2 = frame * 12
    extu.b r2, r2
    mov.l   .L_render_record_table_2, r3
    add r2, r3                          ! r3 -> render_record[frame]
    mov.w @(8, r3), r0                  ! r0 = render_record[frame].type_id
    mov r0, r2
    extu.w r2, r3
    shll2 r3
    mov r8, r2                          ! r2 = render_base_table
    shll r3                             ! r3 = type_id * 8
    add r3, r2                          ! r2 -> render_base[type_id]
    mov.l r2, @r15                      ! sp[0] = &render_base[type_id]
    mov.l @(4, r2), r3                  ! r3 = render_base[type].frame_data_ptr
    mov.l @r13, r6                      ! r6 = active_slot_index
    add r3, r7                          ! r7 = frame_data_ptr + base_count*4096
    shll r6                             ! r6 = slot_index * 2
    mov.l   .L_direction_table_b_2, r3
    add r3, r6                          ! r6 -> direction_b[active_slot]
    mov.l r6, @(8, r15)               ! sp[8] = &direction_b[active_slot]
    mov.b @(1, r6), r0                  ! r0 = direction_b[slot].low
    mov r0, r6
    mov.l @(8, r15), r2
    mov.l @r15, r5
    mov.l @r13, r4                      ! r4 = active_slot_index
    extu.b r6, r6
    mov.b @r2, r2                       ! r2 = direction_b[slot].high
    mov.l @r5, r5                       ! r5 = render_fn_ptr
    shll2 r4
    shll2 r6
    extu.b r2, r2
    shll2 r6
    shll2 r6                            ! r6 = dir_low * 256
    add r2, r6                          ! r6 = (dir_low << 8) + dir_high
    shll r6                             ! r6 = direction_index * 2
    shll r4                             ! r4 = slot_index * 8
    mov.l   .L_slot_offset_table_2, r3
    add r3, r4                          ! r4 -> slot_offset_table[active_slot]
    mov.l @(4, r4), r4                  ! r4 = count
    shll2 r4                            ! r4 = count * 4
    add #0x20, r15                      ! --- Tail-call layer_setup ---
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    mov.l   .L_fn_layer_setup_2, r2
    jmp @r2                             ! tail-call layer_setup(count*4, render_fn, dir_idx*2, frame_data)
    mov.l @r15+, r14
.L_render_type_b4_2:
    .2byte  0x00B4                       /* alternate render type ID */
    .2byte  0xFFFF
.L_slot_count_word_2:
    .4byte  sym_06089EC6                /* slot count (word) */
.L_fn_slot_check_2:
    .4byte  sym_06035C2C                /* slot availability check */
.L_fn_car_physics_2:
    .4byte  car_physics_final           /* per-car physics final update */
.L_render_record_table_2:
    .4byte  sym_060610BC                /* render record table (12-byte stride) */
.L_slot_offset_table_2:
    .4byte  sym_06058FBC                /* per-slot offset entries */
.L_fp_half_2:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_direction_table_a_2:
    .4byte  sym_0605904C                /* direction pair table A (2-byte stride) */
.L_fn_layer_setup_2:
    .4byte  sym_06028400                /* layer setup / geometry dispatch */
.L_direction_table_b_2:
    .4byte  sym_06059060                /* direction pair table B (2-byte stride) */
.L_exit:                                    ! === Clean up and return ===
    add #0x20, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
