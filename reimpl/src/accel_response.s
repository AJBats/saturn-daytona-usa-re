/* accel_response -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600C4F8 - 0x0600C5D6
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Acceleration response curve — computes the acceleration delta to apply
 * to the player car each frame based on gear state, car type, and speed.
 *
 * Car struct offsets used:
 *   [+8]    = car type index (selects accel curve)
 *   [+12]   = current speed (32-bit, accumulated each frame)
 *   [+0xB8] = shift timer (nonzero = shift in progress)
 *   [+0xBC] = gear lock flag
 *   [+0xD4] = shift animation timer (decremented per frame)
 *   [+0xFC] = acceleration delta (written each frame)
 *   [+0x194] = collision speed component
 *   [+0x198] = collision response value
 *
 * Logic:
 *   1. Decrement shift animation timer (+0xD4) if positive
 *   2. Check game state bit 15 — if set, skip (game paused/frozen)
 *   3. If gear lock (+0xBC) > 0 OR shift timer (+0xB8) != 0:
 *      → write deceleration constant (0xF052) to +0xFC
 *   4. Otherwise compute acceleration:
 *      a. Look up curve_a[car_type] and curve_b[car_type]
 *      b. base = curve_a - curve_b + 0xFEC00000 (base accel constant)
 *      c. delta = fpmul(base, 1)
 *      d. max_delta = fpmul(delta, collision_speed) >> 1
 *      e. Clamp: min(max_delta, collision_offset - speed)
 *      f. Store result to +0xFC
 *   5. speed = speed + accel_delta; clamp to >= 0
 *   6. Convert speed to 16-bit display value via fpmul + shlr16
 */

    .section .text.FUN_0600C4F8


    .global accel_response
    .type accel_response, @function
accel_response:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    sts.l pr, @-r15
    mov.l   .L_fn_fpmul, r13          /* r13 = fpmul function (reused) */
    mov.l   .L_car_struct_ptr, r14
    mov.w   DAT_0600c590, r0          /* r0 = +0xD4 (shift anim timer) */
    mov.l @r14, r14                    /* r14 = car struct */
    mov.w @(r0, r14), r3              /* read shift animation timer */
    cmp/pl r3
    bf      .L_0600C516               /* timer <= 0 → skip decrement */
    mov.w   DAT_0600c590, r0
    mov.w @(r0, r14), r2
    add #-0x1, r2                      /* decrement timer */
    mov.w r2, @(r0, r14)
.L_0600C516:
    mov.l   .L_game_state_flags, r3
    mov.l   .L_flag_bitmask, r2       /* 0x8000 = check bit 15 */
    mov.l @r3, r3
    and r2, r3
    tst r3, r3
    bf      .L_0600C5CC               /* bit 15 set → skip accel (frozen) */
    mov.w   .L_decel_constant, r12    /* r12 = 0xF052 (deceleration value) */
    mov.w   DAT_0600c594, r0          /* +0xBC = gear lock flag */
    mov.l @(r0, r14), r3
    cmp/pl r3
    bt      .L_0600C534               /* gear locked → use decel constant */
    mov.w   DAT_0600c596, r0          /* +0xB8 = shift timer */
    mov.l @(r0, r14), r0
    tst r0, r0
    bt      .L_0600C53A               /* no shift in progress → compute accel */
.L_0600C534:
    mov.w   DAT_0600c598, r0          /* shifting: write decel to +0xFC */
    bra     .L_0600C580
    mov.l r12, @(r0, r14)
.L_0600C53A:                              /* --- compute acceleration --- */
    mov.l @(8, r14), r4               /* r4 = car type index */
    mov.l   .L_accel_curve_a, r2      /* acceleration curve table A */
    mov.l   .L_accel_curve_b, r3      /* acceleration curve table B */
    shll2 r4                           /* type * 4 (32-bit entries) */
    add r4, r2                         /* r2 → curve_a[type] */
    add r4, r3                         /* r3 → curve_b[type] */
    mov.l @r2, r2                      /* r2 = curve_a value */
    mov.l @r3, r3                      /* r3 = curve_b value */
    mov.l   .L_accel_base_const, r4   /* 0xFEC00000 (negative base) */
    sub r3, r2                         /* r2 = curve_a - curve_b */
    add r2, r4                         /* r4 = difference + base constant */
    jsr @r13                           /* fpmul(base_accel, 1) */
    mov #0x1, r5
    mov r0, r4                         /* r4 = scaled base accel */
    mov.w   DAT_0600c59a, r0          /* +0x198 = collision response */
    jsr @r13                           /* fpmul(accel, collision_speed) */
    mov.l @(r0, r14), r5
    mov r0, r5                         /* r5 = result */
    mov.l @(12, r14), r3              /* r3 = current speed */
    shar r5                            /* r5 >>= 1 (halve for clamping) */
    mov.w   .L_off_collision_result, r0  /* +0x194 = collision offset */
    mov.l @(r0, r14), r4              /* r4 = collision offset value */
    sub r3, r4                         /* r4 = headroom (offset - speed) */
    cmp/ge r12, r4                     /* headroom >= decel constant? */
    bt      .L_0600C572
    mov.w   DAT_0600c598, r0          /* headroom too small → decel */
    bra     .L_0600C580
    mov.l r12, @(r0, r14)
.L_0600C572:
    cmp/ge r4, r5                      /* accel <= headroom? */
    bt      .L_0600C57C
    mov.w   DAT_0600c598, r0          /* accel > headroom → clamp to accel */
    bra     .L_0600C580
    mov.l r5, @(r0, r14)
.L_0600C57C:
    mov.w   DAT_0600c598, r0          /* normal: use headroom as delta */
    mov.l r4, @(r0, r14)
.L_0600C580:                              /* --- apply acceleration delta --- */
    mov.l @(12, r14), r4              /* r4 = current speed */
    mov.w   DAT_0600c598, r0
    mov.l @(r0, r14), r3              /* r3 = accel delta from +0xFC */
    add r3, r4                         /* speed += delta */
    cmp/pl r4
    bf      .L_0600C5BC               /* speed < 0 → clamp to 0 */
    bra     .L_0600C5C0
    mov.l r4, @(12, r14)              /* store updated speed */

    .global DAT_0600c590
DAT_0600c590:
    .2byte  0x00D4                        /* car offset: shift animation timer */
.L_decel_constant:
    .2byte  0xF052                        /* deceleration constant (signed: -4014) */

    .global DAT_0600c594
DAT_0600c594:
    .2byte  0x00BC                        /* car offset: gear lock flag */

    .global DAT_0600c596
DAT_0600c596:
    .2byte  0x00B8                        /* car offset: shift timer */

    .global DAT_0600c598
DAT_0600c598:
    .2byte  0x00FC                        /* car offset: acceleration delta */

    .global DAT_0600c59a
DAT_0600c59a:
    .2byte  0x0198                        /* car offset: collision response value */
.L_off_collision_result:
    .2byte  0x0194                        /* car offset: collision speed component */
    .2byte  0xFFFF
.L_fn_fpmul:
    .4byte  fpmul                      /* fixed-point multiply */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* pointer to current car struct */
.L_game_state_flags:
    .4byte  sym_0607EBC4               /* game state flags (bit 15 = frozen) */
.L_flag_bitmask:
    .4byte  0x00008000                  /* bitmask: check bit 15 (freeze flag) */
.L_accel_curve_a:
    .4byte  sym_060477EC               /* acceleration curve table A (per car type) */
.L_accel_curve_b:
    .4byte  sym_060454CC               /* acceleration curve table B (per car type) */
.L_accel_base_const:
    .4byte  0xFEC00000                  /* base acceleration constant (negative) */
.L_0600C5BC:
    mov #0x0, r2                       /* clamp speed to 0 (no negative) */
    mov.l r2, @(12, r14)
.L_0600C5C0:                              /* --- convert to display speed --- */
    .byte   0xD5, 0x16    /* mov.l .L_pool_0600C61C, r5 */
    jsr @r13                           /* fpmul(speed, display_coeff) */
    mov.l @(12, r14), r4
    shlr16 r0                          /* convert 32-bit → 16-bit */
    exts.w r0, r0                      /* sign-extend */
    mov.l r0, @(8, r14)               /* car[+8] = display speed value */
.L_0600C5CC:
    lds.l @r15+, pr
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
