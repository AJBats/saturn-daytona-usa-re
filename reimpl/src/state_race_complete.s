/* state_race_complete -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06009A60 - 0x06009C48
 * Auto-generated by tools/generate_l3_tu.py
 *
 * End-of-race state handler — called when the race finishes. Collects
 * results, determines post-race flow (continue, game over, time extend),
 * and sets up the next game state.
 *
 * Persistent registers:
 *   r8  = car struct pointer (from car_array_base)
 *   r9  = &race_result_byte (sym_06078637)
 *   r10 = 4 (used as bit-OR constant)
 *   r11 = 1 (used as bit-OR constant)
 *   r12 = &car_array_base pointer variable
 *   r13 = 0 (zero constant)
 *   r14 = &mode_flags (byte, accumulates result bits)
 *
 * Result flag bits (written to mode_flags and result_flags):
 *   bit 0 = state 0 result    bit 1 = state 0 result (alt)
 *   bit 2 = state 1 result    bit 3 = set on race end bit 3
 *   bit 4 = state 2 result
 *
 * Post-race setup:
 *   car[+0x40] = 0, game_state = 0x15 (results screen),
 *   countdown = 86 frames (0x56), camera_mode = 4, state_word = 4
 *
 * Continue logic: checks car position thresholds:
 *   - state 0: car[+24] (Z pos) >= -0x480000 → allow continue
 *   - state 1: car[+16] (X pos) > -0x13A0000 → allow continue
 */

    .section .text.FUN_06009A60


    .global state_race_complete
    .type state_race_complete, @function
state_race_complete:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov #0x0, r13                     /* r13 = 0 (zero constant) */
    mov.l r11, @-r15
    mov #0x1, r11                     /* r11 = 1 */
    mov.l r10, @-r15
    mov #0x4, r10                     /* r10 = 4 */
    mov.l r9, @-r15
    mov.l r8, @-r15
    sts.l pr, @-r15
    add #-0x4, r15
    mov.l   .L_race_result_byte, r9
    mov.l   .L_car_array_base, r12
    mov.l   .L_mode_flags, r14
    mov.l   .L_fn_vdp1_update, r3
    jsr @r3                            /* vdp1_cmd_update() */
    mov.l @r12, r8                    /* r8 = car struct */
    mov.l   .L_fn_obj_render, r3
    jsr @r3                            /* obj_render_update() */
    nop
    .byte   0xB2, 0xB7    /* bsr 0x06009FFC (external) — post-race frame update */
    nop
    mov r13, r6                       /* r6 = 0 */
    mov.l   .L_course_index, r5
    mov.b @r5, r5
    add #0xA, r5                      /* handler index = course + 10 */
    mov.l r5, @r15
    mov.l   .L_fn_handler_dispatch, r3
    jsr @r3                            /* handler_dispatch(course + 10) */
    mov r5, r4
    mov.l @r12, r2                    /* r2 = car struct */
    mov.w   .L_off_car_sound_id, r0  /* +0x224 = car sound ID */
    mov.l @(r0, r2), r3
    add #0x1C, r0                     /* +0x240 = best lap time */
    mov.b r3, @r9                     /* store sound byte as race result */
    mov.l @r12, r3
    mov.l   .L_race_time_store, r1
    mov.l @(r0, r3), r2              /* r2 = car[+0x240] (best lap time) */
    mov.l r2, @r1                     /* store to race time */
    mov.l   .L_prev_lap_time, r3
    mov.l   .L_race_time_copy, r2
    mov.l @r3, r3
    mov.l r3, @r2                     /* copy prev lap time → race time copy */
    mov.l   .L_terrain_mode, r0
    mov.b @r0, r0
    tst r0, r0
    bt      .L_06009AE0              /* terrain mode off → skip flags */
    mov #0x1, r2
    mov.l   .L_race_phase, r3
    mov.l @r3, r3
    cmp/gt r2, r3
    bf      .L_06009AE0              /* phase <= 1 → skip */
    mov.b @r9, r2
    tst r2, r2
    bf      .L_06009AE0              /* result != 0 → skip */
    mov.l   .L_finish_flag, r0
    mov.l @r0, r0
    tst r0, r0
    bf      .L_06009AE0              /* already finished → skip */
    mov.b @r14, r0
    or #0x8, r0                       /* set bit 3 (terrain complete) */
    exts.b r0, r0
    mov.b r0, @r14
.L_06009AE0:                              /* --- continue eligibility check --- */
    mov.l   .L_continue_enabled, r0
    mov.b @r0, r0
    tst r0, r0
    bt      .L_06009BAA              /* continue disabled → skip to scoring */
    mov #0x1, r2
    mov.l   .L_race_phase_b, r3
    mov.l @r3, r3
    cmp/gt r2, r3
    bf      .L_06009BAA              /* phase <= 1 → skip */
    mov.l   .L_finish_flag, r0
    mov.l @r0, r0
    tst r0, r0
    bf      .L_06009BAA              /* already finished → skip */
    mov.b @r9, r3                     /* check race result */
    mov #0x3, r2
    cmp/ge r2, r3
    bt      .L_06009B78              /* result >= 3 → skip flag setting */
    mov.l   .L_result_flags, r4
    mov.l   .L_race_end_state, r0
    bra     .L_06009B6C              /* → dispatch on end state */
    mov.l @r0, r0
.L_06009B0A:                              /* end state 0: set bit 0 */
    mov.b @r4, r2
    bra     .L_06009B66
    or r11, r2                        /* flags |= 1 */
.L_off_car_sound_id:
    .2byte  0x0224                        /* car offset: sound ID / race result */
    .2byte  0xFFFF
.L_race_result_byte:
    .4byte  sym_06078637               /* race result byte */
.L_car_array_base:
    .4byte  sym_0607E944               /* car array base pointer variable */
.L_mode_flags:
    .4byte  sym_0605AB17               /* post-race mode flags (byte) */
.L_fn_vdp1_update:
    .4byte  vdp1_cmd_update            /* VDP1 command table update */
.L_fn_obj_render:
    .4byte  obj_render_update          /* object render update */
.L_course_index:
    .4byte  sym_06078648               /* current course index (byte) */
.L_fn_handler_dispatch:
    .4byte  handler_dispatch           /* course-specific handler dispatch */
.L_race_time_store:
    .4byte  sym_06078638               /* race time storage */
.L_prev_lap_time:
    .4byte  sym_060786A4               /* previous lap time */
.L_race_time_copy:
    .4byte  sym_0607863C               /* race time copy */
.L_terrain_mode:
    .4byte  sym_06083255               /* terrain rendering mode flag */
.L_race_phase:
    .4byte  sym_0605AD00               /* race phase counter A */
.L_finish_flag:
    .4byte  sym_0607EAE0               /* race finish flag */
.L_continue_enabled:
    .4byte  sym_06085FF4               /* continue eligibility flag (byte) */
.L_race_phase_b:
    .4byte  sym_0605AD04               /* race phase counter B */
.L_result_flags:
    .4byte  sym_0605AB16               /* result flags byte */
.L_race_end_state:
    .4byte  sym_0607EAD8               /* race end state (0/1/2 dispatch) */
.L_06009B58:                              /* end state 1: set bit 1 */
    mov.b @r4, r0
    or #0x2, r0
    exts.b r0, r0
    bra     .L_06009B78
    mov.b r0, @r4
.L_06009B62:                              /* end state 2: set bit 2 */
    mov.b @r4, r2
    or r10, r2                        /* flags |= 4 */
.L_06009B66:
    exts.b r2, r2
    bra     .L_06009B78
    mov.b r2, @r4
.L_06009B6C:                              /* --- end state dispatch --- */
    cmp/eq #0x0, r0
    bt      .L_06009B0A              /* state 0 */
    cmp/eq #0x1, r0
    bt      .L_06009B58              /* state 1 */
    cmp/eq #0x2, r0
    bt      .L_06009B62              /* state 2 */
.L_06009B78:                              /* --- mode flags dispatch --- */
    mov.b @r9, r2
    tst r2, r2
    bf      .L_06009BAA              /* result != 0 → skip mode flags */
    mov.l   .L_race_end_state_2, r0
    bra     .L_06009B9E              /* → dispatch on end state */
    mov.l @r0, r0
.L_06009B84:                              /* end state 0: mode |= 1 */
    mov.b @r14, r2
    bra     .L_06009B98
    or r11, r2
.L_06009B8A:                              /* end state 1: mode |= 2 */
    mov.b @r14, r0
    or #0x2, r0
    exts.b r0, r0
    bra     .L_06009BAA
    mov.b r0, @r14
.L_06009B94:                              /* end state 2: mode |= 4 */
    mov.b @r14, r2
    or r10, r2
.L_06009B98:
    exts.b r2, r2
    bra     .L_06009BAA
    mov.b r2, @r14
.L_06009B9E:                              /* --- mode flags end state dispatch --- */
    cmp/eq #0x0, r0
    bt      .L_06009B84
    cmp/eq #0x1, r0
    bt      .L_06009B8A
    cmp/eq #0x2, r0
    bt      .L_06009B94
.L_06009BAA:                              /* --- scoring and continue check --- */
    .byte   0xB3, 0x05    /* bsr 0x0600A1B8 (external) — scoring/ranking */
    nop
    mov r8, r0                        /* r0 = car struct */
    mov.l   .L_continue_byte, r4
    mov.b @(3, r0), r0               /* car[+3] = controller flags */
    tst #0x8, r0                      /* bit 3 = controller connected? */
    bf      .L_06009BF6              /* connected → force continue=2 */
    mov.l   .L_race_end_state_2, r0
    bra     .L_06009BE6              /* → dispatch on end state */
    mov.l @r0, r0
.L_06009BBE:                              /* end state 0: check Z position */
    mov.l @(24, r8), r2              /* car[+24] = Z position */
    mov.l   .L_neg_z_threshold, r3   /* 0xFFB80000 = -0x480000 */
    cmp/ge r3, r2
    bf      .L_06009BCA              /* Z < threshold → no continue */
    bra     .L_06009BD8              /* Z >= threshold → allow continue */
    nop
.L_06009BCA:
    exts.b r13, r2
    bra     .L_06009BFA              /* continue = 0 (no continue) */
    mov.b r2, @r4
.L_06009BD0:                              /* end state 1: check X position */
    mov.l @(16, r8), r2              /* car[+16] = X position */
    mov.l   .L_neg_x_threshold, r3   /* 0xFEC60000 = -0x13A0000 */
    cmp/gt r3, r2
    bt      .L_06009BDC              /* X > threshold → no continue */
.L_06009BD8:
    bra     .L_06009BFA
    mov.b r11, @r4                    /* continue = 1 (allow continue) */
.L_06009BDC:
    exts.b r13, r2
    bra     .L_06009BFA              /* continue = 0 */
    mov.b r2, @r4
.L_06009BE2:                              /* end state 2: no continue */
    bra     .L_06009BF8
    exts.b r13, r2
.L_06009BE6:                              /* --- continue dispatch --- */
    cmp/eq #0x0, r0
    bt      .L_06009BBE              /* state 0: Z check */
    cmp/eq #0x1, r0
    bt      .L_06009BD0              /* state 1: X check */
    cmp/eq #0x2, r0
    bt      .L_06009BE2              /* state 2: no continue */
    bra     .L_06009BFA
    nop
.L_06009BF6:                              /* controller connected → force continue */
    mov #0x2, r2
.L_06009BF8:
    mov.b r2, @r4
.L_06009BFA:                              /* --- set post-race state --- */
    mov #0x40, r0
    mov.l @r12, r3
    mov.l r13, @(r0, r3)             /* car[+0x40] = 0 (clear state) */
    mov #0x15, r3
    mov.l   .L_game_state, r2
    mov.l r3, @r2                     /* game_state = 0x15 (results screen) */
    mov #0x56, r3
    mov.l   .L_countdown_timer, r2
    mov.l r3, @r2                     /* countdown = 86 frames */
    mov.l   .L_camera_mode, r2
    mov.b r10, @r2                    /* camera_mode = 4 */
    mov.l   .L_state_word, r2
    mov.w r10, @r2                    /* state_word = 4 */
    add #0x4, r15
    lds.l @r15+, pr
    mov.l @r15+, r8
    mov.l @r15+, r9
    mov.l @r15+, r10
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
.L_race_end_state_2:
    .4byte  sym_0607EAD8               /* race end state (dup for reach) */
.L_continue_byte:
    .4byte  sym_06083261               /* continue flag byte (0=no, 1=yes, 2=forced) */
.L_neg_z_threshold:
    .4byte  0xFFB80000                  /* -0x480000: Z position continue threshold */
.L_neg_x_threshold:
    .4byte  0xFEC60000                  /* -0x13A0000: X position continue threshold */
.L_game_state:
    .4byte  sym_0605AD10               /* game phase state */
.L_countdown_timer:
    .4byte  sym_0607EBCC               /* race countdown timer */
.L_camera_mode:
    .4byte  sym_06078654               /* camera mode (byte) */
.L_state_word:
    .4byte  sym_0605A016               /* game state word (16-bit) */
