/* state_race_complete -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06009A60 - 0x06009C48
 * Auto-generated by tools/generate_l3_tu.py
 *
 * End-of-race state handler -- called once per frame after the player crosses
 * the finish line on the final lap.  Orchestrates the transition from active
 * racing into the results / game-over / time-extend flow.
 *
 * Per-frame pipeline:
 *   1. Refresh VDP1 command table and 3-D object list
 *   2. Call post-race frame update (external BSR)
 *   3. Dispatch course-specific handler (course_index + 10)
 *   4. Capture race timing data from the player car struct
 *   5. Optionally set bit 3 in mode_flags (terrain-complete gate)
 *   6. Dispatch on race_end_state (0/1/2) to accumulate result_flags
 *   7. Dispatch again to accumulate mode_flags
 *   8. Call external scoring / ranking routine
 *   9. Determine continue eligibility based on car world position
 *  10. Write post-race state: game_state = 0x15, countdown = 86,
 *      camera_mode = 4, state_word = 4, car[+0x40] = 0
 *
 * Persistent registers:
 *   r8  = car struct pointer (from car_array_base)
 *   r9  = &race_result_byte (sym_06078637)
 *   r10 = 4 (used as bit-OR constant for "state 2" flag)
 *   r11 = 1 (used as bit-OR constant for "state 0" flag)
 *   r12 = &car_array_base pointer variable
 *   r13 = 0 (zero constant, also used as sign-extended 0 for writes)
 *   r14 = &mode_flags (byte, accumulates per-state result bits)
 *
 * Result flag bits (written to result_flags @ sym_0605AB16):
 *   bit 0 = end state 0 complete
 *   bit 1 = end state 1 complete
 *   bit 2 = end state 2 complete
 *
 * Mode flag bits (written to mode_flags @ sym_0605AB17):
 *   bit 0 = end state 0 mode set
 *   bit 1 = end state 1 mode set
 *   bit 2 = end state 2 mode set
 *   bit 3 = terrain-complete (set when terrain mode active, phase > 1,
 *            result == 0, and race not yet finished)
 *
 * Continue eligibility (written to continue_byte @ sym_06083261):
 *   0 = no continue   1 = continue allowed   2 = forced (controller bit 3)
 *   State 0: car Z position >= -0x480000
 *   State 1: car X position >  -0x13A0000
 *   State 2: never allowed
 *
 * Post-race setup:
 *   car[+0x40] = 0, game_state = 0x15 (results screen),
 *   countdown = 86 frames (0x56), camera_mode = 4, state_word = 4
 */

    .section .text.FUN_06009A60


    .global state_race_complete
    .type state_race_complete, @function
state_race_complete:
    mov.l r14, @-r15                         ! save r14 (mode_flags ptr)
    mov.l r13, @-r15                         ! save r13 (zero constant)
    mov.l r12, @-r15                         ! save r12 (car_array_base ptr)
    mov #0x0, r13                            ! r13 = 0 — zero constant for the function
    mov.l r11, @-r15                         ! save r11 (bit-1 constant)
    mov #0x1, r11                            ! r11 = 1 — "state 0" OR mask
    mov.l r10, @-r15                         ! save r10 (bit-2 constant)
    mov #0x4, r10                            ! r10 = 4 — "state 2" OR mask
    mov.l r9, @-r15                          ! save r9 (race result ptr)
    mov.l r8, @-r15                          ! save r8 (car struct ptr)
    sts.l pr, @-r15                          ! save return address
    add #-0x4, r15                           ! allocate 4 bytes of stack scratch
    mov.l   .L_race_result_byte, r9          ! r9 = &race_result_byte
    mov.l   .L_car_array_base, r12           ! r12 = &car_array_base (pointer to pointer)
    mov.l   .L_mode_flags, r14               ! r14 = &mode_flags byte
    mov.l   .L_fn_vdp1_update, r3            ! load vdp1_cmd_update address
    jsr @r3                                  ! vdp1_cmd_update() — refresh VDP1 command list
    mov.l @r12, r8                           ! (delay slot) r8 = *car_array_base = car struct
    mov.l   .L_fn_obj_render, r3             ! load obj_render_update address
    jsr @r3                                  ! obj_render_update() — update 3-D object list
    nop                                      ! (delay slot)
    .byte   0xB2, 0xB7    /* bsr 0x06009FFC (external) — post-race per-frame update */
    nop                                      ! (delay slot)
    mov r13, r6                              ! r6 = 0 — second arg to handler_dispatch
    mov.l   .L_course_index, r5              ! r5 = &course_index byte
    mov.b @r5, r5                            ! r5 = course_index (0/1/2)
    add #0xA, r5                             ! r5 = course_index + 10 — post-race handler ID
    mov.l r5, @r15                           ! [sp+0] = handler ID (scratch save)
    mov.l   .L_fn_handler_dispatch, r3       ! load handler_dispatch address
    jsr @r3                                  ! handler_dispatch(course + 10, 0)
    mov r5, r4                               ! (delay slot) r4 = handler ID
    mov.l @r12, r2                           ! r2 = car struct base
    mov.w   .L_off_car_sound_id, r0          ! r0 = 0x224 — offset to car sound/result field
    mov.l @(r0, r2), r3                      ! r3 = car[+0x224] (sound ID / race result)
    add #0x1C, r0                            ! r0 = 0x240 — offset to best lap time field
    mov.b r3, @r9                            ! race_result_byte = low byte of car[+0x224]
    mov.l @r12, r3                           ! r3 = car struct base (reload)
    mov.l   .L_race_time_store, r1           ! r1 = &race_time_store
    mov.l @(r0, r3), r2                      ! r2 = car[+0x240] (best lap time)
    mov.l r2, @r1                            ! race_time_store = best lap time
    mov.l   .L_prev_lap_time, r3             ! r3 = &prev_lap_time
    mov.l   .L_race_time_copy, r2            ! r2 = &race_time_copy
    mov.l @r3, r3                            ! r3 = prev_lap_time value
    mov.l r3, @r2                            ! race_time_copy = prev_lap_time
    /* --- terrain-complete gate: set mode_flags bit 3 if conditions met --- */
    mov.l   .L_terrain_mode, r0              ! r0 = &terrain_mode flag
    mov.b @r0, r0                            ! r0 = terrain_mode (0 = off)
    tst r0, r0                               ! is terrain mode disabled?
    bt      .L_check_continue_eligible       ! yes → skip bit-3 setting
    mov #0x1, r2                             ! r2 = 1 — comparison threshold
    mov.l   .L_race_phase, r3                ! r3 = &race_phase_a
    mov.l @r3, r3                            ! r3 = race_phase_a value
    cmp/gt r2, r3                            ! is phase > 1?
    bf      .L_check_continue_eligible       ! no (phase <= 1) → skip
    mov.b @r9, r2                            ! r2 = race_result_byte
    tst r2, r2                               ! is result == 0?
    bf      .L_check_continue_eligible       ! no (already have a result) → skip
    mov.l   .L_finish_flag, r0               ! r0 = &finish_flag
    mov.l @r0, r0                            ! r0 = finish_flag value
    tst r0, r0                               ! is race not yet finished?
    bf      .L_check_continue_eligible       ! no (already finished) → skip
    mov.b @r14, r0                           ! r0 = current mode_flags
    or #0x8, r0                              ! set bit 3 (terrain-complete marker)
    exts.b r0, r0                            ! sign-extend byte for clean store
    mov.b r0, @r14                           ! mode_flags |= 0x08
    /* ================================================================== */
    /* Continue eligibility pre-check: must have continue enabled, phase   */
    /* > 1, race not finished, and result < 3.                             */
    /* ================================================================== */
.L_check_continue_eligible:
    mov.l   .L_continue_enabled, r0          ! r0 = &continue_enabled flag
    mov.b @r0, r0                            ! r0 = continue_enabled (0 = off)
    tst r0, r0                               ! is continue disabled?
    bt      .L_scoring_and_continue          ! yes → skip all flag work, go to scoring
    mov #0x1, r2                             ! r2 = 1 — comparison threshold
    mov.l   .L_race_phase_b, r3              ! r3 = &race_phase_b
    mov.l @r3, r3                            ! r3 = race_phase_b value
    cmp/gt r2, r3                            ! is phase > 1?
    bf      .L_scoring_and_continue          ! no → skip
    mov.l   .L_finish_flag, r0               ! r0 = &finish_flag
    mov.l @r0, r0                            ! r0 = finish_flag value
    tst r0, r0                               ! is race not yet finished?
    bf      .L_scoring_and_continue          ! no (already finished) → skip
    mov.b @r9, r3                            ! r3 = race_result_byte
    mov #0x3, r2                             ! r2 = 3 — threshold
    cmp/ge r2, r3                            ! is result >= 3?
    bt      .L_mode_flags_dispatch           ! yes → skip result_flags, go to mode dispatch
    mov.l   .L_result_flags, r4              ! r4 = &result_flags byte
    mov.l   .L_race_end_state, r0            ! r0 = &race_end_state
    bra     .L_result_state_dispatch         ! → dispatch on end state value
    mov.l @r0, r0                            ! (delay slot) r0 = race_end_state (0/1/2)
    /* --- result_flags: state 0 handler — set bit 0 --- */
.L_result_state0_set_bit0:
    mov.b @r4, r2                            ! r2 = current result_flags
    bra     .L_result_sign_extend_store      ! → sign-extend and store
    or r11, r2                               ! (delay slot) r2 |= 1 (bit 0)
.L_off_car_sound_id:
    .2byte  0x0224                           /* car struct offset: sound ID / race result */
    .2byte  0xFFFF                           /* padding to 4-byte alignment */
.L_race_result_byte:
    .4byte  sym_06078637                     /* race result byte */
.L_car_array_base:
    .4byte  sym_0607E944                     /* car array base pointer variable */
.L_mode_flags:
    .4byte  sym_0605AB17                     /* post-race mode flags (byte) */
.L_fn_vdp1_update:
    .4byte  vdp1_cmd_update                  /* VDP1 command table update fn */
.L_fn_obj_render:
    .4byte  obj_render_update                /* object render update fn */
.L_course_index:
    .4byte  sym_06078648                     /* current course index (byte, 0-2) */
.L_fn_handler_dispatch:
    .4byte  handler_dispatch                 /* course-specific handler dispatch fn */
.L_race_time_store:
    .4byte  sym_06078638                     /* race time storage (32-bit) */
.L_prev_lap_time:
    .4byte  sym_060786A4                     /* previous lap time (32-bit) */
.L_race_time_copy:
    .4byte  sym_0607863C                     /* race time copy destination (32-bit) */
.L_terrain_mode:
    .4byte  sym_06083255                     /* terrain rendering mode flag (byte) */
.L_race_phase:
    .4byte  sym_0605AD00                     /* race phase counter A (32-bit) */
.L_finish_flag:
    .4byte  sym_0607EAE0                     /* race finish flag (32-bit, nonzero = done) */
.L_continue_enabled:
    .4byte  sym_06085FF4                     /* continue eligibility flag (byte) */
.L_race_phase_b:
    .4byte  sym_0605AD04                     /* race phase counter B (32-bit) */
.L_result_flags:
    .4byte  sym_0605AB16                     /* result flags byte */
.L_race_end_state:
    .4byte  sym_0607EAD8                     /* race end state (0/1/2 dispatch) */
    /* --- result_flags: state 1 handler — set bit 1 --- */
.L_result_state1_set_bit1:
    mov.b @r4, r0                            ! r0 = current result_flags
    or #0x2, r0                              ! set bit 1
    exts.b r0, r0                            ! sign-extend for clean store
    bra     .L_mode_flags_dispatch           ! → done with result_flags, go to mode dispatch
    mov.b r0, @r4                            ! (delay slot) store updated result_flags
    /* --- result_flags: state 2 handler — set bit 2 --- */
.L_result_state2_set_bit2:
    mov.b @r4, r2                            ! r2 = current result_flags
    or r10, r2                               ! r2 |= 4 (bit 2)
.L_result_sign_extend_store:
    exts.b r2, r2                            ! sign-extend for clean store
    bra     .L_mode_flags_dispatch           ! → done with result_flags
    mov.b r2, @r4                            ! (delay slot) store updated result_flags
    /* --- result_flags end-state dispatch table --- */
.L_result_state_dispatch:
    cmp/eq #0x0, r0                          ! is end state == 0?
    bt      .L_result_state0_set_bit0        ! yes → set bit 0
    cmp/eq #0x1, r0                          ! is end state == 1?
    bt      .L_result_state1_set_bit1        ! yes → set bit 1
    cmp/eq #0x2, r0                          ! is end state == 2?
    bt      .L_result_state2_set_bit2        ! yes → set bit 2
    /* (fall through for unknown state — no flags set) */
    /* ================================================================== */
    /* mode_flags dispatch: if race_result == 0, set the corresponding    */
    /* mode bit (0/1/2) based on race_end_state.                          */
    /* ================================================================== */
.L_mode_flags_dispatch:
    mov.b @r9, r2                            ! r2 = race_result_byte
    tst r2, r2                               ! is result == 0?
    bf      .L_scoring_and_continue          ! no → skip mode flag setting
    mov.l   .L_race_end_state_2, r0          ! r0 = &race_end_state (second pool copy)
    bra     .L_mode_state_dispatch           ! → dispatch on end state
    mov.l @r0, r0                            ! (delay slot) r0 = race_end_state value
    /* --- mode_flags: state 0 — set bit 0 --- */
.L_mode_state0_set_bit0:
    mov.b @r14, r2                           ! r2 = current mode_flags
    bra     .L_mode_sign_extend_store        ! → sign-extend and store
    or r11, r2                               ! (delay slot) r2 |= 1 (bit 0)
    /* --- mode_flags: state 1 — set bit 1 --- */
.L_mode_state1_set_bit1:
    mov.b @r14, r0                           ! r0 = current mode_flags
    or #0x2, r0                              ! set bit 1
    exts.b r0, r0                            ! sign-extend for clean store
    bra     .L_scoring_and_continue          ! → done, go to scoring
    mov.b r0, @r14                           ! (delay slot) store updated mode_flags
    /* --- mode_flags: state 2 — set bit 2 --- */
.L_mode_state2_set_bit2:
    mov.b @r14, r2                           ! r2 = current mode_flags
    or r10, r2                               ! r2 |= 4 (bit 2)
.L_mode_sign_extend_store:
    exts.b r2, r2                            ! sign-extend for clean store
    bra     .L_scoring_and_continue          ! → done
    mov.b r2, @r14                           ! (delay slot) store updated mode_flags
    /* --- mode_flags end-state dispatch table --- */
.L_mode_state_dispatch:
    cmp/eq #0x0, r0                          ! is end state == 0?
    bt      .L_mode_state0_set_bit0          ! yes → set mode bit 0
    cmp/eq #0x1, r0                          ! is end state == 1?
    bt      .L_mode_state1_set_bit1          ! yes → set mode bit 1
    cmp/eq #0x2, r0                          ! is end state == 2?
    bt      .L_mode_state2_set_bit2          ! yes → set mode bit 2
    /* (fall through for unknown state — no mode bits set) */
    /* ================================================================== */
    /* Scoring call + continue position check.  Determines whether the    */
    /* player earns a continue credit based on car world position.        */
    /* ================================================================== */
.L_scoring_and_continue:
    .byte   0xB3, 0x05    /* bsr 0x0600A1B8 (external) — scoring / ranking calculation */
    nop                                      ! (delay slot)
    mov r8, r0                               ! r0 = car struct base
    mov.l   .L_continue_byte, r4             ! r4 = &continue_byte (0/1/2)
    mov.b @(3, r0), r0                       ! r0 = car[+3] (controller / input flags)
    tst #0x8, r0                             ! test bit 3 — controller connected?
    bf      .L_force_continue                ! bit set → force continue = 2
    mov.l   .L_race_end_state_2, r0          ! r0 = &race_end_state
    bra     .L_continue_state_dispatch       ! → dispatch position check by end state
    mov.l @r0, r0                            ! (delay slot) r0 = race_end_state value
    /* --- continue: state 0 — check Z position threshold --- */
.L_continue_check_z:
    mov.l @(24, r8), r2                      ! r2 = car[+24] = Z world position (fixed-point)
    mov.l   .L_neg_z_threshold, r3           ! r3 = 0xFFB80000 = -0x480000
    cmp/ge r3, r2                            ! is Z >= -0x480000?
    bf      .L_continue_deny_z               ! no → deny continue
    bra     .L_continue_allow                ! yes → allow continue
    nop                                      ! (delay slot)
.L_continue_deny_z:
    exts.b r13, r2                           ! r2 = 0 (sign-extended zero)
    bra     .L_set_postrace_state            ! → write continue = 0, set up results
    mov.b r2, @r4                            ! (delay slot) continue_byte = 0
    /* --- continue: state 1 — check X position threshold --- */
.L_continue_check_x:
    mov.l @(16, r8), r2                      ! r2 = car[+16] = X world position (fixed-point)
    mov.l   .L_neg_x_threshold, r3           ! r3 = 0xFEC60000 = -0x13A0000
    cmp/gt r3, r2                            ! is X > -0x13A0000?
    bt      .L_continue_deny_x              ! yes (further along track) → deny continue
.L_continue_allow:
    bra     .L_set_postrace_state            ! → write continue = 1
    mov.b r11, @r4                           ! (delay slot) continue_byte = 1
.L_continue_deny_x:
    exts.b r13, r2                           ! r2 = 0 (sign-extended zero)
    bra     .L_set_postrace_state            ! → write continue = 0
    mov.b r2, @r4                            ! (delay slot) continue_byte = 0
    /* --- continue: state 2 — never allowed --- */
.L_continue_deny_state2:
    bra     .L_write_continue_and_setup      ! → write r2 to continue_byte
    exts.b r13, r2                           ! (delay slot) r2 = 0
    /* --- continue end-state dispatch table --- */
.L_continue_state_dispatch:
    cmp/eq #0x0, r0                          ! is end state == 0?
    bt      .L_continue_check_z              ! yes → Z position check
    cmp/eq #0x1, r0                          ! is end state == 1?
    bt      .L_continue_check_x              ! yes → X position check
    cmp/eq #0x2, r0                          ! is end state == 2?
    bt      .L_continue_deny_state2          ! yes → no continue
    bra     .L_set_postrace_state            ! unknown state → fall through
    nop                                      ! (delay slot)
    /* --- controller connected: force continue = 2 --- */
.L_force_continue:
    mov #0x2, r2                             ! r2 = 2 (forced continue)
.L_write_continue_and_setup:
    mov.b r2, @r4                            ! continue_byte = r2
    /* ================================================================== */
    /* Post-race state setup: write game state, countdown, camera mode.   */
    /* ================================================================== */
.L_set_postrace_state:
    mov #0x40, r0                            ! r0 = 0x40 — car struct state offset
    mov.l @r12, r3                           ! r3 = car struct base
    mov.l r13, @(r0, r3)                     ! car[+0x40] = 0 — clear car state field
    mov #0x15, r3                            ! r3 = 0x15 — results screen state ID
    mov.l   .L_game_state, r2                ! r2 = &game_state
    mov.l r3, @r2                            ! game_state = 0x15 (transition to results)
    mov #0x56, r3                            ! r3 = 86 — countdown frames
    mov.l   .L_countdown_timer, r2           ! r2 = &countdown_timer
    mov.l r3, @r2                            ! countdown_timer = 86 frames (~1.4 sec @ 60fps)
    mov.l   .L_camera_mode, r2              ! r2 = &camera_mode byte
    mov.b r10, @r2                           ! camera_mode = 4 (post-race camera)
    mov.l   .L_state_word, r2               ! r2 = &state_word (16-bit)
    mov.w r10, @r2                           ! state_word = 4
    /* --- epilogue: deallocate stack and restore registers --- */
    add #0x4, r15                            ! free 4 bytes of stack scratch
    lds.l @r15+, pr                          ! restore return address
    mov.l @r15+, r8                          ! restore r8
    mov.l @r15+, r9                          ! restore r9
    mov.l @r15+, r10                         ! restore r10
    mov.l @r15+, r11                         ! restore r11
    mov.l @r15+, r12                         ! restore r12
    mov.l @r15+, r13                         ! restore r13
    rts                                      ! return to caller
    mov.l @r15+, r14                         ! (delay slot) restore r14
.L_race_end_state_2:
    .4byte  sym_0607EAD8                     /* race end state — second pool entry for reach */
.L_continue_byte:
    .4byte  sym_06083261                     /* continue flag byte (0=no, 1=yes, 2=forced) */
.L_neg_z_threshold:
    .4byte  0xFFB80000                       /* -0x480000: Z position continue threshold */
.L_neg_x_threshold:
    .4byte  0xFEC60000                       /* -0x13A0000: X position continue threshold */
.L_game_state:
    .4byte  g_game_state                     /* game phase state (32-bit) */
.L_countdown_timer:
    .4byte  sym_0607EBCC                     /* race countdown timer (32-bit) */
.L_camera_mode:
    .4byte  sym_06078654                     /* camera mode (byte) */
.L_state_word:
    .4byte  sym_0605A016                     /* game state word (16-bit) */
