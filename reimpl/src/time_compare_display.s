/* time_compare_display -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06015B48 - 0x06015C5E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * time_compare_display(car_index):
 *   Animates 8 time-comparison HUD element slots toward their target
 *   positions. For slots 0..6, the animation counter (offset 0x30) is
 *   incremented by 0x0C00 each frame; once it reaches >= 0 it is clamped
 *   to zero and the slot is marked complete. Slot 7 is the reverse:
 *   its counter is decremented by 0x0C00 and clamped when it reaches <= 0.
 *   After processing each slot, track_vtx_builder is called to rebuild
 *   the vertex data.  When all 8 slots finish, the function tail-calls
 *   sym_060172E4 (HUD element finalizer) to advance the display state.
 *
 * Slot struct layout (68 bytes per slot, stride = idx*4 + idx*64):
 *   +0x00  ... general fields ...
 *   +0x02  display_type (byte) -- indexes into fn_ptr_table
 *   +0x30  animation counter (32-bit signed, field at disp 48)
 *   +0x40  secondary flag (byte)
 *
 * Persistent registers:
 *   r8  = total slot count (8)
 *   r9  = boundary index (7) — separates add/subtract behavior
 *   r10 = completed slot counter
 *   r11 = animation step value (0x0C00)
 *   r12 = zero constant
 *   r13 = slot data array base (sym_06084FC8)
 *   r14 = loop counter (current slot index, 0..7)
 *
 * loc_06015C30(car_index):
 *   Dispatches to a per-slot display handler based on the display-type
 *   byte (offset +2) of the slot struct for car_index. Reads the type
 *   field, indexes into the function pointer table at sym_0605B8B0
 *   (which contains best_lap_display and time_compare_display), and
 *   jumps to the selected handler with car_index in r4.
 */

    .section .text.FUN_06015B48


    .global time_compare_display
    .type time_compare_display, @function
time_compare_display:
    mov.l r14, @-r15                      ! save r14 (loop counter)
    mov.l r13, @-r15                      ! save r13 (slot array base)
    mov.l r12, @-r15                      ! save r12 (zero constant)
    mov.l r11, @-r15                      ! save r11 (anim step)
    mov.l r10, @-r15                      ! save r10 (completed counter)
    mov.l r9, @-r15                       ! save r9 (boundary index)
    mov.l r8, @-r15                       ! save r8 (total slots)
    sts.l pr, @-r15                       ! save return address
    add #-0x4, r15                        ! allocate 4 bytes on stack for car_index
    mov #0x8, r8                          ! r8 = 8 (total number of slots)
    mov #0x7, r9                          ! r9 = 7 (boundary: slots 0-6 add, slot 7 subtracts)
    mov.w   .L_wpool_anim_step, r11        ! r11 = 0x0C00 (animation step per frame)
    mov #0x0, r12                         ! r12 = 0 (zero constant for clamping)
    mov.l   .L_pool_slot_data_base, r13   ! r13 = slot data array base (sym_06084FC8)
    mov.b r4, @r15                        ! store car_index on stack
    extu.b r12, r10                       ! r10 = 0 (completed slot counter)
    extu.b r12, r14                       ! r14 = 0 (loop counter / current slot index)
.L_slot_loop:
    extu.b r14, r3                        ! r3 = current slot index (unsigned byte)
    cmp/ge r9, r3                         ! is slot_index >= 7?
    bt      .L_last_slot                  ! if so, handle slot 7 (subtract path)
    extu.b r14, r4                        ! r4 = slot_index
    mov r4, r3                            ! r3 = slot_index (for *64 calc)
    shll2 r4                              ! r4 = slot_index * 4
    shll2 r3                              ! r3 = slot_index * 4
    shll2 r3                              ! r3 = slot_index * 16
    shll2 r3                              ! r3 = slot_index * 64
    add r3, r4                            ! r4 = slot_index * 68 (struct stride)
    exts.w r4, r4                         ! sign-extend to 32-bit offset
    add r13, r4                           ! r4 = &slot[slot_index] (struct base)
    mov.l @(48, r4), r2                   ! r2 = slot[i].anim_counter (offset 0x30)
    add r11, r2                           ! r2 += 0x0C00 (step toward zero from negative)
    mov.l r2, @(48, r4)                   ! write back updated counter
    mov r2, r3                            ! r3 = updated counter
    cmp/pz r3                             ! has counter reached >= 0?
    bf      .L_call_vtx_builder           ! if still negative, skip clamping
    extu.b r14, r3                        ! r3 = slot_index (recompute struct addr)
    mov r3, r2                            ! r2 = slot_index (for *64 calc)
    shll2 r3                              ! r3 = slot_index * 4
    shll2 r2                              ! r2 = slot_index * 4
    shll2 r2                              ! r2 = slot_index * 16
    shll2 r2                              ! r2 = slot_index * 64
    add r2, r3                            ! r3 = slot_index * 68
    exts.w r3, r3                         ! sign-extend offset
    add r13, r3                           ! r3 = &slot[slot_index]
    mov.l r12, @(48, r3)                  ! clamp anim_counter to 0 (animation done)
    bra     .L_call_vtx_builder           ! continue to vertex rebuild
    add #0x1, r10                         ! (delay slot) increment completed count
.L_last_slot:
    extu.b r14, r0                        ! r0 = slot_index
    cmp/eq #0x7, r0                       ! is this exactly slot 7?
    bf      .L_call_vtx_builder           ! if not (shouldn't happen), skip
    extu.b r14, r4                        ! r4 = slot_index (= 7)
    mov r4, r3                            ! r3 = slot_index (for *64 calc)
    shll2 r4                              ! r4 = 7 * 4 = 28
    shll2 r3                              ! r3 = 7 * 4 = 28
    shll2 r3                              ! r3 = 7 * 16 = 112
    shll2 r3                              ! r3 = 7 * 64 = 448
    add r3, r4                            ! r4 = 7 * 68 = 476
    exts.w r4, r4                         ! sign-extend offset
    add r13, r4                           ! r4 = &slot[7]
    mov.l @(48, r4), r2                   ! r2 = slot[7].anim_counter
    sub r11, r2                           ! r2 -= 0x0C00 (step toward zero from positive)
    mov.l r2, @(48, r4)                   ! write back updated counter
    mov r2, r3                            ! r3 = updated counter
    cmp/pl r3                             ! is counter still > 0?
    bt      .L_call_vtx_builder           ! if positive, animation still running
    extu.b r14, r3                        ! r3 = slot_index (recompute struct addr)
    mov r3, r2                            ! r2 = slot_index (for *64 calc)
    shll2 r3                              ! r3 = slot_index * 4
    shll2 r2                              ! r2 = slot_index * 4
    shll2 r2                              ! r2 = slot_index * 16
    shll2 r2                              ! r2 = slot_index * 64
    add r2, r3                            ! r3 = slot_index * 68
    exts.w r3, r3                         ! sign-extend offset
    add r13, r3                           ! r3 = &slot[slot_index]
    mov.l r12, @(48, r3)                  ! clamp anim_counter to 0 (animation done)
    add #0x1, r10                         ! increment completed count
.L_call_vtx_builder:
    mov.l   .L_pool_track_vtx_builder, r3 ! r3 = &track_vtx_builder
    jsr @r3                               ! call track_vtx_builder(slot_index)
    extu.b r14, r4                        ! (delay slot) r4 = slot_index arg
    add #0x1, r14                         ! advance to next slot
    extu.b r14, r2                        ! r2 = next slot index (unsigned)
    cmp/ge r8, r2                         ! have we processed all 8 slots?
    bf      .L_slot_loop                  ! if not, loop back
    extu.b r10, r0                        ! r0 = completed count
    cmp/eq #0x8, r0                       ! did all 8 slots complete?
    bf      .L_return_normal              ! if not, return normally (animation ongoing)
    mov.b @r15, r4                        ! r4 = car_index (reload from stack)
    extu.b r4, r4                         ! zero-extend car_index
    add #0x4, r15                         ! free stack local
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r8                       ! restore r8
    mov.l @r15+, r9                       ! restore r9
    mov.l @r15+, r10                      ! restore r10
    mov.l @r15+, r11                      ! restore r11
    mov.l @r15+, r12                      ! restore r12
    mov.l @r15+, r13                      ! restore r13
    mov.l   .L_pool_hud_finalizer, r3     ! r3 = &sym_060172E4 (HUD element finalizer)
    jmp @r3                               ! tail-call finalizer(car_index)
    mov.l @r15+, r14                      ! (delay slot) restore r14
.L_return_normal:
    add #0x4, r15                         ! free stack local
    lds.l @r15+, pr                       ! restore return address
    mov.l @r15+, r8                       ! restore r8
    mov.l @r15+, r9                       ! restore r9
    mov.l @r15+, r10                      ! restore r10
    mov.l @r15+, r11                      ! restore r11
    mov.l @r15+, r12                      ! restore r12
    mov.l @r15+, r13                      ! restore r13
    rts                                   ! return (animation still in progress)
    mov.l @r15+, r14                      ! (delay slot) restore r14
.L_wpool_anim_step:
    .2byte  0x0C00
.L_pool_slot_data_base:
    .4byte  sym_06084FC8         /* [HIGH] slot data array base — 68-byte structs */
.L_pool_track_vtx_builder:
    .4byte  track_vtx_builder    /* [HIGH] rebuild vertex data for slot */
.L_pool_hud_finalizer:
    .4byte  sym_060172E4         /* [HIGH] clear VDP2 registers / HUD element finalizer */

    .global loc_06015C30
loc_06015C30:
/* loc_06015C30(car_index):
 *   Display-type dispatcher — reads the display-type field (byte at
 *   offset +2) from the slot struct for car_index, uses it as an index
 *   into the function pointer table at sym_0605B8B0, and jumps to the
 *   selected handler. The table contains:
 *     [0] = best_lap_display
 *     [1] = time_compare_display
 */
    add #-0x4, r15                        ! allocate 4 bytes on stack
    mov.b r4, @r15                        ! store car_index on stack
    mov.b @r15, r3                        ! r3 = car_index (reload, sign-extended)
    extu.b r3, r3                         ! r3 = car_index (unsigned)
    mov r3, r2                            ! r2 = car_index (for *64 calc)
    shll2 r3                              ! r3 = car_index * 4
    shll2 r2                              ! r2 = car_index * 4
    shll2 r2                              ! r2 = car_index * 16
    shll2 r2                              ! r2 = car_index * 64
    add r2, r3                            ! r3 = car_index * 68 (struct stride)
    exts.w r3, r3                         ! sign-extend offset
    .byte   0xD1, 0x16    /* mov.l .L_pool_slot_data_base, r1 */  ! r1 = slot data array base
    add r1, r3                            ! r3 = &slot[car_index]
    mov.b @(2, r3), r0                    ! r0 = slot[car_index].display_type (byte +2)
    mov r0, r3                            ! r3 = display_type
    extu.b r3, r3                         ! r3 = display_type (unsigned)
    shll2 r3                              ! r3 = display_type * 4 (pointer table index)
    .byte   0xD2, 0x14    /* mov.l .L_pool_fn_ptr_table, r2 */  ! r2 = &fn_ptr_table (sym_0605B8B0)
    add r2, r3                            ! r3 = &fn_ptr_table[display_type]
    mov.l @r3, r3                         ! r3 = handler function address
    mov.b @r15, r4                        ! r4 = car_index (reload from stack)
    jmp @r3                               ! jump to selected handler(car_index)
    add #0x4, r15                         ! (delay slot) free stack local
