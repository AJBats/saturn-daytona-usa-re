/* render_pass_secondary -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602A840 - 0x0602ABC4
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Secondary render pass: depth-sorts objects for VDP1 sprite output.
 *
 * Called with:
 *   r4 = object array base (24-byte entries)
 *   r5 = vertex data pointer
 *   r6 = transform matrix pointer
 *   r7 = object count
 *
 * For each object (iterated in reverse):
 *   1. Invalidates the depth cache (64 entries x 16 bytes, filled with -1)
 *   2. Checks render-enable flag; skips disabled objects
 *   3. Computes camera-space Z via 3x3 matrix-vector dot products
 *   4. Performs backface culling (skip if Z dot product <= 0)
 *   5. Fetches cached vertex transforms or computes fresh ones
 *   6. Tests all 4 vertex Z-values against near/far clip planes
 *   7. Tests X-values against left/right clip planes
 *   8. Selects a depth-mode function via jump table (average, min, max, fixed)
 *   9. Writes a 16-bit sort key into the sort index table
 *
 * Data tables (local):
 *   sym_0602AB68 = z-value scratch buffer (4 vertices x 2 words = 32 bytes)
 *   sym_0602AB88 = dot product result vector (3 words)
 *   sym_0602AB98 = transform result buffer (3 words)
 *   sym_0602ABA4 = depth-mode jump table (5 entries)
 */

    .section .text.FUN_0602A840


    .global render_pass_secondary
    .type render_pass_secondary, @function
render_pass_secondary:
    mov.l r14, @-r15                    ! save callee-saved regs
    sts.l pr, @-r15
    mov r4, r8                          ! r8 = obj_array base
    mov r5, r14                         ! r14 = vertex_data ptr
    mov r6, r13                         ! r13 = palette/color index
    mov.l   .L_depth_cache_base, r12    ! r12 → depth cache (64 x 16B)
    mov #0x40, r4                       ! 64 entries to clear
    mov #-0x1, r0                       ! fill value = 0xFFFFFFFF (invalid)
.L_cache_invalidate_loop:
    mov.l r0, @r12                      ! cache[i].tag = -1
    dt r4
    bf/s    .L_cache_invalidate_loop
    add #0x10, r12                      ! stride = 16 bytes per entry
    mov.l   .L_render_state_ptr, r10
    mov.l @r10, r10                     ! r10 = render state (depth threshold)
    mov #0x18, r0                       ! 24 bytes per object entry
    mul.l r7, r0                        ! total = count * 24
    sts macl, r0
    add r0, r8                          ! r8 → past end (iterate in reverse)
.L_obj_loop_top:
    mov.l r7, @-r15                     ! push remaining count
    add #-0x18, r8                      ! r8 → previous obj (reverse iteration)
    mov.l   .L_render_enable_flag, r12
    mov.w @r12, r0                      ! r0 = render enable flag
    cmp/eq #0x0, r0                     ! 0 = all objects enabled
    bt      .L_obj_visible
    mov.w @(14, r8), r0                 ! r0 = obj.type_id (offset +14)
    mov.w   .L_skip_obj_type_id, r1    ! r1 = 0x97 (type to skip)
    cmp/eq r0, r1
    bf      .L_obj_visible              ! not the skip type → process it
    bra     .L_next_obj                 ! skip this object
    nop
.L_skip_obj_type_id:
    .2byte  0x0097
    .2byte  0x0000
.L_depth_cache_base:
    .4byte  sym_0608A820                ! → depth cache (64 entries x 16B)
.L_render_state_ptr:
    .4byte  sym_06063F08                ! → render state ptr (deref for threshold)
.L_render_enable_flag:
    .4byte  sym_0605BE36                ! → render enable flag (0 = all enabled)
.L_obj_visible:
    mov.l   .L_zval_scratch_buf, r11    ! r11 → z-value scratch (output buf)
    mov.l   .L_dot_result_vec, r5       ! r5 → dot product result vec
    mov.l   .L_matrix_stack_ptr, r0
    mov.l @r0, r6                       ! r6 = current transform matrix
    mov.w @(16, r8), r0                 ! r0 = obj.vertex_index_0 (offset +16)
    mov r0, r9
    bsr     .L_compute_dot_products     ! compute camera-space coords for vtx 0
    nop
    mov.l r1, @r5                       ! store dot_x
    mov.l r2, @(4, r5)                  ! store dot_y
    mov.l r3, @(8, r5)                  ! store dot_z
    mov.w @(12, r8), r0                 ! r0 = obj.flags (offset +12)
    tst #0x8, r0                        ! bit 3 = backface cull enable
    bf      .L_backface_passed          ! bit set → skip backface test
    mov.l   .L_xform_result_buf, r7     ! r7 → transform result buf
    mov r8, r4                          ! r4 = obj position (3 words)
    ! --- 3x3 matrix * obj_pos dot product (row 0) ---
    clrmac
    mac.l @r4+, @r6+                   ! sum += pos[i] * mat[0][i]
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    add #-0xC, r4                       ! rewind pos ptr
    sts mach, r0
    sts macl, r9
    clrmac
    mac.l @r4+, @r6+                   ! row 1 dot product
    xtrct r0, r9                        ! r9 = 16.16 fixed result row 0
    mov.l r9, @r7                       ! xform[0] = row 0 result
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    add #-0xC, r4                       ! rewind pos ptr
    sts mach, r0
    sts macl, r9
    clrmac
    mac.l @r4+, @r6+                   ! row 2 dot product
    xtrct r0, r9                        ! r9 = row 1 result
    mov.l r9, @(4, r7)                  ! xform[1] = row 1 result
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    add #-0x24, r6                      ! rewind matrix ptr (9 words = 0x24)
    sts mach, r0
    sts macl, r9
    xtrct r0, r9
    mov.l r9, @(8, r7)                  ! xform[2] = row 2 result
    ! --- backface test: dot(normal, xform) ---
    clrmac
    mac.l @r5+, @r7+                   ! sum += dot_vec[i] * xform[i]
    mac.l @r5+, @r7+
    mac.l @r5+, @r7+
    add #-0xC, r5                       ! rewind dot_vec ptr
    sts mach, r9
    sts macl, r0
    xtrct r9, r0                        ! r0 = backface dot product (16.16)
    cmp/pl r0                           ! facing camera if > 0
    bt      .L_backface_passed
    bra     .L_next_obj                 ! backface → skip
    nop
    .2byte  0x0000
.L_zval_scratch_buf:
    .4byte  sym_0602AB68                ! → z-scratch (4 verts x Z,X)
.L_dot_result_vec:
    .4byte  sym_0602AB88                ! → dot product result vec (3 words)
.L_matrix_stack_ptr:
    .4byte  sym_06089EDC                ! → matrix stack A ptr (current xform)
.L_xform_result_buf:
    .4byte  sym_0602AB98                ! → transform result buf (3 words)
.L_backface_passed:
    ! --- Process vertex 0 ---
    mov.w @(16, r8), r0                 ! r0 = vtx_index_0 (offset +16)
    mov.l   .L_fn_process_vtx_1, r7    ! r7 = continuation for vtx 1
    bsr     .L_fetch_cached_vtx         ! try cache; on hit, jmp @r7
    mov r0, r9                          ! r9 = vtx index (delay slot)
    mov.l r3, @r5                       ! store z-component
    bsr     .L_clip_and_cache_vtx       ! clip test + write cache entry
    add #0x4, r5                        ! advance result ptr

    .global sym_0602A91A
sym_0602A91A:
    ! --- Process vertex 1 ---
    mov.w @(18, r8), r0                 ! r0 = vtx_index_1 (offset +18)
    mov.l   .L_fn_process_vtx_2, r7    ! r7 = continuation for vtx 2
    bsr     .L_fetch_cached_vtx
    mov r0, r9
    bsr     .L_compute_dot_products     ! cache miss → recompute
    nop
    mov.l r3, @r5
    bsr     .L_clip_and_cache_vtx
    add #0x4, r5

    .global sym_0602A92C
sym_0602A92C:
    ! --- Process vertex 2 ---
    mov.w @(20, r8), r0                 ! r0 = vtx_index_2 (offset +20)
    mov.l   .L_fn_process_vtx_3, r7
    bsr     .L_fetch_cached_vtx
    mov r0, r9
    bsr     .L_compute_dot_products
    nop
    mov.l r3, @r5
    bsr     .L_clip_and_cache_vtx
    add #0x4, r5

    .global sym_0602A93E
sym_0602A93E:
    ! --- Process vertex 3 ---
    mov.w @(22, r8), r0                 ! r0 = vtx_index_3 (offset +22)
    mov.l   .L_fn_process_vtx_4, r7
    bsr     .L_fetch_cached_vtx
    mov r0, r9
    bsr     .L_compute_dot_products
    nop
    mov.l r3, @r5
    bsr     .L_clip_and_cache_vtx
    add #0x4, r5

    .global sym_0602A950
sym_0602A950:
    ! --- All 4 vertices processed; build sprite entry ---
    mov.l   .L_sprite_count_ptr, r0
    mov #0x18, r1                       ! 24 bytes per sprite entry
    mov.l @r0, r0                       ! r0 = current sprite count
    mulu.w r0, r1                       ! offset = count * 24
    mov.l   .L_sprite_table_base, r2
    sts macl, r9
    add r2, r9                          ! r9 → sprite entry in table
    add #-0x20, r11                     ! r11 → start of z-scratch (4 pairs)
    mov.w   DAT_0602a97e, r12           ! r12 = 0xFF50 = near clip plane Z
    mov.l @(0, r11), r0                 ! r0 = vtx0.z
    mov.l @(8, r11), r2                 ! r2 = vtx1.z
    mov.l @(16, r11), r4                ! r4 = vtx2.z
    mov.l @(24, r11), r6                ! r6 = vtx3.z
    ! --- Near-plane clip: all 4 verts must be closer than near clip ---
    cmp/gt r0, r12                      ! near > vtx0.z?
    bf      .L_check_far_clip
    cmp/gt r2, r12
    bf      .L_check_far_clip
    cmp/gt r4, r12
    bf      .L_check_far_clip
    cmp/gt r6, r12
    bf      .L_check_far_clip
    bra     .L_next_obj                 ! all behind near plane → cull
    nop

    .global DAT_0602a97e
DAT_0602a97e:
    .2byte  0xFF50                      ! near clip plane Z (-176)
.L_fn_process_vtx_1:
    .4byte  sym_0602A91A                ! → vtx 1 handler entry
.L_fn_process_vtx_2:
    .4byte  sym_0602A92C                ! → vtx 2 handler entry
.L_fn_process_vtx_3:
    .4byte  sym_0602A93E                ! → vtx 3 handler entry
.L_fn_process_vtx_4:
    .4byte  sym_0602A950                ! → all-verts-done entry
.L_sprite_count_ptr:
    .4byte  sym_060620D0                ! → sprite count / write index
.L_sprite_table_base:
    .4byte  sym_0608AC20                ! → sprite data table (24B entries)
.L_check_far_clip:
    ! --- Far-plane clip: if ANY vert in front of far plane, keep ---
    mov.w   DAT_0602aa12, r12           ! r12 = 0x00B0 = far clip plane Z
    cmp/gt r0, r12                      ! far > vtx0.z? → vtx in range
    bt      .L_check_x_left_clip
    cmp/gt r2, r12
    bt      .L_check_x_left_clip
    cmp/gt r4, r12
    bt      .L_check_x_left_clip
    cmp/gt r6, r12
    bt      .L_next_obj                 ! all beyond far plane → cull
.L_check_x_left_clip:
    ! --- Left X clip: if all verts left of screen, cull ---
    mov.w   DAT_0602aa14, r12           ! r12 = 0xFF81 = left clip X (-127)
    mov.l @(4, r11), r1                 ! r1 = vtx0.x
    mov.l @(12, r11), r3                ! r3 = vtx1.x
    mov.l @(20, r11), r5                ! r5 = vtx2.x
    mov.l @(28, r11), r7                ! r7 = vtx3.x
    cmp/gt r1, r12                      ! left > vtx0.x? → all off-screen
    bf      .L_check_x_right_clip
    cmp/gt r3, r12
    bf      .L_check_x_right_clip
    cmp/gt r5, r12
    bf      .L_check_x_right_clip
    cmp/gt r7, r12
    bt      .L_next_obj                 ! all left of screen → cull
.L_check_x_right_clip:
    ! --- Right X clip: if ANY vert right of left edge, keep ---
    mov.w   DAT_0602aa16, r12           ! r12 = 0x0051 = right clip X (81)
    cmp/gt r1, r12                      ! right > vtx0.x? → on screen
    bt      .L_write_sprite_entry
    cmp/gt r3, r12
    bt      .L_write_sprite_entry
    cmp/gt r5, r12
    bt      .L_write_sprite_entry
    cmp/gt r7, r12
    bf      .L_next_obj                 ! all right of screen → cull
.L_write_sprite_entry:
    ! --- Store 8 clip coords (4 verts x Z,X) into sprite entry ---
    mov r9, r12
    add #0x18, r12                      ! r12 → end of 24-byte sprite entry
    mov.w r7, @-r12                     ! store vtx3.x (as 16-bit)
    mov.w r6, @-r12                     ! store vtx3.z
    mov.w r5, @-r12                     ! store vtx2.x
    mov.w r4, @-r12                     ! store vtx2.z
    mov.w r3, @-r12                     ! store vtx1.x
    mov.w r2, @-r12                     ! store vtx1.z
    mov.w r1, @-r12                     ! store vtx0.x
    mov.w r0, @-r12                     ! store vtx0.z
    mov.w @(14, r8), r0                 ! obj.type_id → sprite.type_id
    mov.w r0, @(6, r9)
    mov.w @(12, r8), r0                 ! r0 = obj.flags
    shlr2 r0                            ! >> 4: extract render priority
    shlr2 r0
    and #0xF, r0
    mov.b r0, @(4, r9)                  ! sprite.priority = flags[7:4]
    mov r13, r0
    mov.b r0, @(5, r9)                  ! sprite.color_index = r13
    mov.w @(12, r8), r0                 ! r0 = obj.flags (again)
    mov.l   .L_depth_mode_table, r1    ! r1 → depth mode jump table
    and #0x7, r0                        ! depth mode = flags[2:0]
    shll2 r0                            ! index * 4
    mov.l @(r0, r1), r2                ! r2 = jump target for depth mode
    .word 0xC760 /* mova @(0x180,PC),r0 → sym_0602AB80 (z-scratch mid) */
    mov.l @r0, r3                       ! r3 = vtx0.z from z-scratch
    mov.l @(4, r0), r4                  ! r4 = vtx1.z
    mov.l @(8, r0), r5                  ! r5 = vtx2.z
    jmp @r2                             ! dispatch to depth mode handler
    mov.l @(12, r0), r6                 ! r6 = vtx3.z (delay slot)

    .global DAT_0602aa12
DAT_0602aa12:
    .2byte  0x00B0                      ! far clip plane Z threshold (176)

    .global DAT_0602aa14
DAT_0602aa14:
    .2byte  0xFF81                      ! left clip X threshold (-127)

    .global DAT_0602aa16
DAT_0602aa16:
    .2byte  0x0051                      ! right clip X threshold (81)
.L_depth_mode_table:
    .4byte  sym_0602ABA4                ! → depth mode jump table (5 entries)

    ! === Depth mode 0: Average of 4 vertex Z-values ===
    .global loc_0602AA1C
loc_0602AA1C:
    add r4, r3                          ! r3 = z0 + z1
    add r5, r6                          ! r6 = z2 + z3
    add r6, r3                          ! r3 = z0 + z1 + z2 + z3
    bra     .L_write_sort_key
    shlr2 r3                            ! r3 = average = sum / 4

    ! === Depth mode 1: Minimum (closest) Z ===
    .global loc_0602AA26
loc_0602AA26:
    cmp/ge r3, r4                       ! if z1 < z0, use z1
    bt      .L_min_check_v2
    mov r4, r3
.L_min_check_v2:
    cmp/ge r3, r5                       ! if z2 < current min
    bt      .L_min_check_v3
    mov r5, r3
.L_min_check_v3:
    cmp/ge r3, r6                       ! if z3 < current min
    bt      .L_min_check_v4
    mov r6, r3
.L_min_check_v4:
    bra     .L_write_sort_key
    nop

    ! === Depth mode 2: Maximum (farthest) Z, no bias ===
    .global loc_0602AA3C
loc_0602AA3C:
    bra     .L_find_max_depth
    mov #0x0, r0                        ! bias = 0

    ! === Depth mode 3: Maximum Z + 0x10000 bias ===
    .global loc_0602AA40
loc_0602AA40:
    mov #0x1, r0
    bra     .L_find_max_depth
    shll16 r0                           ! bias = 0x10000

    ! === Depth mode 4: Maximum Z + large fixed bias ===
    .global loc_0602AA46
loc_0602AA46:
    mov.l   .L_fixed_depth_bias, r0    ! bias = 0x000B8000 (753664)
.L_find_max_depth:
    cmp/gt r3, r4                       ! if z1 > z0, use z1
    bf      .L_max_check_v2
    mov r4, r3
.L_max_check_v2:
    cmp/gt r3, r5                       ! if z2 > current max
    bf      .L_max_check_v3
    mov r5, r3
.L_max_check_v3:
    cmp/gt r3, r6                       ! if z3 > current max
    bf      .L_max_check_v4
    mov r6, r3
.L_max_check_v4:
    add r0, r3                          ! r3 = max_z + bias
.L_write_sort_key:
    ! --- Convert depth to 16-bit sort key and write to sort table ---
    mov.l   .L_sort_write_idx_ptr, r2  ! r2 → sprite count (write index)
    neg r3, r3                          ! negate: farther = larger key
    mov.l   .L_sort_index_table, r1    ! r1 → sort index array base
    shlr8 r3                            ! >> 12 total: convert 16.16 fixed
    mov.l @r2, r0                       ! r0 = current write index
    shlr2 r3                            !   to 16-bit sort key
    shlr2 r3
    shll r0                             ! index * 2 (word-sized entries)
    mov.w r3, @(r0, r1)                ! sort_table[idx] = sort_key
    shar r0                             ! restore index
    add #0x1, r0                        ! increment write index
    mov.l r0, @r2                       ! store updated count
.L_next_obj:
    mov.l @r15+, r7                     ! pop remaining object count
    dt r7                               ! decrement and test
    bt      .L_epilogue                 ! count == 0 → done
    bra     .L_obj_loop_top
    nop
    .2byte  0x0000
.L_fixed_depth_bias:
    .4byte  0x000B8000                  ! large depth bias constant (753664)
.L_sort_write_idx_ptr:
    .4byte  sym_060620D0                ! → sprite/object count (write index)
.L_sort_index_table:
    .4byte  sym_0606A4F8                ! → sort index array (word per entry)
.L_epilogue:
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r14                    ! restore callee-saved regs
    mov.l @r15+, r13
    mov.l @r15+, r12
    mov.l @r15+, r11
    mov.l @r15+, r10
    mov.l @r15+, r9
    rts
    mov.l @r15+, r8                     ! (delay slot)
    .2byte  0x0009
    ! ===================================================================
    ! .L_compute_dot_products — Transform vertex by matrix, return (x,y,z)
    !   Input:  r9 = vertex index, r14 = vertex data base, r6 = matrix
    !   Output: r1 = camera X, r2 = camera Y, r3 = camera Z
    ! ===================================================================
.L_compute_dot_products:
    mov #0xC, r0                        ! 12 bytes per vertex
    mul.l r0, r9                        ! offset = vtx_index * 12
    mov #0x18, r7                       ! matrix row 2 offset (24 bytes)
    add r6, r7                          ! r7 → mat[2][0] (translation row)
    sts macl, r4
    add r14, r4                         ! r4 → vertex data for this index
    ! --- dot(vertex, mat_row_2) → camera Z ---
    clrmac
    mac.l @r4+, @r7+                   ! sum += vtx[i] * mat[2][i]
    mac.l @r4+, @r7+
    mac.l @r4+, @r7+
    add #-0xC, r4                       ! rewind vertex ptr
    mov.l @(8, r7), r2                  ! r2 = mat translation Z
    sts mach, r0
    sts macl, r3
    xtrct r0, r3                        ! r3 = 16.16 dot result
    add r2, r3                          ! r3 = camera-space Z + translation
    cmp/gt r10, r3                      ! compare against depth threshold
    bf      .L_next_obj                 ! behind threshold → skip
    mov.w   .L_sprite_entry_offset, r2 ! r2 = scratch offset (signed)
    mov.w   .L_sprite_cmd_size, r0     ! r0 = 0x00A0 (sprite cmd size)
    mov.l r0, @(16, r2)                 ! scratch.cmd_size = 0xA0
    mov.l r3, @(0, r2)                  ! scratch.z = camera Z
    mov #0x0, r0
    mov.l r0, @(20, r2)                 ! scratch.padding = 0
    ! --- dot(vertex, mat_row_0) → camera X ---
    clrmac
    mac.l @r4+, @r6+                   ! sum += vtx[i] * mat[0][i]
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    add #-0xC, r4                       ! rewind vertex ptr
    mov.l @r7+, r2                      ! r2 = mat translation X
    sts mach, r0
    sts macl, r1
    clrmac
    mac.l @r4+, @r6+                   ! dot(vertex, mat_row_1) → camera Y
    xtrct r0, r1                        ! r1 = camera-space X
    add r2, r1                          ! r1 += translation X
    mac.l @r4+, @r6+
    mac.l @r4+, @r6+
    mov.l @r7+, r7                      ! r7 = mat translation Y
    add #-0x18, r6                      ! rewind matrix ptr
    sts mach, r0
    sts macl, r2
    xtrct r0, r2                        ! r2 = camera-space Y
    rts
    add r7, r2                          ! r2 += translation Y (delay slot)
.L_sprite_entry_offset:
    .2byte  0xFF00                      ! signed offset (-256) into scratch area
.L_sprite_cmd_size:
    .2byte  0x00A0                      ! VDP1 sprite command size (160 bytes)
    .2byte  0x0009
    ! ===================================================================
    ! .L_clip_and_cache_vtx — Perspective divide, clip test, cache write
    !   Input:  r1 = camera X, r2 = camera Y, r3 = camera Z
    !   Uses:   r11 → z-scratch output, r12 → cache entry
    ! ===================================================================
.L_clip_and_cache_vtx:
    mov.w   DAT_0602ab36, r0           ! r0 = 0xFF00 (signed offset)
    mov.l @(28, r0), r4                 ! r4 = perspective scale factor
    dmuls.l r1, r4                      ! screen_x = cam_x * scale (64-bit)
    neg r2, r2                          ! negate Y (screen coords are flipped)
    sts mach, r1                        ! r1 = screen X (high 32 bits)
    dmuls.l r2, r4                      ! screen_y = (-cam_y) * scale
    mov.l r1, @r11                      ! z_scratch[n].x = screen X
    sts mach, r2                        ! r2 = screen Y
    mov.l r2, @(4, r11)                 ! z_scratch[n].y = screen Y
    add #0x8, r11                       ! advance z-scratch ptr
    ! --- Clip bounds test ---
    mov.w   DAT_0602ab38, r7           ! r7 = 0x0190 = clip extent (400)
    cmp/gt r7, r1                       ! screen X > +400?
    bt      .L_next_obj                 ! off right → reject
    neg r7, r0                          ! r0 = -400
    cmp/gt r1, r0                       ! screen X < -400?
    bt      .L_next_obj                 ! off left → reject
    cmp/gt r2, r0                       ! screen Y < -400?
    bt      .L_next_obj                 ! off bottom → reject
    shlr r7                             ! r7 = 200
    cmp/gt r7, r2                       ! screen Y > +200?
    bt      .L_next_obj                 ! off top → reject
    ! --- Cache write: store vtx data for reuse ---
    mov.l r9, @r12                      ! cache[slot].tag = vtx_index
    mov.l r1, @(4, r12)                 ! cache[slot].x = screen X
    mov.l r2, @(8, r12)                 ! cache[slot].y = screen Y
    mov.l r3, @(12, r12)               ! cache[slot].z = camera Z
    rts
    nop

    .global DAT_0602ab36
DAT_0602ab36:
    .2byte  0xFF00                      ! signed offset for perspective LUT

    .global DAT_0602ab38
DAT_0602ab38:
    .2byte  0x0190                      ! clip extent = 400 (screen half-width)
    ! ===================================================================
    ! .L_fetch_cached_vtx — Check depth cache for vertex transform
    !   Input:  r0 = vertex index, r9 = expected tag, r7 = continuation
    !   On hit: loads cached (x,y,z), jumps to r7 (skip recompute)
    !   On miss: returns to caller (who recomputes via dot products)
    ! ===================================================================
.L_fetch_cached_vtx:
    and #0x3F, r0                       ! cache slot = vtx_index & 63
    mov.l   .L_cache_entry_base, r12
    shll2 r0                            ! slot * 16
    shll2 r0
    add r0, r12                         ! r12 → cache[slot]
    mov.l @r12, r0                      ! r0 = cache[slot].tag
    cmp/pz r0                           ! tag >= 0? (negative = empty)
    bf      .L_cache_miss
    cmp/eq r0, r9                       ! tag == expected vtx_index?
    bf      .L_cache_miss
    ! --- Cache hit: retrieve stored values ---
    mov.l @(4, r12), r1                 ! r1 = cached screen X
    mov.l @(8, r12), r2                 ! r2 = cached screen Y
    mov.l @(12, r12), r3               ! r3 = cached camera Z
    mov.l r1, @r11                      ! write X to z-scratch
    mov.l r2, @(4, r11)                 ! write Y to z-scratch
    add #0x8, r11
    mov.l r3, @r5                       ! write Z to result vec
    jmp @r7                             ! jump to next vertex handler
    add #0x4, r5                        ! advance result ptr (delay slot)
.L_cache_entry_base:
    .4byte  sym_0608A820                ! → depth cache (64 entries x 16B)
.L_cache_miss:
    rts                                 ! return to caller → will recompute
    nop

    ! --- Z-value scratch buffer: 4 vertices x (Z, X) = 32 bytes ---
    .global sym_0602AB68
sym_0602AB68:
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */

    ! --- Dot product result vector: 3 components (X, Y, Z) ---
    .global sym_0602AB88
sym_0602AB88:
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */

    .global DAT_0602ab8c
DAT_0602ab8c:
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */

    .global DAT_0602ab90
DAT_0602ab90:
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */

    .global DAT_0602ab94
DAT_0602ab94:
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */

    ! --- Transform result buffer: 3 components ---
    .global sym_0602AB98
sym_0602AB98:
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */
    .word 0xFFFF /* UNKNOWN */

    ! --- Depth mode jump table (5 entries, indexed by flags[2:0]) ---
    ! Mode 0: average Z    Mode 1: min Z (closest)
    ! Mode 2: max Z        Mode 3: max Z + 0x10000
    ! Mode 4: max Z + 0xB8000
    .global sym_0602ABA4
sym_0602ABA4:
    .4byte  loc_0602AA1C                ! mode 0 → average
    .4byte  loc_0602AA26                ! mode 1 → minimum
    .4byte  loc_0602AA3C                ! mode 2 → max, no bias
    .4byte  loc_0602AA40                ! mode 3 → max + small bias
    .4byte  loc_0602AA46                ! mode 4 → max + large bias

    ! --- Next TU prologue (scene_process_b) ---
    .global sym_0602ABB8
sym_0602ABB8:
    mov.l r8, @-r15
    mov.l r9, @-r15
    mov.l r10, @-r15
    mov.l r11, @-r15
    mov.l r12, @-r15
    mov.l r13, @-r15
