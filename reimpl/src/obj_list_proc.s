/* obj_list_proc -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x060204D0 - 0x0602052C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Processes an object display list entry. Advances the display offset
 * accumulator by a fixed stride, calls display_channel_b to commit the
 * entry, then checks if the offset has exceeded the maximum. If so,
 * clears the object's animation state and tail-calls display_channel_b
 * with the clamped offset to finalize.
 */

    .section .text.FUN_060204D0


    .global obj_list_proc
    .type obj_list_proc, @function
obj_list_proc:
    mov.l r14, @-r15                         ! save r14 (callee-saved)
    sts.l pr, @-r15                          ! save return address
    add #-0x4, r15                           ! allocate 0x4 bytes on stack
    mov.b r4, @r15                           ! store obj index (r4) on stack
    mov.l   .L_pool_disp_offset_ptr, r14     ! r14 = &disp_offset accumulator
    mov.l   .L_pool_disp_stride, r2          ! r2 = 0x00180000 (display stride)
    mov.l @r14, r3                           ! r3 = current disp_offset value
    add r2, r3                               ! r3 += stride (advance offset)
    mov.l r3, @r14                           ! store updated offset back
    mov r3, r6                               ! r6 = updated offset (arg3 for call)
    mov.l   .L_pool_fn_disp_channel, r3      ! r3 = &display_channel_b
    jsr @r3                                  ! display_channel_b(r4=0x20, r6=offset)
    mov #0x20, r4                            ! r4 = 0x20 (channel 32) [delay slot]
    mov.l @r14, r2                           ! r2 = current disp_offset
    mov.l   .L_pool_disp_offset_max, r3      ! r3 = 0x00980000 (max offset)
    cmp/gt r3, r2                            ! T = (r2 > max offset)?
    bf      .L_under_limit                   ! branch if offset <= max (not exceeded)
    mov.b @r15, r4                           ! r4 = stored obj index from stack
    .byte   0xB4, 0x7B    /* bsr 0x06020DEE (external) */  ! call obj_anim_clear
    extu.b r4, r4                            ! r4 = zero-extend obj index [delay slot]
    mov.l   .L_pool_disp_offset_max, r6      ! r6 = max offset (clamp value)
    mov #0x0, r5                             ! r5 = 0x0 (arg2)
    mov #0x20, r4                            ! r4 = 0x20 (channel 32)
    add #0x4, r15                            ! free stack local
    lds.l @r15+, pr                          ! restore return address
    mov.l   .L_pool_fn_disp_channel, r3      ! r3 = &display_channel_b
    jmp @r3                                  ! tail-call display_channel_b(0x20, 0, max)
    mov.l @r15+, r14                         ! restore r14 [delay slot]
.L_under_limit:
    add #0x4, r15                            ! free stack local
    lds.l @r15+, pr                          ! restore return address
    rts                                      ! return
    mov.l @r15+, r14                         ! restore r14 [delay slot]

    .global loc_06020510
loc_06020510:
    rts                                      ! return immediately (stub)
    nop                                      ! delay slot nop
    .4byte  sym_06028560
    .4byte  gameover_channel_setup
.L_pool_disp_offset_ptr:
    .4byte  sym_06087814
.L_pool_disp_stride:
    .4byte  0x00180000                  /* display offset stride per entry */
.L_pool_fn_disp_channel:
    .4byte  display_channel_b
.L_pool_disp_offset_max:
    .4byte  0x00980000
