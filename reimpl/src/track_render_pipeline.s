/* track_render_pipeline -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602F9A6 - 0x0602FDB0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Race sound trigger dispatcher. Monitors countdown timers, car object
 * status flags, speed/distance thresholds, and other race state to fire
 * sound commands via sound_cmd_dispatch. Called once per frame during
 * racing. Each check decrements a per-channel countdown byte; when it
 * reaches zero, a specific sound command (0xAE11xxFF) is dispatched.
 *
 * Data tables at the end of this TU hold:
 *   sym_0602FD30  — sound ID lookup table (per-event type)
 *   sym_0602FD3C  — unknown table (6 words)
 *   sym_0602FD48  — unknown table (6 words)
 *   sym_0602FD54  — car scan table header (count + offsets per course)
 *   sym_0602FD60  — car scan entry table (segment ID + trigger type pairs)
 *   sym_0602FD98  — 3 channel countdown bytes (fade/volume timers)
 *   sym_0602FD9B  — 3 front-speaker countdown bytes
 *   sym_0602FDA0  — 2 collision sound countdown bytes
 */

    .section .text.FUN_0602F9A6


    .global track_render_pipeline
    .type track_render_pipeline, @function
track_render_pipeline:
    sts.l pr, @-r15
    mov.l @r14, r14                     ! r14 = car state base pointer
    .byte   0xDC, 0x18    /* mov.l .L_fn_sound_cmd_dispatch, r12 */  ! r12 = sound_cmd_dispatch (persists)
    mov r14, r0
    .byte   0xDD, 0x18    /* mov.l .L_channel_countdown_base, r13 */  ! r13 → countdown bytes [0..2]
    mov.b @r13, r0                      ! r0 = channel A countdown
    tst r0, r0
    bt      .L_check_channel_b          ! skip if already zero
    add #-0x1, r0                       ! decrement countdown
    cmp/eq #0x2, r0                     ! fire when countdown reaches 2
    bf/s    .L_check_channel_b
    mov.b r0, @r13                      ! store decremented value
    .byte   0xD5, 0x15    /* mov.l .L_snd_channel_a_cmd, r5 */  ! r5 = 0xAE1103FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1103FF)
    mov #0x0, r4
.L_check_channel_b:
    mov.b @(1, r13), r0                 ! r0 = channel B countdown
    tst r0, r0
    bt      .L_check_channel_c
    add #-0x1, r0
    cmp/eq #0x2, r0
    bf/s    .L_check_channel_c
    mov.b r0, @(1, r13)
    .byte   0xD5, 0x11    /* mov.l .L_snd_channel_b_cmd, r5 */  ! r5 = 0xAE1104FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1104FF)
    mov #0x0, r4
.L_check_channel_c:
    mov.b @(2, r13), r0                 ! r0 = channel C countdown
    tst r0, r0
    bt      .L_check_front_speaker_a
    add #-0x1, r0
    cmp/eq #0x2, r0
    bf/s    .L_check_front_speaker_a
    mov.b r0, @(2, r13)
    .byte   0xD5, 0x0C    /* mov.l .L_snd_channel_b_cmd, r5 */  ! r5 = 0xAE1104FF (same cmd)
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1104FF)
    mov #0x0, r4
.L_check_front_speaker_a:
    .byte   0xDD, 0x0B    /* mov.l .L_front_speaker_countdown_base, r13 */  ! r13 → front speaker bytes [0..2]
    mov.b @r13, r0                      ! r0 = front speaker A countdown
    tst r0, r0
    bt      .L_check_front_speaker_b
    add #-0x1, r0
    cmp/eq #0x4, r0                     ! fire 0xAE1110FF when countdown == 4 (expire)
    .byte   0xD5, 0x09    /* mov.l .L_snd_front_a_expire, r5 */
    bt/s    .L_dispatch_front_sound
    mov.b r0, @r13
    cmp/eq #0x0, r0                     ! fire 0xAE1111FF when countdown == 0 (done)
    .byte   0xD5, 0x08    /* mov.l .L_snd_front_a_zero, r5 */
    bt      .L_dispatch_front_sound
    bra     .L_check_ambient_state
    nop
    .4byte  sym_0607E944                ! car state pointer (not referenced in this func)
.L_fn_sound_cmd_dispatch:
    .4byte  sound_cmd_dispatch
.L_channel_countdown_base:
    .4byte  sym_0602FD98
.L_snd_channel_a_cmd:
    .4byte  0xAE1103FF                  ! sound cmd: channel A fade
.L_snd_channel_b_cmd:
    .4byte  0xAE1104FF                  ! sound cmd: channel B fade
.L_front_speaker_countdown_base:
    .4byte  sym_0602FD9B                ! 3 front-speaker countdown bytes
.L_snd_front_a_expire:
    .4byte  0xAE1110FF                  ! sound cmd: front A expire
.L_snd_front_a_zero:
    .4byte  0xAE1111FF                  ! sound cmd: front A zero
.L_check_front_speaker_b:
    mov.b @(1, r13), r0
    tst r0, r0
    bt      .L_check_ambient_state
    add #-0x1, r0
    cmp/eq #0x4, r0
    .byte   0xD5, 0x0C    /* mov.l .L_snd_front_b_expire, r5 */
    bt/s    .L_dispatch_front_sound
    mov.b r0, @(1, r13)
    cmp/eq #0x0, r0
    .byte   0xD5, 0x0B    /* mov.l .L_snd_front_b_zero, r5 */
    bf      .L_check_ambient_state
.L_dispatch_front_sound:
    jsr @r12
    mov #0x0, r4
.L_check_ambient_state:
    .byte   0xD5, 0x0A    /* mov.l .L_attract_cycle_counter, r5 */
    mov.w   .L_car_segment_offset, r4   ! r4 = offset 0x01EC (car segment ID field)
    mov.l @r5, r0                       ! r0 = attract cycle count
    add r14, r4
    tst r0, r0                          ! if attract cycle != 0, skip ambient check
    mov.l @r4, r4                       ! r4 = player car segment ID
    bf      .L_check_cooldown_timer
    .byte   0xDD, 0x07    /* mov.l .L_ambient_state_bytes, r13 */  ! r13 → [active_flag, countdown]
    mov #0x1E, r5                       ! r5 = 0x1E (max segment threshold)
    mov.b @r13, r1                      ! r1 = active flag
    mov.b @(1, r13), r0                 ! r0 = countdown
    cmp/pl r0                           ! countdown > 0?
    bf      .L_ambient_countdown_zero
    bra     .L_store_ambient_state      ! still counting down, decrement and store
    add #-0x1, r0
.L_car_segment_offset:
    .2byte  0x01EC
    .2byte  0x0000
.L_snd_front_b_expire:
    .4byte  0xAE1112FF                  ! sound cmd: front B expire
.L_snd_front_b_zero:
    .4byte  0xAE1113FF                  ! sound cmd: front B zero
.L_attract_cycle_counter:
    .4byte  sym_0607EAD8                ! attract cycle counter (0/1/2)
.L_ambient_state_bytes:
    .4byte  sym_0602FD9D                ! 2 bytes: [active_flag, countdown]
.L_ambient_countdown_zero:
    tst r4, r4                          ! segment ID == 0? (not on track)
    bt      .L_check_ambient_active
    cmp/ge r4, r5                       ! segment ID <= 0x1E? (near start)
    bf      .L_check_ambient_active
    .byte   0xD5, 0x02    /* mov.l .L_snd_ambient_trigger, r5 */  ! r5 = 0xAE1119FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1119FF)
    mov #0x0, r4
    mov #0x14, r0                       ! new countdown = 0x14 (20 frames)
    bra     .L_store_ambient_state
    mov #0x1, r1                        ! active flag = 1
.L_snd_ambient_trigger:
    .4byte  0xAE1119FF                  ! sound cmd: ambient trigger
.L_check_ambient_active:
    tst r1, r1                          ! active flag == 0?
    bt      .L_store_ambient_state
    .byte   0xD4, 0x08    /* mov.l .L_two_player_flag, r4 */
    mov.b @r4, r4                       ! r4 = two-player mode flag
    .byte   0xD5, 0x08    /* mov.l .L_snd_ambient_single, r5 */  ! single-player: 0xAE111AFF
    tst r4, r4
    bt      .L_dispatch_ambient_sound
    .byte   0xD5, 0x08    /* mov.l .L_snd_ambient_split, r5 */  ! split-screen: 0xAE113EFF
.L_dispatch_ambient_sound:
    jsr @r12                            ! sound_cmd_dispatch(0, snd_cmd)
    mov #0x0, r4
    mov #0x0, r1                        ! clear active flag after dispatch
.L_store_ambient_state:
    mov.b r1, @r13                      ! store active flag
    mov.b r0, @(1, r13)                 ! store countdown
.L_check_cooldown_timer:
    .byte   0xDD, 0x06    /* mov.l .L_sound_cooldown_timer, r13 */  ! r13 → cooldown timer (word)
    mov.w @r13, r1                      ! r1 = cooldown frames remaining
    tst r1, r1
    bt      .L_cooldown_expired         ! cooldown done, proceed to main checks
    add #-0x1, r1                       ! decrement cooldown
    bra     .L_return                   ! still cooling down, exit early
    mov.w r1, @r13
.L_two_player_flag:
    .4byte  sym_0605D241                ! byte: nonzero if 2-player split screen
.L_snd_ambient_single:
    .4byte  0xAE111AFF                  ! sound cmd: ambient (1-player)
.L_snd_ambient_split:
    .4byte  0xAE113EFF                  ! sound cmd: ambient (2-player)
.L_sound_cooldown_timer:
    .4byte  sym_06086054                ! word: frames until next sound allowed
.L_cooldown_expired:
    mov.l @(0, r14), r0                 ! r0 = car state flags
    mov #0x8, r1
    tst r0, r1                          ! bit 3 set? (race paused/special mode)
    bt      .L_begin_car_scan           ! not set — continue to car scan
    bra     .L_return                   ! set — skip all remaining checks
    nop
.L_begin_car_scan:
    .byte   0xD1, 0x10    /* mov.l .L_obj_scan_complete_flag, r1 */
    mov.l @r1, r4                       ! r4 = scan-complete flag
    tst r4, r4
    bf      .L_check_pit_entry          ! already scanned this frame, skip
    .byte   0xD1, 0x0F    /* mov.l .L_car_object_count, r1 */
    .byte   0xD4, 0x10    /* mov.l .L_car_object_array_base, r4 */
    mov.l @r1, r5                       ! r5 = car count
    add #-0x1, r5                       ! r5 = count - 1 (loop counter)
    mov.l @r4, r4                       ! r4 = car object array base ptr
    mov #0x0, r0                        ! r0 = SINIT/collision match count
    mov #0x0, r6                        ! r6 = offtrack match count
.L_car_scan_loop:
    .byte   0xD3, 0x0E    /* mov.l .L_sinit, r3 */  ! r3 = 0x01800000 (SINIT mask)
    mov.l @(0, r4), r1                  ! r1 = car[i].status_flags
    and r3, r1
    cmp/eq r1, r3                       ! SINIT status set?
    bt      .L_status_match_found
    .byte   0xD3, 0x0C    /* mov.l .L_status_mask_collision, r3 */  ! r3 = 0x01400000
    mov.l @(0, r4), r1
    and r3, r1
    cmp/eq r1, r3                       ! collision status set?
    bt      .L_status_match_found
    .byte   0xD3, 0x0B    /* mov.l .L_status_mask_offtrack, r3 */  ! r3 = 0x02C00000
    mov.l @(0, r4), r1
    and r3, r1
    cmp/eq r1, r3                       ! offtrack status set?
    bf      .L_car_scan_next
    add #0x1, r6                        ! offtrack_count++
.L_car_scan_next:
    dt r5                               ! decrement loop counter, set T if zero
    mov.w   .L_car_struct_stride, r3    ! r3 = 0x0268 (car struct size)
    bt      .L_car_scan_done
    bra     .L_car_scan_loop
    add r3, r4                          ! advance to next car struct
.L_car_struct_stride:
    .2byte  0x0268
    .2byte  0x0000
.L_obj_scan_complete_flag:
    .4byte  sym_0607EAE0                ! long: nonzero if scan already done
.L_car_object_count:
    .4byte  sym_0607EA98                ! long: total car objects in scene
.L_car_object_array_base:
    .4byte  sym_0607E948                ! ptr: base of car object array
.L_sinit:
    .4byte  0x01800000                  ! SINIT — secondary SH-2 init comm
.L_status_mask_collision:
    .4byte  0x01400000                  ! collision status bitmask
.L_status_mask_offtrack:
    .4byte  0x02C00000                  ! offtrack status bitmask
.L_status_match_found:
    add #0x1, r0                        ! match_count++
    cmp/eq #0x2, r0                     ! 2 matches found?
    bt      .L_two_matches_found        ! yes — trigger SINIT sound
    dt r5
    mov.w   .L_car_struct_stride_2, r3  ! r3 = 0x0268
    bt      .L_car_scan_done
    bra     .L_car_scan_loop
    add r3, r4
.L_car_struct_stride_2:
    .2byte  0x0268
.L_two_matches_found:
    .byte   0xD3, 0x03    /* mov.l .L_sinit_cooldown_byte, r3 */
    mov.b @r3, r5                       ! r5 = SINIT cooldown
    tst r5, r5
    bt      .L_sinit_cooldown_ready     ! cooldown == 0, ready to fire
    add #-0x1, r5                       ! decrement cooldown
    bra     .L_check_pit_entry
    mov.b r5, @r3
.L_sinit_cooldown_byte:
    .4byte  sym_0602FDA1                ! byte: SINIT sound cooldown counter
.L_sinit_cooldown_ready:
    mov.l @(12, r4), r5                 ! r5 = car[i].distance
    mov.l @(12, r14), r0                ! r0 = player distance
    cmp/ge r5, r0                       ! player distance >= car distance?
    bf      .L_check_pit_entry          ! no — skip
    mov #0xA, r5                        ! reset cooldown to 10 frames
    mov.b r5, @r3
    .byte   0xD5, 0x02    /* mov.l .L_snd_sinit_distance, r5 */  ! r5 = 0xAE1135FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1135FF)
    mov #0x0, r4
    mov #0x3C, r4                       ! set cooldown timer = 0x3C (60 frames)
    bra     .L_return
    mov.w r4, @r13
.L_snd_sinit_distance:
    .4byte  0xAE1135FF                  ! sound cmd: SINIT proximity
.L_car_scan_done:
    cmp/pl r6                           ! offtrack_count > 0?
    bf      .L_check_pit_entry          ! no offtrack cars found
    .byte   0xD3, 0x03    /* mov.l .L_offtrack_cooldown_byte, r3 */
    mov.b @r3, r5                       ! r5 = offtrack cooldown
    tst r5, r5
    bt      .L_check_offtrack_distance  ! cooldown == 0, ready to fire
    add #-0x1, r5                       ! decrement cooldown
    bra     .L_check_pit_entry
    mov.b r5, @r3
    .2byte  0x0000
.L_offtrack_cooldown_byte:
    .4byte  sym_0602FDA0                ! byte: offtrack sound cooldown counter
.L_check_offtrack_distance:
    mov.l @(12, r4), r0                 ! r0 = car[last].distance
    mov.l @(12, r14), r5               ! r5 = player distance
    sub r5, r0                          ! r0 = distance delta
    mov.w   DAT_0602fba8, r5           ! r5 = 0x8E38 (distance threshold)
    cmp/pz r0                           ! delta >= 0?
    extu.w r5, r5
    bf      .L_check_pit_entry          ! negative delta — skip
    cmp/gt r0, r5                       ! threshold > delta? (close proximity)
    .byte   0xD5, 0x05    /* mov.l .L_snd_offtrack_near, r5 */  ! near: 0xAE113AFF
    bt      .L_dispatch_offtrack_sound
    .byte   0xD5, 0x05    /* mov.l .L_snd_offtrack_far, r5 */  ! far: 0xAE1130FF
.L_dispatch_offtrack_sound:
    mov #0x3, r0                        ! reset cooldown to 3 frames
    mov.b r0, @r3
    jsr @r12                            ! sound_cmd_dispatch(0, snd_cmd)
    mov #0x0, r4
    mov #0x3C, r4                       ! set cooldown timer = 0x3C (60 frames)
    bra     .L_return
    mov.w r4, @r13

    .global DAT_0602fba8
DAT_0602fba8:
    .2byte  0x8E38                      ! offtrack distance threshold
    .2byte  0x0000
.L_snd_offtrack_near:
    .4byte  0xAE113AFF                  ! sound cmd: offtrack near
.L_snd_offtrack_far:
    .4byte  0xAE1130FF                  ! sound cmd: offtrack far
.L_check_pit_entry:
    mov.w   DAT_0602fbca, r0           ! r0 = offset 0x01BC (pit lane flag field)
    mov #0x1, r3
    mov.l @(r0, r14), r1               ! r1 = car_state[0x01BC] (pit lane flag)
    cmp/eq r1, r3                       ! == 1? (entering pit)
    bf      .L_check_stereo_crossfade
    .byte   0xD5, 0x03    /* mov.l .L_snd_pit_entry, r5 */  ! r5 = 0xAE1132FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1132FF)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13

    .global DAT_0602fbca
DAT_0602fbca:
    .2byte  0x01BC                      ! offset: pit lane flag in car state
.L_snd_pit_entry:
    .4byte  0xAE1132FF                  ! sound cmd: pit entry
.L_check_stereo_crossfade:
    .byte   0xD3, 0x05    /* mov.l .L_front_speaker_state_pair, r3 */
    mov.b @r3+, r0                      ! r0 = front_speaker[0] (byte A)
    mov.b @r3, r5                       ! r5 = front_speaker[1] (byte B)
    add r5, r0                          ! sum of both front speaker states
    cmp/eq #0x1, r0                     ! exactly one speaker active?
    bf      .L_segment_trigger_scan
    .byte   0xD5, 0x03    /* mov.l .L_snd_stereo_crossfade, r5 */  ! r5 = 0xAE1137FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1137FF)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13
.L_front_speaker_state_pair:
    .4byte  sym_0602FD9B                ! front-speaker state bytes (reused)
.L_snd_stereo_crossfade:
    .4byte  0xAE1137FF                  ! sound cmd: stereo crossfade
.L_segment_trigger_scan:
    .byte   0xD1, 0x09    /* mov.l .L_attract_cycle_counter_2, r1 */
    .byte   0xD4, 0x0A    /* mov.l .L_seg_table_header, r4 */
    mov.l @r1, r2                       ! r2 = course index (attract cycle)
    shll2 r2                            ! r2 *= 4 (index into header table)
    add r2, r4                          ! r4 → course entry in header
    mov.w   .L_car_segment_offset_2, r0 ! r0 = 0x01EC (segment ID offset)
    mov.w @r4, r3                       ! r3 = entry count for this course
    mov.l @(r0, r14), r5               ! r5 = player segment ID
    mov.w @(2, r4), r0                  ! r0 = byte offset into entry table
    .byte   0xD6, 0x07    /* mov.l .L_seg_entry_table, r6 */
    add r0, r6                          ! r6 → first entry for this course
.L_seg_scan_loop:
    mov.w @r6+, r7                      ! r7 = entry[i].segment_id (auto-inc)
    cmp/eq r7, r5                       ! matches player segment?
    bt      .L_seg_match_found
    dt r3                               ! decrement entry count
    bt      .L_check_time_warning       ! no more entries
    bra     .L_seg_scan_loop
    add #0x2, r6                        ! skip entry[i].trigger_type (2 bytes)
.L_car_segment_offset_2:
    .2byte  0x01EC
    .2byte  0x0000
.L_attract_cycle_counter_2:
    .4byte  sym_0607EAD8                ! attract cycle = course index
.L_seg_table_header:
    .4byte  sym_0602FD54                ! per-course: [count, offset] pairs
.L_seg_entry_table:
    .4byte  sym_0602FD60                ! segment trigger entries base
.L_seg_match_found:
    mov.w @r6, r0                       ! r0 = trigger type (1/2/3)
    cmp/eq #0x2, r0                     ! type 2 = speed-based trigger
    bt      .L_seg_type_speed_check
    cmp/eq #0x3, r0                     ! type 3 = distance-based trigger
    bt      .L_seg_type_distance_check
    mov.w   DAT_0602fc6e, r1            ! type 1: sum 4 car state fields
    mov.w   DAT_0602fc70, r2           ! offsets: 0x0250, 0x0150, 0x01BC, 0x00B8
    mov.w   DAT_0602fc72, r3
    mov.w   DAT_0602fc74, r4
    add r14, r1
    add r14, r2
    add r14, r3
    add r14, r4
    mov.w @r1, r1                       ! load 4 car state values
    mov.w @r2, r2
    mov.l @r3, r3
    mov.l @r4, r4
    add r1, r2                          ! accumulate sum
    add r2, r3
    add r3, r4
    tst r4, r4                          ! sum == 0?
    bf      .L_check_time_warning       ! nonzero — conditions not met
    .byte   0xD1, 0x09    /* mov.l .L_sound_id_lookup_table, r1 */
    mov.w   DAT_0602fc76, r11          ! r11 = offset 0x0228 (enabled flag)
    add r14, r11
    mov.l @r11, r11                     ! r11 = car_state[0x0228]
    mov #0x1, r5
    tst r11, r5                         ! bit 0 set? (sound enabled)
    bt      .L_check_time_warning       ! not enabled — skip
    shll2 r0                            ! r0 = trigger_type * 4
    add r0, r1                          ! index into sound ID lookup table
    mov.l @r1, r5                       ! r5 = sound command ID
    jsr @r12                            ! sound_cmd_dispatch(0, snd_id)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13

    .global DAT_0602fc6e
DAT_0602fc6e:
    .2byte  0x0250

    .global DAT_0602fc70
DAT_0602fc70:
    .2byte  0x0150

    .global DAT_0602fc72
DAT_0602fc72:
    .2byte  0x01BC

    .global DAT_0602fc74
DAT_0602fc74:
    .2byte  0x00B8

    .global DAT_0602fc76
DAT_0602fc76:
    .2byte  0x0228
.L_sound_id_lookup_table:
    .4byte  sym_0602FD30                ! sound ID table indexed by trigger type
.L_seg_type_speed_check:
    mov.w   DAT_0602fc9c, r2           ! r2 = 0x00C8 (min distance for speed check)
    mov.l @(8, r14), r3                 ! r3 = player distance (field +8)
    cmp/gt r3, r2                       ! distance < threshold?
    bt      .L_check_time_warning       ! too close to start — skip
    mov.w   DAT_0602fc9e, r0           ! r0 = 0x005C (speed field offset)
    mov #0x18, r5                       ! r5 = 0x18
    mov.l @(r0, r14), r1               ! r1 = player speed
    shll8 r5                            ! r5 = 0x1800 (speed threshold)
    cmp/gt r1, r5                       ! speed > threshold?
    bt      .L_check_time_warning       ! below threshold — skip
    .byte   0xD5, 0x03    /* mov.l .L_snd_speed_threshold, r5 */  ! r5 = 0xAE1136FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1136FF)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13

    .global DAT_0602fc9c
DAT_0602fc9c:
    .2byte  0x00C8

    .global DAT_0602fc9e
DAT_0602fc9e:
    .2byte  0x005C
.L_snd_speed_threshold:
    .4byte  0xAE1136FF                  ! sound cmd: speed trigger
.L_seg_type_distance_check:
    mov.w   .L_distance_threshold_b, r2 ! r2 = 0x00F0 (distance threshold)
    mov.l @(8, r14), r3                 ! r3 = player distance
    cmp/gt r3, r2                       ! distance < 0xF0?
    bt      .L_check_time_warning       ! too close — skip
    .byte   0xD5, 0x03    /* mov.l .L_snd_distance_trigger, r5 */  ! r5 = 0xAE112CFF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE112CFF)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13
.L_distance_threshold_b:
    .2byte  0x00F0
    .2byte  0x0000
.L_snd_distance_trigger:
    .4byte  0xAE112CFF                  ! sound cmd: distance trigger
.L_check_time_warning:
    mov.w   .L_race_mode_offset, r0    ! r0 = 0x00B8 (race mode field offset)
    mov.l @(r0, r14), r0               ! r0 = car_state[0x00B8] (race mode)
    cmp/eq #0x1, r0                     ! mode == 1? (timed race)
    bf      .L_check_final_lap
    .byte   0xD2, 0x05    /* mov.l .L_time_threshold, r2 */  ! r2 = 0x00028000 (time limit)
    mov.l @(12, r14), r1               ! r1 = player race time
    cmp/ge r1, r2                       ! time limit >= race time? (still have time)
    bt      .L_check_final_lap          ! plenty of time — skip warning
    .byte   0xD5, 0x04    /* mov.l .L_snd_time_warning, r5 */  ! r5 = 0xAE1131FF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE1131FF)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13
.L_race_mode_offset:
    .2byte  0x00B8
    .2byte  0x0000
.L_time_threshold:
    .4byte  0x00028000                  ! fixed-point time warning threshold
.L_snd_time_warning:
    .4byte  0xAE1131FF                  ! sound cmd: time running low
.L_check_final_lap:
    .byte   0xD5, 0x0C    /* mov.l .L_attract_cycle_counter_3, r5 */
    mov.w   DAT_0602fd1a, r4           ! r4 = 0x01EC (segment ID offset)
    mov.l @r5, r0                       ! r0 = attract cycle
    add r14, r4
    cmp/eq #0x1, r0                     ! cycle == 1? (specific course)
    bf      .L_return
    mov #-0x20, r1                      ! r1 = -32
    mov.l @r4, r4                       ! r4 = player segment ID
    extu.b r1, r1                       ! r1 = 0xE0 (segment ID A)
    cmp/eq r1, r4                       ! on segment 0xE0?
    bt      .L_final_lap_speed_check
    add #0x1, r1                        ! r1 = 0xE1 (segment ID B)
    cmp/eq r1, r4                       ! on segment 0xE1?
    bf      .L_return
.L_final_lap_speed_check:
    mov #0xA, r1                        ! r1 = 0xA
    mov.l @(20, r14), r0               ! r0 = player speed (field +20)
    shll16 r1                           ! r1 = 0xA0000 (speed threshold)
    cmp/ge r0, r1                       ! threshold >= speed? (going slow)
    bt      .L_return                   ! too slow — skip alert
    .byte   0xD5, 0x04    /* mov.l .L_snd_final_lap_alert, r5 */  ! r5 = 0xAE112EFF
    jsr @r12                            ! sound_cmd_dispatch(0, 0xAE112EFF)
    mov #0x0, r4
    mov #0x3C, r4                       ! cooldown = 60 frames
    bra     .L_return
    mov.w r4, @r13

    .global DAT_0602fd1a
DAT_0602fd1a:
    .2byte  0x01EC
.L_attract_cycle_counter_3:
    .4byte  sym_0607EAD8                ! attract cycle (reused as course index)
.L_snd_final_lap_alert:
    .4byte  0xAE112EFF                  ! sound cmd: final lap alert
.L_return:
    lds.l @r15+, pr                     ! restore PR and callee-saved regs
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14

    .global sym_0602FD30
sym_0602FD30:
    .byte   0xAE, 0x11    /* bra 0x0602F956 (external) */
    addv r15, r1
    .4byte  0xAE112FFF
    .4byte  0xAE1136FF

    .global sym_0602FD3C
sym_0602FD3C:
    .word 0x0000 /* UNKNOWN */
    .word 0x0000 /* UNKNOWN */
    stc sr, r0
    .word 0x0000 /* UNKNOWN */
    .word 0x0001 /* UNKNOWN */
    clrt

    .global sym_0602FD48
sym_0602FD48:
    .word 0x0058 /* UNKNOWN */
    mov.w r7, @(r0, r0)
    .word 0x00E0 /* UNKNOWN */
    .word 0x00E1 /* UNKNOWN */
    mov.l r6, @(r0, r0)
    mov.w @(r0, r6), r0

    .global sym_0602FD54
sym_0602FD54:
    bsrf r0
    .word 0x0000 /* UNKNOWN */
    mov.l r0, @(r0, r0)
    mov.b @(r0, r0), r0
    mov.w r0, @(r0, r0)
    mov.b r2, @(r0, r0)

    .global sym_0602FD60
sym_0602FD60:
    sleep
    stc sr, r0
    .word 0x003A /* UNKNOWN */
    .word 0x0001 /* UNKNOWN */
    mov.w @(r0, r4), r0
    stc sr, r0
    .word 0x0052 /* UNKNOWN */
    stc sr, r0
    .word 0x006A /* UNKNOWN */
    .word 0x0001 /* UNKNOWN */
    .word 0x0082 /* UNKNOWN */
    stc sr, r0
    mov.w @(r0, r9), r0
    stc sr, r0
    mov.b r11, @(r0, r0)
    stc sr, r0
    mov.b @(r0, r13), r0
    stc sr, r0
    .word 0x0078 /* UNKNOWN */
    bsrf r0
    mov.w @(r0, r9), r0
    stc sr, r0
    mov.b r13, @(r0, r0)
    bsrf r0
    .word 0x0190 /* UNKNOWN */
    .word 0x0001 /* UNKNOWN */
    mov.l @(r0, r12), r1
    stc sr, r0

    .global sym_0602FD98
sym_0602FD98:
    .word 0x0000 /* UNKNOWN */

    .global sym_0602FD9A
sym_0602FD9A:
    .word 0x0000 /* UNKNOWN */

    .global sym_0602FD9C
sym_0602FD9C:
    .word 0x0000 /* UNKNOWN */
    .word 0x0000 /* UNKNOWN */

    .global sym_0602FDA0
sym_0602FDA0:
    .word 0x0000 /* UNKNOWN */
    .word 0x0000 /* UNKNOWN */

    .global sym_0602FDA4
sym_0602FDA4:
    mov.l r8, @-r15
    mov.l r9, @-r15
    mov.l r10, @-r15
    mov.l r11, @-r15
    mov.l r12, @-r15
    mov.l r13, @-r15
