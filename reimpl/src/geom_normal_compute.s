/* geom_normal_compute -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601EB70 - 0x0601EBDA
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Geometry normal buffer initializer -- resets the geometry output buffer
 * and copies 16 bytes of reference data into the secondary geometry buffer.
 *
 * Called as part of the geometry pipeline (from geom_output_main and
 * geom_vertex_process) when the geometry system is idle or needs
 * reinitialization.
 *
 * Flow:
 *   1. Check geometry busy flag (sym_06087080). If non-zero, exit early.
 *   2. Zero-fill the primary output buffer (sym_0605E098 deref'd) up to
 *      course_size_table[player_index] bytes.
 *   3. Copy 16 bytes of reference data from sym_0604A5AC into the
 *      secondary buffer (sym_0605E09C deref'd), 2 bytes per iteration.
 *
 * Key symbols:
 *   sym_0604A5C0 = course size table (4 bytes per entry, indexed by player)
 *   sym_060877D8 = current player/car index (byte)
 *   sym_0605E098 = primary geometry output buffer pointer (deref'd)
 *   sym_0604A5AC = reference normal data source (16 bytes)
 *   sym_0605E09C = secondary geometry buffer pointer (deref'd)
 *   sym_06087080 = geometry busy flag (byte)
 *
 * Arguments: none (reads from globals)
 * Returns: void
 */

    .section .text.FUN_0601EB70


    .global geom_normal_compute
    .type geom_normal_compute, @function
geom_normal_compute:
    mov.l r14, @-r15                   ! save r14
    mov #0x10, r14                     ! r14 = 16 (reference data copy length)
    mov.l r13, @-r15                   ! save r13
    mov.l r12, @-r15                   ! save r12
    mov.l r11, @-r15                   ! save r11
    .byte   0xDB, 0x1E    /* mov.l .L_pool_0601EBF4, r11 — sym_0604A5C0 (course size table) */
    .byte   0xDC, 0x1E    /* mov.l .L_pool_0601EBF8, r12 — sym_060877D8 (player index byte) */
    .byte   0xDD, 0x1F    /* mov.l .L_pool_0601EBFC, r13 — sym_0605E098 (output buf ptr) */
    .byte   0xD7, 0x1F    /* mov.l .L_pool_0601EC00, r7  — sym_0604A5AC (reference data src) */
    .byte   0xD6, 0x20    /* mov.l .L_pool_0601EC04, r6  — sym_0605E09C (secondary buf ptr) */
    .byte   0xD0, 0x20    /* mov.l .L_pool_0601EC08, r0  — sym_06087080 (busy flag ptr) */
    mov.b @r0, r0                      ! read geometry busy flag
    extu.b r0, r0                      ! zero-extend to 32-bit
    tst r0, r0                         ! busy flag == 0?
    bt/s    .L_flag_clear              ! yes: proceed with initialization
    mov #0x0, r5                       ! r5 = 0 (fill byte / loop counter init) (delay slot)
    bra     .L_epilogue                ! busy: skip all work
    nop                                ! delay slot
    ! ---- Phase 1: Zero-fill primary output buffer ----
.L_flag_clear:
    bra     .L_zero_fill_test          ! jump to loop test
    mov r5, r4                         ! r4 = 0 (byte offset into buffer) (delay slot)
.L_zero_fill_body:
    mov.l @r13, r2                     ! r2 = *output_buf_ptr (deref'd buffer address)
    add r4, r2                         ! r2 = output_buf + offset
    extu.b r5, r3                      ! r3 = 0 (zero byte to write)
    mov.b r3, @r2                      ! output_buf[offset] = 0
    add #0x1, r4                       ! offset++
.L_zero_fill_test:
    mov.b @r12, r0                     ! r0 = player index (signed byte)
    extu.b r0, r0                      ! r0 = player index (unsigned)
    shll2 r0                           ! r0 = player_index * 4 (table stride)
    mov.l @(r0, r11), r3              ! r3 = course_size_table[player_index]
    cmp/hs r3, r4                      ! unsigned: offset >= course_size?
    bf      .L_zero_fill_body          ! no: continue zeroing
    ! ---- Phase 2: Copy 16 bytes of reference data to secondary buffer ----
    mov r5, r4                         ! r4 = 0 (reset byte offset for copy loop)
.L_ref_copy_body:
    mov.l @r6, r3                      ! r3 = *secondary_buf_ptr (deref'd dest address)
    mov r4, r2                         ! r2 = offset (for source indexing)
    add r4, r3                         ! r3 = dest_buf + offset
    add r7, r2                         ! r2 = ref_data_src + offset
    add #0x1, r4                       ! offset++ (advance to next byte position)
    mov.b @r2, r1                      ! r1 = ref_data[offset] (read even byte)
    mov r4, r2                         ! r2 = offset+1
    mov.b r1, @r3                      ! dest_buf[offset] = ref_data[offset] (write even byte)
    add r7, r2                         ! r2 = ref_data_src + offset+1
    mov.l @r6, r3                      ! r3 = *secondary_buf_ptr (reload dest address)
    mov.b @r2, r1                      ! r1 = ref_data[offset+1] (read odd byte)
    add r4, r3                         ! r3 = dest_buf + offset+1
    mov.b r1, @r3                      ! dest_buf[offset+1] = ref_data[offset+1] (write odd byte)
    add #0x1, r4                       ! offset++ (now at offset+2)
    cmp/ge r14, r4                     ! signed: offset >= 16?
    bf      .L_ref_copy_body           ! no: continue copying (2 bytes per iteration)
    ! ---- Epilogue ----
.L_epilogue:
    mov.l @r15+, r11                   ! restore r11
    mov.l @r15+, r12                   ! restore r12
    mov.l @r15+, r13                   ! restore r13
    rts                                ! return
    mov.l @r15+, r14                   ! restore r14 (delay slot)
