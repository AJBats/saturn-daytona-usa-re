/* vblank_dma_chain -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603F582 - 0x0603F93C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Functions in this TU:
 *
 * vblank_dma_chain (0x0603F582):
 *   Main DMA chain command processor. Reads a command descriptor from the
 *   input stream, parses an ISO 9660-style filename (handling ';' version
 *   separators and '.' extension dots), and populates an output DMA transfer
 *   struct with the parsed filename, address offsets, and control flags.
 *   Calls menu_element_render (0x0603F3F6) repeatedly to consume bytes from
 *   the command stream, audio_sync_slave (0x0603F500) to read 32-bit addresses,
 *   audio_sync_master (0x0603F4E0) to read 16-bit values, and
 *   attract_timer_init (0x0603F534) to validate/count commands.
 *   r14 = input command descriptor pointer
 *   r13 = output DMA transfer struct pointer
 *   Output struct layout:
 *     [0]  byte: total command count
 *     [4]  long: source address (from audio_sync_slave + 0x96 offset)
 *     [8]  long: destination address (from audio_sync_slave)
 *     [12] word: transfer length / control flags (bit 7 = needs-fixup flag)
 *     [14] byte: filename char 1
 *     [15] byte: filename char 2
 *     [16] bytes: parsed filename buffer (up to 12 chars)
 *     [29] byte: extra param byte
 *
 * sym_0603F8B8 (cmd_desc_init):
 *   Initializes a 6-field command descriptor struct from registers and stack.
 *   r4 = struct pointer, r5/r6/r7 = first 3 fields, stack = next 3 fields.
 *   Returns struct pointer in r0.
 *
 * sym_0603F8EE (cmd_dispatch_slot2):
 *   Virtual dispatch trampoline — calls function pointer at struct offset +8.
 *   Pushes r4 to stack, loads callback from [r4+8], restores r4 from [r4],
 *   then jumps to the callback.
 *
 * sym_0603F900 (cmd_dispatch_slot3):
 *   Virtual dispatch trampoline — calls function pointer at struct offset +12.
 *
 * sym_0603F90E (cmd_dispatch_slot4):
 *   Virtual dispatch trampoline — calls function pointer at struct offset +16.
 *
 * sym_0603F91C (cmd_dispatch_slot5):
 *   Virtual dispatch trampoline — calls function pointer at struct offset +20.
 */

    .section .text.FUN_0603F582


    .global vblank_dma_chain
    .type vblank_dma_chain, @function
vblank_dma_chain:
    mov.l r14, @-r15                    ! save r14 (will hold input cmd desc ptr)
    mov.l r13, @-r15                    ! save r13 (will hold output DMA struct ptr)
    mov r4, r14                         ! r14 = input command descriptor
    mov.l r12, @-r15                    ! save r12 (loop counter)
    mov r5, r13                         ! r13 = output DMA transfer struct
    mov.l r11, @-r15                    ! save r11 (filename write cursor)
    mov.l r10, @-r15                    ! save r10 (zero constant)
    mov.l r9, @-r15                     ! save r9 (max filename length)
    mov #0x0, r10                       ! r10 = 0 (constant zero)
    mov.l r8, @-r15                     ! save r8 (needs-fixup flag)
    sts.l pr, @-r15                     ! save return address
    add #-0x54, r15                     ! allocate 84 bytes of local stack frame
    mov.l @r14, r0                      ! r0 = cmd_desc->data_ptr (first field)
    tst r0, r0                          ! test if data pointer is null
    bf/s    .L_has_commands             ! if non-null, process commands
    mov r10, r8                         ! r8 = 0 (clear needs-fixup flag, delay slot)
    bra     .L_epilogue                 ! no commands — skip to exit
    mov.b r10, @r13                     ! output->count = 0 (delay slot)
.L_has_commands:
    .byte   0xBF, 0xC5    /* bsr 0x0603F534 (external) */ ! call attract_timer_init(cmd_desc) — validate/count commands
    mov r14, r4                         ! r4 = cmd_desc (delay slot arg)
    mov.b r0, @r13                      ! output->count = command count byte
    mov.b @r13, r2                      ! r2 = re-read count from output struct
    extu.b r2, r2                       ! zero-extend count to 32 bits
    tst r2, r2                          ! test if count is zero
    bf      .L_count_nonzero            ! if nonzero, continue parsing
    bra     .L_epilogue                 ! zero commands — exit
    nop                                 ! delay slot
    .4byte  0x0800FFFF                  ! padding / alignment data
    .4byte  cmd_multi_validate          ! pool: ptr to cmd_multi_validate function
.L_count_nonzero:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBF, 0x16    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read 1 byte to sp+0x4C
    add #0x4C, r5                       ! r5 = &local_buf[0x4C] (delay slot)
    .byte   0xBF, 0x99    /* bsr 0x0603F500 (external) */ ! call audio_sync_slave — read 32-bit source addr
    mov r14, r4                         ! r4 = cmd_desc (delay slot arg)
    mov.w   DAT_0603f682, r2            ! r2 = 0x0096 (address offset constant)
    add r2, r0                          ! r0 = source_addr + 0x96
    mov.l r0, @(4, r13)                 ! output->src_addr = source_addr + 0x96
    .byte   0xBF, 0x94    /* bsr 0x0603F500 (external) */ ! call audio_sync_slave — read 32-bit dest addr
    mov r14, r4                         ! r4 = cmd_desc (delay slot arg)
    mov.l r0, @(8, r13)                 ! output->dst_addr = dest_addr
    bra     .L_skip_init_test           ! jump to first iteration check
    mov r10, r12                        ! r12 = 0 (init skip-fields counter, delay slot)
.L_skip_field_loop:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBF, 0x07    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — skip 1 byte
    add #0x48, r5                       ! r5 = &local_buf[0x48] (delay slot)
    add #0x1, r12                       ! r12++ (increment skip counter)
.L_skip_init_test:
    mov #0x7, r2                        ! r2 = 7 (skip first 7 fields)
    cmp/ge r2, r12                      ! if counter >= 7, done skipping
    bf      .L_skip_field_loop          ! keep skipping if counter < 7
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0xFE    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read field[7] into sp+0x28
    add #0x28, r5                       ! r5 = &local_buf[0x28] (delay slot)
    mov #0x28, r0                       ! r0 = offset 0x28
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    mov.b @(r0, r15), r2                ! r2 = local_buf[0x28] (field[7] byte)
    mov #0x2C, r0                       ! r0 = offset 0x2C
    mov.b r2, @(r0, r15)               ! local_buf[0x2C] = field[7] (copy to flags area)
    .byte   0xBE, 0xF5    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read field[8] into sp+0x24
    add #0x24, r5                       ! r5 = &local_buf[0x24] (delay slot)
    mov #0x24, r0                       ! r0 = offset 0x24
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    mov.b @(r0, r15), r0                ! r0 = local_buf[0x24] (field[8] byte)
    mov.b r0, @(14, r13)               ! output->fname_char1 = field[8]
    .byte   0xBE, 0xED    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read field[9] into sp+0x20
    add #0x20, r5                       ! r5 = &local_buf[0x20] (delay slot)
    mov #0x20, r0                       ! r0 = offset 0x20
    mov.b @(r0, r15), r0                ! r0 = local_buf[0x20] (field[9] byte)
    mov.b r0, @(15, r13)               ! output->fname_char2 = field[9]
    .byte   0xBF, 0x5D    /* bsr 0x0603F4E0 (external) */ ! call audio_sync_master — read 16-bit value
    mov r14, r4                         ! r4 = cmd_desc (delay slot arg)
    mov r14, r4                         ! r4 = cmd_desc (redundant reload)
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0xE3    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read filename length into sp+0x1C
    add #0x1C, r5                       ! r5 = &local_buf[0x1C] (delay slot)
    mov #0x1C, r0                       ! r0 = offset 0x1C
    mov.b @(r0, r15), r9                ! r9 = local_buf[0x1C] (filename length byte)
    extu.b r9, r2                       ! r2 = zero-extended filename length
    add #0x21, r2                       ! r2 = fname_len + 0x21 (total field count)
    mov.l r2, @(4, r15)                 ! local_var[4] = total_fields (save for later)
    mov r13, r11                        ! r11 = output struct base
    add #0x10, r11                      ! r11 = &output->filename_buf (write cursor)
    bra     .L_fname_read_test          ! jump to filename read loop test
    mov r10, r12                        ! r12 = 0 (init char counter, delay slot)
.L_fname_read_char:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0xD5    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read next filename char
    add #0x18, r5                       ! r5 = &local_buf[0x18] (delay slot)
    mov #0x18, r0                       ! r0 = offset 0x18
    mov.b @(r0, r15), r2                ! r2 = local_buf[0x18] (filename char)
    mov.b r2, @r15                      ! local_buf[0] = current char (temp storage)
    mov.b @r15, r0                      ! r0 = current char
    extu.b r0, r0                       ! zero-extend char
    cmp/eq #0x3B, r0                    ! is it ';' (ISO 9660 version separator)?
    bf/s    .L_not_version_sep          ! if not ';', check further
    add #0x1, r12                       ! r12++ (increment char counter, delay slot)
    bra     .L_fname_done               ! ';' found — filename complete
    nop                                 ! delay slot
.L_not_version_sep:
    mov r11, r2                         ! r2 = current write position
    mov.b @r15, r3                      ! r3 = current char
    mov.b r3, @r2                       ! *write_cursor = char (store in filename buf)
    mov.b @r15, r0                      ! r0 = current char (re-read)
    extu.b r0, r0                       ! zero-extend
    cmp/eq #0x2E, r0                    ! is it '.' (extension separator)?
    bf/s    .L_fname_read_test          ! if not '.', continue reading
    add #0x1, r11                       ! r11++ (advance write cursor, delay slot)
    mov #0x50, r0                       ! r0 = offset 0x50 in stack frame
    bra     .L_fname_done               ! '.' found — save dot position and finish
    mov.l r11, @(r0, r15)              ! local_var[0x50] = dot position (delay slot)
.L_fname_read_test:
    mov #0x8, r4                        ! r4 = 8 (max filename base length)
    extu.b r9, r5                       ! r5 = zero-extended total filename length
    cmp/gt r4, r5                       ! is total length > 8?
    bf      .L_use_total_len            ! if not, use total length as limit
    bra     .L_use_max_8                ! else cap at 8
    mov r4, r2                          ! r2 = 8 (max length, delay slot)

    .global DAT_0603f682
DAT_0603f682:
    .2byte  0x0096                      ! constant: source address offset (150 decimal)
.L_use_total_len:
    mov r5, r2                          ! r2 = total filename length (use as limit)
.L_use_max_8:
    cmp/ge r2, r12                      ! has char counter reached limit?
    bf      .L_fname_read_char          ! if not, keep reading chars
.L_fname_done:
    mov.b @r15, r0                      ! r0 = last char read
    extu.b r0, r0                       ! zero-extend
    cmp/eq #0x3B, r0                    ! was last char ';' (version separator)?
    bf      .L_not_semicolon            ! if not, check for '.' handling
    bra     .L_skip_version_loop_test   ! skip version number chars
    nop                                 ! delay slot
.L_skip_version_char:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0xAB    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — skip version char
    add #0x44, r5                       ! r5 = &local_buf[0x44] (delay slot, discard)
    add #0x1, r12                       ! r12++ (count skipped chars)
.L_skip_version_loop_test:
    extu.b r9, r2                       ! r2 = total filename length
    cmp/ge r2, r12                      ! have we consumed all filename chars?
    bf      .L_skip_version_char        ! if not, keep skipping
    bra     .L_post_ext_parsing         ! done — go to post-extension parsing
    nop                                 ! delay slot
.L_not_semicolon:
    mov.b @r15, r0                      ! r0 = last char read
    extu.b r0, r0                       ! zero-extend
    cmp/eq #0x2E, r0                    ! was last char '.' (extension dot)?
    bt      .L_ext_chars_done           ! if '.', extension parsing complete
    bra     .L_ext_read_test            ! otherwise enter extension read loop
    nop                                 ! delay slot
.L_ext_read_char:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x9A    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read ext char
    add #0x14, r5                       ! r5 = &local_buf[0x14] (delay slot)
    mov #0x14, r0                       ! r0 = offset 0x14
    mov.b @(r0, r15), r2                ! r2 = local_buf[0x14] (extension char)
    mov.b r2, @r15                      ! local_buf[0] = ext char (temp)
    mov.b @r15, r0                      ! r0 = ext char
    extu.b r0, r0                       ! zero-extend
    cmp/eq #0x2E, r0                    ! is it another '.'?
    bf/s    .L_ext_not_dot              ! if not '.', just count it
    add #0x1, r12                       ! r12++ (count char, delay slot)
    mov r11, r2                         ! r2 = write cursor
    add #0x1, r11                       ! r11++ (advance cursor)
    mov.b @r15, r3                      ! r3 = '.' char
    mov.b r3, @r2                       ! store '.' in filename buf
    mov #0x50, r0                       ! r0 = offset 0x50
    bra     .L_ext_chars_done           ! dot found — save position and finish ext
    mov.l r11, @(r0, r15)              ! local_var[0x50] = post-dot position (delay slot)
.L_ext_not_dot:
    mov #0x1, r8                        ! r8 = 1 (set needs-fixup flag)
.L_ext_read_test:
    extu.b r9, r2                       ! r2 = total filename length
    cmp/ge r2, r12                      ! consumed all chars?
    bf      .L_ext_read_char            ! if not, keep reading
.L_ext_chars_done:
    bra     .L_post_ext_parsing         ! done with extension
    nop                                 ! delay slot
.L_read_remaining_char:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x80    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read remaining char
    add #0x10, r5                       ! r5 = &local_buf[0x10] (delay slot)
    mov #0x10, r0                       ! r0 = offset 0x10
    mov.b @(r0, r15), r2                ! r2 = local_buf[0x10] (char)
    mov.b r2, @r15                      ! local_buf[0] = char (temp)
    mov.b @r15, r0                      ! r0 = char
    extu.b r0, r0                       ! zero-extend
    cmp/eq #0x3B, r0                    ! is it ';' (version separator)?
    bf/s    .L_remaining_not_semi       ! if not ';', handle as extension char
    add #0x1, r12                       ! r12++ (count char, delay slot)
    bra     .L_skip_remaining_test      ! ';' found — skip rest
    nop                                 ! delay slot
.L_skip_remaining_char:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x71    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — skip remaining char
    add #0x40, r5                       ! r5 = &local_buf[0x40] (delay slot, discard)
    add #0x1, r12                       ! r12++ (count skipped)
.L_skip_remaining_test:
    extu.b r9, r2                       ! r2 = total filename length
    cmp/ge r2, r12                      ! consumed all chars?
    bf      .L_skip_remaining_char      ! if not, keep skipping
    bra     .L_fname_null_terminate     ! done — go to null termination
    nop                                 ! delay slot
.L_remaining_not_semi:
    mov #0x50, r0                       ! r0 = offset 0x50
    mov r11, r3                         ! r3 = current write cursor
    mov #0x3, r1                        ! r1 = 3 (max extension chars)
    mov.l @(r0, r15), r2                ! r2 = local_var[0x50] (dot position)
    sub r2, r3                          ! r3 = chars written since dot
    cmp/gt r1, r3                       ! more than 3 extension chars?
    bf      .L_ext_len_ok              ! if not, check further
    bra     .L_post_ext_parsing         ! too many ext chars — set fixup flag and stop
    mov #0x1, r8                        ! r8 = 1 (set needs-fixup flag, delay slot)
.L_ext_len_ok:
    mov r13, r2                         ! r2 = output struct base
    mov r11, r3                         ! r3 = write cursor
    add #0x10, r2                       ! r2 = &output->filename_buf
    sub r2, r3                          ! r3 = total chars in filename buf
    mov #0xC, r2                        ! r2 = 12 (max filename buf size)
    cmp/ge r2, r3                       ! is filename buf full (>= 12 chars)?
    bt      .L_post_ext_parsing         ! if full, stop writing
    mov r11, r2                         ! r2 = write cursor
    add #0x1, r11                       ! r11++ (advance cursor)
    mov.b @r15, r3                      ! r3 = current char
    mov.b r3, @r2                       ! *write_cursor = char
.L_post_ext_parsing:
    extu.b r9, r3                       ! r3 = total filename length
    cmp/ge r3, r12                      ! consumed all chars?
    bf      .L_read_remaining_char      ! if not, keep reading remaining chars
.L_fname_null_terminate:
    mov r13, r3                         ! r3 = output struct base
    mov r11, r2                         ! r2 = write cursor (end of filename)
    add #0x10, r3                       ! r3 = &output->filename_buf
    sub r3, r2                          ! r2 = filename length written
    mov #0xC, r3                        ! r3 = 12 (max filename buf size)
    cmp/ge r3, r2                       ! is buf full (>= 12)?
    bt      .L_skip_null               ! if full, don't add null terminator
    extu.b r10, r3                      ! r3 = 0 (null byte)
    mov.b r3, @r11                      ! *write_cursor = '\0' (null-terminate)
.L_skip_null:
    extu.b r9, r0                       ! r0 = total filename length
    add #0x1, r0                        ! r0 = fname_len + 1
    tst #0x1, r0                        ! is (fname_len + 1) even?
    bt      .L_no_pad_byte             ! if even, no padding needed
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x42    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read padding byte
    add #0x3C, r5                       ! r5 = &local_buf[0x3C] (delay slot, discard)
    mov.l @(4, r15), r2                 ! r2 = total_fields count
    add #0x1, r2                        ! total_fields++ (account for pad byte)
    mov.l r2, @(4, r15)                 ! save updated total_fields
.L_no_pad_byte:
    mov r13, r3                         ! r3 = output struct base
    add #0x10, r3                       ! r3 = &output->filename_buf
    mov.b @r3, r2                       ! r2 = first char of filename
    extu.b r2, r2                       ! zero-extend
    tst r2, r2                          ! is first char null?
    bf      .L_fname_nonempty          ! if non-null, filename has content
    mov r13, r0                         ! r0 = output struct base
    .byte   0xD3, 0x20    /* mov.l _pool_strcpy, r3 */ ! r3 = strcpy function ptr
    .byte   0xD1, 0x1E    /* mov.l _pool_str_dot, r1 */ ! r1 = "." string (single dot)
    jsr @r3                             ! call strcpy(output->filename_buf, ".")
    add #0x10, r0                       ! r0 = &output->filename_buf (delay slot arg)
    bra     .L_post_fname_fixup        ! continue to command tail parsing
    nop                                 ! delay slot
.L_fname_nonempty:
    mov r13, r0                         ! r0 = output struct base
    add #0x10, r0                       ! r0 = &output->filename_buf
    mov.b @r0, r0                       ! r0 = first char of filename
    extu.b r0, r0                       ! zero-extend
    cmp/eq #0x1, r0                     ! is first char 0x01 (parent dir marker)?
    bf      .L_post_fname_fixup        ! if not, skip dotdot substitution
    .byte   0xD1, 0x1B    /* mov.l _pool_str_dotdot, r1 */ ! r1 = ".." string (parent dir)
    mov r13, r0                         ! r0 = output struct base
    .byte   0xD2, 0x19    /* mov.l _pool_strcpy, r2 */ ! r2 = strcpy function ptr
    jsr @r2                             ! call strcpy(output->filename_buf, "..")
    add #0x10, r0                       ! r0 = &output->filename_buf (delay slot arg)
.L_post_fname_fixup:
    mov.b @r13, r3                      ! r3 = output->count (total command count)
    mov.l @(4, r15), r2                 ! r2 = total_fields consumed so far
    extu.b r3, r3                       ! zero-extend count
    cmp/ge r3, r2                       ! have we consumed all fields?
    bt      .L_all_fields_consumed     ! if so, handle short-form output
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x4, r6                        ! r6 = 4 (read 4 bytes)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x1D    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read 4-byte field
    add #0x38, r5                       ! r5 = &local_buf[0x38] (delay slot)
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x2, r6                        ! r6 = 2 (read 2 bytes)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x18    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read 2-byte xfer length
    add #0xC, r5                        ! r5 = &local_buf[0xC] (delay slot)
    mov.w @(12, r15), r0                ! r0 = local_buf[0xC] as word (transfer length)
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x2, r6                        ! r6 = 2 (read 2 bytes)
    mov r15, r5                         ! r5 = stack buffer base
    mov.w r0, @(12, r13)               ! output->xfer_len = transfer length word
    .byte   0xBE, 0x11    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read 2-byte field
    add #0x34, r5                       ! r5 = &local_buf[0x34] (delay slot)
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x0C    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — read 1-byte extra param
    add #0x8, r5                        ! r5 = &local_buf[0x8] (delay slot)
    mov.b @(8, r15), r0                 ! r0 = local_buf[0x8] (extra param byte)
    mov r0, r4                          ! r4 = extra param
    mov #0x1D, r0                       ! r0 = offset 0x1D (29 decimal)
    mov.b r4, @(r0, r13)               ! output->extra_param = extra param byte
    mov.l @(4, r15), r12                ! r12 = total_fields consumed so far
    bra     .L_tail_skip_test           ! jump to tail skip loop test
    add #0x9, r12                       ! r12 += 9 (account for 9 fields just read, delay slot)
.L_tail_skip_char:
    mov r14, r4                         ! r4 = cmd_desc
    mov #0x1, r6                        ! r6 = 1 (read 1 byte)
    mov r15, r5                         ! r5 = stack buffer base
    .byte   0xBE, 0x00    /* bsr 0x0603F3F6 (external) */ ! call menu_element_render — skip tail byte
    add #0x30, r5                       ! r5 = &local_buf[0x30] (delay slot, discard)
    add #0x1, r12                       ! r12++ (count consumed field)
.L_tail_skip_test:
    mov.b @r13, r2                      ! r2 = output->count (total command count)
    extu.b r2, r2                       ! zero-extend
    cmp/ge r2, r12                      ! consumed all commands?
    bf      .L_tail_skip_char           ! if not, keep consuming tail bytes
    bra     .L_check_fixup_flag        ! done — check if fixup needed
    nop                                 ! delay slot
_pool_str_dot:
    .4byte  sym_06059CB8                ! pool: ptr to "." string (ISO 9660 current dir)
_pool_strcpy:
    .4byte  sym_06035FEC                ! pool: ptr to strcpy function
_pool_str_dotdot:
    .4byte  sym_06059CBC                ! pool: ptr to ".." string (ISO 9660 parent dir)
.L_all_fields_consumed:
    mov #0x2C, r0                       ! r0 = offset 0x2C (flags byte in local frame)
    mov.b @(r0, r15), r0                ! r0 = local_buf[0x2C] (flags from field[7])
    extu.b r0, r0                       ! zero-extend flags
    tst #0x2, r0                        ! test bit 1 of flags
    bt      .L_no_half_flag            ! if bit 1 clear, use zero for xfer length
    .byte   0xD2, 0x26    /* mov.l .L_fp_half, r2 */ ! r2 = 0x8000 (0.5 in 16.16 fixed-point)
    bra     .L_store_xfer_len          ! store half-size transfer length
    nop                                 ! delay slot
.L_no_half_flag:
    mov #0x0, r2                        ! r2 = 0 (no transfer length)
.L_store_xfer_len:
    extu.w r2, r2                       ! zero-extend to 32 bits
    mov r2, r0                          ! r0 = transfer length value
    mov.w r0, @(12, r13)               ! output->xfer_len = value (0 or 0x8000)
    extu.b r10, r3                      ! r3 = 0 (zero byte)
    mov #0x1D, r0                       ! r0 = offset 0x1D (29 decimal)
    mov.b r3, @(r0, r13)               ! output->extra_param = 0
.L_check_fixup_flag:
    tst r8, r8                          ! test needs-fixup flag
    bt      .L_epilogue                 ! if no fixup needed, exit
    mov.w @(12, r13), r0                ! r0 = output->xfer_len
    or #0x80, r0                        ! set bit 7 (needs-fixup flag in xfer_len)
    mov.w r0, @(12, r13)               ! output->xfer_len |= 0x80
.L_epilogue:
    add #0x54, r15                      ! deallocate 84-byte stack frame
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r8                     ! restore r8
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return
    mov.l @r15+, r14                    ! restore r14 (delay slot)
    .4byte  0x5351E01D                  ! --- trailing code blob (unrelocated) ---
    .4byte  0x24325252
    .4byte  0x1421005C
    .4byte  0x804A8556
    .4byte  0xD3156603
    .4byte  0x666D2369
    .4byte  0x23388901
    .4byte  0xA001E310
    .4byte  0xE300921D
    .4byte  0x22692228
    .4byte  0x8901A001
    .4byte  0xE108E100
    .4byte  0x92172269
    .4byte  0x22288D02
    .4byte  0x331CA001
    .4byte  0xE104E100
    .4byte  0x92102269
    .4byte  0x22288D02
    .4byte  0x331CA001
    .4byte  0xE102E100
    .4byte  0x331C603C
    .4byte  0x804B845E
    .4byte  0x8048845F
    .4byte  0x000B8049
    .2byte  0x0800

    .global DAT_0603f8ae
DAT_0603f8ae:
    .2byte  0x1000                      ! data constant: 4096
    .4byte  0x2000FFFF                  ! data: mask / sentinel value
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */

    .global sym_0603F8B8
sym_0603F8B8:
    mov.l r5, @r4                       ! desc->field[0] = r5 (first param)
    mov.l r6, @(4, r4)                  ! desc->field[1] = r6 (second param)
    mov.l r7, @(8, r4)                  ! desc->field[2] = r7 (third param)
    mov.l @r15, r3                      ! r3 = stack arg 0 (fourth param)
    mov.l r3, @(12, r4)                 ! desc->field[3] = fourth param
    mov.l @(4, r15), r3                 ! r3 = stack arg 1 (fifth param)
    mov.l r3, @(16, r4)                 ! desc->field[4] = fifth param
    mov.l @(8, r15), r3                 ! r3 = stack arg 2 (sixth param)
    mov.l r3, @(20, r4)                 ! desc->field[5] = sixth param
    rts                                 ! return
    mov r4, r0                          ! r0 = struct pointer (return value, delay slot)
    .2byte  0x7FFC                      ! --- trailing code blob (dispatch thunk A) ---
    .4byte  0x2F426043
    .4byte  0x50016442
    .4byte  0x402B7F04
    .4byte  0x7FFC2F42
    .4byte  0x60435001
    .4byte  0xE600D505
    .4byte  0x6442402B
    .2byte  0x7F04

    .global sym_0603F8EE
sym_0603F8EE:
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l r4, @r15                      ! save original r4 (struct pointer)
    mov r4, r0                          ! r0 = struct pointer
    mov.l @(8, r0), r0                  ! r0 = desc->field[2] (callback slot 2)
    mov.l @r4, r4                       ! r4 = desc->field[0] (data pointer for callback)
    jmp @r0                             ! jump to callback at slot 2
    add #0x4, r15                       ! restore stack (delay slot)
    .4byte  0x0000FFFF                  ! padding / sentinel

    .global sym_0603F900
sym_0603F900:
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l r4, @r15                      ! save original r4 (struct pointer)
    mov r4, r0                          ! r0 = struct pointer
    mov.l @(12, r0), r0                 ! r0 = desc->field[3] (callback slot 3)
    mov.l @r4, r4                       ! r4 = desc->field[0] (data pointer for callback)
    jmp @r0                             ! jump to callback at slot 3
    add #0x4, r15                       ! restore stack (delay slot)

    .global sym_0603F90E
sym_0603F90E:
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l r4, @r15                      ! save original r4 (struct pointer)
    mov r4, r0                          ! r0 = struct pointer
    mov.l @(16, r0), r0                 ! r0 = desc->field[4] (callback slot 4)
    mov.l @r4, r4                       ! r4 = desc->field[0] (data pointer for callback)
    jmp @r0                             ! jump to callback at slot 4
    add #0x4, r15                       ! restore stack (delay slot)

    .global sym_0603F91C
sym_0603F91C:
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l r4, @r15                      ! save original r4 (struct pointer)
    mov r4, r3                          ! r3 = struct pointer
    mov.l @(20, r3), r3                 ! r3 = desc->field[5] (callback slot 5)
    mov.l @r4, r4                       ! r4 = desc->field[0] (data pointer for callback)
    jmp @r3                             ! jump to callback at slot 5
    add #0x4, r15                       ! restore stack (delay slot)
    .2byte  0x0000                      ! --- trailing code blob (multi-field store) ---
    .4byte  0x14586362
    .4byte  0x14395261
    .4byte  0x142A5362
    .4byte  0x000B143B
