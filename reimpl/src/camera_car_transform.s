/* camera_car_transform -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600ADD4 - 0x0600AFB2
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Camera-to-car coordinate transformation — positions and orients the
 * camera relative to the player car using Stack A matrix rotations and
 * interpolation. Paired with camera_track_setup (0x0600AFB2) which uses
 * Stack B matrix ops for track-viewing mode.
 *
 * Matrix stack: Uses Stack A (pointer at 0x06089EDC, 48 bytes/entry).
 *   mat_push_A (0x06026DBC) — push matrix
 *   mat_xform_trans_A (0x06026E2E) — transform vector by matrix+translation
 *   mat_rot_y / mat_rot_z — Y/Z axis rotation
 *   transform_matrix — apply accumulated rotation matrix
 *
 * Persistent registers:
 *   r11 = &camera_mode_idx (16-bit, indexes into bank angle table)
 *   r13 = transform_matrix function pointer
 *   r14 = car struct (loaded from car_array_base at sym_0607E944)
 *
 * Transform pipeline:
 *   1. mat_push_A() — push current matrix onto Stack A
 *   2. mat_xform_trans_A(car[+16], car[+20], car[+24]) — transform XYZ
 *   3. mat_rot_y(car[+32] + 0x8000) — yaw rotation (+ 180 degrees)
 *   4. mat_rot_z(-car[+36]) — pitch rotation (negated)
 *   5. Bank angle: car[+28] negated, offset by table[camera_mode_idx]
 *      Two paths: special mode (flag 0x00800008) or normal
 *   6. transform_matrix() — apply accumulated rotation
 *   7. mat_rot_y(car[+0x1D8] + car[+0x1CC]) — additional yaw offset
 *   8. If camera_follow_flag (sym_06059F30) set:
 *      -> vec_matrix_xform for rotation sources, mat_xform_trans_A,
 *         mat_rot_z, transform_matrix
 *   9. Optional camera shake (flag bit 1): BSR external handler
 *  10. LOD/distance computation with table lookup
 *  11. Cross-TU final transforms (2 vec_matrix_xform + dispatch calls)
 *  12. Conditional flag-based adjustment call
 *  13. Decrement Stack A matrix ptr (sym_06089EDC) by 0x30 (render budget)
 *
 * Car struct offsets (base at sym_0607E944, published to sym_0607E940):
 *   +0x01 = visibility/LOD flags byte
 *   +0x10/+0x14/+0x18 = X/Y/Z position
 *   +0x1C = bank angle     +0x20 = yaw angle     +0x24 = pitch angle
 *   +0x1B4 = camera roll    +0x1C8 = camera pitch B
 *   +0x1CC = yaw offset     +0x1D0 = camera pitch A    +0x1D8 = camera yaw
 *
 * Adjacent function pool (lines 98-105): Pool entries belonging to the
 * preceding TU (FUN_0600AC44 — Type B object renderer). These use Stack B
 * functions and car data struct pointers for absolute-positioned object
 * rendering.
 */

   .section .text.FUN_0600ADD4


/* camera_car_transform
 *
 * Main camera-to-car transform entry point. Builds the camera orientation
 * matrix from the player car's position, yaw, pitch, roll, and bank angle
 * using Stack A matrix operations.
 *
 * Applies optional camera follow mode (sym_06059F30), camera shake (bit 1
 * of sym_06082A25), and LOD selection via per-mode lookup table (sym_06044740).
 *
 * Finishes by chaining into cross-TU vector/matrix transform routines
 * (in camera_track_setup's pool), conditionally calling replay_playback,
 * and decrementing the Stack A render budget by 0x30 (one matrix entry).
 *
 * Arguments: none (reads car struct from car_array_base at sym_0607E944)
 * Returns:   none (writes to Stack A matrix and render budget)
 * Clobbers:  r0-r7, r11-r14, pr
 */
   .global camera_car_transform
   .type camera_car_transform, @function
camera_car_transform:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    mov.l r11, @-r15
    sts.l pr, @-r15
    mov.l   .L_camera_mode_idx, r11  ! r11 = &camera_mode_idx (persists across calls)
    mov.l   .L_fn_transform_matrix, r13 ! r13 = &transform_matrix (persists)
    mov.l   .L_car_array_base, r14   ! r14 = &car_array_base (pointer to pointer)
    mov.l   .L_car_struct_ptr, r3    ! r3 = &current_car_struct_ptr global
    mov.l @r14, r14                  ! r14 = car struct (dereference pointer)
    mov.l r14, @r3                   ! store car struct as the current car for other routines
    mov.l   .L_fn_mat_push_a, r3    ! r3 = &mat_push_A
    jsr @r3                          ! mat_push_A() — push matrix onto Stack A
    nop
    mov.l @(24, r14), r6             ! r6 = car[+24] = Z position
    mov.l @(20, r14), r5             ! r5 = car[+20] = Y position
    mov.l   .L_fn_mat_xform_a, r3     ! r3 = &mat_xform_trans_A
    jsr @r3                          ! mat_xform_trans_A(X, Y, Z) — transform position by Stack A matrix
    mov.l @(16, r14), r4             ! r4 = car[+16] = X position (delay slot)
    mov.l @(32, r14), r4             ! r4 = car[+32] = yaw angle
    mov.l   .L_fp_half, r2           ! r2 = 0x8000 (180 degrees in fixed-point)
    mov.l   .L_fn_rot_y, r3          ! r3 = &mat_rot_y
    jsr @r3                          ! mat_rot_y(yaw + 0x8000) — rotate camera 180 deg
    add r2, r4                       ! r4 = yaw + 0x8000 (delay slot: add half turn)
    mov.l @(36, r14), r4             ! r4 = car[+36] = pitch angle
    mov.l   .L_fn_rot_z, r3          ! r3 = &mat_rot_z
    jsr @r3                          ! mat_rot_z(-pitch) — apply negated pitch rotation
    neg r4, r4                       ! r4 = -pitch (delay slot: negate)
    mov.l   .L_game_flags, r2        ! r2 = &game_mode_flags
    mov.l   .L_flag_mask_800008, r3  ! r3 = 0x00800008 (special camera mode bitmask)
    mov.l @r2, r2                    ! r2 = game_mode_flags value
    and r3, r2                       ! r2 = flags & special_camera_mask
    tst r2, r2                       ! test if any special camera bits are set
    bt      .L_normal_bank           ! if no special bits → normal bank angle path
    mov.l @(28, r14), r4             ! r4 = car[+28] = bank angle (special path)
    neg r4, r4                       ! r4 = -bank angle
    mov.w @r11, r3                   ! r3 = camera_mode_idx (16-bit)
    extu.w r3, r2                    ! r2 = zero-extended mode index
    shll2 r2                         ! r2 = mode_idx * 4 (index into 4-byte table)
    mov.l   .L_bank_angle_table, r3  ! r3 = &bank_angle_offset_table
    add r2, r3                       ! r3 = &table[mode_idx]
    mov.l @r3, r2                    ! r2 = bank offset for this camera mode
    bra     .L_apply_bank            ! skip normal path, go apply final bank angle
    add r2, r4                       ! r4 = -bank + offset (delay slot)
    .4byte  sym_06027080             /* (adj pool FUN_0600AC44: mat_push_B — Stack B push matrix) */
    .4byte  sym_06044670             /* (adj pool FUN_0600AC44: static object position table) */
    .4byte  sym_060270F2             /* (adj pool FUN_0600AC44: mat_xform_trans_B — Stack B transform) */
    .4byte  mat_rot_xz_b            /* (adj pool FUN_0600AC44: XZ rotation) */
    .4byte  sym_060621D8             /* (adj pool FUN_0600AC44: car 3 data struct base) */
    .4byte  sym_06032158             /* (adj pool FUN_0600AC44: distance check / visibility cull B) */
    .4byte  sym_06062180             /* (adj pool FUN_0600AC44: car 2 data struct base) */
    .4byte  sym_06031DF4             /* (adj pool FUN_0600AC44: render submission / VDP1 submit B) */
.L_camera_mode_idx:
    .4byte  sym_06063F46             /* camera mode index, 16-bit (MEDIUM) */
.L_fn_transform_matrix:
    .4byte  transform_matrix         /* apply accumulated rotation matrix (HIGH) */
.L_car_array_base:
    .4byte  sym_0607E944             /* car array base pointer (HIGH — used across rendering/AI/collision) */
.L_car_struct_ptr:
    .4byte  sym_0607E940             /* current car struct pointer (HIGH — published for other subsystems) */
.L_fn_mat_push_a:
    .4byte  sym_06026DBC             /* mat_push_A — push matrix onto Stack A (HIGH) */
.L_fn_mat_xform_a:
    .4byte  sym_06026E2E             /* mat_xform_trans_A — vector transform + translate (HIGH) */
.L_fp_half:
    .4byte  0x00008000               /* 0x8000 = 180 degrees in 16-bit angle space (HIGH) */
.L_fn_rot_y:
    .4byte  mat_rot_y                /* Y-axis rotation (HIGH) */
.L_fn_rot_z:
    .4byte  mat_rot_z                /* Z-axis rotation (HIGH) */
.L_game_flags:
    .4byte  sym_0607EBC4             /* game mode flags word (HIGH — confirmed across multiple TUs) */
.L_flag_mask_800008:
    .4byte  0x00800008               /* bits: 0x00800000 | 0x00000008 — special camera mode (MEDIUM) */
.L_bank_angle_table:
    .4byte  sym_0605BDCC             /* per-mode bank angle offset table, 4 bytes/entry (MEDIUM) */
.L_normal_bank:                      /* --- normal bank angle path --- */
    mov.l @(28, r14), r4             ! r4 = car[+28] = bank angle
    neg r4, r4                       ! r4 = -bank angle
    mov.l   .L_camera_height_offset, r3 ! r3 = &camera_height_offset
    mov.l @r3, r3                    ! r3 = height offset value
    add r3, r4                       ! r4 = -bank + height_offset
    mov.w @r11, r2                   ! r2 = camera_mode_idx (16-bit)
    extu.w r2, r1                    ! r1 = zero-extended mode index
    shll2 r1                         ! r1 = mode_idx * 4 (table stride)
    mov.l   .L_bank_angle_table_2, r2 ! r2 = &bank_angle_offset_table (dup pool entry)
    add r1, r2                       ! r2 = &table[mode_idx]
    mov.l @r2, r1                    ! r1 = bank offset for this camera mode
    add r1, r4                       ! r4 = -bank + height_offset + table_offset
.L_apply_bank:
    jsr @r13                         ! transform_matrix(r4) — apply bank rotation
    nop
    mov.w   .L_off_cam_yaw, r0       ! r0 = 0x1D8 (offset to camera yaw in car struct)
    mov.l @(r0, r14), r4             ! r4 = car[+0x1D8] = camera yaw angle
    add #-0xC, r0                    ! r0 = 0x1CC (offset to yaw correction)
    mov.l @(r0, r14), r3             ! r3 = car[+0x1CC] = yaw offset
    add r3, r4                       ! r4 = camera_yaw + yaw_offset
    mov.l   .L_fn_rot_y_2, r3        ! r3 = &mat_rot_y
    jsr @r3                          ! mat_rot_y(camera_yaw + yaw_offset)
    nop
    mov.l   .L_camera_follow_flag, r0 ! r0 = &camera_follow_flag
    mov.l @r0, r0                    ! r0 = follow flag value
    tst r0, r0                       ! test if camera follow mode is enabled
    bt      .L_counter_decrement     ! if follow mode off → skip to counter decrement
    mov.l   .L_rot_src_a, r5         ! --- camera follow mode ---
    mov.l   .L_rot_dst_a, r4         ! r4 = &car1 rotation data (ptr)
    mov.l   .L_fn_vec_copy_a, r3     ! r3 = &vec_matrix_xform_A
    mov.l @r5, r5                    ! r5 = car3 rotation data (dereference)
    jsr @r3                          ! vec_matrix_xform_A(car1, car3)
    mov.l @r4, r4                    ! r4 = car1 rotation data (delay slot)
    mov.l   .L_rot_src_b, r6         ! r6 = &car2 rotation data (ptr)
    mov.l   .L_rot_scale_b, r5       ! r5 = &sprite/scale table
    mov.l   .L_rot_dst_b, r4         ! r4 = &car0 rotation data (ptr)
    mov.l   .L_fn_vec_copy_b, r3     ! r3 = &vec_scaled_xform_A
    mov.l @r6, r6                    ! r6 = car2 rotation data (dereference)
    mov.w @r5, r5                    ! r5 = scale factor (16-bit load)
    jsr @r3                          ! vec_scaled_xform_A(car0, car2, scale)
    mov.l @r4, r4                    ! r4 = car0 rotation data (delay slot)
    mov #0x0, r6                     ! r6 = 0 (Z position = 0 for follow cam)
    mov.w   .L_off_cam_roll, r0      ! r0 = 0x1B4 (offset to camera roll)
    mov.l   .L_fn_mat_xform_a_2, r3   ! r3 = &mat_xform_trans_A
    mov.l @(r0, r14), r5             ! r5 = car[+0x1B4] = camera roll angle
    jsr @r3                          ! mat_xform_trans_A(0, roll, 0) — transform follow position
    mov r6, r4                       ! r4 = 0 (X position = 0, delay slot)
    mov.w   .L_off_cam_pitch_a, r0   ! r0 = 0x1D0 (offset to camera pitch A)
    mov.l   .L_fn_rot_z_2, r3        ! r3 = &mat_rot_z
    jsr @r3                          ! mat_rot_z(pitch_A) — apply pitch rotation
    mov.l @(r0, r14), r4             ! r4 = car[+0x1D0] = camera pitch A (delay slot)
    mov.w   .L_off_cam_pitch_b, r0   ! r0 = 0x1C8 (offset to camera pitch B)
    jsr @r13                         ! transform_matrix(pitch_B) — final follow transform
    mov.l @(r0, r14), r4             ! r4 = car[+0x1C8] = camera pitch B (delay slot)
    mov.l   .L_camera_shake_flags, r0 ! r0 = &camera_shake_flags
    mov.b @r0, r0                    ! r0 = shake flags byte
    tst #0x2, r0                     ! test bit 1: camera shake active?
    bf      .L_lod_compute           ! if bit 1 set → skip shake (already applied)
    mov #0x0, r5                     ! r5 = 0 (shake intensity param)
    .byte   0xBD, 0xD2    /* bsr FUN_0600AA98 (external) — render_obj_additive (Type A) */
    mov r14, r4                      ! r4 = car struct ptr (delay slot for BSR)
.L_lod_compute:                      /* --- LOD / distance computation --- */
    mov r14, r0                      ! r0 = car struct base address
    mov.b @(1, r0), r0               ! r0 = car[+1] = visibility/LOD flags byte
    tst #0x1, r0                     ! test bit 0: is car visible?
    bt/s    .L_default_lod           ! if not visible → branch to default LOD path
    mov #0x0, r12                    ! r12 = 0 (default LOD table index, delay slot)
    mov #0xD, r12                    ! r12 = 13 (active car LOD table index)
    mov.w @r11, r4                   ! r4 = camera_mode_idx (16-bit)
    extu.w r4, r4                    ! r4 = zero-extended mode index
    mov.l   .L_camera_lod_lut, r3    ! r3 = &LOD lookup table
    add r3, r4                       ! r4 = &lut[mode_idx]
    mov.b @r4, r4                    ! r4 = LOD level for this camera mode (byte)
    mov.l   .L_camera_offset_base, r2 ! r2 = &camera_LOD_offset_base ptr
    mov.l @r2, r2                    ! r2 = LOD offset base value
    bra     .L_apply_lod             ! branch to apply LOD transform
    add r2, r4                       ! r4 = LOD_base + level (delay slot)
.L_off_cam_yaw:
    .2byte  0x01D8                   /* car offset: camera yaw */
.L_off_cam_roll:
    .2byte  0x01B4                   /* car offset: camera roll */
.L_off_cam_pitch_a:
    .2byte  0x01D0                   /* car offset: camera pitch A */
.L_off_cam_pitch_b:
    .2byte  0x01C8                   /* car offset: camera pitch B */
    .2byte  0xFFFF                       /* alignment padding */
.L_camera_height_offset:
    .4byte  sym_06078668             /* camera height offset value (MEDIUM) */
.L_bank_angle_table_2:
    .4byte  sym_0605BDCC             /* bank angle offset table (dup for reach) (MEDIUM) */
.L_fn_rot_y_2:
    .4byte  mat_rot_y                /* Y rotation (dup for reach) (HIGH) */
.L_camera_follow_flag:
    .4byte  sym_06059F30             /* camera follow mode flag (MEDIUM — also used in course-specific renderer) */
.L_rot_src_a:
    .4byte  sym_060621E8             /* car 3 data struct + 0x10 (rotation source A) (MEDIUM) */
.L_rot_dst_a:
    .4byte  sym_0606213C             /* car 1 data struct + 0x10 (rotation dest A) (MEDIUM) */
.L_fn_vec_copy_a:
    .4byte  sym_06031D8C             /* vec_matrix_xform_A — distance/visibility (Stack A) (MEDIUM) */
.L_rot_src_b:
    .4byte  sym_06062190             /* car 2 data struct + 0x10 (rotation source B) (MEDIUM) */
.L_rot_scale_b:
    .4byte  sym_06089E44             /* indexed sprite/scale table (16-bit entries) (MEDIUM) */
.L_rot_dst_b:
    .4byte  sym_060620E8             /* car 0 data struct + 0x10 (rotation dest B) (MEDIUM) */
.L_fn_vec_copy_b:
    .4byte  sym_06031A28             /* vec_scaled_xform_A — sprite submit / scaled transform (MEDIUM) */
.L_fn_mat_xform_a_2:
    .4byte  sym_06026E2E             /* mat_xform_trans_A (dup for reach) (HIGH) */
.L_fn_rot_z_2:
    .4byte  mat_rot_z                /* Z rotation (dup for reach) (HIGH) */
.L_camera_shake_flags:
    .4byte  sym_06082A25             /* camera shake flags byte — bit 1 = shake active (MEDIUM) */
.L_camera_lod_lut:
    .4byte  sym_06044740             /* per-mode LOD lookup table, byte entries indexed by mode (LOW) */
.L_camera_offset_base:
    .4byte  sym_06083258             /* camera LOD offset base pointer (LOW) */
.L_default_lod:                      /* --- default LOD path --- */
    .byte   0xD4, 0x2B    /* mov.l @(0x0600B00C), r4 — sym_06083258: camera LOD offset base */
    mov.l @r4, r4                    ! r4 = default LOD base value (dereference)
.L_apply_lod:
    jsr @r13                         ! transform_matrix(LOD_param) — apply LOD transform
    nop
    extu.w r12, r14                  ! r14 = LOD table index (zero-extended to 32-bit)
    .byte   0xD5, 0x2A    /* mov.l @(0x0600B010), r5 — sym_060621D8: car 3 struct (chain src A) */
    .byte   0xD4, 0x2A    /* mov.l @(0x0600B014), r4 — sym_0606212C: car 1 struct (chain dst A) */
    .byte   0xD3, 0x2B    /* mov.l @(0x0600B018), r3 — sym_06031D8C: vec_matrix_xform_A fn */
    shll2 r14                        ! r14 = index * 4 (stride for pointer arrays)
    add r14, r5                      ! r5 = &car3_struct[index]
    add r14, r4                      ! r4 = &car1_struct[index]
    mov.l @r5, r5                    ! r5 = car3[index] (dereference)
    jsr @r3                          ! vec_matrix_xform_A(car1[idx], car3[idx])
    mov.l @r4, r4                    ! r4 = car1[index] (delay slot: dereference)
    .byte   0xD6, 0x28    /* mov.l @(0x0600B01C), r6 — sym_06062180: car 2 struct (chain src B) */
    .byte   0xD5, 0x29    /* mov.l @(0x0600B020), r5 — sym_06089E44: sprite/scale table (16-bit) */
    .byte   0xD4, 0x29    /* mov.l @(0x0600B024), r4 — sym_060620D8: car 0 struct (chain dst B) */
    .byte   0xD3, 0x2A    /* mov.l @(0x0600B028), r3 — sym_06031A28: vec_scaled_xform_A fn */
    add r14, r6                      ! r6 = &car2_struct[index]
    mov.w @r5, r5                    ! r5 = scale factor (16-bit)
    add r14, r4                      ! r4 = &car0_struct[index]
    mov.l @r6, r6                    ! r6 = car2[index] (dereference)
    jsr @r3                          ! vec_scaled_xform_A(car0[idx], car2[idx], scale)
    mov.l @r4, r4                    ! r4 = car0[index] (delay slot: dereference)
.L_counter_decrement:                /* --- render budget decrement --- */
    .byte   0xD2, 0x27    /* mov.l @(0x0600B02C), r2 — sym_0607EBC4: game mode flags */
    .byte   0xD3, 0x28    /* mov.l @(0x0600B030), r3 — 0x20020000: geometry rendering mask */
    mov.l @r2, r2                    ! r2 = game mode flags value
    and r3, r2                       ! r2 = flags & 0x20020000
    tst r2, r2                       ! test if geometry rendering bits set
    bt      .L_do_decrement          ! if clear -> skip replay_playback call
    .byte   0xD3, 0x26    /* mov.l @(0x0600B034), r3 — replay_playback fn */
    jsr @r3                          ! replay_playback() — geometry rendering dispatch
    nop
.L_do_decrement:
    .byte   0xD4, 0x26    /* mov.l @(0x0600B038), r4 — sym_06089EDC: Stack A matrix ptr (render budget) */
    mov.l @r4, r2                    ! r2 = current Stack A matrix pointer
    add #-0x30, r2                   ! r2 -= 48 (pop one matrix entry = render budget)
    mov.l r2, @r4                    ! write back decremented pointer
    lds.l @r15+, pr
    mov.l @r15+, r11
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14
