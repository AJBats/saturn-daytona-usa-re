/* pre_update_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600E99C - 0x0600EB14
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Pre-frame car update setup — runs AI physics, then projects the car's
 * Y position into screen coordinates for camera targeting. If the car
 * state field at +0x1EC is zero, clears the camera tracking global and
 * resets related car struct fields.
 *
 * Called from the per-car update loop before rendering.
 *
 * Flow:
 *   1. ai_physics_main   — run AI opponent physics pipeline
 *   2. If not in special camera mode:
 *      fpmul(car.Y_pos, 0x066505B3) — project Y coordinate
 *      Store projected result at car[+0xE4] and car[+0xE0]
 *   3. If car[+0x1EC] == 0:
 *      Clear camera tracking global (sym_0607EAD0)
 *      Clear car[+0x228] and car[+0x21C]
 */

    .section .text.FUN_0600E99C


    .global pre_update_setup
    .type pre_update_setup, @function
pre_update_setup:
    mov.l r14, @-r15                   ! save r14 (car struct base)
    sts.l pr, @-r15                    ! save return address
    mov.l   .L_car_state_ptr, r14      ! r14 = &car_state_pointer
    .byte   0xBF, 0xB0    /* bsr 0x0600E906 (external) */  ! call ai_physics_main
    mov.l @r14, r14                    ! (delay) r14 = car struct base
    mov.l   .L_camera_mode_flag, r0    ! r0 = &camera_mode_flag
    mov.l @r0, r0                      ! r0 = camera mode value
    tst r0, r0                         ! test if camera mode == 0
    bf      .L_skip_projection         ! nonzero → skip projection
    mov.l   .L_projection_const, r5    ! r5 = 0x066505B3 (projection constant)
    mov.l   .L_fn_fpmul, r3            ! r3 = &fpmul
    jsr @r3                            ! call fpmul(r4, r5)
    mov.l @(12, r14), r4               ! (delay) r4 = car.Y_position
    shlr16 r0                          ! result >> 16 (fixed-point to integer)
    exts.w r0, r0                      ! sign-extend 16→32 bits
    mov.w   DAT_0600e9e8, r1           ! r1 = 0x00E4 (projected coord A offset)
    add r14, r1                        ! r1 = &car[+0xE4]
    mov.l r0, @r1                      ! car[+0xE4] = projected Y coordinate
    mov.w   DAT_0600e9ea, r1           ! r1 = 0x00E0 (projected coord B offset)
    add r14, r1                        ! r1 = &car[+0xE0]
    mov.l r0, @r1                      ! car[+0xE0] = projected Y coordinate
.L_skip_projection:
    mov.w   .L_wpool_0600E9EC, r0      ! r0 = 0x01EC (car state offset)
    mov.l @(r0, r14), r0               ! r0 = car[+0x1EC] (state field)
    tst r0, r0                         ! test if state == 0
    bf      .L_done                    ! nonzero → skip cleanup, return
    mov #0x0, r4                       ! r4 = 0 (clear value)
    mov.l   .L_camera_tracking_global, r3  ! r3 = &camera_tracking_global
    mov.l r4, @r3                      ! clear camera tracking global
    mov.w   .L_wpool_0600E9E2, r0      ! r0 = 0x0228 (camera target offset)
    mov.l r4, @(r0, r14)               ! car[+0x228] = 0
    add #-0xC, r0                      ! r0 = 0x021C
    mov.l r4, @(r0, r14)               ! car[+0x21C] = 0
.L_done:
    lds.l @r15+, pr                    ! restore return address
    rts                                ! return
    mov.l @r15+, r14                   ! (delay) restore r14
.L_wpool_0600E9E2:
    .2byte  0x0228                     ! word pool: car offset for camera target field

    .global DAT_0600e9e4
DAT_0600e9e4:
    mov.b @(r0, r1), r2
    .word 0x0200 /* UNKNOWN */

    .global DAT_0600e9e8
DAT_0600e9e8:
    .2byte  0x00E4                     ! car offset: projected coordinate A

    .global DAT_0600e9ea
DAT_0600e9ea:
    .2byte  0x00E0                     ! car offset: projected coordinate B
.L_wpool_0600E9EC:
    .2byte  0x01EC                     ! word pool: car state field offset
    .2byte  0xFFFF                     ! alignment padding
    .4byte  friction_stub              ! (adjacent TU pool — not used by this function)
    .4byte  ai_orchestrator            ! (adjacent TU pool — not used by this function)
    .4byte  0x00480000                 ! (adjacent TU pool — not used by this function)
.L_fn_fpmul:
    .4byte  fpmul                      ! fixed-point multiply: (r4*r5)>>16
    .4byte  track_segment_advance      ! (adjacent TU pool — not used by this function)
    .4byte  sym_0607EA9C               ! (adjacent TU pool — not used by this function)
.L_car_state_ptr:
    .4byte  sym_0607E944               ! pointer to current car state struct
.L_camera_mode_flag:
    .4byte  sym_0607EAD8               ! camera mode flag (0 = normal, nonzero = special)
.L_projection_const:
    .4byte  0x066505B3                 ! fixed-point projection constant for Y coordinate
.L_camera_tracking_global:
    .4byte  sym_0607EAD0               ! global camera tracking state variable
    .4byte  0x7FF4952C                 ! byte blob: encoded function (not decoded to mnemonics)
    .4byte  0x354C5351
    .4byte  0x2F325352
    .4byte  0x1F3266F2
    .4byte  0x5753263B
    .4byte  0x267B6352
    .4byte  0x1F31263B
    .4byte  0x273952F2
    .4byte  0x61F22729
    .4byte  0x27192F72
    .4byte  0xD50E2668
    .4byte  0x8D03E700
    .4byte  0x60F2C880
    .4byte  0x89022572
    .4byte  0xA0167F0C
    .4byte  0xE2332629
    .4byte  0x26688901
    .4byte  0xA0092572
    .4byte  0x62527201
    .4byte  0x25229307
    .4byte  0x32338B02
    .4byte  0x2572A007
    .4byte  0x7F0C000B
    .2byte  0x7F0C

    .global DAT_0600ea76
DAT_0600ea76:
    .2byte  0x0120                     ! byte blob: encoded function data (not decoded)
    .4byte  0x00A0FFFF
    .4byte  sym_0605A228
    .4byte  0x903BD31F
    .4byte  0x5244054E
    .4byte  0x63324508
    .4byte  0x45007503
    .4byte  0x45084508
    .4byte  0x353C6652
    .4byte  0x57515346
    .4byte  0x85553628
    .4byte  0x37386203
    .4byte  0x4621534C
    .4byte  0x42084621
    .4byte  0x32384621
    .4byte  0x652FD314
    .4byte  0xE2102322
    .4byte  0x4621D313
    .4byte  0x23624721
    .4byte  0xD3124521
    .4byte  0x47214521
    .4byte  0x47214521
    .4byte  0x47214521
    .4byte  0x2372655F
    .4byte  0xD30E2351
    .4byte  0xE5001453
    .4byte  0x1452900D
    .4byte  0x04567004
    .4byte  0x0456E501
    .4byte  0x703C0456
    .4byte  0x70040456
    .4byte  0x70040456
    .4byte  0x7004000B
    .2byte  0x0456

    .global DAT_0600eafa
DAT_0600eafa:
    .2byte  0x01EC                     ! byte blob: constant pool for encoded function
    .4byte  0x00E0FFFF
    .4byte  sym_0607EB88
    .4byte  sym_060786BC
    .4byte  sym_060786C0
    .4byte  sym_060786C4
    .4byte  sym_060786C8
