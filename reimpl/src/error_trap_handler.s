/* error_trap_handler -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041382 - 0x0604140E
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Error trap registration — validates two slot indices and registers an
 * event with four parameters in the AI/game state structure. If both slots
 * are active and the event channel is not already in use, stores the
 * parameters at state offsets +0x034C..+0x0358, marks the channel active,
 * and triggers track edge validation.
 *
 * Parameters:
 *   r4 = first slot index (byte offset into status array at state+0x18)
 *   r5 = second slot index (byte offset into status array at state+0x18)
 *   r6 = event param 3 (stored at state+0x0354)
 *   r7 = event param 4 (stored at state+0x0358)
 *
 * Returns:
 *   r0 = 0 on success (event registered and validated)
 *   r0 = -7 if either slot is not active (status byte == 0)
 *   r0 = -1 if event channel already in use (state[+0x348] != 0)
 *
 * Game state struct (base = *sym_060A5400):
 *   +0x18  = per-slot status byte array (nonzero = active)
 *   +0x348 = event channel active flag (0 = free, 1 = in use)
 *   +0x34C = event param 1 (r4)
 *   +0x350 = event param 2 (r5)
 *   +0x354 = event param 3 (r6)
 *   +0x358 = event param 4 (r7)
 *
 * Calls:
 *   track_edge_validate (BSR 0x06041EE8) — post-registration validation
 */

    .section .text.FUN_06041382


    .global error_trap_handler
    .type error_trap_handler, @function
error_trap_handler:
    mov.l r14, @-r15                                   ! save r14 (callee-saved)
    sts.l pr, @-r15                                    ! save return address
    add #-0x8, r15                                     ! allocate 8 bytes of stack space
    .byte   0xDE, 0x1A    /* mov.l .L_pool_state_base_ptr, r14 */  ! r14 = &sym_060A5400 (state base indirect ptr)
    mov.l @r14, r3                                     ! r3 = *sym_060A5400 (state base address)
    add #0x18, r3                                      ! r3 = &state[+0x18] (slot status array)
    mov.l r3, @(4, r15)                                ! stash status array ptr on stack
    add r4, r3                                         ! r3 = &state[+0x18 + r4] (first slot status)
    mov.b @r3, r3                                      ! r3 = status byte for slot r4
    tst r3, r3                                         ! is first slot inactive (zero)?
    bt      .L_slot_inactive                           ! yes -> return -7
    mov.l @(4, r15), r3                                ! r3 = status array ptr (reload from stack)
    add r5, r3                                         ! r3 = &state[+0x18 + r5] (second slot status)
    mov.b @r3, r3                                      ! r3 = status byte for slot r5
    tst r3, r3                                         ! is second slot inactive (zero)?
    bf      .L_both_slots_active                       ! no (nonzero) -> both slots active, continue
.L_slot_inactive:
    mov #-0x7, r0                                      ! r0 = -7 (slot not active error)
    add #0x8, r15                                      ! free stack space
    lds.l @r15+, pr                                    ! restore return address
    rts                                                ! return -7
    mov.l @r15+, r14                                   ! restore r14 (delay slot)
.L_both_slots_active:
    mov.l @r14, r3                                     ! r3 = state base address
    mov.w   .L_wpool_060413EE, r0                      ! r0 = 0x0348 (event channel flag offset)
    mov.l @(r0, r3), r0                                ! r0 = state[+0x348] (event active flag)
    tst r0, r0                                         ! is event channel free (zero)?
    bt      .L_channel_free                            ! yes -> register the event
    mov #-0x1, r0                                      ! r0 = -1 (channel already in use)
    add #0x8, r15                                      ! free stack space
    lds.l @r15+, pr                                    ! restore return address
    rts                                                ! return -1
    mov.l @r15+, r14                                   ! restore r14 (delay slot)
.L_channel_free:
    mov.l @r14, r3                                     ! r3 = state base address
    mov #0x1, r2                                       ! r2 = 1 (active flag value)
    mov.w   .L_wpool_060413EE, r0                      ! r0 = 0x0348 (event channel flag offset)
    mov.l r2, @(r0, r3)                                ! state[+0x348] = 1 (mark channel active)
    mov.l @r14, r3                                     ! r3 = state base address
    add #0x4, r0                                       ! r0 = 0x034C (param 1 offset)
    mov.l r4, @(r0, r3)                                ! state[+0x34C] = r4 (first slot index)
    add #0x4, r0                                       ! r0 = 0x0350 (param 2 offset)
    mov.l @r14, r3                                     ! r3 = state base address
    mov.l r5, @(r0, r3)                                ! state[+0x350] = r5 (second slot index)
    mov.l @r14, r3                                     ! r3 = state base address
    add #0x4, r0                                       ! r0 = 0x0354 (param 3 offset)
    mov.l r6, @(r0, r3)                                ! state[+0x354] = r6 (event param 3)
    add #0x4, r0                                       ! r0 = 0x0358 (param 4 offset)
    mov.l @r14, r3                                     ! r3 = state base address
    mov.l r7, @(r0, r3)                                ! state[+0x358] = r7 (event param 4)
    .byte   0xB5, 0x82    /* bsr 0x06041EE8 (external) */  ! call track_edge_validate
    mov r15, r4                                        ! r4 = stack pointer (delay slot; iteration counter ptr)
    mov #0x0, r0                                       ! r0 = 0 (success)
    add #0x8, r15                                      ! free stack space
    lds.l @r15+, pr                                    ! restore return address
    rts                                                ! return 0
    mov.l @r15+, r14                                   ! restore r14 (delay slot)
.L_wpool_060413EE:
    .2byte  0x0348
    .4byte  ai_recovery_handler
.L_pool_state_base_ptr:
    .4byte  sym_060A5400
    .4byte  0xD3149026
    .4byte  0x6332003E
    .4byte  0x20088901
    .4byte  0x000BE000
    .4byte  0xE001000B
    .2byte  0x0009
