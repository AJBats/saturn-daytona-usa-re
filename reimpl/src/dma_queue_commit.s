/* dma_queue_commit -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06007D8E - 0x06007E08
 * Auto-generated by tools/generate_l3_tu.py
 *
 * dma_queue_commit:
 *   Waits for the SH-2 Free-Running Timer overflow (OVF bit in FTCSR),
 *   then clears the overflow flags and adjusts the DMA render budget
 *   counter at sym_0605A1C0. If the timer had NOT yet overflowed on
 *   entry (r4=0 path), the budget is increased by 10; if it was already
 *   overflowing (r4=1 path), the budget is decreased by 10. Finally,
 *   tail-calls render finalize (sym_0603C000).
 *
 * Register plan:
 *   r12 = 1 (constant, used to signal "was already overflowed")
 *   r13 = 0xFFFFFE11 (SH2_FTCSR — FRT Control/Status Register)
 *   r14 = 0x0080 (OVF bitmask — bit 7 of FTCSR)
 *   r4  = overflow-was-pending flag (0=no, 1=yes)
 *   r5  = &sym_0605A1C0 (DMA render budget counter, 16-bit word)
 *
 * Pool entries between .L_wpool_06007DA0 and the code at .L_ovf_retry
 * belong to the preceding TU (dma_queue_mgr) and are not referenced
 * by this function.
 *
 * Tail-calls: sym_0603C000 (render finalize)
 */

    .section .text.FUN_06007D8E


    .global dma_queue_commit
    .type dma_queue_commit, @function
dma_queue_commit:
    mov.l r14, @-r15                    ! save r14 on stack
    mov.l r13, @-r15                    ! save r13 on stack
    mov.l r12, @-r15                    ! save r12 on stack
    mov #0x1, r12                       ! r12 = 1 (constant: "overflow was pending" flag)
    mov.w   .L_wpool_06007D9E, r13      ! r13 = 0xFFFFFE11 (SH2_FTCSR address)
    mov.w   .L_wpool_06007DA0, r14      ! r14 = 0x0080 (OVF bitmask, bit 7)
    bra     .L_ovf_poll                 ! jump to overflow poll loop
    mov #0x0, r4                        ! r4 = 0 (overflow not yet seen) [delay slot]
.L_wpool_06007D9E:
    .2byte  0xFE11
.L_wpool_06007DA0:
    .2byte  0x0080
    .2byte  0xFFFF
    .4byte  sym_060281B8
    .4byte  sym_0606A4F8
    .4byte  0x00008000
    .4byte  sym_0608AC20
    .4byte  sym_06078624
    .4byte  sym_0603C000
    .4byte  sym_060280F8
    .4byte  sym_06078620
    .4byte  0x0000FFFF
    .4byte  0x21800000
.L_ovf_retry:
    mov r12, r4                         ! r4 = 1 (mark that overflow was already pending)
.L_ovf_poll:
    mov.b @r13, r2                      ! r2 = FTCSR byte (FRT status register)
    extu.b r2, r2                       ! zero-extend byte to 32 bits
    and r14, r2                         ! r2 = FTCSR & 0x80 (isolate OVF bit)
    cmp/eq r14, r2                      ! is OVF bit set?
    bf      .L_ovf_retry                ! no — loop back, set r4=1 (waited at least once)
    mov.b @r13, r0                      ! r0 = FTCSR byte (re-read for clearing)
    and #0xF, r0                        ! r0 = FTCSR & 0x0F (clear upper 4 status bits, keep lower 4)
    mov.b r0, @r13                      ! write back to FTCSR (acknowledge OVF + other flags)
    .byte   0xD5, 0x08    /* mov.l .L_pool_render_budget, r5 */  ! r5 = &sym_0605A1C0 (render budget counter)
    tst r4, r4                          ! was overflow already pending on entry?
    bt      .L_budget_increase          ! if r4==0 (first poll succeeded): increase budget
    mov.w @r5, r3                       ! r3 = current render budget (16-bit word)
    add #-0xA, r3                       ! r3 -= 10 (decrease budget — frame took too long)
    mov.w r3, @r5                       ! store decreased budget
    bra     .L_epilogue                 ! skip to function exit
    nop                                 ! delay slot
.L_budget_increase:
    mov.w @r5, r2                       ! r2 = current render budget (16-bit word)
    add #0xA, r2                        ! r2 += 10 (increase budget — frame completed in time)
    mov.w r2, @r5                       ! store increased budget
.L_epilogue:
    mov.l @r15+, r12                    ! restore r12 from stack
    mov.l @r15+, r13                    ! restore r13 from stack
    .byte   0xD3, 0x02    /* mov.l .L_pool_render_finalize, r3 */  ! r3 = sym_0603C000 (render finalize)
    jmp @r3                             ! tail-call render finalize
    mov.l @r15+, r14                    ! restore r14 from stack [delay slot]
    .2byte  0xFFFF
.L_pool_render_budget:
    .4byte  sym_0605A1C0
.L_pool_render_finalize:
    .4byte  sym_0603C000
