/* track_boundary_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06041AA0 - 0x06041B3C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Manages the two-phase boundary-crossing state machine for channel 1 of the
 * AI/game event system (state[+0x0304]).
 *
 *   Phase 1 (state[+0x0304] == 1): segment boundary detected.
 *     - Call track_seg_boundary(state[+0x0308], r4) to compute boundary result.
 *     - Store result byte to state[+0x40] (busy_flag / output field).
 *     - Increment counter at *r4_in (caller-supplied counter pointer).
 *     - Advance state to phase 2 (set state[+0x0304] = 2).
 *     - Then fall through to validate checkpoint (ai_checkpoint_validate).
 *   Phase 2 (state[+0x0304] == 2): waiting for HIRQ condition.
 *     - Call sym_06035C4E (HIRQ/CD status reader) — return value held in r0.
 *     - Sign-extend low word, AND with 0x40 (bit 6).
 *     - If bit set: boundary confirmed, clear state[+0x0304] = 0.
 *     - If bit clear: not yet ready, leave state unchanged.
 *
 * Entry:
 *   r4 = pointer to a caller-managed counter (incremented when phase 1 fires)
 * Returns:
 *   r0 = final value of state[+0x0304] (0 after confirmation, 2 while waiting)
 *
 * Key symbols:
 *   sym_060A5400         -- global AI/game state base pointer (indirect)
 *   track_seg_boundary   -- compute track segment boundary result
 *   ai_checkpoint_validate -- validate AI checkpoint from stack buffer
 *   sym_06035C4E         -- read HIRQ/CD status word
 *   DAT_06041b0a (0x0304) -- state struct offset: channel 1 boundary phase
 *   0x0308               -- state struct offset: channel 1 segment argument
 *   0x40                 -- state struct offset: output/busy field
 */

    .section .text.FUN_06041AA0


    .global track_boundary_check
    .type track_boundary_check, @function
track_boundary_check:
    mov.l r14, @-r15             ! save r14 (callee-saved)
    sts.l pr, @-r15              ! save return address
    add #-0x10, r15              ! allocate 16 bytes of stack frame
    mov.l   .L_pool_state_base, r14  ! r14 = &sym_060A5400 (ptr-to-state-base)
    mov.l r4, @r15               ! stack[+0x00] = r4 (input counter pointer)
    mov.l @r14, r0               ! r0 = state base address
    mov.w   DAT_06041b0a, r1     ! r1 = 0x0304 (channel 1 boundary phase offset)
    mov.l @(r0, r1), r0          ! r0 = state[+0x0304] (boundary phase)
    cmp/eq #0x1, r0              ! phase == 1?
    bf      .L_skip_phase1       ! no — skip phase 1 block
    mov.l @r14, r4               ! r4 = state base
    mov.w   .L_wpool_06041B0C, r0  ! r0 = 0x0308 (channel 1 segment arg offset)
    mov.l   .L_pool_track_seg_boundary, r3  ! r3 = &track_seg_boundary
    jsr @r3                      ! call track_seg_boundary(r4=state_base, r5=state[+0x0308])
    mov.l @(r0, r4), r4          ! (delay slot) r4 = state[+0x0308] (segment arg -> r5 shifted)
    mov r0, r4                   ! r4 = return value from track_seg_boundary
    mov.l @r15, r2               ! r2 = stack[+0x00] = input counter pointer
    mov.l @r2, r3                ! r3 = *counter (current count)
    add #0x1, r3                 ! increment counter
    tst r4, r4                   ! result == 0?
    bf/s    .L_skip_state_update  ! if non-zero: skip writing phase=2 (delay slot still runs)
    mov.l r3, @r2                ! (delay slot) store incremented counter
    mov.l @r14, r3               ! r3 = state base
    mov #0x2, r2                 ! r2 = 2 (advance to phase 2)
    mov.w   DAT_06041b0a, r0     ! r0 = 0x0304 (boundary phase offset)
    mov.l r2, @(r0, r3)          ! state[+0x0304] = 2 (transition to phase 2)
.L_skip_state_update:
    mov r15, r4                  ! r4 = stack frame base (output buffer for validate)
    mov.l   .L_pool_ai_checkpoint_validate, r3  ! r3 = &ai_checkpoint_validate
    jsr @r3                      ! call ai_checkpoint_validate(r4=stack_buf)
    add #0x4, r4                 ! (delay slot) r4 = stack+4 (checkpoint output area)
    mov.l @r14, r2               ! r2 = state base
    mov r15, r3                  ! r3 = stack frame base
    add #0x4, r3                 ! r3 = stack+4 (result byte location)
    mov.b @r3, r1                ! r1 = byte result from checkpoint validate
    mov #0x40, r0                ! r0 = 0x40 (busy_flag offset)
    mov.b r1, @(r0, r2)          ! state[+0x40] = result byte
.L_skip_phase1:
    mov.l @r14, r0               ! r0 = state base
    mov.w   DAT_06041b0a, r1     ! r1 = 0x0304 (boundary phase offset)
    mov.l @(r0, r1), r0          ! r0 = state[+0x0304] (current phase)
    cmp/eq #0x2, r0              ! phase == 2?
    bf      .L_return            ! no — skip phase 2 block, go to return
    mov #0x40, r2                ! r2 = 0x40 (bit mask to test: bit 6)
    mov.l   .L_pool_hirq_status, r3  ! r3 = &sym_06035C4E (HIRQ status reader)
    jsr @r3                      ! call sym_06035C4E() — read HIRQ/CD status
    mov.l r2, @r15               ! (delay slot) stack[+0x00] = 0x40 (AND mask)
    mov r0, r5                   ! r5 = raw status word from sym_06035C4E
    mov.l @r15, r3               ! r3 = 0x40 (AND mask from stack)
    exts.w r5, r4                ! r4 = sign-extended low word of status
    and r3, r4                   ! r4 = status & 0x40 (test bit 6)
    tst r4, r4                   ! bit 6 clear?
    bt      .L_bit_clear         ! yes — bit not set, boundary not confirmed
    bra     .L_bit_set_exit      ! no — bit set, boundary confirmed
    mov #0x1, r4                 ! (delay slot) r4 = 1 (bit-set result)

    .global DAT_06041b0a
DAT_06041b0a:
    .2byte  0x0304               ! state struct offset: channel 1 boundary phase
.L_wpool_06041B0C:
    .2byte  0x0308               ! state struct offset: channel 1 segment argument
    .2byte  0xFFFF
.L_pool_state_base:
    .4byte  sym_060A5400
.L_pool_track_seg_boundary:
    .4byte  track_seg_boundary
.L_pool_ai_checkpoint_validate:
    .4byte  ai_checkpoint_validate
.L_pool_hirq_status:
    .4byte  sym_06035C4E
.L_bit_clear:
    mov #0x0, r4                 ! r4 = 0 (bit not set — boundary not yet confirmed)
.L_bit_set_exit:
    tst r4, r4                   ! r4 == 0?
    bt      .L_return            ! yes — not confirmed, leave state unchanged
    mov.l @r14, r3               ! r3 = state base
    mov #0x0, r2                 ! r2 = 0 (clear boundary phase)
    .byte   0x90, 0x4C    /* mov.w .L_wpool_06041BC6, r0 */
    mov.l r2, @(r0, r3)          ! state[+0x0304] = 0 (boundary confirmed, reset phase)
.L_return:
    mov.l @r14, r0               ! r0 = state base
    .byte   0x91, 0x49    /* mov.w .L_wpool_06041BC6, r1 */
    mov.l @(r0, r1), r0          ! r0 = state[+0x0304] (final phase value — return value)
    add #0x10, r15               ! deallocate stack frame
    lds.l @r15+, pr              ! restore return address
    rts                          ! return r0 = current boundary phase
    mov.l @r15+, r14             ! (delay slot) restore r14
