/* sprite_pair_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06026590 - 0x060266CC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Clears and rebuilds sprite priority masks for render slot elements.
 *
 * Two paths depending on the slot count sentinel (r5):
 *   - r5 == 0xA9 (sentinel): variant A — 10 render record entries, uses
 *     render_record_ptr_table_a (sym_06061170) and calls
 *     transform_rotation_apply for mode 4.
 *   - r5 != 0xA9: variant B — 8 render record entries, uses
 *     render_record_ptr_table_b (sym_06061184) and calls
 *     transform_rotation_alt for mode 4.
 *
 * Processing phases:
 *   1. Clear phase: iterates the 14-entry slot element table (12-byte stride),
 *      writing zero to the priority word at both write_ptr_a (+0) and
 *      write_ptr_b (+4) for each entry pair (processes 2 entries per iteration).
 *   2. Optional rotation: if mode == 4, calls transform_rotation_apply (A)
 *      or transform_rotation_alt (B) to compute sprite rotation state.
 *   3. OR-merge phase: iterates render records (10 for A, 8 for B) in 8-byte
 *      stride. For each non-null record, reads the destination ptr and a
 *      mask word, then ORs the mask into the destination's priority word.
 *   4. Copy-back phase (mode 4 only): iterates the slot element table again,
 *      reading the priority word from write_ptr_b and copying it to write_ptr_a,
 *      propagating the merged results back.
 *
 * Arguments:
 *   r4 = mode byte (sign-extended; mode 4 triggers rotation + copy-back)
 *   r5 = slot count sentinel (0xA9 = variant A / 10 slots, else variant B / 8 slots)
 *
 * Persistent registers:
 *   r8  = slot_table_size (0x00A8 = 14 entries * 12 bytes, end offset)
 *   r9  = 0x40 (render record count B * 8 = 8 entries * 8 bytes)
 *   r10 = mode << 2 + render_record_ptr_table base (for table lookup)
 *   r11 = 0x50 (render record count A * 8 = 10 entries * 8 bytes)
 *   r12 = mode (from r4, sign-extended byte)
 *   r13 = slot_element_table base (sym_060610BC, 12-byte stride)
 *   r14 = 0 (zero constant, used for clearing)
 */

    .section .text.FUN_06026590


    .global sprite_pair_render
    .type sprite_pair_render, @function
sprite_pair_render:
    mov.l r14, @-r15                        ! save r14
    extu.w r5, r5                           ! zero-extend slot sentinel to 16 bits
    mov.l r13, @-r15                        ! save r13
    mov #0x0, r14                           ! r14 = 0 (zero constant for clearing)
    mov.l r12, @-r15                        ! save r12
    mov.l r11, @-r15                        ! save r11
    mov.l r10, @-r15                        ! save r10
    mov #0x50, r11                          ! r11 = 0x50 (variant A: 10 records * 8 bytes)
    mov.l r9, @-r15                         ! save r9
    mov #0x40, r9                           ! r9 = 0x40 (variant B: 8 records * 8 bytes)
    mov.l r8, @-r15                         ! save r8
    sts.l pr, @-r15                         ! save return address
    mov.w   .L_slot_table_size, r8          ! r8 = 0x00A8 (slot element table total bytes)
    mov.l   .L_slot_element_table, r13      ! r13 = slot_element_table base (sym_060610BC)
    mov r8, r3                              ! r3 = 0xA8
    add #0x1, r3                            ! r3 = 0xA9 (slot sentinel value)
    cmp/eq r3, r5                           ! is slot sentinel == 0xA9? (variant A?)
    bf/s    .L_variant_b_clear              ! branch if variant B (r5 != 0xA9)
    mov r4, r12                             ! r12 = mode arg (delay slot)
    /* --- Variant A path: 10 render record entries --- */
    mov r13, r4                             ! r4 = current slot element ptr (iterator)
    mov r13, r6                             ! r6 = slot_element_table base
    add r8, r6                              ! r6 = slot_element_table + 0xA8 (end sentinel)
.L_clear_loop_a:
    mov r4, r5                              ! r5 = current entry ptr (for @(4,r5) access)
    extu.w r14, r1                          ! r1 = 0 (zero, unsigned)
    mov.l @r4, r3                           ! r3 = entry[i].write_ptr_a (dest ptr A)
    mov.l @(4, r5), r2                      ! r2 = entry[i].write_ptr_b (dest ptr B)
    add #0xC, r4                            ! advance to next entry (+12 byte stride)
    mov.w r14, @r2                          ! clear priority word at write_ptr_b
    mov r4, r5                              ! r5 = next entry ptr (for @(4,r5) access)
    mov.w r14, @r3                          ! clear priority word at write_ptr_a
    mov.l @r4, r3                           ! r3 = entry[i+1].write_ptr_a
    mov.l @(4, r5), r2                      ! r2 = entry[i+1].write_ptr_b
    add #0xC, r4                            ! advance to next entry (+12 byte stride)
    mov.w r1, @r2                           ! clear priority word at write_ptr_b
    mov.w r1, @r3                           ! clear priority word at write_ptr_a
    cmp/hs r6, r4                           ! has iterator reached end of table?
    bf      .L_clear_loop_a                 ! loop if more entries remain
    /* --- Check if mode == 4 for rotation call --- */
    exts.b r12, r0                          ! r0 = mode (sign-extended byte)
    cmp/eq #0x4, r0                         ! mode == 4?
    bf      .L_skip_rotation_a              ! skip rotation if mode != 4
    .byte   0xBE, 0xBF    /* bsr 0x06026362 (external) */
    nop                                     ! (delay slot) call transform_rotation_apply
.L_skip_rotation_a:
    mov r14, r5                             ! r5 = 0 (record byte offset, increments by 8)
    mov r14, r4                             ! r4 = 0 (record byte offset, increments by 8)
    exts.b r12, r10                         ! r10 = mode (sign-extended)
    shll2 r10                               ! r10 = mode * 4 (index into ptr table)
    mov.l   .L_render_record_ptr_table_a, r3 ! r3 = render_record_ptr_table_a base
    bra     .L_merge_check_a                ! jump to loop condition check
    add r3, r10                             ! r10 = &render_record_ptr_table_a[mode] (delay slot)
.L_merge_loop_a:
    mov.l @r10, r3                          ! r3 = render_record_base (from ptr table)
    add r4, r3                              ! r3 = &render_record[i] (current record)
    mov.l @r3, r0                           ! r0 = record[i].dest_ptr
    tst r0, r0                              ! is dest_ptr null?
    bf      .L_merge_apply_a               ! branch if non-null (has data to merge)
    bra     .L_merge_next_a                 ! skip this entry
    nop                                     ! (delay slot)
.L_merge_apply_a:
    mov.l @r10, r6                          ! r6 = render_record_base (reload)
    add r5, r6                              ! r6 = &render_record[i] (via offset r5)
    mov.l @r6, r3                           ! r3 = record[i].dest_ptr
    mov.w @(4, r6), r0                      ! r0 = record[i].mask_word (+4 offset)
    mov r0, r2                              ! r2 = mask_word
    extu.w r2, r2                           ! zero-extend mask to 16 bits
    mov.w @r3, r1                           ! r1 = current priority word at dest
    or r2, r1                               ! OR in the new mask bits
    mov.w r1, @r3                           ! write merged priority word back
.L_merge_next_a:
    add #0x8, r5                            ! advance offset by record stride (8 bytes)
    add #0x8, r4                            ! advance offset by record stride (8 bytes)
.L_merge_check_a:
    cmp/hs r11, r4                          ! has offset reached 0x50 (10 records)?
    bf      .L_merge_loop_a                 ! loop if more records remain
    bra     .L_post_merge                   ! done with variant A merge, go to copy-back
    nop                                     ! (delay slot)
.L_variant_b_clear:
    /* --- Variant B path: 8 render record entries --- */
    mov r13, r4                             ! r4 = current slot element ptr (iterator)
    mov r13, r6                             ! r6 = slot_element_table base
    add r8, r6                              ! r6 = slot_element_table + 0xA8 (end sentinel)
.L_clear_loop_b:
    mov r4, r5                              ! r5 = current entry ptr (for @(4,r5) access)
    extu.w r14, r1                          ! r1 = 0 (zero, unsigned)
    mov.l @r4, r2                           ! r2 = entry[i].write_ptr_a
    mov.l @(4, r5), r3                      ! r3 = entry[i].write_ptr_b
    add #0xC, r4                            ! advance to next entry (+12 byte stride)
    mov.w r14, @r3                          ! clear priority word at write_ptr_b
    mov r4, r5                              ! r5 = next entry ptr (for @(4,r5) access)
    mov.w r14, @r2                          ! clear priority word at write_ptr_a
    mov.l @r4, r3                           ! r3 = entry[i+1].write_ptr_a
    mov.l @(4, r5), r2                      ! r2 = entry[i+1].write_ptr_b
    add #0xC, r4                            ! advance to next entry (+12 byte stride)
    mov.w r1, @r2                           ! clear priority word at write_ptr_b
    mov.w r1, @r3                           ! clear priority word at write_ptr_a
    cmp/hs r6, r4                           ! has iterator reached end of table?
    bf      .L_clear_loop_b                 ! loop if more entries remain
    /* --- Check if mode == 4 for rotation call --- */
    exts.b r12, r0                          ! r0 = mode (sign-extended byte)
    cmp/eq #0x4, r0                         ! mode == 4?
    bf      .L_skip_rotation_b              ! skip rotation if mode != 4
    .byte   0xBF, 0x21    /* bsr 0x0602648E (external) */
    nop                                     ! (delay slot) call transform_rotation_alt
.L_skip_rotation_b:
    mov r14, r5                             ! r5 = 0 (record byte offset)
    mov r14, r4                             ! r4 = 0 (record byte offset)
    exts.b r12, r10                         ! r10 = mode (sign-extended)
    shll2 r10                               ! r10 = mode * 4 (index into ptr table)
    mov.l   .L_render_record_ptr_table_b, r3 ! r3 = render_record_ptr_table_b base
    bra     .L_merge_check_b                ! jump to loop condition check
    add r3, r10                             ! r10 = &render_record_ptr_table_b[mode] (delay slot)
.L_merge_loop_b:
    mov.l @r10, r3                          ! r3 = render_record_base (from ptr table)
    add r4, r3                              ! r3 = &render_record[i]
    mov.l @r3, r0                           ! r0 = record[i].dest_ptr
    tst r0, r0                              ! is dest_ptr null?
    bf      .L_merge_apply_b               ! branch if non-null
    bra     .L_merge_next_b                 ! skip this entry
    nop                                     ! (delay slot)
.L_slot_table_size:
    .2byte  0x00A8                          /* 14 entries * 12 bytes = 168 = 0xA8 */
    .2byte  0xFFFF                          /* padding / unused */
.L_slot_element_table:
    .4byte  sym_060610BC                    /* slot element table (12-byte stride) */
.L_render_record_ptr_table_a:
    .4byte  sym_06061170                    /* render record ptr table A (5 x 4-byte ptrs) */
.L_render_record_ptr_table_b:
    .4byte  sym_06061184                    /* render record ptr table B (5 x 4-byte ptrs) */
.L_merge_apply_b:
    mov.l @r10, r6                          ! r6 = render_record_base (reload)
    add r5, r6                              ! r6 = &render_record[i] (via offset r5)
    mov.l @r6, r3                           ! r3 = record[i].dest_ptr
    mov.w @(4, r6), r0                      ! r0 = record[i].mask_word (+4 offset)
    mov r0, r2                              ! r2 = mask_word
    extu.w r2, r2                           ! zero-extend mask to 16 bits
    mov.w @r3, r1                           ! r1 = current priority word at dest
    or r2, r1                               ! OR in the new mask bits
    mov.w r1, @r3                           ! write merged priority word back
.L_merge_next_b:
    add #0x8, r5                            ! advance offset by record stride (8 bytes)
    add #0x8, r4                            ! advance offset by record stride (8 bytes)
.L_merge_check_b:
    cmp/hs r9, r4                           ! has offset reached 0x40 (8 records)?
    bf      .L_merge_loop_b                 ! loop if more records remain
.L_post_merge:
    /* --- Copy-back phase (mode 4 only) --- */
    exts.b r12, r0                          ! r0 = mode (sign-extended byte)
    cmp/eq #0x4, r0                         ! mode == 4?
    bf      .L_epilogue                     ! skip copy-back if mode != 4
    mov r13, r4                             ! r4 = slot_element_table ptr (iterator)
    mov r13, r6                             ! r6 = slot_element_table base
    add r8, r6                              ! r6 = slot_element_table + 0xA8 (end sentinel)
.L_copyback_loop:
    mov r4, r5                              ! r5 = current entry ptr (for @(4,r5) access)
    mov.l @r4, r2                           ! r2 = entry[i].write_ptr_a
    mov.l @(4, r5), r3                      ! r3 = entry[i].write_ptr_b
    add #0xC, r4                            ! advance to next entry (+12 byte stride)
    mov.w @r3, r1                           ! r1 = priority word from write_ptr_b
    mov r4, r5                              ! r5 = next entry ptr (for @(4,r5) access)
    mov.w r1, @r2                           ! copy priority word to write_ptr_a
    mov.l @r4, r3                           ! r3 = entry[i+1].write_ptr_a
    mov.l @(4, r5), r2                      ! r2 = entry[i+1].write_ptr_b
    add #0xC, r4                            ! advance to next entry (+12 byte stride)
    mov.w @r2, r1                           ! r1 = priority word from write_ptr_b
    mov.w r1, @r3                           ! copy priority word to write_ptr_a
    cmp/hs r6, r4                           ! has iterator reached end of table?
    bf      .L_copyback_loop                ! loop if more entries remain
.L_epilogue:
    lds.l @r15+, pr                         ! restore return address
    mov.l @r15+, r8                         ! restore r8
    mov.l @r15+, r9                         ! restore r9
    mov.l @r15+, r10                        ! restore r10
    mov.l @r15+, r11                        ! restore r11
    mov.l @r15+, r12                        ! restore r12
    mov.l @r15+, r13                        ! restore r13
    rts                                     ! return to caller
    mov.l @r15+, r14                        ! restore r14 (delay slot)
