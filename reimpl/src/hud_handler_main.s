/* hud_handler_main -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601E810 - 0x0601E958
 * Auto-generated by tools/generate_l3_tu.py
 *
 * HUD handler main entry point — called from the per-frame render pipeline.
 *
 * Initializes HUD element rendering for the current frame:
 *   1. Clamps display name strings to safe lengths (11 / 10 chars max)
 *   2. Calls geom_display_proc to decode geometry display parameters
 *   3. Copies the HUD output struct and entry name string into the
 *      HUD work area (sym_060877B4) via smpc_cmd_helper_a (memcpy-like)
 *   4. Clears the "dirty" flag at work_area[0x17]
 *   5. Calls vtable dispatch slot 10 to compute render parameters,
 *      stores result at work_area[24]
 *   6. Loads course size from sym_0604A5C0 per player index, stores
 *      at work_area[28]
 *   7. Brackets the actual HUD element dispatch call with SMPC
 *      RESDISA (0x1A) / RESENAB (0x19) for inter-CPU synchronization
 *   8. Dispatches the HUD element's display function via vtable slot 4
 *      using the element's display ID from field +0x1C
 *
 * Arguments:
 *   r4 = element index (word, saved to stack)
 *   r5 = HUD output struct pointer (name string at byte 0)
 *   r6 = callback/extra parameter (saved to stack)
 *
 * Returns:
 *   r0 = result from HUD element display dispatch
 *
 * Key data structures:
 *   sym_0605E06C = entry string table ("DAYTONA   ", etc.), 11 bytes per entry
 *   sym_060877D8 = current player/car index (byte)
 *   sym_060877B4 = HUD work area struct:
 *       [0..11]  = HUD output struct copy (from r5)
 *       [12..22] = entry name string copy
 *       [0x17]   = dirty flag (cleared to 0 each frame)
 *       [24]     = vtable dispatch result (render params)
 *       [28]     = course size for current player
 *   sym_060877E8 = geom display parameter block
 *   sym_06087094 = HUD element array (0x20 bytes per element, field +0x1C = display ID)
 *   sym_06000354 = function dispatch table pointer
 *   sym_0604A5C0 = course size table (4 bytes per entry, indexed by player)
 */

    .section .text.FUN_0601E810


    .global hud_handler_main
    .type hud_handler_main, @function
hud_handler_main:
    mov.l r14, @-r15               ! save r14
    mov r4, r0                     ! r0 = element index (arg1)
    mov.l r13, @-r15               ! save r13
    mov #0x1, r14                  ! r14 = 1 (SMPC SF bit mask, used throughout)
    mov.l r12, @-r15               ! save r12
    mov.l r11, @-r15               ! save r11
    mov.l r10, @-r15               ! save r10
    mov #0xB, r11                  ! r11 = 11 (entry name stride / max name length)
    mov.l r9, @-r15                ! save r9
    mov r5, r9                     ! r9 = HUD output struct pointer (arg2)
    mov.l r8, @-r15                ! save r8
    sts.l pr, @-r15                ! save return address
    sts.l macl, @-r15              ! save macl (used for mul.l)
    add #-0x8, r15                 ! allocate 8 bytes: [sp+0]=callback param, [sp+4]=element index (word)
    mov.l   .L_pool_entry_table, r8 ! r8 = entry string table base (sym_0605E06C, "DAYTONA   " etc.)
    mov.l   .L_pool_player_index, r10 ! r10 = &player_index byte (sym_060877D8)
    mov.l   .L_smpc_sf, r13       ! r13 = 0x20100063 (SMPC SF register, cache-through)
    mov.w r0, @(4, r15)           ! [sp+4] = element index (save as word)
    mov.l r6, @r15                 ! [sp+0] = callback/extra parameter (arg3)
    mov.l   .L_pool_strlen_fn, r3  ! r3 = strlen function (sym_06035C1C)
    jsr @r3                        ! call strlen(r4=hud_output_struct)
    mov r9, r4                     ! (delay) r4 = HUD output struct pointer
    cmp/gt r11, r0                 ! strlen result > 11?
    bf      .L_name_ok             ! no: skip truncation
    mov #0x0, r3                   ! r3 = 0 (null terminator)
    mov r3, r0                     ! r0 = 0
    mov.b r0, @(11, r9)           ! hud_output_struct[11] = '\0' (truncate name to 11 chars)
.L_name_ok:
    mov.b @r10, r4                 ! r4 = current player/car index byte
    mov.l   .L_pool_strlen_fn, r3  ! r3 = strlen function
    extu.b r4, r4                  ! zero-extend player index
    mul.l r11, r4                  ! macl = player_index * 11 (entry name stride)
    sts macl, r4                   ! r4 = player_index * 11
    jsr @r3                        ! call strlen(r4=&entry_table[player*11])
    add r8, r4                     ! (delay) r4 = entry_table + player_index * 11
    mov #0xA, r2                   ! r2 = 10 (max entry name length for table entries)
    cmp/gt r2, r0                  ! strlen result > 10?
    bf      .L_entry_name_ok       ! no: skip truncation
    mov.b @r10, r2                 ! r2 = player index byte
    extu.b r2, r2                  ! zero-extend
    mul.l r11, r2                  ! macl = player_index * 11
    sts macl, r2                   ! r2 = player_index * 11
    add r8, r2                     ! r2 = &entry_table[player*11]
    mov #0x0, r3                   ! r3 = 0 (null terminator)
    mov r3, r0                     ! r0 = 0
    mov.b r0, @(10, r2)           ! entry_table[player*11 + 10] = '\0' (truncate to 10 chars)
.L_entry_name_ok:
    mov.l   .L_pool_geom_display_param, r4 ! r4 = geom display parameter block (sym_060877E8)
    .byte   0xB6, 0x22    /* bsr 0x0601F4B4 (geom_display_proc — decode display params) */
    nop                            ! (delay) no additional setup needed
    mov.l   .L_pool_hud_work_area, r12 ! r12 = HUD work area base (sym_060877B4)
    mov r9, r5                     ! r5 = HUD output struct pointer (source for copy)
    mov.l   .L_pool_smpc_memcpy, r3 ! r3 = smpc_cmd_helper_a (memcpy-like helper)
    jsr @r3                        ! call smpc_cmd_helper_a(r4=work_area, r5=hud_output_struct)
    mov r12, r4                    ! (delay) r4 = work_area base (destination)
    mov r12, r4                    ! r4 = work_area base (for second copy)
    mov.l   .L_pool_smpc_memcpy, r3 ! r3 = smpc_cmd_helper_a
    mov.b @r10, r5                 ! r5 = player index byte
    extu.b r5, r5                  ! zero-extend player index
    mul.l r11, r5                  ! macl = player_index * 11
    sts macl, r5                   ! r5 = player_index * 11
    add r8, r5                     ! r5 = &entry_table[player*11] (source: entry name string)
    jsr @r3                        ! call smpc_cmd_helper_a(r4=work_area+12, r5=entry_name)
    add #0xC, r4                   ! (delay) r4 = work_area + 12 (destination for entry name)
    mov #0x0, r2                   ! r2 = 0
    mov #0x17, r0                  ! r0 = 0x17 (offset: dirty flag within work area)
    mov.b r2, @(r0, r12)          ! work_area[0x17] = 0 (clear dirty flag)
    mov.l   .L_pool_dispatch_table_ptr, r3 ! r3 = &dispatch_table_ptr (sym_06000354)
    mov.l   .L_pool_geom_display_param, r4 ! r4 = geom display parameter block (sym_060877E8, arg1)
    mov.l @r3, r3                  ! r3 = *dispatch_table_ptr (actual dispatch table address)
    mov.l @(40, r3), r2            ! r2 = dispatch_table[10] (vtable slot 10, render param compute fn)
    jsr @r2                        ! call vtable_slot10(geom_display_param)
    nop                            ! (delay)
    mov.l r0, @(24, r12)          ! work_area[24] = render param result from vtable dispatch
    mov.b @r10, r3                 ! r3 = player index byte
    extu.b r3, r3                  ! zero-extend player index
    shll2 r3                       ! r3 = player_index * 4 (course size table stride)
    mov.l   .L_pool_course_size_table, r2 ! r2 = course size table base (sym_0604A5C0)
    add r2, r3                     ! r3 = &course_size_table[player_index]
    mov.l @r3, r1                  ! r1 = course_size_table[player_index] (course size value)
    mov.l r1, @(28, r12)          ! work_area[28] = course size for current player
.L_poll_sf_set_resdisa:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0 (busy flag)
    cmp/eq r14, r2                 ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_set_resdisa ! spin while busy
    extu.b r14, r2                 ! r2 = 1
    mov.b r2, @r13                 ! SF = 1 (set busy before issuing new command)
    mov #0x1A, r3                  ! 0x1A = SMPC RESDISA command (Reset Disable)
    mov.l   .L_smpc_comreg_ct, r2  ! r2 = 0x2010001F (SMPC COMREG, cache-through)
    mov.b r3, @r2                  ! write RESDISA command to COMREG
.L_poll_sf_clear_resdisa:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0
    tst r2, r2                     ! SF.bit0 == 0? (command completed)
    bf      .L_poll_sf_clear_resdisa ! spin while busy
    mov #0x0, r7                   ! r7 = 0 (arg4 for dispatch: flags=0)
    mov.l @r15, r6                 ! r6 = callback/extra parameter (arg3, from stack)
    mov.l   .L_pool_dispatch_table_ptr, r3 ! r3 = &dispatch_table_ptr
    mov.l   .L_pool_hud_work_area, r5 ! r5 = HUD work area (arg2 for dispatch)
    mov.w @(4, r15), r0            ! r0 = element index (word, from stack)
    mov.l @r3, r3                  ! r3 = *dispatch_table_ptr (actual dispatch table)
    mov r0, r4                     ! r4 = element index
    mov.l @(16, r3), r2            ! r2 = dispatch_table[4] (vtable slot 4, element display fn)
    extu.w r4, r4                  ! zero-extend element index to 32 bits
    mov.l   .L_pool_hud_element_array, r3 ! r3 = HUD element array base (sym_06087094, 0x20 per elem)
    shll2 r4                       ! r4 = index * 4
    shll2 r4                       ! r4 = index * 16
    shll r4                        ! r4 = index * 32 (element stride = 0x20)
    add r3, r4                     ! r4 = &hud_element[index]
    mov.w @(28, r4), r0            ! r0 = element[index].field_1C (display ID, word at +0x1C)
    mov r0, r4                     ! r4 = display_id
    jsr @r2                        ! call vtable_slot4(display_id, work_area, callback, 0)
    extu.w r4, r4                  ! (delay) zero-extend display_id to 32 bits
    mov r0, r4                     ! r4 = dispatch result (saved for return)
.L_poll_sf_set_resenab:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0
    cmp/eq r14, r2                 ! SF.bit0 == 1? (previous command still active)
    bt      .L_poll_sf_set_resenab ! spin while busy
    extu.b r14, r2                 ! r2 = 1
    mov.b r2, @r13                 ! SF = 1 (set busy before issuing new command)
    bra     .L_issue_resenab       ! jump to RESENAB command issue
    nop                            ! (delay)
.L_pool_entry_table:
    .4byte  sym_0605E06C
.L_pool_player_index:
    .4byte  sym_060877D8
.L_smpc_sf:
    .4byte  0x20100063                  /* SMPC SF — status flag */
.L_pool_strlen_fn:
    .4byte  sym_06035C1C
.L_pool_geom_display_param:
    .4byte  sym_060877E8
.L_pool_hud_work_area:
    .4byte  sym_060877B4
.L_pool_smpc_memcpy:
    .4byte  smpc_cmd_helper_a
.L_pool_dispatch_table_ptr:
    .4byte  sym_06000354
.L_pool_course_size_table:
    .4byte  sym_0604A5C0
.L_smpc_comreg_ct:
    .4byte  0x2010001F                  /* SMPC COMREG (cache-through) */
.L_pool_hud_element_array:
    .4byte  sym_06087094
.L_issue_resenab:
    mov #0x19, r3                  ! 0x19 = SMPC RESENAB command (Reset Enable)
    .byte   0xD2, 0x2F    /* mov.l .L_pool_0601E9F0, r2 (out-of-TU: SMPC COMREG 0x2010001F) */
    mov.b r3, @r2                  ! write RESENAB command to COMREG
.L_poll_sf_clear_resenab:
    mov.b @r13, r2                 ! read SMPC SF register
    extu.b r2, r2                  ! zero-extend
    and r14, r2                    ! isolate bit 0
    tst r2, r2                     ! SF.bit0 == 0? (command completed)
    bf      .L_poll_sf_clear_resenab ! spin while busy
    mov r4, r0                     ! r0 = dispatch result (return value)
    add #0x8, r15                  ! free 8 bytes of stack
    lds.l @r15+, macl              ! restore macl
    lds.l @r15+, pr                ! restore return address
    mov.l @r15+, r8                ! restore r8
    mov.l @r15+, r9                ! restore r9
    mov.l @r15+, r10               ! restore r10
    mov.l @r15+, r11               ! restore r11
    mov.l @r15+, r12               ! restore r12
    mov.l @r15+, r13               ! restore r13
    rts                            ! return (r0 = dispatch result)
    mov.l @r15+, r14               ! (delay) restore r14
