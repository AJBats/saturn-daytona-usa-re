/* sound_channel_mgr -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06030E72 - 0x06030FCC
 * Auto-generated by tools/generate_l3_tu.py, then annotated.
 *
 * This TU contains the tail of the music panning/damping calculation,
 * a per-car countdown timer tick, a sound-trigger wrapper, per-channel
 * dispatch tables, volume/fade threshold data tables, and the register-
 * save prologue for the next function (car_proximity_check continuation).
 *
 * sound_channel_mgr (0x06030E72):
 *   Tail of the surround-sound panning computation (continues from
 *   sound_music_ctrl). Performs three 32x32->64 fixed-point multiplies
 *   to integrate velocity/panning deltas into the car struct fields at
 *   +16 (X pan) and +24 (Z pan), then applies a damping factor to the
 *   distance field at +12 based on a mode word at struct offset +0x7C:
 *     mode >= 8  -> damping = 0xC000  (75.0% — strong damping)
 *     mode >= 6  -> damping = 0xFAE1  (98.0% — light damping)
 *     otherwise  -> damping = 0xDEB8  (87.0% — moderate damping)
 *   r14 = pointer into car/sound work struct (set by caller).
 *
 * sym_06030EE0:
 *   Per-car state countdown timer tick. Loads the car struct pointer
 *   from sym_0607E940, reads a 16-bit countdown at offset +0x150,
 *   decrements it if positive. Called from car_frame_update,
 *   car_update_racing, etc.
 *
 * Embedded function at 0x06030EFC (inside pool/data area):
 *   Sound trigger wrapper — pushes r12/r0/PR, calls sound_cmd_dispatch
 *   with r4=0 and r5=command, then restores and returns. The bytes are
 *   left as .4byte since they share the constant pool with sym_06030EE0.
 *
 * sym_06030F1C:
 *   Channel dispatch table — 4 function pointers to per-channel handlers
 *   in sound_music_ctrl (loc_06030758..loc_060307E8), followed by 32
 *   16-bit volume/position offset entries (two interleaved tables of 16
 *   entries each for front and rear speaker groups).
 *
 * sym_06030F74:
 *   Low fade threshold table — 16 entries of 16-bit thresholds used by
 *   the music fader to determine when to start attenuating a channel.
 *   (Data, not code — L3 generator misinterpreted as instructions.)
 *
 * sym_06030F98:
 *   High fade threshold table — 16 entries of 16-bit thresholds for the
 *   upper fade boundary. (Data, not code.)
 *
 * sym_06030FBC:
 *   Music target position — 16-bit variable written by sound_music_ctrl,
 *   read by the music fader to blend channel volumes.
 *
 * sym_06030FBE:
 *   Music control flag — 16-bit variable. Nonzero when music positioning
 *   is active.
 *
 * sym_06030FC0:
 *   Register-save prologue for a function whose body resides in the next
 *   TU (car_proximity_check). Pushes r8-r13 onto the stack.
 */

    .section .text.FUN_06030E72


    .global sound_channel_mgr
    .type sound_channel_mgr, @function
sound_channel_mgr:
    sts.l pr, @-r15                     ! save return address (caller's subroutine)
    jsr @r0                             ! call function whose address is in r0 (trig lookup)
    nop                                 ! delay slot
    lds.l @r15+, pr                     ! restore return address
    dmuls.l r0, r3                      ! 32x32->64 multiply: r0 (cos result) * r3 (X delta)
    sts mach, r0                        ! r0 = high 32 bits of product
    sts macl, r3                        ! r3 = low 32 bits of product
    xtrct r0, r3                        ! r3 = middle 32 bits (16.16 fixed-point result)
    add r3, r5                          ! accumulate X pan delta into r5
    mov.l r5, @(16, r14)                ! store updated X pan to struct offset +16
    dmuls.l r8, r9                      ! 32x32->64 multiply: r8 (sin result) * r9 (Z delta)
    sts mach, r8                        ! r8 = high 32 bits of product
    sts macl, r9                        ! r9 = low 32 bits of product
    xtrct r8, r9                        ! r9 = middle 32 bits (16.16 fixed-point result)
    add r9, r6                          ! accumulate Z pan delta into r6
    mov.l r6, @(24, r14)                ! store updated Z pan to struct offset +24
    mov.l @(12, r14), r3                ! r3 = distance field from struct offset +12
    mov.w   DAT_06030eae, r10           ! r10 = 0x7C (offset to mode word in struct)
    .byte   0xD4, 0x08    /* mov.l .L_pool_damp_moderate, r4 */  ! r4 = 0xDEB8 (moderate damping, default)
    add r14, r10                        ! r10 = pointer to mode word (struct + 0x7C)
    mov.w @r10, r9                      ! r9 = mode value (16-bit)
    mov #0x8, r8                        ! r8 = 8 (high mode threshold)
    cmp/ge r8, r9                       ! compare: mode >= 8?
    bt      .L_mode_high                ! yes -> use strong damping (0xC000)
    add #-0x2, r8                       ! r8 = 6 (mid mode threshold)
    cmp/ge r8, r9                       ! compare: mode >= 6?
    bf      .L_apply_damping            ! no -> use default moderate damping (0xDEB8)
    .byte   0xD4, 0x04    /* mov.l .L_pool_damp_light, r4 */     ! r4 = 0xFAE1 (light damping)
    bra     .L_apply_damping            ! skip to damping multiply
    nop                                 ! delay slot

    .global DAT_06030eae
DAT_06030eae:
    .2byte  0x007C                      /* struct offset to mode word */
    .4byte  cos_lookup                  /* pointer to cosine lookup function */
    .4byte  sin_lookup                  /* pointer to sine lookup function */
.L_pool_damp_moderate:
    .4byte  0x0000DEB8                  /* 16.16 fixed-point ~0.87 (moderate damping) */
.L_pool_damp_light:
    .4byte  0x0000FAE1                  /* 16.16 fixed-point ~0.98 (light damping) */
.L_mode_high:
    .byte   0xD4, 0x06    /* mov.l .L_pool_damp_strong, r4 */    ! r4 = 0xC000 (strong damping)
.L_apply_damping:
    dmuls.l r3, r4                      ! 32x32->64 multiply: distance * damping factor
    sts mach, r3                        ! r3 = high 32 bits of product
    sts macl, r4                        ! r4 = low 32 bits of product
    xtrct r3, r4                        ! r4 = middle 32 bits (16.16 fixed-point result)
    mov.l r4, @(12, r14)                ! store damped distance back to struct offset +12
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r8                     ! restore r8
    lds.l @r15+, pr                     ! restore return address
    mov.l @r15+, r14                    ! restore r14
    mov.l @r15+, r13                    ! restore r13
    rts                                 ! return to caller
    mov.l @r15+, r12                    ! restore r12 (delay slot)
.L_pool_damp_strong:
    .4byte  0x0000C000                  /* 16.16 fixed-point 0.75 (strong damping) */

/* sym_06030EE0 -- Per-car countdown timer tick
 *
 * Reads the car struct pointer from sym_0607E940, then reads a 16-bit
 * countdown value at struct offset +0x150. If positive, decrements by 1.
 * Called once per frame per car from car_frame_update, car_update_racing,
 * and car_update_simple.
 */
    .global sym_06030EE0
sym_06030EE0:
    mov.w   .L_wpool_countdown_timer_offset, r0       ! r0 = 0x150 (offset to countdown timer in car struct)
    .byte   0xD1, 0x05    /* mov.l .L_pool_car_struct_ptr, r1 */ ! r1 = &sym_0607E940 (car struct pointer)
    mov.l @r1, r3                       ! r3 = car struct base address
    mov.w @(r0, r3), r2                 ! r2 = countdown timer value (16-bit) at struct+0x150
    cmp/pl r2                           ! is timer > 0?
    bf      .L_timer_done               ! no -> skip decrement
    add #-0x1, r2                       ! decrement timer by 1
    mov.w r2, @(r0, r3)                 ! write decremented timer back
.L_timer_done:
    rts                                 ! return to caller
    nop                                 ! delay slot
.L_wpool_countdown_timer_offset:
    .2byte  0x0150                      /* [HIGH] offset +0x150: countdown timer field in car struct */
    .2byte  0x0000                      /* alignment padding */
.L_pool_car_struct_ptr:
    .4byte  sym_0607E940                /* pointer to current car struct */
/* Embedded sound trigger wrapper function (0x06030EFC)
 *
 * Small function that calls sound_cmd_dispatch(r4=0, r5=0xAE1102FF).
 * Saves r12/r0/PR, loads sound_cmd_dispatch into r12 and the command
 * ID into r5, calls it, then restores and returns.
 * Left as raw .4byte because it shares the constant pool with
 * sym_06030EE0 and cannot be separated without breaking pool offsets.
 */
    .4byte  0x2FC62F06                  /* mov.l r12, @-r15 / mov.l r0, @-r15 */
    .4byte  0x4F22DC04                  /* sts.l pr, @-r15 / mov.l @(PC+16), r12 = sound_cmd_dispatch */
    .4byte  0xD5044C0B                  /* mov.l @(PC+16), r5 = 0xAE1102FF / jsr @r12 */
    .4byte  0xE4004F26                  /* mov #0, r4 / lds.l @r15+, pr */
    .4byte  0x60F6000B                  /* mov.l @r15+, r0 / rts */
    .4byte  0x6CF60000                  /* mov.l @r15+, r12 / padding */
    .4byte  sound_cmd_dispatch          /* pool: sound_cmd_dispatch function pointer */
    .4byte  0xAE1102FF                  /* pool: sound command ID (sound effect trigger) */

/* sym_06030F1C -- Channel dispatch table + volume/position offset data
 *
 * First 4 entries: function pointers to per-channel handlers in
 * sound_music_ctrl (channels 3, 2, 1, 0 — reverse order for priority).
 * Remaining 32 entries: pairs of 16-bit volume/position offset values
 * used to configure speaker panning. Two groups of 16:
 *   - Front speaker group offsets (entries 4-19)
 *   - Rear speaker group offsets (entries 20-35)
 */
    .global sym_06030F1C
sym_06030F1C:
    .4byte  loc_060307E8                /* channel 3 handler (lowest priority) */
    .4byte  loc_060307B8                /* channel 2 handler */
    .4byte  loc_06030788                /* channel 1 handler */
    .4byte  loc_06030758                /* channel 0 handler (highest priority) */
    .4byte  0x01220122                  /* front offsets [0]: 0x122, 0x122 */
    .4byte  0x012C0140                  /* front offsets [1]: 0x12C, 0x140 */
    .4byte  0x01400140                  /* front offsets [2]: 0x140, 0x140 */
    .4byte  0x01400140                  /* front offsets [3]: 0x140, 0x140 */
    .4byte  0x01400140                  /* front offsets [4]: 0x140, 0x140 */
    .4byte  0x01400140                  /* front offsets [5]: 0x140, 0x140 */
    .4byte  0x01400140                  /* front offsets [6]: 0x140, 0x140 */
    .4byte  0x01400140                  /* front offsets [7]: 0x140, 0x140 */
    .4byte  0x01400140                  /* front offsets [8]: 0x140, 0x140 */
    .4byte  0x01180118                  /* rear offsets [0]: 0x118, 0x118 */
    .4byte  0x012C0136                  /* rear offsets [1]: 0x12C, 0x136 */
    .4byte  0x01360136                  /* rear offsets [2]: 0x136, 0x136 */
    .4byte  0x01360136                  /* rear offsets [3]: 0x136, 0x136 */
    .4byte  0x01360136                  /* rear offsets [4]: 0x136, 0x136 */
    .4byte  0x01360136                  /* rear offsets [5]: 0x136, 0x136 */
    .4byte  0x01360136                  /* rear offsets [6]: 0x136, 0x136 */
    .4byte  0x01360136                  /* rear offsets [7]: 0x136, 0x136 */
    .4byte  0x01360136                  /* rear offsets [8]: 0x136, 0x136 */

/* sym_06030F74 -- Low fade threshold table
 *
 * 16 entries of 16-bit thresholds. When the computed panning distance
 * falls below these thresholds, the music fader begins attenuating
 * the corresponding channel. Data, not executable code (L3 generator
 * misinterpreted these bytes as SH-2 instructions).
 */
    .global sym_06030F74
sym_06030F74:
    mov.w @(r0, r1), r1
    stc vbr, r1
    mov.b @(r0, r2), r1
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)
    mov.l r3, @(r0, r1)

/* sym_06030F98 -- High fade threshold table
 *
 * 16 entries of 16-bit thresholds. When the computed panning distance
 * exceeds these thresholds, the channel is fully attenuated.
 * Data, not executable code.
 */
    .global sym_06030F98
sym_06030F98:
    .word 0x0113 /* UNKNOWN */
    .word 0x0118 /* UNKNOWN */
    stc vbr, r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1
    mov.b @(r0, r2), r1

/* sym_06030FBC -- Music target position (16-bit variable)
 * Written by sound_music_ctrl with the computed stereo panning target.
 * Read by the music fader to blend channel volumes.
 */
    .global sym_06030FBC
sym_06030FBC:
    .word 0x0000 /* UNKNOWN */

/* sym_06030FBE -- Music control flag (16-bit variable)
 * Nonzero when music positioning/panning is active.
 * Cleared when no channels have the active bit set.
 */
    .global sym_06030FBE
sym_06030FBE:
    .word 0x0000 /* UNKNOWN */

/* sym_06030FC0 -- Register-save prologue
 *
 * Saves r8-r13 onto the stack. This is the entry point for a function
 * whose body resides in the next TU (referenced by car_proximity_check
 * as a player proximity collision wrapper). Only the prologue falls
 * within this TU's address range.
 */
    .global sym_06030FC0
sym_06030FC0:
    mov.l r8, @-r15                     ! save r8
    mov.l r9, @-r15                     ! save r9
    mov.l r10, @-r15                    ! save r10
    mov.l r11, @-r15                    ! save r11
    mov.l r12, @-r15                    ! save r12
    mov.l r13, @-r15                    ! save r13
