/* lap_time_record -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0600D92C - 0x0600D9BC
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Lap time recording — called when a lap is completed. Records the
 * elapsed time for this lap and updates the best lap time.
 *
 * Car struct offsets:
 *   [+0x21C] = current lap counter
 *   [+0x220] = lap delta time (this lap's duration)
 *   [+0x22C] = lap start timestamp (updated to current timer each lap)
 *   [+0x230] = completed laps counter
 *   [+0x240] = best lap time (0 = no best yet)
 *
 * Logic:
 *   1. If lap_counter > max_laps - 1:
 *      → set race_complete_flag = 3, increment completed_laps
 *   2. Set countdown_timer = 40 frames (0x28)
 *   3. Call lap timing function (external BSR)
 *   4. Compute lap_time = global_timer - lap_start_timestamp
 *   5. Update lap_start_timestamp to current timer
 *   6. Store lap_time in per-lap array: lap_times[(lap-1)*4]
 *   7. If lap_time < best_lap OR best_lap == 0:
 *      → update best_lap to this lap_time
 */

    .section .text.FUN_0600D92C


    .global lap_time_record
    .type lap_time_record, @function
lap_time_record:
    mov.l r14, @-r15                 ! save r14 (car struct ptr)
    sts.l pr, @-r15                  ! save return address
    mov.l   .L_car_struct_ptr, r14     ! r14 → car struct pointer addr
    mov.l   .L_max_laps, r3           ! r3 → max laps addr
    mov.w   DAT_0600d996, r0          ! r0 = +0x21C (lap counter offset)
    mov.l @r14, r14                    ! r14 = car struct base
    mov.l @r3, r3                      ! r3 = max laps
    mov.l @(r0, r14), r2              ! r2 = current lap count
    add #-0x1, r3                      ! r3 = max_laps - 1
    cmp/hi r3, r2                      ! lap_count > max_laps - 1?
    bf      .L_set_countdown           ! no → skip race-complete logic
    mov #0x3, r2                       ! race_complete_flag = 3
    mov.l   .L_race_complete_flag, r3  ! r3 → race complete flag addr
    mov.l r2, @r3                      ! store flag
    mov.w   DAT_0600d998, r0          ! r0 = +0x230 (completed laps offset)
    mov.l @(r0, r14), r2              ! r2 = completed laps count
    add #0x1, r2                       ! increment completed laps
    mov.l r2, @(r0, r14)              ! store updated count
.L_set_countdown:
    mov #0x28, r3                      ! countdown = 40 frames
    mov.l   .L_countdown_timer, r2    ! r2 → countdown timer addr
    mov.l r3, @r2                      ! store countdown
    .byte   0xB1, 0xB7    ! bsr 0x0600DCC8 (external) — lap timing function
    nop                                ! delay slot
    mov.l   .L_global_timer, r5       ! r5 → global timer addr
    mov.w   DAT_0600d99a, r0          ! r0 = +0x22C (lap start timestamp offset)
    mov.l @r5, r4                      ! r4 = current global timer
    mov.l @r5, r3                      ! r3 = global timer (for store)
    mov.l @(r0, r14), r2              ! r2 = lap start timestamp
    mov.l r3, @(r0, r14)              ! update start timestamp to current
    sub r2, r4                         ! r4 = lap_time (current - start)
    mov.l @(r0, r14), r3              ! r3 = updated start timestamp
    mov.l   .L_prev_lap_store, r2     ! r2 → external lap time store
    add #-0xC, r0                      ! r0 = +0x220 (lap delta offset)
    mov.l r3, @r2                      ! store timestamp externally
    mov.l r4, @(r0, r14)              ! car[+0x220] = lap_time
    add #-0x4, r0                      ! r0 = +0x21C (lap counter offset)
    mov.l   .L_lap_times_array, r2    ! r2 → per-lap time array
    mov.l @(r0, r14), r3              ! r3 = lap counter
    add #0x24, r0                      ! r0 = +0x240 (best lap offset)
    add #-0x1, r3                      ! index = lap - 1
    shll2 r3                           ! index * 4 (32-bit entries)
    add r2, r3                         ! r3 → lap_times[lap-1]
    mov.l r4, @r3                      ! store this lap's time
    mov.l @(r0, r14), r5              ! r5 = current best lap time
    cmp/ge r5, r4                      ! new_time >= best?
    bf      .L_update_best             ! new_time < best → update best
    tst r5, r5                         ! best == 0? (no best recorded yet)
    bf      .L_return                  ! best != 0 → keep current best
.L_update_best:
    mov.w   .L_off_best_lap, r0       ! r0 = +0x240 (best lap offset)
    mov.l r4, @(r0, r14)              ! car[+0x240] = new best lap time
.L_return:
    lds.l @r15+, pr                    ! restore return address
    rts                                ! return
    mov.l @r15+, r14                   ! restore r14 (delay slot)

    .global DAT_0600d996
DAT_0600d996:
    .2byte  0x021C                        /* car offset: current lap counter */

    .global DAT_0600d998
DAT_0600d998:
    .2byte  0x0230                        /* car offset: completed laps counter */

    .global DAT_0600d99a
DAT_0600d99a:
    .2byte  0x022C                        /* car offset: lap start timestamp */
.L_off_best_lap:
    .2byte  0x0240                        /* car offset: best lap time */
    .2byte  0xFFFF                       /* alignment padding */
.L_car_struct_ptr:
    .4byte  sym_0607E940               /* pointer to current car struct */
.L_max_laps:
    .4byte  sym_06063F28               /* maximum lap count for current race */
.L_race_complete_flag:
    .4byte  sym_0607EBF4               /* race complete flag (3 = finished) */
.L_countdown_timer:
    .4byte  sym_0607EAC0               /* countdown timer (set to 40 on lap complete) */
.L_global_timer:
    .4byte  sym_060786B0               /* global race timer */
.L_prev_lap_store:
    .4byte  sym_060786A4               /* external lap time storage */
.L_lap_times_array:
    .4byte  sym_0607EBF8               /* per-lap time array (4 bytes per lap) */
