/* vdp2_scroll_setup -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0602E264 - 0x0602E2E0
 * Auto-generated by tools/generate_l3_tu.py
 *
 * VDP2 scroll plane setup (0x0602E264):
 *   Part of the VDP2 background layer configuration chain. Configures
 *   NBG0-NBG3 scroll planes for track surface, sky, and HUD layers.
 *
 *   1. Calls the setup function pre-loaded in r13 (saves/restores PR)
 *   2. Dereferences the car state struct pointer (sym_0607E940)
 *   3. Reads a 32-bit scroll coefficient from struct offset +0xE4
 *   4. Clamps the value to [0x0708, 0x2134]
 *   5. Normalizes: result = (clamped - 0x0708) << 7
 *   6. Loads parameters for the next dispatch stage (vdp2_coeff_load)
 *
 *   r13 = function pointer set by caller (preceding setup fn)
 *   r12 = loaded with next-stage function pointer on exit
 *
 *   Embedded data table at +0x34 (0x298): sym_0607EAC8, constants,
 *   and function pointers for the car update dispatch chain.
 */

    .section .text.FUN_0602E264


    .global vdp2_scroll_setup
    .type vdp2_scroll_setup, @function
vdp2_scroll_setup:
    sts.l pr, @-r15                        ! save return address
    jsr @r13                               ! call preceding setup function (in r13)
    nop                                    ! (delay slot)
    lds.l @r15+, pr                        ! restore return address
    mov.l   .L_car_state_ptr, r0           ! r0 = &car_state_ptr (sym_0607E940)
    mov.l @r0, r0                          ! r0 = car_state_base (dereference pointer)
    mov.w   .L_wpool_0602E290, r5          ! r5 = 0x00E4 (scroll coefficient offset)
    add r0, r5                             ! r5 = &car_state[+0xE4] (scroll coeff field)
    mov.w   .L_wpool_0602E292, r3          ! r3 = 0x0708 (lower clamp bound)
    mov.l @r5, r1                          ! r1 = car_state[+0xE4] (raw scroll value)
    mov.w   .L_wpool_0602E294, r4          ! r4 = 0x2134 (upper clamp bound)
    cmp/gt r3, r1                          ! if r1 > 0x0708 (above lower bound)
    bt      .L_above_lower_bound           ! then check upper bound
    mov r3, r1                             ! else clamp r1 = lower bound (0x0708)
    bra     .L_normalize                   ! skip upper bound check
    nop                                    ! (delay slot)

    .global DAT_0602e284
DAT_0602e284:
    mov.b r1, @(r0, r2)
    .word 0x0088 /* UNKNOWN */

    .global DAT_0602e288
DAT_0602e288:
    mov.b r4, @(r0, r0)

    .global DAT_0602e28a
DAT_0602e28a:
    stc vbr, r0
    .word 0x0011 /* UNKNOWN */

    .global DAT_0602e28e
DAT_0602e28e:
    .word 0x0208 /* UNKNOWN */
.L_wpool_0602E290:
    .2byte  0x00E4                         /* word pool: struct offset +0xE4 (scroll coefficient) */
.L_wpool_0602E292:
    .2byte  0x0708                         /* word pool: lower clamp bound */
.L_wpool_0602E294:
    .2byte  0x2134                         /* word pool: upper clamp bound */
    .2byte  0x0000                         /* padding */
    .4byte  sym_0607EAC8                   /* data table: VDP2 state struct */
    .4byte  0x00000001                     /* data table: constant 1 */
    .4byte  0x00000028                     /* data table: constant 0x28 (40) */
    .4byte  0x00000000                     /* data table: constant 0 */
    .4byte  0x000000C0                     /* data table: constant 0xC0 (192) */
    .4byte  sym_0602F3EC                   /* data table: damage_mac_core */
    .4byte  sym_0602F7BC                   /* data table: per-car timer tick */
    .4byte  sym_06030A06                   /* data table: per-car physics init */
    .4byte  sym_06030EE0                   /* data table: per-car state update */
    .4byte  brake_force_apply              /* data table: brake force application */
    .4byte  accel_response                 /* data table: acceleration response */
.L_car_state_ptr:
    .4byte  sym_0607E940                   /* pool: pointer to car state struct */
    .4byte  sym_0602D82A                   /* pool: display intensity curve fn */
    .4byte  sym_0602F17C                   /* pool: camera state machine fn */
.L_above_lower_bound:
    cmp/gt r1, r4                          ! if 0x2134 > r1 (below upper bound)
    bt      .L_normalize                   ! then value is in range, skip clamp
    mov r4, r1                             ! else clamp r1 = upper bound (0x2134)
.L_normalize:
    sub r3, r1                             ! r1 = clamped_value - 0x0708 (zero-based)
    shll8 r1                               ! r1 <<= 8
    .byte   0x90, 0x0D    /* mov.w .L_wpool_0602E2F8, r0 */ ! r0 = divisor (from next TU pool)
    shlr r1                                ! r1 >>= 1 (net effect: r1 <<= 7)
    .byte   0xDC, 0x07    /* mov.l .L_pool_0602E2FC, r12 */ ! r12 = next dispatch fn (from next TU pool)
