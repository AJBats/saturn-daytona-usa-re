/* dual_hud_render -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x06011E7C - 0x06011F92
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Contains three functions:
 *
 * 1. dual_hud_render (0x06011E7C)
 *    Renders the HUD for 2-player split-screen mode. Loads display list
 *    data for both players and calls the display list loader twice:
 *      - Player 1: dlist base sym_060638B0, index 0x04BE
 *      - Player 2: dlist base sym_060638A0, index 0x0486
 *    Each call uses mode r4=0xC (12 layers) and a texture offset
 *    computed from struct field +4 plus 0x4000.
 *
 * 2. sym_06011EB4 — single_hud_render_dispatch (0x06011EB4)
 *    Conditional HUD render dispatcher called from transition screens.
 *    If 2-player flag (sym_06085FF4) is set, branches to dual_hud_render.
 *    Otherwise, checks the frame counter (sym_0607EADC); if nonzero,
 *    renders player 1's HUD only using index 0x0420. If zero, renders
 *    player 2's HUD only using index 0x0420.
 *
 * 3. sym_06011F1C — palette_color_fade (0x06011F1C)
 *    Fades 16 RGB555 palette entries toward black. Each channel (R, G, B)
 *    is decremented by 2 per call, clamped at zero. Called from
 *    transition effects. r4 = pointer to 16 .word palette entries.
 *
 * Data pool (shared):
 *   sym_060638B0 = player 1 HUD display list struct
 *   sym_060638A0 = player 2 HUD display list struct
 *   sym_06028400 = display_list_loader function
 *   sym_06085FF4 = 2-player mode flag (byte)
 *   sym_0607EADC = frame counter (dword)
 */

    .section .text.FUN_06011E7C


    .global dual_hud_render
    .type dual_hud_render, @function
dual_hud_render:
    sts.l pr, @-r15                     ! save return address
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l   .L_pool_p1_dlist_base, r3   ! r3 = &player1_hud_dlist (sym_060638B0)
    mov.l r3, @r15                      ! store dlist base ptr on stack
    mov r3, r7                          ! r7 = dlist struct ptr
    mov.w   DAT_06011f00, r6            ! r6 = 0x04BE (player 1 dlist index)
    mov.l @r15, r5                      ! r5 = dlist struct base ptr
    mov.l @(4, r7), r7                  ! r7 = struct[+4] (texture base offset)
    mov.w   DAT_06011efe, r3            ! r3 = 0x4000 (texture offset addend)
    mov.l @r5, r5                       ! r5 = *dlist_base (deref first field)
    add r3, r7                          ! r7 = texture_base + 0x4000
    mov.l   .L_pool_dlist_loader, r3    ! r3 = &display_list_loader (sym_06028400)
    jsr @r3                             ! call display_list_loader(0xC, dlist, 0x04BE, tex)
    mov #0xC, r4                        ! r4 = 0xC (12 layers) [delay slot]
    mov.l   .L_pool_p2_dlist_base, r2   ! r2 = &player2_hud_dlist (sym_060638A0)
    mov.l r2, @r15                      ! store p2 dlist base ptr on stack
    mov r2, r7                          ! r7 = p2 dlist struct ptr
    mov.l @(4, r7), r7                  ! r7 = p2 struct[+4] (texture base offset)
    mov.w   DAT_06011efe, r3            ! r3 = 0x4000 (texture offset addend)
    add r3, r7                          ! r7 = p2_texture_base + 0x4000
    mov.w   DAT_06011f02, r6            ! r6 = 0x0486 (player 2 dlist index)
    mov r2, r5                          ! r5 = p2 dlist struct base ptr
    mov.l @r5, r5                       ! r5 = *p2_dlist_base (deref first field)
    mov #0xC, r4                        ! r4 = 0xC (12 layers)
    add #0x4, r15                       ! free stack allocation
    mov.l   .L_pool_dlist_loader, r3    ! r3 = &display_list_loader
    jmp @r3                             ! tail-call display_list_loader(0xC, dlist, 0x0486, tex)
    lds.l @r15+, pr                     ! restore return address [delay slot]

    .global sym_06011EB4
sym_06011EB4:
    add #-0x4, r15                      ! allocate 4 bytes on stack
    mov.l   .L_pool_2p_mode_flag, r0    ! r0 = &2p_mode_flag (sym_06085FF4)
    mov.b @r0, r0                       ! r0 = 2p_mode_flag (byte)
    tst r0, r0                          ! test if 2-player mode active
    bt      .L_single_player_path       ! if zero (1P mode), skip to single path
    bra     dual_hud_render             ! 2P mode: branch to full dual HUD render
    add #0x4, r15                       ! restore stack [delay slot]
.L_single_player_path:
    mov.l   .L_pool_frame_counter, r0   ! r0 = &frame_counter (sym_0607EADC)
    mov.l @r0, r0                       ! r0 = frame_counter value
    tst r0, r0                          ! test if frame counter is zero
    bt      .L_render_player2_hud       ! if zero, render player 2 HUD
    mov.l   .L_pool_p1_dlist_base, r3   ! r3 = &player1_hud_dlist (sym_060638B0)
    mov.l r3, @r15                      ! store p1 dlist base on stack
    mov r3, r7                          ! r7 = p1 dlist struct ptr
    mov.l @(4, r7), r7                  ! r7 = p1 struct[+4] (texture base offset)
    mov.w   DAT_06011efe, r3            ! r3 = 0x4000 (texture offset addend)
    add r3, r7                          ! r7 = p1_texture_base + 0x4000
    mov.w   .L_wpool_single_dlist_idx, r6 ! r6 = 0x0420 (single-screen dlist index)
    mov.l @r15, r5                      ! r5 = p1 dlist struct base ptr
    mov.l @r5, r5                       ! r5 = *p1_dlist_base (deref first field)
    mov #0xC, r4                        ! r4 = 0xC (12 layers)
    mov.l   .L_pool_dlist_loader, r3    ! r3 = &display_list_loader
    jmp @r3                             ! tail-call display_list_loader(0xC, dlist, 0x0420, tex)
    add #0x4, r15                       ! restore stack [delay slot]
.L_render_player2_hud:
    mov.l   .L_pool_p2_dlist_base, r2   ! r2 = &player2_hud_dlist (sym_060638A0)
    mov.l r2, @r15                      ! store p2 dlist base on stack
    mov r2, r7                          ! r7 = p2 dlist struct ptr
    mov.l @(4, r7), r7                  ! r7 = p2 struct[+4] (texture base offset)
    mov.w   DAT_06011efe, r3            ! r3 = 0x4000 (texture offset addend)
    add r3, r7                          ! r7 = p2_texture_base + 0x4000
    mov.w   .L_wpool_single_dlist_idx, r6 ! r6 = 0x0420 (single-screen dlist index)
    mov r2, r5                          ! r5 = p2 dlist struct base ptr
    mov.l @r5, r5                       ! r5 = *p2_dlist_base (deref first field)
    mov #0xC, r4                        ! r4 = 0xC (12 layers)
    mov.l   .L_pool_dlist_loader, r3    ! r3 = &display_list_loader
    jmp @r3                             ! tail-call display_list_loader(0xC, dlist, 0x0420, tex)
    add #0x4, r15                       ! restore stack [delay slot]

    .global DAT_06011efe
DAT_06011efe:
    .2byte  0x4000

    .global DAT_06011f00
DAT_06011f00:
    .2byte  0x04BE

    .global DAT_06011f02
DAT_06011f02:
    .2byte  0x0486
.L_wpool_single_dlist_idx:
    .2byte  0x0420
    .2byte  0xFFFF
.L_pool_p1_dlist_base:
    .4byte  sym_060638B0
.L_pool_dlist_loader:
    .4byte  sym_06028400
.L_pool_p2_dlist_base:
    .4byte  sym_060638A0
.L_pool_2p_mode_flag:
    .4byte  sym_06085FF4
.L_pool_frame_counter:
    .4byte  sym_0607EADC

    .global sym_06011F1C
sym_06011F1C:
    mov.l r13, @-r15                    ! save r13 (will hold red decrement)
    mov.l r12, @-r15                    ! save r12 (will hold red channel mask)
    mov.l r11, @-r15                    ! save r11 (will hold loop count)
    mov.l r10, @-r15                    ! save r10 (will hold blue channel mask)
    mov.l r9, @-r15                     ! save r9 (will hold green channel mask)
    .byte   0x99, 0x55    /* mov.w .L_wpool_06011FD4, r9 */  ! r9 = 0x03E0 (green mask: bits 5-9)
    mov #0x1F, r10                      ! r10 = 0x1F (blue mask: bits 0-4)
    mov #0x10, r11                      ! r11 = 16 (number of palette entries)
    .byte   0x9C, 0x53    /* mov.w .L_wpool_06011FD6, r12 */ ! r12 = 0x7C00 (red mask: bits 10-14)
    .byte   0x9D, 0x53    /* mov.w .L_wpool_06011FD8, r13 */ ! r13 = 0xF800 (sign-ext = -0x800, red -2 step)
    mov #0x0, r6                        ! r6 = 0 (accumulated fade result, init)
    exts.w r6, r5                       ! r5 = 0 (loop counter, sign-extended)
.L_fade_loop:
    mov.w @r4, r0                       ! r0 = current palette entry (RGB555)
    exts.w r6, r3                       ! r3 = accumulated fade result (sign-ext)
    exts.w r0, r7                       ! r7 = sign-extended palette entry
    mov.w r3, @r4                       ! write accumulated result to palette entry
    and r10, r7                         ! r7 = blue channel (bits 0-4)
    add #-0x2, r7                       ! r7 = blue - 2 (fade toward black)
    cmp/pl r7                           ! test if blue > 0
    bf      .L_blue_clamp_zero          ! if not positive, clamp to 0
    bra     .L_blue_done                ! blue still positive, keep value
    mov r7, r2                          ! r2 = faded blue value [delay slot]
.L_blue_clamp_zero:
    mov #0x0, r2                        ! r2 = 0 (blue clamped to zero)
.L_blue_done:
    exts.w r0, r7                       ! r7 = sign-extended palette entry
    mov.w @r4, r3                       ! r3 = current palette word (being built)
    and r9, r7                          ! r7 = green channel (bits 5-9)
    or r2, r3                           ! merge faded blue into result
    add #-0x40, r7                      ! r7 = green - 0x40 (= -2 green steps, LSB=0x20)
    mov.w r3, @r4                       ! write partial result back
    cmp/pl r7                           ! test if green > 0
    bf      .L_green_clamp_zero         ! if not positive, clamp to 0
    bra     .L_green_done               ! green still positive, keep value
    mov r7, r2                          ! r2 = faded green value [delay slot]
.L_green_clamp_zero:
    mov #0x0, r2                        ! r2 = 0 (green clamped to zero)
.L_green_done:
    mov.w @r4, r3                       ! r3 = current palette word (being built)
    exts.w r0, r7                       ! r7 = sign-extended palette entry
    or r2, r3                           ! merge faded green into result
    and r12, r7                         ! r7 = red channel (bits 10-14)
    mov.w r3, @r4                       ! write partial result back
    add r13, r7                         ! r7 = red + (-0x800) = red - 2 steps (LSB=0x400)
    cmp/pl r7                           ! test if red > 0
    bf      .L_red_clamp_zero           ! if not positive, clamp to 0
    bra     .L_red_done                 ! red still positive, keep value
    mov r7, r2                          ! r2 = faded red value [delay slot]
.L_red_clamp_zero:
    mov #0x0, r2                        ! r2 = 0 (red clamped to zero)
.L_red_done:
    add #0x1, r5                        ! increment loop counter
    mov.w @r4, r3                       ! r3 = current palette word (being built)
    or r2, r3                           ! merge faded red into result
    mov.w r3, @r4                       ! write final faded color back to palette
    exts.w r5, r2                       ! r2 = loop counter (sign-extended)
    cmp/ge r11, r2                      ! compare counter >= 16?
    bf/s    .L_fade_loop                ! if not done, continue loop
    add #0x2, r4                        ! advance to next palette entry [delay slot]
    mov.l @r15+, r9                     ! restore r9
    mov.l @r15+, r10                    ! restore r10
    mov.l @r15+, r11                    ! restore r11
    mov.l @r15+, r12                    ! restore r12
    rts                                 ! return
    mov.l @r15+, r13                    ! restore r13 [delay slot]
