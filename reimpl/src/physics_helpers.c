#include "game.h"

/*
 * physics_helpers.c -- Shared physics helper functions
 *
 * Hand-translated from DEFINITE/HIGH-confidence annotated ASM
 * (asm/collision.s, asm/ai_behavior.s) and verified
 * instruction-by-instruction against build/aprog.s raw binary.
 *
 * Functions:
 *   FUN_0600C928 (0x0600C928) -- Speed reduction (collision friction)
 *   FUN_0600C8CC (0x0600C8CC) -- Speed targeting (heading controller)
 *   FUN_0600C7D4 (0x0600C7D4) -- Heading/steering with speed-based damping
 *
 * These helpers are called from BOTH player_physics.c and ai_physics.c.
 * They operate on the current car struct via volatile pointer arithmetic.
 */


/* ================================================================
 * Car struct access macros (same as force_system.c)
 * ================================================================ */
#define CAR_INT(car, off)    (*(volatile int *)((char *)(car) + (off)))
#define CAR_SHORT(car, off)  (*(volatile short *)((char *)(car) + (off)))


/* ================================================================
 * Extern helper declarations
 * ================================================================ */
extern int          FUN_0602744C(int x, int z);   /* atan2 */
extern void         FUN_06027358(int heading, int sin_out, int cos_out);  /* sin/cos lookup */
extern unsigned int FUN_06027552(int a, int b);    /* fixed-point multiply */


/* ================================================================
 * FUN_0600C928 -- Speed Reduction on Collision (0x0600C928)
 *
 * CONFIDENCE: DEFINITE (collision.s lines 1161-1206)
 * Every instruction verified. Pool word at 0x0600C966 = 0x2000.
 * Shift sequence (shlr8, shlr, extu.w, shll16, sub, 8x shar,
 * extu.w) confirmed. Offsets 0x48/0x50 confirmed.
 *
 * Computes a speed reduction factor from car[+0x0C], caps it,
 * and subtracts from car[+0x48] and car[+0x50].
 *
 * Formula: reduction = min(((speed >> 9) * 65535) >> 8, cap)
 * Approximately: min(speed / 2, 8192)
 * ================================================================ */
void FUN_0600C928(int car)
{
    unsigned int val;
    int product;
    int reduction, result, speed;
    int cap = 0x2000;   /* pool at 0x0600C966 */

    /* shlr8 + shlr + extu.w: unsigned right shift by 9, mask 16 bits */
    val = (unsigned int)CAR_INT(car, 0x0C);
    val >>= 8;     /* shlr8 */
    val >>= 1;     /* shlr */
    val &= 0xFFFF; /* extu.w */

    /* shll16, sub: val * 65535 */
    product = ((int)val << 16) - (int)val;

    /* 8x shar: arithmetic right shift by 8 */
    product >>= 1;
    product >>= 1;
    product >>= 1;
    product >>= 1;
    product >>= 1;
    product >>= 1;
    product >>= 1;
    product >>= 1;

    /* extu.w: mask to 16 bits */
    reduction = product & 0xFFFF;

    /* Clamp: if reduction >= cap, use cap; else use reduction */
    if (reduction >= cap) {
        result = cap;
    } else {
        result = reduction;
    }

    /* Subtract from car[+0x48], copy to car[+0x50] */
    speed = CAR_INT(car, 0x48);
    speed -= result;
    CAR_INT(car, 0x48) = speed;
    CAR_INT(car, 0x50) = speed;
}


/* ================================================================
 * FUN_0600C8CC -- Speed Targeting / Heading Controller (0x0600C8CC)
 *
 * CONFIDENCE: HIGH (ai_behavior.s lines 574-621)
 * All opcodes verified through atan2 call and heading adjustment.
 * Pool constants:
 *   0x0600C962: 0x0600 = 1536 (upper heading threshold)
 *   0x0600C964: 0xFA00 = -1536 signed (lower threshold)
 *   0x0600C968: 0x0602744C (atan2 function)
 *   0x0600C96C: 0x0000FA00 (subtract constant)
 *
 * Computes angle from car to next waypoint via atan2, then
 * adjusts the target heading (state[0x28]) with a clamped turn rate
 * of +/-1536 per frame. If within range, sets target to raw angle.
 *
 * FUN_0600C8CC is a trampoline: push r14, mov r4->r14, fall through
 * to FUN_0600C8D0. In C we implement it directly.
 * ================================================================ */
void FUN_0600C8CC(int car, int course_data)
{
    int waypoint_z, waypoint_x, delta_z, delta_x;
    int angle, neg_angle;
    int target, heading_diff;
    int threshold = 0x0600;  /* 1536, pool at 0x0600C962 */

    /* Compute direction to waypoint */
    waypoint_z = *(volatile int *)(course_data + 8);
    delta_z = waypoint_z - CAR_INT(car, 0x18);

    waypoint_x = *(volatile int *)course_data;
    delta_x = waypoint_x - CAR_INT(car, 0x10);

    /* atan2(delta_X, delta_Z) -> angle */
    angle = FUN_0602744C(delta_x, delta_z);

    /* Negate angle for heading reference */
    neg_angle = -angle;
    target = CAR_INT(car, 0x28);

    /* Heading difference: 16-bit modular subtraction */
    heading_diff = (short)(((unsigned short)neg_angle) - ((unsigned short)target));

    if (heading_diff > threshold) {
        /* Too far right: clamp turn rate to +1536 */
        int new_target = (short)((unsigned short)target + (unsigned short)threshold);
        CAR_INT(car, 0x28) = new_target;
    } else if (heading_diff >= (short)0xFA00) {
        /* Within range: direct pursuit */
        CAR_INT(car, 0x28) = neg_angle;
    } else {
        /* Too far left: clamp turn rate to -1536 */
        int new_target = (short)((unsigned short)target + 0xFA00u);
        CAR_INT(car, 0x28) = new_target;
    }
}

/* Alias for trampoline entry point (FUN_0600C8D0 is never called directly,
 * but it's a global label in the binary. Signature matches to avoid warnings.) */
/* FUN_0600C8D0 -- original binary (196 bytes) */
__asm__(
    ".section .text.FUN_0600C8D0, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0600C8D0\n"
    ".type _FUN_0600C8D0, @function\n"
    "_FUN_0600C8D0:\n"
    ".byte 0x4F, 0x22, 0x7F, 0xFC, 0x2F, 0x52, 0x55, 0x52, 0x53, 0xE6, 0x64, 0xF2, 0x35, 0x38, 0x64, 0x42\n"  /* 0x0600C8D0 */
    ".byte 0x53, 0xE4, 0x34, 0x38, 0xD3, 0x20, 0x43, 0x0B, 0x00, 0x09, 0x65, 0x0B, 0x53, 0xEA, 0x96, 0x38\n"  /* 0x0600C8E0 */
    ".byte 0x64, 0x5D, 0x63, 0x3D, 0x34, 0x38, 0x64, 0x4F, 0x34, 0x67, 0x8B, 0x06, 0x53, 0xEA, 0x63, 0x3D\n"  /* 0x0600C8F0 */
    ".byte 0x33, 0x6C, 0x63, 0x3F, 0x1E, 0x3A, 0xA0, 0x0B, 0x00, 0x09, 0x92, 0x2B, 0x34, 0x23, 0x89, 0x06\n"  /* 0x0600C900 */
    ".byte 0x52, 0xEA, 0x62, 0x2D, 0xD3, 0x15, 0x32, 0x3C, 0x62, 0x2F, 0xA0, 0x01, 0x1E, 0x2A, 0x1E, 0x5A\n"  /* 0x0600C910 */
    ".byte 0x7F, 0x04, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6, 0x55, 0x43, 0x97, 0x1C, 0x45, 0x19, 0x45, 0x01\n"  /* 0x0600C920 */
    ".byte 0x65, 0x5D, 0x63, 0x53, 0x45, 0x28, 0x35, 0x38, 0x45, 0x21, 0x45, 0x21, 0x45, 0x21, 0x45, 0x21\n"  /* 0x0600C930 */
    ".byte 0x45, 0x21, 0x45, 0x21, 0x45, 0x21, 0x45, 0x21, 0x66, 0x5D, 0x36, 0x73, 0x89, 0x01, 0xA0, 0x01\n"  /* 0x0600C940 */
    ".byte 0x62, 0x63, 0x62, 0x73, 0xE0, 0x48, 0x03, 0x4E, 0x33, 0x28, 0x04, 0x36, 0xE0, 0x50, 0x00, 0x0B\n"  /* 0x0600C950 */
    ".byte 0x04, 0x36, 0x06, 0x00, 0xFA, 0x00, 0x20, 0x00, 0x06, 0x02, 0x74, 0x4C, 0x00, 0x00, 0xFA, 0x00\n"  /* 0x0600C960 */
    ".byte 0x90, 0x38, 0xE3, 0x45, 0x05, 0x4E, 0x35, 0x33, 0x8B, 0x0A, 0xE3, 0x62, 0x35, 0x37, 0x89, 0x07\n"  /* 0x0600C970 */
    ".byte 0x75, 0xBB, 0x45, 0x00, 0xD3, 0x18, 0x35, 0x3C, 0x62, 0x51, 0x51, 0x43, 0x31, 0x2C, 0x14, 0x13\n"  /* 0x0600C980 */
    ".byte 0x00, 0x0B, 0x00, 0x09\n"  /* 0x0600C990 */
);


/* Alias for trampoline entry point (FUN_0600C7D8 is never called directly,
 * but it's a global label in the binary. Signature matches to avoid warnings.) */
/* FUN_0600C7D8 -- original binary (244 bytes) */
__asm__(
    ".section .text.FUN_0600C7D8, \"ax\"\n"
    ".balign 2\n"
    ".global _FUN_0600C7D8\n"
    ".type _FUN_0600C7D8, @function\n"
    "_FUN_0600C7D8:\n"
    ".byte 0x4F, 0x22, 0x53, 0xE8, 0x90, 0x6B, 0x0E, 0x36, 0x54, 0xEA, 0x53, 0xE8, 0x52, 0xE2, 0x64, 0x4D\n"  /* 0x0600C7D8 */
    ".byte 0x63, 0x3B, 0x63, 0x3D, 0x34, 0x3C, 0x93, 0x63, 0x32, 0x37, 0x8F, 0x04, 0x64, 0x4F, 0x44, 0x21\n"  /* 0x0600C7E8 */
    ".byte 0x44, 0x21, 0xA0, 0x0C, 0x44, 0x21, 0x52, 0xE2, 0x93, 0x5B, 0x32, 0x37, 0x8B, 0x02, 0x44, 0x21\n"  /* 0x0600C7F8 */
    ".byte 0xA0, 0x05, 0x44, 0x21, 0x52, 0xE2, 0x93, 0x55, 0x32, 0x37, 0x8B, 0x00, 0x44, 0x21, 0x64, 0x4D\n"  /* 0x0600C808 */
    ".byte 0x53, 0xE8, 0x63, 0x3D, 0x33, 0x4C, 0x63, 0x3F, 0x1E, 0x38, 0x62, 0x33, 0x90, 0x4B, 0x62, 0x2D\n"  /* 0x0600C818 */
    ".byte 0x03, 0xEE, 0x63, 0x3B, 0x85, 0x59, 0x63, 0x3D, 0x32, 0x3C, 0x63, 0x03, 0x63, 0x3B, 0x63, 0x3D\n"  /* 0x0600C828 */
    ".byte 0x32, 0x3C, 0x62, 0x2F, 0x1E, 0x2C, 0x85, 0x56, 0x52, 0xE7, 0x63, 0x03, 0x62, 0x2D, 0x63, 0x3D\n"  /* 0x0600C838 */
    ".byte 0x33, 0x2C, 0x63, 0x3F, 0x43, 0x21, 0x1E, 0x37, 0x85, 0x58, 0x52, 0xE9, 0x63, 0x03, 0x62, 0x2D\n"  /* 0x0600C848 */
    ".byte 0x63, 0x3D, 0x33, 0x2C, 0x63, 0x3F, 0x43, 0x21, 0x1E, 0x39, 0x53, 0xE4, 0x1E, 0x3E, 0x52, 0xE6\n"  /* 0x0600C858 */
    ".byte 0x1E, 0x2F, 0x53, 0xE8, 0x85, 0x59, 0x63, 0x3D, 0x62, 0x03, 0x62, 0x2B, 0x42, 0x21, 0x42, 0x21\n"  /* 0x0600C868 */
    ".byte 0x62, 0x2D, 0x33, 0x2C, 0x63, 0x3F, 0x1E, 0x38, 0x96, 0x1E, 0x95, 0x1E, 0x54, 0xEA, 0xD3, 0x0F\n"  /* 0x0600C878 */
    ".byte 0x36, 0xEC, 0x35, 0xEC, 0x43, 0x0B, 0x64, 0x4B, 0x90, 0x17, 0xD3, 0x0D, 0x05, 0xEE, 0x43, 0x0B\n"  /* 0x0600C888 */
    ".byte 0x54, 0xE3, 0x52, 0xE4, 0x32, 0x0C, 0x1E, 0x24, 0x90, 0x0E, 0xD3, 0x09, 0x05, 0xEE, 0x43, 0x0B\n"  /* 0x0600C898 */
    ".byte 0x54, 0xE3, 0x52, 0xE6, 0x32, 0x0C, 0x1E, 0x26, 0x4F, 0x26, 0x00, 0x0B, 0x6E, 0xF6, 0x01, 0xB0\n"  /* 0x0600C8A8 */
    ".byte 0x01, 0x18, 0x00, 0xFA, 0x00, 0xDC, 0x01, 0xD8, 0x01, 0x90, 0x01, 0x8C, 0x06, 0x02, 0x73, 0x58\n"  /* 0x0600C8B8 */
    ".byte 0x06, 0x02, 0x75, 0x52\n"  /* 0x0600C8C8 */
);

