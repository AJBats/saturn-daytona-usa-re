/* camera_angle_interp -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601424C - 0x06014360
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Camera angle interpolation — smoothly tracks a car's orientation angle
 * using halving interpolation, then builds a view matrix from the result.
 *
 * Algorithm:
 *   1. camera_push() + camera_init()
 *   2. camera_pos(0, 0x8000, 0x108F5) — fixed initial position
 *   3. Halving angle interpolation:
 *      target = car_data[slot * 32 + 24] (16-bit angle)
 *      delta = target - current_angle
 *      current_angle += (delta + (delta < 0 ? 1 : 0)) >> 1
 *   4. mat_rot_z(current_angle) — rotate by interpolated angle
 *   5. Distance interpolation:
 *      target_dist = car_data[slot * 32 + 0] (32-bit)
 *      delta = target_dist - camera_distance + 0x020C
 *      camera_distance += fpmul(delta, 0.5)
 *   6. camera_pos(0, camera_distance, 0) — update position
 *   7. mat_rot_z(-current_angle) — counter-rotate
 *   8. mat_rot_y((wind_dir & 0x1F) << 11) — apply wind/environment rotation
 *   9. mat_scale_columns(1.0, 1.0, 1.0) — identity scale
 *  10. vec_copy(src_a, 4) + vec_scale(src_b, scale, 1)
 *  11. frame_counter -= 0x30
 *
 * Persistent registers:
 *   r12 = car data entry pointer (computed from car_slot * 32 + table)
 *   r13 = camera distance state (sym_06084AFC)
 *   r14 = interpolated angle state (sym_06084AF8)
 */

    .section .text.FUN_0601424C


    .global camera_angle_interp
    .type camera_angle_interp, @function
camera_angle_interp:
    mov.l r14, @-r15
    mov.l r13, @-r15
    mov.l r12, @-r15
    sts.l pr, @-r15
    mov.l   .L_fn_camera_push, r3
    jsr @r3                              /* camera_push() — save camera state */
    nop
    mov.l   .L_fn_camera_init, r3
    jsr @r3                              /* camera_init() — reset for new frame */
    nop
    mov.l   .L_camera_z_offset, r6     /* 0x108F5 = fixed Z position */
    mov.w   DAT_06014306, r5            /* 0x8000 = fixed Y position */
    mov.l   .L_fn_camera_pos, r3
    jsr @r3                              /* camera_pos(0, 0x8000, 0x108F5) */
    mov #0x0, r4
    mov #0x0, r1                         /* === Angle interpolation === */
    mov.l   .L_car_slot_index, r12
    mov.l   .L_car_data_table, r3
    mov.l   .L_interp_angle, r14
    mov.l @r12, r12                      /* car_slot = *car_slot_index */
    shll2 r12
    shll2 r12
    shll r12                             /* car_slot * 32 */
    add r3, r12                          /* r12 = &car_data[slot * 32] */
    mov.w @(24, r12), r0                /* target_angle = car_data[+24] */
    mov.w @r14, r3                       /* current_angle */
    mov r0, r2
    sub r3, r2                           /* delta = target - current */
    cmp/gt r2, r1                        /* delta < 0? */
    addc r1, r2                          /* if negative: delta += 1 (round toward zero) */
    shar r2                              /* delta >>= 1 (halving step) */
    add r2, r3                           /* current += delta/2 */
    mov.w r3, @r14                       /* store updated angle */
    mov.l   .L_fn_rot_z, r3
    jsr @r3                              /* mat_rot_z(current_angle) */
    mov.w @r14, r4
    mov.l   .L_camera_distance, r13     /* === Distance interpolation === */
    mov.l   .L_fp_half, r5             /* 0.5 (16.16 fixed-point) */
    mov.l @r12, r4                       /* target_dist = car_data[+0] */
    mov.w   .L_distance_bias, r2        /* 0x020C = distance bias */
    mov.l @r13, r3                       /* current_distance */
    sub r3, r4                           /* delta = target - current */
    mov.l   .L_fn_fpmul, r3
    jsr @r3                              /* fpmul(delta + bias, 0.5) */
    add r2, r4                           /* r4 = delta + 0x020C (delay slot) */
    mov #0x0, r6                         /* === Update camera position === */
    mov.l @r13, r2
    add r0, r2                           /* distance += fpmul result */
    mov.l r2, @r13                       /* store updated distance */
    mov r2, r5
    mov.l   .L_fn_camera_pos, r3
    jsr @r3                              /* camera_pos(0, distance, 0) */
    mov r6, r4
    mov.w @r14, r4                       /* === Build view matrix === */
    mov.l   .L_fn_rot_z, r3
    jsr @r3                              /* mat_rot_z(-current_angle) */
    neg r4, r4
    mov.l   .L_wind_direction, r0       /* === Environment rotation === */
    mov.l   .L_fn_rot_y, r3
    mov.l @r0, r0
    and #0x1F, r0                        /* wind_dir & 0x1F (5-bit value) */
    mov r0, r4
    shll8 r4                             /* << 8 */
    shll2 r4                             /* << 10 */
    jsr @r3                              /* mat_rot_y((wind & 0x1F) << 11) */
    shll r4                              /* << 11 (delay slot) */
    mov.l   .L_fp_one, r14             /* === Identity scale + copy === */
    mov.l   .L_fn_mat_scale, r3
    mov r14, r6                          /* scale_z = 1.0 */
    mov r14, r5                          /* scale_y = 1.0 */
    jsr @r3                              /* mat_scale_columns(1.0, 1.0, 1.0) */
    mov r14, r4                          /* scale_x = 1.0 */
    mov #0x4, r5                         /* count = 4 */
    mov.l   .L_vec_src_a, r4
    mov.l   .L_fn_vec_copy, r3
    jsr @r3                              /* vec_copy(src_a[value], 4) */
    mov.l @r4, r4
    mov #0x1, r6                         /* count = 1 */
    mov.l   .L_scale_factor, r5
    mov.l   .L_vec_src_b, r4
    mov.l   .L_fn_vec_scale, r3
    mov.w @r5, r5                        /* scale = *scale_factor (16-bit) */
    jsr @r3                              /* vec_scale(src_b[value], scale, 1) */
    mov.l @r4, r4
    mov.l   .L_frame_counter, r4       /* === Decrement frame counter === */
    mov.l @r4, r2
    add #-0x30, r2                       /* counter -= 0x30 (48 units) */
    mov.l r2, @r4
    lds.l @r15+, pr
    mov.l @r15+, r12
    mov.l @r15+, r13
    rts
    mov.l @r15+, r14

    .global DAT_06014306
DAT_06014306:
    .2byte  0x8000                        /* initial Y position (half-rotation) */
.L_distance_bias:
    .2byte  0x020C                        /* distance interpolation bias */
    .2byte  0xFFFF
.L_fn_camera_push:
    .4byte  sym_06026E0C               /* camera state push/save */
.L_fn_camera_init:
    .4byte  sym_06026DBC               /* camera state initialization */
.L_camera_z_offset:
    .4byte  0x000108F5                  /* fixed Z camera position */
.L_fn_camera_pos:
    .4byte  sym_06026E2E               /* set camera base position */
.L_car_slot_index:
    .4byte  sym_06084B08               /* active car slot index (32-bit ptr) */
.L_car_data_table:
    .4byte  sym_0605AD5C               /* car data table base */
.L_interp_angle:
    .4byte  sym_06084AF8               /* interpolated angle state (16-bit) */
.L_fn_rot_z:
    .4byte  mat_rot_z                  /* Z-axis rotation */
.L_camera_distance:
    .4byte  sym_06084AFC               /* camera distance state (32-bit) */
.L_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_fn_fpmul:
    .4byte  fpmul                      /* fixed-point multiply */
.L_wind_direction:
    .4byte  sym_0607EBC8               /* wind/environment direction (5-bit used) */
.L_fn_rot_y:
    .4byte  mat_rot_y                  /* Y-axis rotation */
.L_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_fn_mat_scale:
    .4byte  mat_scale_columns          /* matrix column scaling */
.L_vec_src_a:
    .4byte  sym_060623AC               /* vector source A (ptr to data) */
.L_fn_vec_copy:
    .4byte  sym_06031D8C               /* vector copy function */
.L_scale_factor:
    .4byte  sym_06089E4A               /* per-mode scale factor (16-bit) */
.L_vec_src_b:
    .4byte  sym_06062334               /* vector source B (ptr to data) */
.L_fn_vec_scale:
    .4byte  sym_06031A28               /* scaled vector copy function */
.L_frame_counter:
    .4byte  sym_06089EDC               /* frame/position counter (32-bit) */
