/* scene_data_write_abs -- Absolute scene data writer
 * Translation unit: 0x0603853C - 0x06038642
 *
 * Sets scene rendering pipeline buffers to absolute values. Called with:
 *   r4 = x value (or position value depending on mode)
 *   r5 = y value (or position value depending on mode)
 *   r6 = color matrix value (for channel modes 1/2 only)
 *
 * Dispatches on scene_mode (at sym_060635A8) to select target buffer:
 *   mode 0x04 -> scene buffer A, offsets +0x00/+0x04 (32-bit position XY)
 *   mode 0x08 -> scene buffer A, offsets +0x10/+0x14 (32-bit scale/second XY)
 *   mode 0x10 -> scene buffer A, offsets +0x20/+0x22 (16-bit, upper 16 of value)
 *   mode 0x20 -> scene buffer A, offsets +0x24/+0x26 (16-bit, upper 16 of value)
 *   mode 0x01 -> scene view channel 1 at +0x44/+0x48, plus color accumulator
 *   mode 0x02 -> scene view channel 2 at +0x44/+0x48, plus color accumulator
 *
 * Unlike scene_data_write_add which accumulates deltas, this function writes
 * absolute values directly. For channel modes (1/2): conditionally sets r6
 * into the color matrix accumulator, then tail-calls scene_color_matrix with
 * (r4=0, r5=0, r6=0) if the accumulated value is nonzero. The condition
 * checks scene source pointers and view transform flags to decide whether
 * to store or clear.
 *
 * Auto-generated by tools/generate_l3_tu.py
 */

    .section .text.FUN_0603853C


    .global scene_data_write_abs
    .type scene_data_write_abs, @function
scene_data_write_abs:
    mov.l r14, @-r15                            ! save r14 (used for color accum ptr)
    mov.l   .L_pool_color_accum_ptr, r14        ! r14 = &color_matrix_accum (2 longwords)
    mov.l   .L_pool_scene_buf_a, r7             ! r7 = &scene_buffer_a (pipe_buf_2, 64 bytes)
    mov.l   .L_pool_scene_mode, r0              ! r0 = &scene_mode selector
    bra     .L_dispatch_mode                    ! jump to mode dispatch switch
    mov.l @r0, r0                               ! r0 = scene_mode value (delay slot)
.L_mode_04_set_pos_xy:
    mov.l r4, @r7                               ! scene_buf_a[0x00] = r4 (set position X)
    bra     .L_return                           ! done -- return
    mov.l r5, @(4, r7)                          ! scene_buf_a[0x04] = r5 (set position Y, delay slot)
.L_mode_08_set_scale_xy:
    mov.l r4, @(16, r7)                         ! scene_buf_a[0x10] = r4 (set scale X / second XY pair)
    bra     .L_return                           ! done -- return
    mov.l r5, @(20, r7)                         ! scene_buf_a[0x14] = r5 (set scale Y / second XY pair, delay slot)
.L_mode_10_set_hi16_xy_a:
    shlr16 r4                                   ! r4 >>= 16 -- extract upper 16 bits of x value
    exts.w r4, r4                               ! sign-extend low 16 to 32 bits
    extu.w r4, r4                               ! zero-extend to unsigned 16 bits
    mov #0x20, r0                               ! r0 = 0x20 (offset to 16-bit X field A)
    mov.w r4, @(r0, r7)                         ! scene_buf_a.w[0x20] = r4 (set 16-bit X)
    shlr16 r5                                   ! r5 >>= 16 -- extract upper 16 bits of y value
    exts.w r5, r5                               ! sign-extend low 16 to 32 bits
    extu.w r5, r5                               ! zero-extend to unsigned 16 bits
    bra     .L_store_hi16_y                     ! jump to store Y and return
    mov #0x22, r0                               ! r0 = 0x22 (offset to 16-bit Y field A, delay slot)
.L_mode_20_set_hi16_xy_b:
    shlr16 r4                                   ! r4 >>= 16 -- extract upper 16 bits of x value
    exts.w r4, r4                               ! sign-extend low 16 to 32 bits
    extu.w r4, r4                               ! zero-extend to unsigned 16 bits
    mov #0x24, r0                               ! r0 = 0x24 (offset to 16-bit X field B)
    mov.w r4, @(r0, r7)                         ! scene_buf_a.w[0x24] = r4 (set 16-bit X field B)
    shlr16 r5                                   ! r5 >>= 16 -- extract upper 16 bits of y value
    exts.w r5, r5                               ! sign-extend low 16 to 32 bits
    extu.w r5, r5                               ! zero-extend to unsigned 16 bits
    mov #0x26, r0                               ! r0 = 0x26 (offset to 16-bit Y field B)
.L_store_hi16_y:
    bra     .L_return                           ! done -- return
    mov.w r5, @(r0, r7)                         ! scene_buf_a.w[r0] = r5 (set 16-bit Y, delay slot)
.L_mode_01_set_view_chan1:
    mov #0x44, r0                               ! r0 = 0x44 (offset to view X in channel struct)
    mov.l   .L_pool_scene_view_ch1, r7          ! r7 = &scene_view_ch1 struct
    mov.l r4, @(r0, r7)                         ! view_ch1[0x44] = r4 (set view X)
    mov #0x48, r0                               ! r0 = 0x48 (offset to view Y in channel struct)
    mov.l r5, @(r0, r7)                         ! view_ch1[0x48] = r5 (set view Y)
    mov.l   .L_pool_scene_a_src, r3             ! r3 = &scene_a_src_ptr
    mov.l @r3, r0                               ! r0 = scene_a_src_ptr value
    tst r0, r0                                  ! is scene A source null?
    bt      .L_ch1_clear_accum                  ! if null -> clear accumulator
    mov.l   .L_pool_scene_a_flag, r3            ! r3 = &scene_a_secondary_flag
    mov.l @r3, r0                               ! r0 = scene_a_secondary_flag value
    tst r0, r0                                  ! is secondary flag zero?
    bt      .L_ch1_store_color                  ! if zero -> store color value
    mov.l   .L_pool_xform_flag_a, r3            ! r3 = &view_transform_flag_a
    mov.l @r3, r0                               ! r0 = view_transform_flag_a value
    tst r0, r0                                  ! is transform flag zero?
    bf      .L_ch1_clear_accum                  ! if nonzero -> clear accumulator (both flags set)
.L_ch1_store_color:
    bra     .L_ch1_check_tailcall               ! jump to check if tail-call needed
    mov.l r6, @r14                              ! color_accum[0] = r6 (set absolute color, delay slot)
.L_ch1_clear_accum:
    mov #0x0, r2                                ! r2 = 0
    mov.l r2, @r14                              ! color_accum[0] = 0 (clear channel 1 accum)
.L_ch1_check_tailcall:
    mov.l @r14, r0                              ! r0 = color_accum[0] (current value)
    tst r0, r0                                  ! is color accumulator zero?
    bt      .L_return                           ! if zero -> nothing to apply, return
    mov #0x0, r6                                ! r6 = 0 (clear color arg for tail-call)
    mov r6, r5                                  ! r5 = 0 (clear y arg for tail-call)
    mov r6, r4                                  ! r4 = 0 (clear x arg for tail-call)
    mov.l   .L_pool_scene_color_matrix_ch1, r3  ! r3 = &scene_color_matrix
    jmp @r3                                     ! tail-call scene_color_matrix(0, 0, 0)
    mov.l @r15+, r14                            ! restore r14 (delay slot -- epilogue before jmp)
.L_mode_02_set_view_chan2:
    mov #0x44, r0                               ! r0 = 0x44 (offset to view X in channel struct)
    mov.l   .L_pool_scene_view_ch2, r7          ! r7 = &scene_view_ch2 struct
    mov.l r4, @(r0, r7)                         ! view_ch2[0x44] = r4 (set view X)
    mov #0x48, r0                               ! r0 = 0x48 (offset to view Y in channel struct)
    mov.l r5, @(r0, r7)                         ! view_ch2[0x48] = r5 (set view Y)
    mov.l   .L_pool_scene_b_src, r3             ! r3 = &scene_b_src_ptr
    mov.l @r3, r0                               ! r0 = scene_b_src_ptr value
    tst r0, r0                                  ! is scene B source null?
    bt      .L_ch2_clear_accum                  ! if null -> clear accumulator
    mov.l   .L_pool_scene_b_flag, r3            ! r3 = &scene_b_secondary_flag
    mov.l @r3, r0                               ! r0 = scene_b_secondary_flag value
    tst r0, r0                                  ! is secondary flag zero?
    bt      .L_ch2_store_color                  ! if zero -> store color value
    mov.l   .L_pool_xform_flag_b, r3            ! r3 = &view_transform_flag_b
    mov.l @r3, r0                               ! r0 = view_transform_flag_b value
    tst r0, r0                                  ! is transform flag zero?
    bf      .L_ch2_clear_accum                  ! if nonzero -> clear accumulator (both flags set)
.L_ch2_store_color:
    bra     .L_ch2_check_tailcall               ! jump to check if tail-call needed
    mov.l r6, @(4, r14)                         ! color_accum[1] = r6 (set absolute color, delay slot)
.L_pool_color_accum_ptr:
    .4byte  sym_060A4C78                        ! color matrix accumulator (2 longwords, indexed per channel)
.L_pool_scene_buf_a:
    .4byte  sym_060A3DF8                        ! scene buffer A (pipe_buf_2, 64 bytes)
.L_pool_scene_mode:
    .4byte  sym_060635A8                        ! scene mode selector (longword)
.L_pool_scene_view_ch1:
    .4byte  sym_060A3E68                        ! scene view struct, channel 1
.L_pool_scene_a_src:
    .4byte  sym_060A4C44                        ! scene A source pointer (primary enable)
.L_pool_scene_a_flag:
    .4byte  sym_060A4C4C                        ! scene A secondary flag (secondary enable)
.L_pool_xform_flag_a:
    .4byte  sym_060A4C70                        ! view transform flag A (override disable)
.L_pool_scene_color_matrix_ch1:
    .4byte  scene_color_matrix                  ! scene_color_matrix function address
.L_pool_scene_view_ch2:
    .4byte  sym_060A3EE8                        ! scene view struct, channel 2
.L_pool_scene_b_src:
    .4byte  sym_060A4C48                        ! scene B source pointer (primary enable)
.L_pool_scene_b_flag:
    .4byte  sym_060A4C50                        ! scene B secondary flag (secondary enable)
.L_pool_xform_flag_b:
    .4byte  sym_060A4C74                        ! view transform flag B (override disable)
.L_ch2_clear_accum:
    mov #0x0, r2                                ! r2 = 0
    mov.l r2, @(4, r14)                         ! color_accum[1] = 0 (clear channel 2 accum)
.L_ch2_check_tailcall:
    mov.l @(4, r14), r0                         ! r0 = color_accum[1] (current value)
    tst r0, r0                                  ! is color accumulator zero?
    bt      .L_return                           ! if zero -> nothing to apply, return
    mov #0x0, r6                                ! r6 = 0 (clear color arg for tail-call)
    mov r6, r5                                  ! r5 = 0 (clear y arg for tail-call)
    mov r6, r4                                  ! r4 = 0 (clear x arg for tail-call)
    .byte   0xD3, 0x21    /* mov.l .L_pool_scene_color_matrix_ch2, r3 */  ! r3 = &scene_color_matrix (pool in scene_data_write_add TU)
    jmp @r3                                     ! tail-call scene_color_matrix(0, 0, 0)
    mov.l @r15+, r14                            ! restore r14 (delay slot -- epilogue before jmp)
.L_dispatch_mode:
    cmp/eq #0x1, r0                             ! mode == 1? (scene view channel 1)
    bt      .L_mode_01_set_view_chan1            ! -> set channel 1 view + color accum
    cmp/eq #0x2, r0                             ! mode == 2? (scene view channel 2)
    bt      .L_mode_02_set_view_chan2            ! -> set channel 2 view + color accum
    cmp/eq #0x4, r0                             ! mode == 4? (position XY, 32-bit)
    bt      .L_mode_04_set_pos_xy               ! -> set position XY
    cmp/eq #0x8, r0                             ! mode == 8? (scale/second XY, 32-bit)
    bt      .L_mode_08_set_scale_xy             ! -> set scale XY
    cmp/eq #0x10, r0                            ! mode == 0x10? (hi16 XY field A, 16-bit)
    bt      .L_mode_10_set_hi16_xy_a            ! -> set upper-16 to XY field A
    cmp/eq #0x20, r0                            ! mode == 0x20? (hi16 XY field B, 16-bit)
    bt      .L_mode_20_set_hi16_xy_b            ! -> set upper-16 to XY field B
.L_return:
    rts                                         ! return to caller
    mov.l @r15+, r14                            ! restore r14 (delay slot)
