/* disc_load_complete_check -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0601B418 - 0x0601B48C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * Disc load completion handler — dispatches current disc state,
 * then performs a frame update cycle (transform + commit).
 *
 * Called each frame from state_resource_load while disc I/O is active.
 * Reads the disc_load_phase byte (sym_0608600D) as an index into the
 * disc state jump table (sym_0605DEB4), which contains:
 *   [0] = disc_read_check      — poll CD block for read completion
 *   [1] = disc_error_handler   — handle read errors / retries
 *   [2] = loc_0601B566          — finalize loaded data
 *
 * After dispatching, pushes 3 stack parameters (display config: flags,
 * fixed-point scale 1.0, fixed-point offset 0.5) and calls
 * rigid_body_transform with WRAM-Low base and MINIT comm register,
 * then frame_end_commit to flush the display list.
 *
 * Finally, increments the texture load progress counter (sym_0605D4F8)
 * and returns the disc_load_status byte (sym_0608600C) in r0.
 *
 * Key symbols:
 *   sym_0608600C  = disc_load_status (byte) — returned in r0
 *   sym_0608600D  = disc_load_phase (byte) — index into state jump table
 *   sym_0608600E  = frame_counter (byte) — animation frame selector
 *   sym_0605DEB4  = disc_state_table (3 function pointers)
 *   sym_0605D4F8  = texture_load_progress (word) — incremented each call
 */

    .section .text.FUN_0601B418


    .global disc_load_complete_check
    .type disc_load_complete_check, @function
disc_load_complete_check:
    sts.l pr, @-r15                             ! save return address to stack
    mov.l   .L_pool_disc_load_phase, r3         ! r3 = &disc_load_phase (sym_0608600D)
    mov.l   .L_pool_disc_state_table, r2        ! r2 = &disc_state_table (sym_0605DEB4)
    mov.b @r3, r3                               ! r3 = disc_load_phase byte value
    extu.b r3, r3                               ! zero-extend byte to 32-bit unsigned
    shll2 r3                                    ! r3 *= 4 (convert index to table offset)
    add r2, r3                                  ! r3 = &disc_state_table[phase]
    mov.l @r3, r3                               ! r3 = disc_state_table[phase] (fn pointer)
    jsr @r3                                     ! call state handler for current phase
    nop                                         ! delay slot
    mov.w   .L_wpool_0601B45A, r2               ! r2 = 0x0101 (display config: flags byte pair)
    mov.l r2, @-r15                             ! push display flags onto stack (param 3)
    mov.l   .L_pool_fp_one, r3                  ! r3 = 0x00010000 (1.0 in 16.16 fixed-point)
    mov.l r3, @-r15                             ! push scale factor onto stack (param 2)
    mov.l   .L_pool_fp_half, r2                 ! r2 = 0x00008000 (0.5 in 16.16 fixed-point)
    mov.l r2, @-r15                             ! push offset value onto stack (param 1)
    mov.l   .L_pool_wram_low_base, r7           ! r7 = 0x00200000 (Work RAM Low base address)
    mov.l   .L_pool_minit_comm, r5              ! r5 = 0x01000000 (MINIT — primary SH-2 comm)
    mov.l   .L_pool_fn_rigid_body_transform, r3 ! r3 = &rigid_body_transform
    mov r7, r6                                  ! r6 = WRAM-Low base (copy for arg passing)
    jsr @r3                                     ! call rigid_body_transform(r4=MINIT, r5=MINIT, r6=WRAM, r7=WRAM, stack params)
    mov r5, r4                                  ! delay slot: r4 = MINIT comm register
    mov.l   .L_pool_fn_frame_end_commit, r3     ! r3 = &frame_end_commit
    jsr @r3                                     ! call frame_end_commit() — flush display list
    add #0xC, r15                               ! delay slot: pop 3 stack params (12 bytes)
    mov.l   .L_pool_tex_load_progress, r4       ! r4 = &texture_load_progress (sym_0605D4F8)
    mov.w @r4, r2                               ! r2 = current texture_load_progress (word)
    add #0x1, r2                                ! r2 += 1 (increment progress counter)
    mov.w r2, @r4                               ! store updated progress counter
    mov.l   .L_pool_disc_load_status, r0        ! r0 = &disc_load_status (sym_0608600C)
    lds.l @r15+, pr                             ! restore return address from stack
    rts                                         ! return to caller
    mov.b @r0, r0                               ! delay slot: r0 = disc_load_status byte (return value)
.L_wpool_0601B45A:
    .2byte  0x0101
.L_pool_disc_load_status:
    .4byte  sym_0608600C
    .4byte  sym_0608600E
    .4byte  handler_dispatch
.L_pool_disc_load_phase:
    .4byte  sym_0608600D
.L_pool_disc_state_table:
    .4byte  sym_0605DEB4
.L_pool_fp_one:
    .4byte  0x00010000                  /* 1.0 (16.16 fixed-point) */
.L_pool_fp_half:
    .4byte  0x00008000                  /* 0.5 (16.16 fixed-point) */
.L_pool_wram_low_base:
    .4byte  0x00200000                  /* Work RAM Low base */
.L_pool_minit_comm:
    .4byte  0x01000000                  /* MINIT — primary SH-2 init comm */
.L_pool_fn_rigid_body_transform:
    .4byte  rigid_body_transform
.L_pool_fn_frame_end_commit:
    .4byte  frame_end_commit
.L_pool_tex_load_progress:
    .4byte  sym_0605D4F8
