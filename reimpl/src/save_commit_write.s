/* save_commit_write -- L3 assembly (SH-2 mnemonics)
 * Translation unit: 0x0603BF22 - 0x0603C08C
 * Auto-generated by tools/generate_l3_tu.py
 *
 * This TU contains save-data commit logic plus SH-2 cache management functions.
 *
 * Function catalog:
 *   save_commit_write      -- Commit a save field: calls save_field_read to
 *                             remove an entry, clears the dirty flag at
 *                             struct+0xEC, then optionally tail-calls
 *                             watchdog_timer_reset if a callback context
 *                             was provided.
 *   cache_purge_full_init  -- Full SH-2 cache purge + reconfiguration.
 *          (sym_0603BF7C)     Called once at boot from system_init. Disables
 *                             cache, zeroes all 256 cache address array
 *                             entries (4 ways x 64 sets) via 0x60000000,
 *                             configures two-way mode from r4, then
 *                             re-enables cache.
 *   cache_purge_renable    -- Cache purge + re-enable (no reconfiguration).
 *          (sym_0603C000)     Called during rendering (VDP1 cmd list reset)
 *                             and DMA setup. Purges all cache lines then
 *                             sets CE=1. Does not touch TW/ID/OD bits.
 *   cache_region_purge     -- Targeted cache purge for a memory region.
 *          (sym_0603C05C)     Maps address into SH-2 associative purge space
 *                             (0x40000000) and writes zeros at 16-byte stride
 *                             to invalidate matching cache lines.
 *
 * SH-2 CCR (0xFFFFFE92) bit layout:
 *   Bit 0: CE  = Cache Enable
 *   Bit 1: ID  = Instruction-replacement Disable
 *   Bit 2: OD  = Data-replacement Disable
 *   Bit 3: TW  = Two-Way mode (reduce 4-way to 2-way)
 *   Bit 4: CP  = Cache Purge (write-only)
 *   Bits 6-7: W1/W0 = Way specification for address array access
 *
 * Cache address array (0x60000000):
 *   Each entry is 4 bytes at 16-byte stride. Writing 0 invalidates the line.
 *   4 ways x 64 sets = 256 entries total, covering 0x1000 bytes of array space.
 *
 * Associative purge (0x40000000):
 *   Writing to this region purges any cache line whose tag matches the address.
 */

    .section .text.FUN_0603BF22


    .global save_commit_write
    .type save_commit_write, @function
save_commit_write:
    mov.l r14, @-r15                     ! save r14 (callee-saved)
    sts.l pr, @-r15                      ! save return address
    mov r5, r14                          ! r14 = callback_ctx (second arg)
    add #-0x4, r15                       ! allocate 4 bytes on stack
    mov.l r4, @r15                       ! save r4 (save_struct ptr) on stack
    .byte   0xBD, 0x53    /* bsr 0x0603B9D6 (external) */  ! call save_field_read
    mov r5, r4                           ! delay: r4 = callback_ctx (becomes save_field_read arg)
    mov.l @r15, r4                       ! restore r4 = save_struct ptr
    mov #0x0, r3                         ! r3 = 0 (clear value)
    mov.w   save_dirty_offset, r0        ! r0 = 0xEC (dirty flag offset)
    mov.l r3, @(r0, r4)                  ! save_struct[0xEC] = 0 (clear dirty flag)
    tst r14, r14                         ! callback_ctx == NULL?
    bf      .have_callback               ! branch if callback_ctx != NULL
    add #0x4, r15                        ! deallocate stack frame
    lds.l @r15+, pr                      ! restore return address
    rts                                  ! return (no callback)
    mov.l @r15+, r14                     ! delay: restore r14
.have_callback:
    mov.l @r14, r4                       ! r4 = callback_ctx->base_ptr
    mov.l @(24, r4), r4                  ! r4 = base_ptr->handler_table[6]
    add #0x4, r15                        ! deallocate stack frame
    lds.l @r15+, pr                      ! restore return address
    .byte   0xD3, 0x08    /* mov.l .pool_watchdog_fn, r3 */  ! r3 = &watchdog_timer_reset
    jmp @r3                              ! tail-call watchdog_timer_reset(r4)
    mov.l @r15+, r14                     ! delay: restore r14
    /* --- dead code: unreachable alternate implementation --- */
    .2byte  0x7F04
    .4byte  0x4F26000B
    .4byte  0x6EF6E11D
    .4byte  0x6042001C
    .4byte  0x600CC860
    .4byte  0x8B066542
    .4byte  0x5556A004
    .2byte  0x5459

    .global DAT_0603bf6e
save_dirty_offset:
DAT_0603bf6e:
    .2byte  0x00EC
.pool_watchdog_fn:
    .4byte  watchdog_timer_reset
    .4byte  0xE400000B
    .4byte  0x60430000

    .global sym_0603BF7C
sym_0603BF7C:
    mov.l r13, @-r15                     ! save r13 (way counter)
    mov.l r12, @-r15                     ! save r12 (total entry limit)
    mov.l r11, @-r15                     ! save r11 (cache addr array base)
    mov.l r10, @-r15                     ! save r10 (entries per way)
    mov.l r9, @-r15                      ! save r9 (way-clear mask)
    mov #0x3F, r9                        ! r9 = 0x3F (mask: clear bits 6-7 = way select)
    mov #0x40, r10                       ! r10 = 64 (entries per way, used as loop init)
    .byte   0xDB, 0x1C    /* mov.l .pool_cache_addr_array, r11 */  ! r11 = 0x60000000 (cache addr array base)
    mov.w   .cache_total_entries, r12    ! r12 = 0x0100 = 256 (4 ways x 64 entries)
    mov #0x0, r7                         ! r7 = 0 (value to write — invalidate)
    mov.w   .ccr_addr, r5               ! r5 = 0xFFFFFE92 (SH-2 CCR address, sign-extended)
    mov.b @r5, r0                        ! r0 = current CCR value
    extu.b r0, r0                        ! zero-extend to 32 bits
    and #0xFE, r0                        ! clear bit 0 (CE=0: disable cache)
    extu.b r0, r0                        ! zero-extend result
    mov.b r0, @r5                        ! write CCR — cache now disabled
    mov r7, r13                          ! r13 = 0 (way counter: 0, 64, 128, 192)
.way_loop:
    mov.b @r5, r3                        ! r3 = current CCR value
    extu.b r3, r3                        ! zero-extend
    and r9, r3                           ! clear bits 6-7 (way select field)
    extu.b r13, r2                       ! r2 = way counter low byte (selects way via bits 6-7)
    or r2, r3                            ! set way select bits from counter
    extu.b r3, r3                        ! zero-extend
    mov.b r3, @r5                        ! write CCR — select current way
    mov r11, r6                          ! r6 = 0x60000000 (cache addr array write ptr)
    mov r10, r1                          ! r1 = 64 (entry counter for this way)
.entry_clear_loop:
    mov.l r7, @r6                        ! write 0 to cache addr array entry [even]
    add #-0x2, r1                        ! decrement counter by 2 (two entries per iteration)
    add #0x10, r6                        ! advance to next entry (+16 byte stride)
    mov.l r7, @r6                        ! write 0 to cache addr array entry [odd]
    tst r1, r1                           ! counter == 0?
    bf/s    .entry_clear_loop            ! loop if entries remain
    add #0x10, r6                        ! delay: advance to next entry
    add #0x40, r13                       ! way counter += 64 (next way)
    cmp/hs r12, r13                      ! way counter >= 256? (all 4 ways done?)
    bf      .way_loop                    ! loop if more ways remain
    extu.b r4, r4                        ! r4 = TW flag from caller (bit 3 only)
    mov.b @r5, r0                        ! r0 = current CCR
    extu.b r0, r0                        ! zero-extend
    and #0xF7, r0                        ! clear bit 3 (TW — two-way mode)
    or r4, r0                            ! set TW from argument (r4)
    mov.b r0, @r5                        ! write CCR — configure two-way mode
    mov.b @r5, r0                        ! re-read CCR
    extu.b r0, r0                        ! zero-extend
    and #0xFD, r0                        ! clear bit 1 (ID=0: enable instruction replacement)
    mov.b r0, @r5                        ! write CCR
    mov.b @r5, r0                        ! re-read CCR
    extu.b r0, r0                        ! zero-extend
    and #0xFB, r0                        ! clear bit 2 (OD=0: enable data replacement)
    mov.b r0, @r5                        ! write CCR
    mov.b @r5, r0                        ! re-read CCR
    extu.b r0, r0                        ! zero-extend
    and #0xFE, r0                        ! clear bit 0 (prepare CE field)
    or #0x1, r0                          ! set bit 0 (CE=1: enable cache)
    extu.b r0, r0                        ! zero-extend
    mov.b r0, @r5                        ! write CCR — cache enabled with new config
    mov.l @r15+, r9                      ! restore r9
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    rts                                  ! return
    mov.l @r15+, r13                     ! delay: restore r13
.cache_total_entries:
    .2byte  0x0100
.ccr_addr:
    .2byte  0xFE92
.pool_cache_addr_array:
    .4byte  0x60000000

    .global sym_0603C000
sym_0603C000:
    mov.l r13, @-r15                     ! save r13 (cache addr array base)
    mov.l r12, @-r15                     ! save r12 (total entry limit)
    mov.l r11, @-r15                     ! save r11 (way-clear mask)
    mov.l r10, @-r15                     ! save r10 (entries per way)
    mov #0x40, r10                       ! r10 = 64 (entries per way)
    mov #0x3F, r11                       ! r11 = 0x3F (mask: clear bits 6-7)
    mov.w   DAT_0603c07a, r12            ! r12 = 0x0100 = 256 (total entries)
    .byte   0xDD, 0x1C    /* mov.l .pool_cache_addr_array_b, r13 */  ! r13 = 0x60000000 (cache addr array base)
    mov #0x0, r7                         ! r7 = 0 (invalidate value)
    mov.w   .ccr_addr_b, r5             ! r5 = 0xFFFFFE92 (CCR address, sign-extended)
    mov.b @r5, r0                        ! r0 = current CCR
    extu.b r0, r0                        ! zero-extend
    and #0xFE, r0                        ! clear bit 0 (CE=0: disable cache)
    extu.b r0, r0                        ! zero-extend
    mov.b r0, @r5                        ! write CCR — cache disabled
    mov r7, r1                           ! r1 = 0 (way counter)
.way_loop_b:
    mov.b @r5, r3                        ! r3 = current CCR
    extu.b r3, r3                        ! zero-extend
    and r11, r3                          ! clear way select bits (6-7)
    extu.b r1, r2                        ! r2 = way counter low byte
    or r2, r3                            ! set way select from counter
    extu.b r3, r3                        ! zero-extend
    mov.b r3, @r5                        ! write CCR — select current way
    mov r13, r4                          ! r4 = 0x60000000 (write pointer)
    mov r10, r6                          ! r6 = 64 (entry counter)
.entry_clear_loop_b:
    add #-0x2, r6                        ! decrement counter by 2
    mov.l r7, @r4                        ! write 0 to cache addr array entry [even]
    add #0x10, r4                        ! advance to next entry (+16 byte stride)
    mov.l r7, @r4                        ! write 0 to cache addr array entry [odd]
    tst r6, r6                           ! counter == 0?
    bf/s    .entry_clear_loop_b          ! loop if entries remain
    add #0x10, r4                        ! delay: advance to next entry
    add #0x40, r1                        ! way counter += 64 (next way)
    cmp/hs r12, r1                       ! way counter >= 256?
    bf      .way_loop_b                  ! loop if more ways remain
    mov.b @r5, r0                        ! r0 = current CCR
    extu.b r0, r0                        ! zero-extend
    and #0xFE, r0                        ! clear bit 0 (prepare CE field)
    or #0x1, r0                          ! set bit 0 (CE=1: enable cache)
    extu.b r0, r0                        ! zero-extend
    mov.b r0, @r5                        ! write CCR — cache re-enabled
    mov.l @r15+, r10                     ! restore r10
    mov.l @r15+, r11                     ! restore r11
    mov.l @r15+, r12                     ! restore r12
    rts                                  ! return
    mov.l @r15+, r13                     ! delay: restore r13

    .global sym_0603C05C
sym_0603C05C:
    .byte   0xD3, 0x09    /* mov.l .pool_addr_mask_16align, r3 */  ! r3 = 0x1FFFFFF0 (28-bit addr mask, 16-byte aligned)
    .byte   0xD2, 0x0A    /* mov.l .pool_purge_region_base, r2 */ ! r2 = 0x40000000 (associative purge region base)
    and r3, r4                           ! r4 = addr & 0x1FFFFFF0 (extract physical addr, aligned)
    or r2, r4                            ! r4 |= 0x40000000 (map into purge address space)
    mov r4, r7                           ! r7 = purge_start
    add r5, r7                           ! r7 = purge_start + size (purge_end)
    cmp/hs r7, r4                        ! purge_start >= purge_end? (nothing to clear?)
    bt/s    .purge_done                  ! skip if nothing to clear
    mov #0x0, r6                         ! delay: r6 = 0 (write value)
.purge_loop:
    mov.l r6, @r4                        ! write 0 to purge address (invalidates matching cache line)
    add #0x10, r4                        ! advance by 16 bytes (one cache line)
    cmp/hs r7, r4                        ! current >= end?
    bf      .purge_loop                  ! loop if more lines to purge
.purge_done:
    rts                                  ! return
    nop                                  ! delay: nop

    .global DAT_0603c07a
DAT_0603c07a:
    .2byte  0x0100
.ccr_addr_b:
    .2byte  0xFE92
    .2byte  0xFFFF
.pool_cache_addr_array_b:
    .4byte  0x60000000
.pool_addr_mask_16align:
    .4byte  0x1FFFFFF0
.pool_purge_region_base:
    .4byte  0x40000000                  /* associative purge region base address */
