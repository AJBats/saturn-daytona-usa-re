Delta=0 Analysis: Functions with Matching Opcode Count but Different Sequences
===============================================================================
Generated: 2026-02-03

These 6 functions produce the same number of opcodes as the original binary,
but the opcode mnemonic sequences differ. This analysis identifies the exact
pattern of difference for each and categorizes them.

================================================================================
FUNCTION 1: FUN_06011494  (12 opcodes each)
================================================================================

C Source: Leaf function. Zero-clears 0x0607EADC, then loads a word from a
table at 0x060447A8 indexed by (param_1 << 4) and stores to 0x06078860.

OURS (GCC 2.6.3):                    ORIGINAL BINARY:
 1  mov.l   L2,r1                     1  extu.w  r4,r0
 2  mov     #0,r0                     2  mov     #0,r2
 3  mov.l   L3,r3                     3  mov.l   @(0x64,PC),r1   {0x0607EADC}
 4  mov.l   r0,@r3                    4  mov.l   @(0x60,PC),r3   {0x060447A8}
 5  extu.w  r4,r4                     5  shll2   r0
 6  mov     r4,r0                     6  mov.l   r2,@r1
 7  shll2   r0                        7  shll2   r0
 8  shll2   r0                        8  mov.l   @(0x60,PC),r1   {0x06078860}
 9  mov.l   @(r0,r1),r1               9  add     r3,r0
10  mov.l   L4,r3                    10  mov.l   @r0,r2
11  rts                              11  rts
12  mov.l   r1,@r3                   12  mov.l   r2,@r1

DIFFERENCES:
  (a) SCHEDULING: Original interleaves the extu.w and constant pool loads
      more aggressively. It does extu.w first (line 1), then loads constants
      (lines 3-4), then shifts (lines 5,7). Our GCC loads constants first
      (lines 1-3), then does the store (line 4), then extu.w (line 5), then
      needs an extra "mov r4,r0" (line 6) to move the result to r0.

  (b) REGISTER ALLOCATION: Original uses r0 as the working register for the
      index throughout (extu.w r4,r0 directly), and uses r2 for the zero
      constant. Our GCC uses r0 for the zero, then later extu.w r4,r4
      (extending in place) and needs "mov r4,r0" to get it into r0 for the
      shll2 instructions.

  (c) ADDRESSING MODE: Original uses "add r3,r0" then "mov.l @r0,r2" for
      the table lookup (2 insns). Ours uses "mov.l @(r0,r1),r1" (indexed
      addressing, 1 insn) but needs the extra "mov r4,r0" earlier.
      Net result: same count but different instruction mix.

  PATTERN: Scheduling + register allocation difference. The original
  compiler scheduled the extu.w earlier and used r0 as the index register
  from the start, avoiding the extra register-to-register move. Our GCC
  emits the constant pool loads first, which forces extu.w to a later
  position and requires a compensating mov.

  OPCODE-LEVEL DIFF:
    Position 1: mov.l vs extu.w   (scheduling)
    Position 5: extu.w vs shll2   (scheduling)
    Position 6: mov vs mov.l      (extra reg move vs interleaved const load)
    Position 9: mov.l vs add      (indexed addr mode vs add+load)


================================================================================
FUNCTION 2: FUN_06026E0C  (17 opcodes each)
================================================================================

C Source: Loads a pointer from 0x06089EDC, initializes a 12-element (48-byte)
identity-like matrix: diagonal entries = 0x00010000, off-diagonal = 0.

OURS (GCC 2.6.3):                    ORIGINAL BINARY:
 1  mov.l   L2,r1                     1  mov.l   @(0x258,PC),r0  {0x06089EDC}
 2  mov.l   L3,r0                     2  mov     #0,r2
 3  mov.l   @r0,r0                    3  mov.l   @r0,r0
 4  mov     #0,r2                     4  mov.l   @(0x268,PC),r1  {0x00010000}
 5  mov.l   r2,@(4,r0)                5  mov.l   r2,@(4,r0)
 6  mov.l   r1,@r0                    6  mov.l   r1,@r0
 7  mov.l   r2,@(8,r0)                7  mov.l   r2,@(8,r0)
 8  mov.l   r2,@(12,r0)               8  mov.l   r2,@(12,r0)
 9  mov.l   r1,@(16,r0)               9  mov.l   r1,@(16,r0)
10  mov.l   r2,@(20,r0)              10  mov.l   r2,@(20,r0)
11  mov.l   r2,@(24,r0)              11  mov.l   r2,@(24,r0)
12  mov.l   r2,@(28,r0)              12  mov.l   r2,@(28,r0)
13  mov.l   r1,@(32,r0)              13  mov.l   r1,@(32,r0)
14  mov.l   r2,@(36,r0)              14  mov.l   r2,@(36,r0)
15  mov.l   r2,@(40,r0)              15  mov.l   r2,@(40,r0)
16  rts                              16  rts
17  mov.l   r2,@(44,r0)              17  mov.l   r2,@(44,r0)

DIFFERENCES:
  (a) SCHEDULING of constant pool loads. The original loads the pointer
      address first (line 1), then "mov #0,r2" (line 2), then dereferences
      (line 3), then loads the 0x10000 constant (line 4). Our GCC loads the
      0x10000 constant first (line 1), then the pointer address (line 2),
      dereferences (line 3), then "mov #0,r2" (line 4).

  At the opcode level, both have 2x mov.l (const pool) + 1x mov + 1x mov.l
  (deref) in the first 4 instructions, but in different order:
    - Ours:     mov.l, mov.l, mov.l, mov
    - Original: mov.l, mov,   mov.l, mov.l

  Lines 5-17 are IDENTICAL.

  PATTERN: Pure scheduling difference in the prologue. The original compiler
  interleaves the "mov #0" between the two constant pool loads, while ours
  groups both constant pool loads together. This is a minor instruction
  scheduling difference with no functional impact.

  OPCODE-LEVEL DIFF:
    Position 2: mov.l vs mov   (scheduling of mov #0 vs const pool load)
    Position 4: mov vs mov.l   (scheduling of mov #0 vs const pool load)


================================================================================
FUNCTION 3: FUN_060270D0  (17 opcodes each)
================================================================================

C Source: Identical structure to FUN_06026E0C but with address 0x0608A52C
instead of 0x06089EDC. Same 12-element matrix initialization.

DIFFERENCES: Exactly the same pattern as FUN_06026E0C.

  OURS:     mov.l, mov.l, mov.l, mov, [13 identical stores]
  ORIGINAL: mov.l, mov,   mov.l, mov.l, [13 identical stores]

  PATTERN: Pure scheduling difference in prologue (same as FUN_06026E0C).

  OPCODE-LEVEL DIFF:
    Position 2: mov.l vs mov   (scheduling)
    Position 4: mov vs mov.l   (scheduling)


================================================================================
FUNCTION 4: FUN_060285E0  (8 opcodes each)
================================================================================

C Source: Pure wrapper / tail call. Computes
  (((param_2 << 8) >>> 2) + param_1) << 1
and calls FUN_060283b8(8, result, 0xFFFFF000, param_3).

OURS (GCC 2.6.3):                    ORIGINAL BINARY:
 1  mov     r6,r7                     1  shll8   r5
 2  mov.w   L2,r6                     2  mov     r6,r7
 3  shll8   r5                        3  mov.w   @(0x28,PC),r6
 4  shlr2   r5                        4  shlr2   r5
 5  add     r4,r5                     5  add     r4,r5
 6  add     r5,r5                     6  shll    r5
 7  bra     _FUN_060283b8             7  bra     0x060283B8
 8  mov     #8,r4                     8  mov     #8,r4

DIFFERENCES:
  (a) SCHEDULING: The original does "shll8 r5" first (line 1), then moves
      r6->r7 (line 2). Our GCC reverses this: mov r6,r7 first, then shll8.
      This is pure scheduling -- both are independent operations on different
      registers.

  (b) INSTRUCTION SELECTION: "shll r5" vs "add r5,r5". Both compute r5*2.
      The original uses the dedicated "shll" (shift left logical by 1)
      instruction, while our GCC uses "add r5,r5" which has the same effect.
      Both are single-cycle, single-word instructions on SH-2. The opcodes
      differ in mnemonic but are functionally equivalent.

  PATTERN: Two independent issues:
    1. Scheduling: shll8 vs mov ordering (positions 1-3)
    2. Instruction selection: shll vs add for multiply-by-2 (position 6)

  The "shll vs add" difference is a GCC instruction selection preference.
  GCC's SH backend prefers "add rN,rN" for doubling over "shll rN".

  OPCODE-LEVEL DIFF:
    Position 1: mov vs shll8     (scheduling)
    Position 3: shll8 vs mov.w   (scheduling)
    Position 6: add vs shll      (instruction selection: add r5,r5 vs shll r5)


================================================================================
FUNCTION 5: FUN_06028600  (8 opcodes each)
================================================================================

C Source: Identical structure to FUN_060285E0 but calls FUN_060283e0.

DIFFERENCES: Exactly the same pattern as FUN_060285E0.

  PATTERN: Same two issues:
    1. Scheduling: shll8 vs mov ordering (positions 1-3)
    2. Instruction selection: add vs shll for multiply-by-2 (position 6)

  OPCODE-LEVEL DIFF:
    Position 1: mov vs shll8     (scheduling)
    Position 3: shll8 vs mov.w   (scheduling)
    Position 6: add vs shll      (instruction selection)


================================================================================
FUNCTION 6: FUN_0603C0A0  (9 opcodes each)
================================================================================

C Source: Stores param_2 to 0xFFFFFF00, stores sign-extended upper 16 bits
of param_1 to +0x10, stores param_1<<16 to +0x14, returns the latter.

OURS (GCC 2.6.3):                    ORIGINAL BINARY:
 1  mov     r4,r0                     1  mov.l   @(0x5C,PC),r0   {0xFFFFFF00}
 2  mov.w   L2,r1                     2  swap.w  r4,r2
 3  mov.l   r5,@r1                    3  mov.l   r5,@r0
 4  swap.w  r0,r2                     4  exts.w  r2,r2
 5  exts.w  r2,r2                     5  mov.l   r2,@(0x10,r0)
 6  mov.l   r2,@(16,r1)               6  shll16  r4
 7  shll16  r0                        7  mov.l   r4,@(0x14,r0)
 8  rts                               8  rts
 9  mov.l   r0,@(20,r1)               9  mov.l   @(0x14,r0),r0

DIFFERENCES:
  (a) CONSTANT POOL LOADING: The original loads address 0xFFFFFF00 via a
      4-byte constant pool entry (mov.l @(disp,PC),r0), while our GCC loads
      it via a 2-byte constant (mov.w L2,r1, where L2 = -256 = 0xFFFFFF00
      sign-extended from 16-bit). This is actually BETTER from our compiler
      -- it saves constant pool space. But the mnemonic differs: mov.l vs
      mov.w at position 1, and the base register is r0 (original) vs r1
      (ours).

  (b) SCHEDULING: Original loads the address first (line 1), then swap.w
      (line 2), then stores. Ours does "mov r4,r0" first to copy param_1
      into r0, then loads the address into r1 (line 2), then stores.

  (c) REGISTER ALLOCATION: The original keeps the base address in r0 and
      works with r4 directly for shifts. Our GCC copies r4 to r0 first
      (line 1), then uses r0 for the shifted value and r1 for the address.
      This leads to shll16 r0 (ours) vs shll16 r4 (original).

  (d) RETURN VALUE: Original's final instruction is "mov.l @(0x14,r0),r0"
      -- it RE-LOADS the stored value from memory into r0 for the return.
      Our GCC's final instruction is "mov.l r0,@(20,r1)" -- it stores
      the already-computed shifted value (r0 already contains param_1<<16)
      directly. Our approach is actually more efficient in that the return
      value is already in r0, while the original must reload it.

  PATTERN: Mixed scheduling + register allocation + constant encoding.
    - mov vs mov.l at position 1 (register copy vs const pool load)
    - mov.w vs swap.w at position 2 (const load vs computation)
    - mov.l (store) at position 7 vs mov.l (load) at position 9
      (store in rts delay slot vs reload from memory)

  OPCODE-LEVEL DIFF:
    Position 1: mov vs mov.l         (reg copy vs const pool load)
    Position 2: mov.w vs swap.w      (const load vs computation scheduling)
    Position 7: mov.l(store) remains mov.l but store-to-mem vs store-to-mem
                at different position
    Position 9: mov.l(store) vs mov.l(load)  (store vs re-load for return)


================================================================================
SUMMARY OF PATTERNS
================================================================================

PATTERN 1: INSTRUCTION SCHEDULING (affects 6/6 functions)
  All 6 functions show scheduling differences where the original binary
  interleaves independent operations differently from GCC. The original
  compiler appears to schedule constant pool loads later (interleaved with
  computation) while GCC front-loads constant pool loads.

  Affected functions:
    - FUN_06011494: extu.w scheduled early in original, late in ours
    - FUN_06026E0C: "mov #0" interleaved between const pool loads in original
    - FUN_060270D0: same as FUN_06026E0C
    - FUN_060285E0: shll8 scheduled before mov in original
    - FUN_06028600: same as FUN_060285E0
    - FUN_0603C0A0: const load vs reg copy ordering

PATTERN 2: INSTRUCTION SELECTION - shll vs add (affects 2/6 functions)
  GCC uses "add rN,rN" to multiply by 2, while the original compiler uses
  "shll rN". Both are single-cycle, single-word, functionally equivalent.
  This is a codegen preference in GCC's SH backend.

  Affected functions:
    - FUN_060285E0: add r5,r5 (ours) vs shll r5 (original)
    - FUN_06028600: same

  POTENTIAL FIX: Add a peephole or change the shift-by-1 pattern in sh.md
  to prefer "shll" over "add rN,rN" for left-shift-by-1 operations.

PATTERN 3: REGISTER ALLOCATION (affects 2/6 functions)
  GCC allocates registers differently, sometimes requiring extra register
  moves that the original compiler avoids.

  Affected functions:
    - FUN_06011494: GCC uses r0 for zero first, needs extra "mov r4,r0" later
    - FUN_0603C0A0: GCC copies r4->r0 first instead of using const in r0

PATTERN 4: CONSTANT ENCODING (affects 1/6 functions)
  GCC sometimes uses mov.w (16-bit sign-extended constant) where the
  original uses mov.l (32-bit constant pool), or vice versa. This changes
  the mnemonic but not the instruction count.

  Affected function:
    - FUN_0603C0A0: mov.w (ours, -256 fits in 16-bit) vs mov.l (original)


================================================================================
FIXABILITY ASSESSMENT
================================================================================

EASY TO FIX (compiler patch feasible):
  - Pattern 2 (shll vs add): A peephole in sh.md could convert "add rN,rN"
    to "shll rN" for single-bit shifts. This would fix FUN_060285E0 and
    FUN_06028600 at position 6.

HARD TO FIX (deep in GCC's scheduling/regalloc):
  - Pattern 1 (scheduling): GCC 2.6.3's instruction scheduler makes global
    decisions about operation ordering. Changing this requires modifying the
    scheduler's heuristics, which risks regressions across all functions.
  - Pattern 3 (register allocation): Register allocation is a graph-coloring
    problem in GCC. The allocator's choices are based on liveness analysis
    and spill costs. Tweaking register preferences would affect all code.
  - Pattern 4 (constant encoding): GCC preferring mov.w for small constants
    is actually an optimization (smaller constant pool). Hard to "un-optimize"
    without side effects.

RECOMMENDED NEXT STEPS:
  1. Implement "add rN,rN -> shll rN" peephole to fix Pattern 2 (2 functions)
  2. For scheduling/regalloc patterns, accept the difference as equivalent
     (same performance, same code size, different ordering)
  3. Consider whether the test harness should have a "structural match" mode
     that accepts scheduling-only differences
